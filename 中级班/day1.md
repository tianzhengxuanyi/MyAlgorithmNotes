解题技巧和思想：
- 窗口不回退模型
- 打标
- 预处理

### 题目一
给定一个有序数组arr，代表数轴上从左到右有n个点arr[0]、arr[1]...arr[n－1]，
给定一个正数L，代表一根长度为L的绳子，求绳子最多能覆盖其中的几个点。

**思路1：**

1. 遍历arr，假设当前`i`，寻找arr中大于`arr[i]-L`最左的位置`index`，此时绳子覆盖了`index-i`个点。遍历完成后返回最大的值；
2. 采用二分法寻找arr中大于value的最左位置；

```js
function coverMaxPoint(arr, L) {
    let res = 1;
    for (let i = 0; i < arr.length; i++) {
        let index = nearestIndex(arr, i, arr[i] - L);
        res = res > i - index + 1 ? res : i - index + 1;
    }
    return res;
}

function nearestIndex(arr, R, value) {
    let left = 0;
    let index = R;

    while (left < R) {
        let mid = left + ((R - left) >> 1);
        if (arr[mid] >= value) {
            index = mid
            R = mid - 1
        } else {
            left = mid + 1
        }
    }

    return index;
}
```

### 题目二
小虎去附近的商店买苹果，奸诈的商贩使用了捆绑交易，只提供6个每袋和8个每袋的包装包装不可拆分。可是小虎现在只想购买恰好n个苹果，小虎想购买尽量少的袋数方便携带。如果不能购买恰好n个苹果，小虎将不会购买。输入一个整数n，表示小虎想购买的个苹果，返回最小使用多少袋子。如果无论如何都不能正好装下，返回-1。

### 题目三
牛牛有一些排成一行的正方形。每个正方形已经被染成红色或者绿色。牛牛现在可
以选择任意一个正方形然后用这两种颜色的任意一种进行染色,这个正方形的颜色将
会被覆盖。牛牛的目标是在完成染色之后,每个红色R都比每个绿色G距离最左侧近。
牛牛想知道他最少需要涂染几个正方形。
如样例所示: s = RGRGR
我们涂染之后变成RRRGG满足要求了,涂染的个数为2,没有比这个更好的涂染方案。

### 题目四
给定一个N*N的矩阵matrix，只有0和1两种值，返回边框全是1的最大正方形的边
长长度。
例如:
01111
01001
01001
01111
01011
其中边框全是1的最大正方形的大小为4*4，所以返回4。

### 题目五
给定一个函数f，可以1～5的数字等概率返回一个。请加工出1～7的数字等概率
返回一个的函数g。
给定一个函数f，可以a～b的数字等概率返回一个。请加工出c～d的数字等概率
返回一个的函数g。
给定一个函数f，以p概率返回0，以1-p概率返回1。请加工出等概率返回0和1的
函数g

### 题目六
给定一个非负整数n，代表二叉树的节点个数。返回能形成多少种不同的二叉树结构

### 题目七
一个完整的括号字符串定义规则如下:
①空字符串是完整的。
②如果s是完整的字符串，那么(s)也是完整的。
③如果s和t是完整的字符串，将它们连接起来形成的st也是完整的。
例如，"(()())", ""和"(())()"是完整的括号字符串，"())(", "()(" 和 ")" 是不完整的括号字符串。
牛牛有一个括号字符串s,现在需要在其中任意位置尽量少地添加括号,将其转化
为一个完整的括号字符串。请问牛牛至少需要添加多少个括号。

