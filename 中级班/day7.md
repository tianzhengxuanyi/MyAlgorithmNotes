### 题目1

小Q正在给一条长度为n的道路设计路灯安置方案。

为了让问题更简单,小Q把道路视为n个方格,需要照亮的地方用'.'表示, 不需要
照亮的障碍物格子用'X'表示。

小Q现在要在道路上设置一些路灯, 对于安置在pos位置的路灯, 这盏路灯可以照亮pos - 1, pos, pos + 1这三个位置。

小Q希望能安置尽量少的路灯照亮所有'.'区域, 希望你能帮他计算一下最少需
要多少盏路灯。

输入描述：
输入的第一行包含一个正整数t(1 <= t <= 1000), 表示测试用例数接下来每两行一个测试数据, 第一行一个正整数n(1 <= n <= 1000),表示道路的长度。第二行一个字符串s表示道路的构造,只包含'.'和'X'。

输出描述：
对于每个测试用例, 输出一个正整数表示最少需要多少盏路灯。

**思路（贪心）：**

1. 从位置i开始（假设位置i-1之前都已经被点了，且不会对位置i有影响）：
   1. 如果i位置为“X”，则i++；
   2. 如果i位置不是“X”，则路灯加一。如果i+1为“X”，则下次从i+2开始；如果i+1不是“X”，则下次从i+3开始；如果越界就break；


### 题目2

已知一棵二叉树中没有重复节点，并且给定了这棵树的中序遍历数组和先序遍历数组，返回后序遍历数组。

比如给定：

int[] pre = { 1, 2, 4, 5, 3, 6, 7 };

int[] in = { 4, 2, 5, 1, 6, 3, 7 };

返回：{4,5,2,6,7,3,1}


**思路：**

1. 定义递归process(pre, in, after, peri, perj, ini, inj, afteri, afterj)，其中pre、in、after为先序、中序、后序数组，peri, perj, ini, inj, afteri, afterj为数组中的范围。含义为用pre数组prei~prej范围和in数组ini~inj范围生成后序遍历after数组afteri~afterj范围，其中所有数组的范围等长；
2. pre的一个元素为after的最后一个元素，同时也是二叉树的头；根据头节点在in中的位置推出左树和右树的长度，调用process用pre和in的左树（右树）得出after的左树（右树）；
