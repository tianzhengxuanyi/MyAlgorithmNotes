### 题目一

判定一个由[a-z]字符构成的字符串和一个包含'?'和'\*'通配符的字符串是否匹配。

通配符'?'匹配任意单一字符,'\*'匹配任意多个字符包括 0 个字符。

字符串长度不会超过 100，字符串不为空。

输入描述：

字符串 str 和包含通配符的字符串 pattern。1 <= 字符串长度 <= 100

输出描述：

true 表示匹配，false 表示不匹配

**思路：**

1. process(str, exp, si, ei): boolean，str 表示被匹配的字符串，exp 表示表达式，递归过程表示 exp 从下标 ei 到结束能否匹配 str 从下标 si 到结束位置。
2. 必须保证 ei 位置不能为‘\*’。
3. 可能性一：当 ei+1 位置不为‘\*’时，str[si]必须等于 exp[ei]或 exp[ei]为‘?’，且后续能配上（process(str, exp, si+1, ei+1)为 true）才返回 true。
4. 可能性二：ei+1 为‘\*’；假设当前 str si~ 为 aaaab~，
    1. exp[ei] == 'a' 或者为‘?’，‘a*’尝试变成一个 a、两个 a、三个 a、四个 a，循环 process(str, exp, si+1, ei)。或者‘a*’变成空字符串，尝试 process(str, exp, si, ei+2);
    2. exp[ei] != 'a' 且不为‘?’，从 ei+2 开始尝试 process(str, exp, si, ei+2);

**思路：（改成 DP）**

缺乏 base case，根据依赖位置判断需要初始条件需要哪些，再根据题意自己算出初始条件。

dp 表中需要最后两列和最后一行位置，递归中 base case 只能推出最后一列，所以倒数第二列和最后一行需要根据题意自己算出。

倒数第二列

![](../image/高级班day7-1.png)

倒数最后一行，需要满足"...a*b*c*d*"这样的范式才返回 true，从右向左每隔两个判断是不是‘\*’，是填 true，不是前面的都填 false。

![](../image/高级班day7-2.png)

    注意 dp 表中任何一个地方，按照我们的递归想法，如过那个位置的 e 的字符是 *, 所以不需要考虑那个位置的 e 的字符是 * 的可能性，因为我们递归的想法是我们不考虑当前 ei 位置是 * 字符，注意那个 isValid 函数和 ei+2, 我们不关心

    就算 dp 表需要会到那些东西，我们递归如果不考虑的话，那就不用担心，因为不会被依赖

### 递归技巧

递归：大问题调用小问题，

大问题做决策 1 调用小问题 1 做决策 2 调用小问题 2 ……

保证大问题做的所有的决策的影响都体现在小问题的参数上

（无后效性的递归）

### 题目二

数组异或和的定义:把数组中所有的数异或起来得到的值给定一个整型数组 arr，其中可能有正、有负、有零，求其中子数组的最大异或和

【举例】

arr = {3}

数组只有 1 个数，所以只有一个子数组，就是这个数组本身，最大异或和为 3

arr = {3, -28, -29, 2}

子数组有很多，但是{-28, -29}这个子数组的异或和为 7，是所有子数组中最大的

**思路 1：暴力解**

1. 遍历数组，尝试以 i 为结尾的子数组的最大异或和。
2. 遍历 0~i-1，尝试以 j 开头 i 结尾的异或和。
3. 遍历 j~i 求出，子数组异或和。
4. 返回最大值。

**思路 2：优化第三重遍历**

$XOR_{j-i}=XOR_{0-i} \;  xor \; XOR_{0-j-1}$

预处理 0~j-1 的异或和数组，并用遍历 sum 记录 0~i 的异或和，省去第三重遍历。

**思路 3：前缀树，优化第二层遍历**
将 0~j-1 的异或和数组，变成前缀树。
![](../image/高级班day7-3.png)

贪心策略：先迎合高位

用 0~i 的异或和 sum，采用迎合高位的贪心策略（前缀树从头开始-高位，尽量变成 1，这样异或结果更大；符号位要变成 0），这样就可以获得 0~i 所有可能子数组中异或和最大的一个。

### 题目三 leetcode 312

KMP算法扩展题目二 给定一个数组 arr，代表一排有分数的气球。每打爆一个气球都能获得分数，假设打爆气球 的分数为 X，获得分数的规则如下:

1. 如果被打爆气球的左边有没被打爆的气球，找到离被打爆气球最近的气球，假设分数为L;如果被打爆气球的右边有没被打爆的气球，找到离被打爆气球最近的气球，假设分数为
R。 获得分数为 L*X*R。
2. 如果被打爆气球的左边有没被打爆的气球，找到离被打爆气球最近的气球，假设分数为L;如果被打爆气球的右边所有气球都已经被打爆。获得分数为 L*X。
3. 如果被打爆气球的左边所有的气球都已经被打爆;如果被打爆气球的右边有没被打爆的气球，找到离被打爆气球最近的气球，假设分数为 R;如果被打爆气球的右边所有气球都已经 被打爆。获得分数为 X*R。
4. 如果被打爆气球的左边和右边所有的气球都已经被打爆。获得分数为 X。

目标是打爆所有气球，获得每次打爆的分数。通过选择打爆气球的顺序，可以得到不同的总分，请返回能获得的最大分数。

【举例】

arr = {3,2,5}

如果先打爆3，获得3*2；再打爆2，获得2*5；最后打爆5，获得5；最后总分21

如果先打爆3，获得3*2;再打爆5，获得2*5；最后打爆2，获得2；最后总分18

如果先打爆2，获得3*2*5；再打爆3，获得3*5；最后打爆5，获得5；最后总分50

如果先打爆2，获得3*2*5；再打爆5，获得3*5；最后打爆3，获得3；最后总分48

如果先打爆5，获得2*5；再打爆3，获得3*2；最后打爆2，获得2；最后总分18

如果先打爆5，获得2*5;再打爆2，获得3*2；最后打爆3，获得3；最后总分19

返回能获得的最大分数为50


**思路：**

f(L, R): number 尝试L到R范围每个位置的气球都最后打爆

潜台词：L-1一定没爆，R+1一定没爆

预处理：arr左右两侧插入数字1，主函数调用f(help, 0, R+1)

我们尝试每个位置的气球最后打爆:

1 位置的气球最后爆，调用 f (2,6)(这个完全可以，以为满足了潜台词，潜台词就是 L-1 位置的气球一定没有爆，R+1 位置的气球一定没爆)

所以结果就是分数就是 f (2,6)+1*3*1, 因为我们选择当前 1 位置的气球最后打爆

6 位置的气球最后爆，调用 f (1,5)(这个完全可以，以为满足了潜台词，潜台词就是 L-1 位置的气球一定没有爆，R+1 位置的气球一定没爆)

所以结果就是分数就是 f (1,5)+1*2*1, 因为我们选择当前 6 位置的气球最后打爆

2 位置的气球最后爆，调用 f (1,1) 和 f (3,6)(这个完全可以，以为满足了潜台词，潜台词就是 L-1 位置的气球一定没有爆，R+1 位置的气球一定没爆，这两个调用都符合)

所以结果就是分数就是 f (1,1)+f (3,6)+1*2*1, 因为我们选择当前 2 位置的气球最后打爆

…(其他的都可以)


### 题目四

汉诺塔游戏的要求把所有的圆盘从左边都移到右边的柱子上，给定一个整型数组arr，其中只含有1、2和3，代表所有圆盘目前的状态，1代表左柱，2代表中柱，3代表右柱，
arr[i]的值代表第i+1个圆盘的位置。

比如，arr=[3,3,2,1]，代表第1个圆盘在右柱上、第2个圆盘在右柱上、第3个圆盘在中柱上、第4个圆盘在左柱上

如果arr代表的状态是最优移动轨迹过程中出现的状态，返回arr这种状态是最优移动轨迹中的第几个状态；如果arr代表的状态不是最优移动轨迹过程中出现的状态，则返回-1。

**思路；**

N 层汉诺塔问题是2^N  - 1步

1. 将1~N-1从左移动到中

2. 将N从左移动到右 1步

3. 将1~N - 1从中移动到右

F(N) = 2F(N-1) + 1

i层的汉诺塔

from to other

1. 1 ~ i-1 from - other

2. i from - to

3. 1~ i - 1 other - to

判断i在from还是to上，如果在from上说明第一大步没有走完，需要递归判断在第一大步中的状态；如果在to上，说明在完成第三大步，递归判断；如果在other上说明不是最优移动轨迹。