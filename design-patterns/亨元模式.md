# 享元模式（Flyweight Pattern）
享元模式是**结构型设计模式**，核心思想是「通过共享技术复用大量细粒度的对象，减少内存占用和对象创建开销」——简单说就是：**将对象的属性拆分为“内部状态”（可共享）和“外部状态”（不可共享），复用内部状态相同的对象，仅为不同的外部状态创建新的处理逻辑**。

## 一、核心动机：解决“大量相似对象导致的性能问题”
假设你开发一个「商品列表」功能，页面需渲染1000个商品，每个商品包含“基础信息”（类别、品牌、默认图片，可共享）和“动态信息”（价格、库存、促销标签，不可共享）：
```typescript
// 未使用享元模式：每个商品创建独立对象，内存占用极高
class Product {
  constructor(
    public category: string, // 内部状态（可共享）
    public brand: string,    // 内部状态（可共享）
    public defaultImg: string, // 内部状态（可共享）
    public price: number,   // 外部状态（不可共享）
    public stock: number,   // 外部状态（不可共享）
    public tag: string      // 外部状态（不可共享）
  ) {}

  render() {
    console.log(`渲染商品：${this.brand}-${this.category}，价格${this.price}，库存${this.stock}，标签${this.tag}`);
  }
}

// 创建1000个商品对象，即使类别/品牌相同，也会重复创建
const products: Product[] = [];
for (let i = 0; i < 1000; i++) {
  // 假设前500个是手机类，后500个是电脑类，内部状态重复
  const category = i < 500 ? "手机" : "电脑";
  const brand = i < 500 ? "苹果" : "华为";
  const defaultImg = i < 500 ? "apple-phone.png" : "huawei-pc.png";
  products.push(new Product(category, brand, defaultImg, 999 + i, 100 - i, i % 2 === 0 ? "热销" : "新品"));
}
```
**问题**：
- 1000个对象中，仅内部状态（类别/品牌/默认图片）就有大量重复，每个对象都占用独立内存，导致内存浪费；
- 频繁创建相似对象，增加GC（垃圾回收）压力，降低页面性能；
- 若商品数量增加到10000，内存占用会呈线性增长，甚至引发页面卡顿。

享元模式的目标：**抽离可共享的内部状态，创建“享元池”缓存这些对象，仅为不同的外部状态动态赋值，复用已有对象而非创建新对象**。

## 二、核心概念与角色
### 1. 核心概念：内部状态 vs 外部状态
这是享元模式的核心拆分逻辑，决定了哪些对象可共享：
| 状态类型       | 定义                                                                 | 示例（商品场景）|
|----------------|----------------------------------------------------------------------|---------------------------------------|
| 内部状态（Intrinsic） | 不依赖于上下文、可共享、不变的属性                                   | 商品类别、品牌、默认图片              |
| 外部状态（Extrinsic） | 依赖于上下文、不可共享、动态变化的属性，需由外部传入                   | 价格、库存、促销标签、渲染位置        |

### 2. 核心角色
| 角色               | 职责                                                                 |
|--------------------|----------------------------------------------------------------------|
| 抽象享元（Flyweight） | 定义对象的内部状态接口，声明接收外部状态的方法                       |
| 具体享元（ConcreteFlyweight） | 实现抽象享元接口，存储内部状态，内部状态不可变且可共享               |
| 享元工厂（FlyweightFactory） | 创建并管理享元池，负责复用内部状态相同的具体享元对象                 |
| 上下文（Context）| 存储外部状态，将外部状态传递给享元对象，完成最终的业务逻辑           |

## 三、完整实现（TypeScript版）
基于商品列表场景，用享元模式重构：

### 1. 抽象享元（定义内部状态接口）
```typescript
// 抽象享元：商品基础信息（内部状态）
interface ProductFlyweight {
  category: string;
  brand: string;
  defaultImg: string;
  // 接收外部状态，完成渲染逻辑
  render(price: number, stock: number, tag: string): void;
}
```

### 2. 具体享元（实现可共享的内部状态）
```typescript
// 具体享元：商品基础信息实现类
class ConcreteProductFlyweight implements ProductFlyweight {
  constructor(
    public category: string,
    public brand: string,
    public defaultImg: string
  ) {}

  // 接收外部状态，执行渲染
  render(price: number, stock: number, tag: string): void {
    console.log(`渲染商品：${this.brand}-${this.category}，默认图${this.defaultImg}，价格${price}，库存${stock}，标签${tag}`);
  }
}
```

### 3. 享元工厂（管理享元池，复用对象）
```typescript
// 享元工厂：创建/复用商品享元对象
class ProductFlyweightFactory {
  // 享元池：以「内部状态组合」为key，缓存享元对象
  private flyweightPool: Record<string, ProductFlyweight> = {};

  // 获取享元对象（复用已有或创建新的）
  getFlyweight(category: string, brand: string, defaultImg: string): ProductFlyweight {
    // 生成唯一key：组合内部状态
    const key = `${category}-${brand}-${defaultImg}`;
    // 复用已有对象
    if (!this.flyweightPool[key]) {
      this.flyweightPool[key] = new ConcreteProductFlyweight(category, brand, defaultImg);
      console.log(`创建新享元对象：${key}`);
    }
    return this.flyweightPool[key];
  }

  // 获取享元池大小（用于调试）
  getPoolSize(): number {
    return Object.keys(this.flyweightPool).length;
  }
}
```

### 4. 上下文（处理外部状态）
```typescript
// 上下文：封装外部状态，关联享元对象
class ProductContext {
  private flyweight: ProductFlyweight;
  constructor(
    factory: ProductFlyweightFactory,
    // 内部状态（传给工厂获取享元）
    private category: string,
    private brand: string,
    private defaultImg: string,
    // 外部状态（当前对象独有）
    public price: number,
    public stock: number,
    public tag: string
  ) {
    // 从工厂获取享元对象（复用/创建）
    this.flyweight = factory.getFlyweight(category, brand, defaultImg);
  }

  // 执行渲染：将外部状态传给享元对象
  render(): void {
    this.flyweight.render(this.price, this.stock, this.tag);
  }
}
```

### 5. 使用享元模式
```typescript
// 1. 创建享元工厂
const factory = new ProductFlyweightFactory();

// 2. 创建1000个商品上下文（仅创建2个享元对象）
const products: ProductContext[] = [];
for (let i = 0; i < 1000; i++) {
  const category = i < 500 ? "手机" : "电脑";
  const brand = i < 500 ? "苹果" : "华为";
  const defaultImg = i < 500 ? "apple-phone.png" : "huawei-pc.png";
  
  products.push(new ProductContext(
    factory,
    category,
    brand,
    defaultImg,
    999 + i, // 外部状态：价格
    100 - i, // 外部状态：库存
    i % 2 === 0 ? "热销" : "新品" // 外部状态：标签
  ));
}

// 3. 渲染所有商品
products.forEach(product => product.render());

// 4. 查看享元池大小（仅2个，而非1000个）
console.log(`享元池大小：${factory.getPoolSize()}`); // 输出：2
```

## 四、简化版实现（JavaScript风格）
前端开发中无需严格遵循“抽象享元+工厂”的经典结构，可简化为「对象池」形式，更符合JS特性：
```javascript
// 享元池：缓存可共享的内部状态对象
const productPool = {};

// 创建/获取享元对象的函数
function getProductFlyweight(category, brand, defaultImg) {
  const key = `${category}-${brand}-${defaultImg}`;
  if (!productPool[key]) {
    productPool[key] = { category, brand, defaultImg };
    console.log(`创建新享元：${key}`);
  }
  return productPool[key];
}

// 渲染商品：传入外部状态
function renderProduct(flyweight, price, stock, tag) {
  console.log(`渲染商品：${flyweight.brand}-${flyweight.category}，价格${price}，库存${stock}，标签${tag}`);
}

// 使用：创建1000个商品，仅2个享元对象
for (let i = 0; i < 1000; i++) {
  const category = i < 500 ? "手机" : "电脑";
  const brand = i < 500 ? "苹果" : "华为";
  const defaultImg = i < 500 ? "apple-phone.png" : "huawei-pc.png";
  
  const flyweight = getProductFlyweight(category, brand, defaultImg);
  renderProduct(flyweight, 999 + i, 100 - i, i % 2 === 0 ? "热销" : "新品");
}

console.log(`享元池大小：${Object.keys(productPool).length}`); // 2
```

## 五、享元模式的核心特点
### 1. 优点
- **大幅减少内存占用**：复用内部状态相同的对象，对象数量从“N个”降为“内部状态组合数”（如上例从1000→2）；
- **降低对象创建开销**：减少频繁创建/销毁对象的GC压力，提升性能；
- **提高代码复用性**：可共享的内部状态逻辑集中管理，无需重复编写。

### 2. 缺点
- **增加复杂度**：需拆分内部/外部状态，设计和维护成本提高；
- **外部状态处理成本**：若外部状态过多，传递和管理逻辑会变复杂；
- **仅适用于大量相似对象场景**：少量对象使用享元模式属于过度设计。

## 六、前端中的享元模式应用场景&案例
### 1. 大量DOM/组件渲染（如列表、地图标记）
**场景**：页面渲染大量相似组件（如商品列表、地图上的标记点），仅部分属性不同。
**案例（React列表优化）**：
```tsx
import React from "react";

// 享元池：缓存组件的内部状态（样式、基础结构）
const componentPool = {
  productItem: (props) => (
    <div className="product-item" style={{ border: "1px solid #eee" }}>
      <img src={props.defaultImg} alt={props.brand} />
      <div className="info">
        <h3>{props.brand}-{props.category}</h3>
        <p>价格：{props.price}</p>
        <p>库存：{props.stock}</p>
        <span className={`tag ${props.tag}`}>{props.tag}</span>
      </div>
    </div>
  )
};

// 复用享元组件，仅传递外部状态
const ProductList = ({ products }) => {
  return (
    <div className="product-list">
      {products.map((product, index) => (
        // 复用componentPool中的productItem，仅传入外部状态
        React.createElement(componentPool.productItem, {
          key: index,
          ...product // 包含内部状态（category/brand/defaultImg）和外部状态（price/stock/tag）
        })
      ))}
    </div>
  );
};

// 使用：1000个商品仅复用1个基础组件结构
const products = Array.from({ length: 1000 }, (_, i) => ({
  category: i < 500 ? "手机" : "电脑",
  brand: i < 500 ? "苹果" : "华为",
  defaultImg: i < 500 ? "apple-phone.png" : "huawei-pc.png",
  price: 999 + i,
  stock: 100 - i,
  tag: i % 2 === 0 ? "热销" : "新品"
}));

export default () => <ProductList products={products} />;
```

### 2. 缓存池（如图片缓存、请求缓存）
**场景**：页面加载大量重复图片/发起重复请求，复用已加载/请求的资源。
**案例（图片缓存池）**：
```javascript
// 图片享元池：缓存已加载的图片对象
const imagePool = new Map();

// 加载图片：复用已有图片，避免重复请求
function loadImage(url) {
  if (imagePool.has(url)) {
    console.log(`复用图片：${url}`);
    return imagePool.get(url);
  }
  const img = new Image();
  img.src = url;
  imagePool.set(url, img);
  console.log(`加载新图片：${url}`);
  return img;
}

// 使用：多次加载同一图片，仅第一次发起请求
loadImage("apple-phone.png"); // 加载新图片
loadImage("apple-phone.png"); // 复用图片
loadImage("apple-phone.png"); // 复用图片
```

### 3. 事件池/对象池（如Canvas粒子、弹窗）
**场景**：Canvas绘制大量粒子动画，或频繁创建/销毁弹窗，复用对象减少开销。
**案例（Canvas粒子池）**：
```javascript
// 粒子享元池：缓存未使用的粒子对象
const particlePool = [];

// 创建粒子：复用池中的对象，而非新建
function createParticle(x, y) {
  // 复用已有粒子
  if (particlePool.length > 0) {
    const particle = particlePool.pop();
    particle.x = x; // 外部状态
    particle.y = y; // 外部状态
    particle.speed = Math.random() * 5; // 外部状态
    return particle;
  }
  // 无复用对象时创建新的（内部状态固定）
  return {
    color: "#ff0000", // 内部状态（可共享）
    size: 5,          // 内部状态（可共享）
    x, y, speed       // 外部状态
  };
}

// 回收粒子：放回池供复用
function recycleParticle(particle) {
  particlePool.push(particle);
}

// 使用：绘制1000个粒子，仅创建少量对象
function renderParticles() {
  const particles = [];
  for (let i = 0; i < 1000; i++) {
    particles.push(createParticle(Math.random() * 800, Math.random() * 600));
  }
  // 绘制逻辑...
  // 回收粒子
  particles.forEach(particle => recycleParticle(particle));
}
```

### 4. 框架/库中的应用
- **Vue/React的虚拟DOM**：复用相同类型的VNode结构（内部状态），仅更新props（外部状态）；
- **Redux的store缓存**：复用相同state结构，仅更新变化的字段；
- **Lodash的缓存函数**：`_.memoize` 缓存函数执行结果，复用相同参数的返回值（本质是享元模式）。

## 七、享元模式 vs 单例模式（核心区别）
| 维度                | 享元模式                          | 单例模式                          |
|---------------------|-----------------------------------|-----------------------------------|
| 核心目标            | 复用大量相似对象，减少内存占用    | 确保一个类只有一个实例            |
| 复用粒度            | 细粒度：复用内部状态相同的对象    | 粗粒度：整个类仅一个实例          |
| 状态处理            | 拆分内部/外部状态，外部状态可变   | 实例状态全局唯一，不可拆分        |
| 适用场景            | 大量相似对象（列表、粒子、图片）  | 全局唯一实例（配置、缓存、store） |

**形象类比**：
- 享元模式：图书馆借书，多人复用同一本书（内部状态），仅借书人/借阅时间不同（外部状态）；
- 单例模式：公司唯一的公章，所有人共用这一个章，无“外部状态”拆分。

## 八、使用建议
### 适合场景
1. 系统中存在**大量细粒度的相似对象**，且这些对象可拆分为内部/外部状态；
2. 对象的内部状态**稳定且可共享**，外部状态**动态变化**；
3. 内存占用过高或对象创建开销大，需优化性能。

### 避免场景
1. 对象数量少，或对象属性几乎无重复（无共享价值）；
2. 内部/外部状态难以拆分，或外部状态过多导致管理成本高于共享收益；
3. 对性能要求低，简单实现即可满足需求。

## 总结
享元模式的核心是「拆分状态、共享复用」：
- 核心拆分：将对象属性分为“可共享的内部状态”和“不可共享的外部状态”；
- 核心手段：通过享元池缓存内部状态相同的对象，复用而非新建；
- 前端价值：解决大量相似对象的性能问题（如长列表、粒子动画、图片缓存），是前端性能优化的重要模式。

在前端开发中，无需严格遵循经典的“抽象享元+工厂”结构，核心是抓住“共享可复用状态”的本质——比如实现一个图片缓存池、列表组件复用逻辑，都是享元模式的简化应用。