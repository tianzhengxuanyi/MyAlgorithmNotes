# 桥接模式（Bridge Pattern）详解（TypeScript/JavaScript版）
桥接模式是**结构型设计模式**的核心之一，核心思想是「将抽象部分与实现部分分离，使它们可以独立变化」——简单说就是：**用“组合”替代“继承”，把两个维度的变化解耦，让每个维度可以独立扩展**。

## 一、核心动机：解决“多维度变化”导致的类爆炸问题
假设你需要开发一个「图形渲染」功能，图形有两个变化维度：
1. **图形类型**：圆形、矩形、三角形；
2. **渲染方式**：普通渲染、抗锯齿渲染、3D渲染。

如果用**继承**实现（比如 `CircleNormalRender`、`CircleAntiAliasRender`、`RectNormalRender`...），会出现「类爆炸」：
- 3种图形 × 3种渲染方式 = 9个类；
- 新增1种图形（菱形）→ 需新增3个类；
- 新增1种渲染方式（水墨渲染）→ 需新增3个类。

```typescript
// 继承方式：类爆炸示例（仅展示部分）
class CircleNormalRender {
  render() { console.log("普通渲染圆形"); }
}
class CircleAntiAliasRender {
  render() { console.log("抗锯齿渲染圆形"); }
}
class RectNormalRender {
  render() { console.log("普通渲染矩形"); }
}
// ... 还要写6个类，新增维度时无限扩展
```

**问题**：
- 继承将“图形类型”和“渲染方式”强耦合，一个维度变化会牵连另一个维度；
- 类数量随维度数呈指数级增长，维护成本极高；
- 代码复用性差（渲染逻辑无法在不同图形间复用）。

桥接模式的目标：**把“图形类型”和“渲染方式”两个维度拆分为独立的类层次，通过“组合”（桥接）关联，而非继承**。

## 二、核心角色
桥接模式包含4个核心角色（TypeScript通过接口/类明确约束）：
| 角色               | 职责                                                                 |
|--------------------|----------------------------------------------------------------------|
| 抽象化（Abstraction） | 定义抽象部分的接口（如“图形”），持有对“实现化”对象的引用（桥接核心） |
| 扩展抽象化（RefinedAbstraction） | 继承/实现抽象化接口，扩展抽象部分（如“圆形”“矩形”）|
| 实现化（Implementor） | 定义实现部分的接口（如“渲染方式”），与抽象化接口解耦                 |
| 具体实现化（ConcreteImplementor） | 实现实现化接口，提供具体的实现逻辑（如“普通渲染”“抗锯齿渲染”）|

## 三、完整实现（TypeScript版）
以“图形渲染”为例，用桥接模式解耦「图形类型」和「渲染方式」两个维度：

### 1. 定义“实现化”接口（渲染方式维度）
这是“实现部分”的抽象，与图形类型完全解耦：
```typescript
// 实现化接口：渲染方式（独立维度）
interface Renderer {
  renderShape(shape: string): void; // 渲染逻辑，接收图形名称
}

// 具体实现化1：普通渲染
class NormalRenderer implements Renderer {
  renderShape(shape: string): void {
    console.log(`普通渲染${shape}`);
  }
}

// 具体实现化2：抗锯齿渲染
class AntiAliasRenderer implements Renderer {
  renderShape(shape: string): void {
    console.log(`抗锯齿渲染${shape}`);
  }
}

// 具体实现化3：3D渲染（新增维度只需加类，无需修改原有代码）
class ThreeDRenderer implements Renderer {
  renderShape(shape: string): void {
    console.log(`3D渲染${shape}`);
  }
}
```

### 2. 定义“抽象化”类（图形类型维度）
这是“抽象部分”，持有对「渲染方式」的引用（桥接的核心：组合关联）：
```typescript
// 抽象化类：图形（持有渲染器引用，桥接两个维度）
abstract class Shape {
  constructor(protected renderer: Renderer) {} // 组合：注入渲染器
  abstract draw(): void; // 抽象方法，由子类实现
}

// 扩展抽象化1：圆形
class Circle extends Shape {
  draw(): void {
    this.renderer.renderShape("圆形"); // 调用渲染器的逻辑
  }
}

// 扩展抽象化2：矩形
class Rectangle extends Shape {
  draw(): void {
    this.renderer.renderShape("矩形");
  }
}

// 扩展抽象化3：三角形（新增图形只需加类）
class Triangle extends Shape {
  draw(): void {
    this.renderer.renderShape("三角形");
  }
}
```

### 3. 使用桥接模式
通过“组合”灵活搭配两个维度，无需新增大量类：
```typescript
// 1. 普通渲染圆形
const normalRenderer = new NormalRenderer();
const circle = new Circle(normalRenderer);
circle.draw(); // 输出：普通渲染圆形

// 2. 抗锯齿渲染矩形
const antiAliasRenderer = new AntiAliasRenderer();
const rect = new Rectangle(antiAliasRenderer);
rect.draw(); // 输出：抗锯齿渲染矩形

// 3. 3D渲染三角形（新增维度组合，零修改原有代码）
const threeDRenderer = new ThreeDRenderer();
const triangle = new Triangle(threeDRenderer);
triangle.draw(); // 输出：3D渲染三角形

// 4. 动态切换渲染方式（桥接的灵活性）
circle.renderer = threeDRenderer;
circle.draw(); // 输出：3D渲染圆形
```

## 四、简化版实现（JavaScript风格）
前端开发中无需严格遵循“抽象类+接口”的经典结构，可简化为「对象组合」的形式，更符合JS特性：
```javascript
// 实现维度：渲染方式（普通对象）
const Renderer = {
  normal: (shape) => console.log(`普通渲染${shape}`),
  antiAlias: (shape) => console.log(`抗锯齿渲染${shape}`),
  threeD: (shape) => console.log(`3D渲染${shape}`)
};

// 抽象维度：图形（通过组合关联渲染方式）
class Shape {
  constructor(renderType) {
    this.render = Renderer[renderType]; // 桥接渲染方式
  }
}

class Circle extends Shape {
  draw() {
    this.render("圆形");
  }
}

class Rectangle extends Shape {
  draw() {
    this.render("矩形");
  }
}

// 使用
const circle = new Circle("normal");
circle.draw(); // 普通渲染圆形

circle.render = Renderer.threeD; // 动态切换
circle.draw(); // 3D渲染圆形
```

## 五、桥接模式的核心特点
### 1. 优点
- **解耦多维度变化**：每个维度独立扩展，新增图形/渲染方式只需新增类，无需修改原有代码（符合开闭原则）；
- **替代继承，减少类数量**：3种图形 × 3种渲染方式 → 3+3=6个类（而非9个）；
- **提高灵活性**：可动态切换“实现部分”（如圆形从普通渲染切换为3D渲染）；
- **代码复用性高**：渲染逻辑可在所有图形间复用，无需重复编写。

### 2. 缺点
- **增加理解成本**：相比直接继承，桥接模式的“抽象-实现”分离结构更复杂；
- **仅适用于多维度变化场景**：单维度变化时使用桥接模式属于过度设计。

## 六、桥接模式 vs 其他模式（核心区别）
### 1. 桥接模式 vs 装饰器模式
| 维度                | 桥接模式                          | 装饰器模式                          |
|---------------------|-----------------------------------|-------------------------------------|
| 核心目标            | 解耦“抽象-实现”两个独立维度       | 给对象动态添加功能（单一维度扩展）  |
| 关联方式            | 组合（抽象持有实现的引用）| 嵌套（装饰器包裹被装饰对象）|
| 适用场景            | 多维度独立变化（如图形+渲染）| 单一对象的功能扩展（如给按钮加点击防抖） |

### 2. 桥接模式 vs 策略模式
| 维度                | 桥接模式                          | 策略模式                          |
|---------------------|-----------------------------------|-----------------------------------|
| 核心目标            | 解耦“抽象-实现”，关注结构扩展     | 封装算法，关注行为替换            |
| 应用场景            | 类的结构设计（多维度类扩展）| 运行时切换算法（如排序算法、校验规则） |
| 关联方式            | 抽象与实现的长期关联              | 策略与上下文的临时替换            |

### 3. 桥接模式 vs 适配器模式
| 维度                | 桥接模式                          | 适配器模式                          |
|---------------------|-----------------------------------|-------------------------------------|
| 核心目标            | 解耦两个维度，让它们独立扩展      | 兼容不兼容的接口（无扩展意图）|
| 设计时机            | 设计初期就规划解耦                | 设计后期兼容已有接口                |
| 关系                | 抽象与实现的“正向桥接”            | 接口的“反向适配”                    |

## 七、桥接模式的实际应用场景
### 1. 前端常用场景
- **UI组件库**：组件（按钮、输入框）与主题（浅色、深色、暗黑）解耦（组件=抽象，主题=实现）；
- **跨端渲染**：React组件（抽象）与渲染引擎（实现：Web、React Native、小程序）解耦；
- **日志系统**：日志类型（操作日志、错误日志）与输出方式（控制台、文件、远程接口）解耦；
- **网络请求**：请求逻辑（抽象）与传输协议（实现：HTTP、HTTPS、WebSocket）解耦。

### 2. 知名库中的应用
- **Vue的渲染器**：Vue的组件逻辑（抽象）与平台渲染（实现：Web、SSR、Weex）通过桥接模式解耦；
- **Electron**：主进程/渲染进程（抽象）与操作系统API（实现：Windows、macOS、Linux）解耦；
- **Axios**：请求核心逻辑（抽象）与适配器（实现：XHR、http、mock）解耦（`axios.defaults.adapter` 就是桥接的实现）。

## 八、使用建议
1. **适合使用**：
   - 系统存在两个或多个独立变化的维度（如类型+实现、组件+主题）；
   - 避免使用继承导致类爆炸；
   - 希望抽象和实现都能独立扩展，且不互相影响。
2. **避免使用**：
   - 只有单一维度变化（如仅需扩展图形类型，渲染方式固定）；
   - 系统规模小，类数量少，无需提前解耦。

## 总结
桥接模式的核心是「用组合替代继承，解耦两个独立变化的维度」。它的关键价值在于解决“多维度继承导致的类爆炸”问题，让每个维度可以独立扩展。在前端开发中，无需严格遵循经典的4角色结构，核心是抓住“拆分维度、组合关联”的本质——比如组件与主题、逻辑与渲染、核心功能与适配层的解耦，都是桥接模式的典型应用。

相比其他结构型模式，桥接模式更关注“设计初期的维度拆分”，是前端处理复杂组件/跨端/多主题场景的重要模式，也是“组合优于继承”设计原则的最佳实践之一。