### 工厂模式
#### 一、工厂模式基础认知
##### 1. 核心定义
工厂模式是**创建型设计模式**，核心思想是「封装对象创建过程」，将对象的创建与使用分离，降低代码耦合度，提高扩展性。

##### 2. 三大分类（TypeScript实现）
| 模式类型       | 核心逻辑                          | 适用场景                          | 优缺点                                  |
|----------------|-----------------------------------|-----------------------------------|-----------------------------------------|
| 简单工厂模式   | 一个工厂函数统一创建多种产品      | 产品类型少、新增不频繁            | 优点：简洁、集中管理创建逻辑；缺点：违反开闭原则 |
| 工厂方法模式   | 一个具体工厂负责创建一种产品      | 产品类型多、需频繁新增            | 优点：符合开闭原则、单一职责；缺点：工厂数量增多 |
| 抽象工厂模式   | 一个工厂创建一组相关的产品族      | 需保证产品族一致性、频繁切换产品族 | 优点：产品族统一；缺点：新增产品类型违反开闭原则 |

#### 二、关键区别（重点）
##### 1. 工厂方法模式 vs 抽象工厂模式
| 对比维度       | 工厂方法模式                      | 抽象工厂模式                      |
|----------------|-----------------------------------|-----------------------------------|
| 核心目标       | 生产单一类型产品                  | 生产一组相关产品族                |
| 产品维度       | 单维度（如手机、电脑）            | 双维度（如品牌+类型：苹果手机、华为电脑） |
| 扩展方式       | 新增产品→新增工厂（符合开闭）      | 新增产品族→新增工厂（符合开闭）；新增产品类型→修改所有工厂（违反开闭） |
| 典型类比       | 奶茶店：A店只做珍珠奶茶，B店只做芋泥奶茶 | 餐饮连锁：麦当劳同时做汉堡、薯条、可乐 |

#### 三、TypeScript实现三种工厂模式
##### 1. 简单工厂模式（Simple Factory）
```typescript
// 定义产品接口
interface Product {
  type: string;
  brand: string;
  price: number;
  use(): void;
}

// 具体产品：手机
class Phone implements Product {
  type: string = "手机";
  constructor(public brand: string, public price: number) {}
  use(): void {
    console.log(`使用${this.brand}${this.type}，价格${this.price}元`);
  }
}

// 具体产品：电脑
class Computer implements Product {
  type: string = "电脑";
  constructor(public brand: string, public price: number) {}
  use(): void {
    console.log(`使用${this.brand}${this.type}，价格${this.price}元`);
  }
}

// 简单工厂类
class ProductFactory {
  // 工厂方法：根据类型创建产品
  static createProduct(type: string, brand: string): Product {
    switch (type) {
      case "phone":
        return new Phone(brand, brand === "苹果" ? 7999 : 4999);
      case "computer":
        return new Computer(brand, brand === "苹果" ? 19999 : 8999);
      default:
        throw new Error(`不支持创建${type}类型产品`);
    }
  }
}

// 使用示例
const iphone = ProductFactory.createProduct("phone", "苹果");
const huaweiComputer = ProductFactory.createProduct("computer", "华为");
iphone.use(); // 使用苹果手机，价格7999元
huaweiComputer.use(); // 使用华为电脑，价格8999元
```

##### 2. 工厂方法模式（Factory Method）
```typescript
// 产品接口
interface Product {
  type: string;
  brand: string;
  price: number;
  use(): void;
}

// 具体产品：手机
class Phone implements Product {
  type: string = "手机";
  constructor(public brand: string, public price: number) {}
  use(): void {
    console.log(`使用${this.brand}${this.type}，价格${this.price}元`);
  }
}

// 具体产品：电脑
class Computer implements Product {
  type: string = "电脑";
  constructor(public brand: string, public price: number) {}
  use(): void {
    console.log(`使用${this.brand}${this.type}，价格${this.price}元`);
  }
}

// 抽象工厂接口
interface IFactory {
  createProduct(brand: string): Product;
}

// 具体工厂：手机工厂
class PhoneFactory implements IFactory {
  createProduct(brand: string): Product {
    return new Phone(brand, brand === "苹果" ? 7999 : 4999);
  }
}

// 具体工厂：电脑工厂
class ComputerFactory implements IFactory {
  createProduct(brand: string): Product {
    return new Computer(brand, brand === "苹果" ? 19999 : 8999);
  }
}

// 使用示例
const phoneFactory = new PhoneFactory();
const iphone = phoneFactory.createProduct("苹果");

const computerFactory = new ComputerFactory();
const macBook = computerFactory.createProduct("苹果");

iphone.use(); // 使用苹果手机，价格7999元
macBook.use(); // 使用苹果电脑，价格19999元
```

##### 3. 抽象工厂模式（Abstract Factory）
```typescript
// 产品族接口：手机
interface IPhone {
  type: string;
  brand: string;
  price: number;
  call(): void;
}

// 产品族接口：电脑
interface IComputer {
  type: string;
  brand: string;
  price: number;
  code(): void;
}

// 具体产品：苹果手机
class ApplePhone implements IPhone {
  type: string = "手机";
  brand: string = "苹果";
  price: number = 7999;
  call(): void {
    console.log(`使用苹果手机打电话`);
  }
}

// 具体产品：苹果电脑
class AppleComputer implements IComputer {
  type: string = "电脑";
  brand: string = "苹果";
  price: number = 19999;
  code(): void {
    console.log(`使用苹果电脑写代码`);
  }
}

// 具体产品：华为手机
class HuaweiPhone implements IPhone {
  type: string = "手机";
  brand: string = "华为";
  price: number = 4999;
  call(): void {
    console.log(`使用华为手机打电话`);
  }
}

// 具体产品：华为电脑
class HuaweiComputer implements IComputer {
  type: string = "电脑";
  brand: string = "华为";
  price: number = 8999;
  code(): void {
    console.log(`使用华为电脑写代码`);
  }
}

// 抽象工厂接口（产品族工厂）
interface IBrandFactory {
  createPhone(): IPhone;
  createComputer(): IComputer;
}

// 具体工厂：苹果产品族工厂
class AppleFactory implements IBrandFactory {
  createPhone(): IPhone {
    return new ApplePhone();
  }
  createComputer(): IComputer {
    return new AppleComputer();
  }
}

// 具体工厂：华为产品族工厂
class HuaweiFactory implements IBrandFactory {
  createPhone(): IPhone {
    return new HuaweiPhone();
  }
  createComputer(): IComputer {
    return new HuaweiComputer();
  }
}

// 使用示例
const appleFactory = new AppleFactory();
const iphone = appleFactory.createPhone();
const macBook = appleFactory.createComputer();

const huaweiFactory = new HuaweiFactory();
const huaweiPhone = huaweiFactory.createPhone();
const huaweiComputer = huaweiFactory.createComputer();

iphone.call(); // 使用苹果手机打电话
macBook.code(); // 使用苹果电脑写代码
huaweiPhone.call(); // 使用华为手机打电话
huaweiComputer.code(); // 使用华为电脑写代码
```

#### 四、JavaScript库中的工厂模式应用
工厂模式是前端库的高频设计选择，核心用于「多实例隔离、封装复杂创建逻辑、简化API使用」，典型案例如下：

##### 1. axios（工厂方法模式）
- 核心API：`axios.create(config)`
- 设计动机：
  - axios 核心是请求函数（非类）；
  - 封装「配置合并、方法绑定、实例隔离」逻辑，支持多服务端请求（如同时请求apiA和apiB）；
  - 兼顾全局单例（直接调用 `axios.get`）和多实例（`apiA.get`）。

##### 2. React
- 核心API：`React.createElement`（简单工厂）、`React.createContext`（工厂方法）
- 设计动机：
  - `createElement`：根据入参生成不同类型VNode，隐藏虚拟DOM内部结构；
  - `createContext`：创建独立的上下文实例，支持多上下文隔离。

##### 3. Vue3
- 核心API：`Vue.createApp`（工厂方法模式）
- 设计动机：
  - 替代Vue2的 `new Vue()`，支持多App实例隔离（一个页面多个Vue应用）；
  - 封装实例初始化、插件注册、配置合并逻辑，简化使用。

##### 4. Redux
- 核心API：`Redux.createStore`（工厂方法）、`combineReducers`（工厂函数）
- 设计动机：
  - `createStore`：创建符合Redux规范的状态容器，封装状态管理逻辑；
  - 保证每个store独立，避免状态污染。

##### 5. Express/Koa
- 核心API：`express()`、`new Router()`（工厂模式）
- 设计动机：
  - 创建独立的应用/路由实例，支持多服务启动（如同时监听3000和3001端口）；
  - 隔离中间件、路由配置，避免全局污染。

#### 五、核心设计动机总结
前端库选择工厂模式的共性原因：
1. 多实例隔离：避免不同实例的配置、状态相互影响（如axios多实例、Vue多App）；
2. 封装复杂逻辑：隐藏内部构造细节（如VNode创建、状态容器初始化），使用者只需传递简单参数；
3. 简化API体验：提供简洁的创建入口（如 `createApp`、`createStore`），无需手动处理配置合并、方法绑定；
4. 兼容设计目标：适配函数式调用（如axios）、多场景复用（如React的createElement支持元素、组件创建）。

#### 六、使用建议
1. 小型应用/产品类型少：优先简单工厂模式（简洁高效）；
2. 产品类型多、需频繁新增：选择工厂方法模式（符合开闭原则）；
3. 需创建一组相关产品族：选择抽象工厂模式（保证产品一致性）；