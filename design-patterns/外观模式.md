# 外观模式（Facade Pattern）
## 一、核心定义
外观模式是**结构型设计模式**，核心是将多个复杂的子系统（类/接口/函数）封装为统一、简洁的高层接口，外部调用者无需关注子系统内部细节，仅通过该“门面”接口完成操作。

核心价值：为复杂子系统搭建“前台入口”，外部仅与前台交互，前台统一协调背后的所有子系统逻辑。

## 二、核心动机
解决“子系统调用复杂”的痛点：
1. 多子系统协同工作时，调用者需熟知所有子系统的接口、调用顺序，学习/使用成本高；
2. 子系统耦合紧密，修改任一子系统需改动所有调用处；
3. 重复调用相同子系统组合时，代码冗余且易出错。

## 三、核心角色
| 角色               | 职责                                                                 |
|--------------------|----------------------------------------------------------------------|
| 外观（Facade）| 封装子系统的交互逻辑（调用顺序、异常处理、参数转换），提供统一的高层接口，是外部调用的唯一入口 |
| 子系统（Subsystem） | 多个独立的类/接口/函数，实现具体业务逻辑，外观类内部调用这些子系统，子系统可被独立使用       |

## 四、完整实现（TypeScript版）
### 1. 子系统（独立实现核心逻辑）
```typescript
// 子系统1：库存校验
class InventoryService {
  checkStock(sku: string): boolean {
    console.log(`校验${sku}库存`);
    return true;
  }
}

// 子系统2：价格计算
class PriceService {
  calculatePrice(sku: string, coupon: string): number {
    console.log(`计算${sku}价格（优惠券：${coupon}）`);
    return 99;
  }
}

// 子系统3：支付处理
class PaymentService {
  pay(amount: number, userId: string): boolean {
    console.log(`${userId}支付${amount}元`);
    return true;
  }
}

// 子系统4：订单创建
class OrderService {
  createOrder(sku: string, price: number, userId: string): string {
    console.log(`创建订单：${sku}，价格${price}，用户${userId}`);
    return "ORDER123456";
  }
}

// 子系统5：消息通知
class NotificationService {
  sendMsg(orderId: string, userId: string): void {
    console.log(`给${userId}发送订单${orderId}的成功短信`);
  }
}
```

### 2. 外观类（封装子系统交互逻辑）
```typescript
class OrderFacade {
  // 内部持有子系统实例
  private inventory = new InventoryService();
  private priceService = new PriceService();
  private payment = new PaymentService();
  private orderService = new OrderService();
  private notification = new NotificationService();

  // 统一的高层接口
  placeOrder(sku: string, coupon: string, userId: string): string {
    // 封装子系统调用顺序与异常处理
    if (!this.inventory.checkStock(sku)) {
      throw new Error(`商品${sku}库存不足`);
    }

    const price = this.priceService.calculatePrice(sku, coupon);
    if (!this.payment.pay(price, userId)) {
      throw new Error(`用户${userId}支付失败`);
    }

    const orderId = this.orderService.createOrder(sku, price, userId);
    this.notification.sendMsg(orderId, userId);

    return orderId;
  }
}
```

### 3. 使用外观模式
```typescript
const orderFacade = new OrderFacade();
try {
  const orderId = orderFacade.placeOrder("phone123", "COUPON001", "USER789");
  console.log(`下单成功，订单号：${orderId}`);
} catch (e) {
  console.error("下单失败：", (e as Error).message);
}
```

## 五、核心特点
### 1. 关键特征
- 并非简单的接口聚合，而是封装子系统的**交互逻辑**（调用顺序、异常处理、参数转换）；
- 不改变子系统功能，仅提供“便捷入口”，子系统仍可被直接调用（保留灵活性）；
- 一个系统可设计多个外观类（按业务场景拆分：OrderFacade、RefundFacade等）；
- 可按需隐藏子系统的非必要接口，仅暴露核心能力。

### 2. 优缺点
| 优点 | 缺点 |
|------|------|
| 简化接口，降低外部使用成本 | 外观类易成为“上帝类”，承担过多逻辑违背单一职责； |
| 解耦外部与子系统，提升可维护性 | 新增子系统功能可能需修改外观类，违反开闭原则； |
| 统一管理子系统交互，减少代码冗余 | 过度封装会导致外观类臃肿，增加维护成本； |

## 六、前端典型应用场景&案例
### 1. 工具库封装
- **jQuery**：`$()` 封装DOM操作、事件绑定、AJAX、动画等子系统，外部仅需调用`$("#app").click()`、`$.ajax()`；
- **Lodash**：`_.debounce`/`_.throttle`封装定时器管理、防抖/节流逻辑，外部仅需`_.debounce(fn, 500)`。

### 2. 工程化配置封装
```typescript
// 子系统：基础配置、开发环境配置、生产环境配置
const baseConfig = { /* 入口、输出、loader */ };
const devConfig = { /* 热更新、devServer */ };
const prodConfig = { /* 压缩、缓存 */ };

// 外观函数：封装配置合并逻辑
function createWebpackConfig(env: "dev" | "prod") {
  let config = { ...baseConfig };
  config = env === "dev" ? { ...config, ...devConfig } : { ...config, ...prodConfig };
  return config;
}

// 调用者仅需指定环境
module.exports = createWebpackConfig("prod");
```

### 3. 业务逻辑封装
#### 案例1：请求层封装
```typescript
import axios from "axios";

// 外观函数：统一请求接口
async function request(options: { url: string; method: string; data?: any }) {
  const instance = axios.create({ baseURL: "/api" });
  // 封装拦截器、错误处理等子逻辑
  instance.interceptors.request.use(config => ({
    ...config,
    headers: { token: localStorage.getItem("token") }
  }));
  instance.interceptors.response.use(res => res.data, err => {
    console.error("请求失败：", err);
    return Promise.reject(err);
  });

  return instance(options);
}

// 调用者无需关注axios内部逻辑
request({ url: "/user", method: "get" });
```

#### 案例2：权限校验封装
```typescript
// 子系统：角色校验、功能权限校验、数据权限校验
class RoleService { checkRole(role: string): boolean { /* ... */ } }
class FuncService { checkFunc(func: string): boolean { /* ... */ } }
class DataService { checkData(dataId: string): boolean { /* ... */ } }

// 外观类：统一权限校验入口
class PermissionFacade {
  private roleService = new RoleService();
  private funcService = new FuncService();
  private dataService = new DataService();

  checkPermission(role: string, func: string, dataId: string): boolean {
    return this.roleService.checkRole(role) 
        && this.funcService.checkFunc(func) 
        && this.dataService.checkData(dataId);
  }
}

// 调用者仅需调用一个方法
const permission = new PermissionFacade();
permission.checkPermission("admin", "delete", "123");
```

### 4. 框架API封装
Vue3的`createApp`封装了组件注册、指令注册、插件安装、挂载逻辑等子系统，外部仅需：
```typescript
import { createApp } from "vue";
const app = createApp(App);
app.use(router).use(pinia).mount("#app");
```

## 七、与相似模式的核心区别
| 模式         | 核心目标                     | 关键特征                                   | 类比                     |
|--------------|------------------------------|--------------------------------------------|--------------------------|
| 外观模式     | 简化复杂子系统的调用         | 封装多个子系统交互逻辑，提供统一入口       | 医院前台：整合全流程     |
| 代理模式     | 控制对单个目标对象的访问     | 一对一代理，添加辅助逻辑（缓存、权限）     | 明星经纪人：代理单个明星 |
| 适配器模式   | 兼容不兼容的接口             | 转换接口格式，让不兼容接口协同工作         | 电源转换器：适配不同插座 |

## 八、使用建议
### 适合场景
1. 子系统复杂，调用逻辑繁琐（多步骤业务流程、多依赖整合）；
2. 需为外部提供简洁API，降低使用门槛；
3. 需解耦外部与子系统，便于子系统独立升级/修改。

### 避免场景
1. 简单逻辑（仅1-2个接口调用），无需封装；
2. 外观类过度封装导致内部逻辑臃肿（可拆分多个外观类）；
3. 子系统频繁变更，导致外观类需频繁修改（提前抽象稳定接口）。

## 总结
外观模式的核心是「封装复杂逻辑，提供简洁入口」：
- 形式特征：将多个子系统接口聚合为一个高层接口暴露；
- 本质特征：封装子系统的交互逻辑（顺序、异常、参数）；
- 前端价值：是“优雅封装”的核心手段，几乎所有易用的工具函数、框架API都基于外观模式设计。