# 建造者模式（Builder Pattern）

建造者模式是**创建型设计模式**的核心之一，核心思想是「将复杂对象的构建过程与表示分离」，允许通过分步构建、灵活配置的方式创建不同表示的复杂对象。简单来说：**把复杂对象的“组装步骤”抽离，让相同的构建过程能创建不同的产品**。

## 一、核心动机：解决“复杂对象创建”的痛点
假设你需要创建一个「电脑」对象，电脑包含CPU、内存、硬盘、显卡、系统等多个组件，且不同配置（游戏本/办公本/轻薄本）的组件组合差异大：
```typescript
// 未使用建造者模式：创建逻辑臃肿，参数混乱
class Computer {
  constructor(
    public cpu: string,
    public memory: string,
    public hardDisk: string,
    public graphicsCard: string,
    public os: string
  ) {}
}

// 创建游戏本：参数多且顺序易出错，新增配置需修改创建逻辑
const gameComputer = new Computer(
  "i9-14900K",
  "32GB DDR5",
  "2TB SSD",
  "RTX 4090",
  "Windows 11"
);

// 创建办公本：重复传参逻辑，冗余且易出错
const officeComputer = new Computer(
  "i5-14500H",
  "16GB DDR4",
  "1TB SSD",
  "核显",
  "Windows 11"
);
```
**问题**：
1. 复杂对象的参数过多，构造函数调用时易出错（顺序、类型）；
2. 不同配置的对象创建逻辑混杂，新增配置（如轻薄本）需重复编写相似代码；
3. 构建过程不灵活（无法按需跳过某些步骤，如轻薄本无需独立显卡）。

建造者模式的目标：**把“组件组装”的步骤拆分成独立方法，通过分步调用完成复杂对象构建**。

## 二、核心角色
建造者模式包含4个核心角色（TypeScript中通过接口/类明确约束）：
| 角色           | 职责                                                                 |
|----------------|----------------------------------------------------------------------|
| 产品（Product）| 要创建的复杂对象（如Computer），包含多个组件                         |
| 抽象建造者（Builder） | 定义构建复杂对象的“步骤接口”（如setCPU、setMemory、build等）|
| 具体建造者（ConcreteBuilder） | 实现抽象建造者的接口，完成具体组件的组装（如GameComputerBuilder、OfficeComputerBuilder） |
| 指挥者（Director）| 控制构建流程（如“先装CPU→再装内存→最后装系统”），调用建造者的分步方法 |

## 三、完整实现（TypeScript版）
以“定制电脑”为例，实现建造者模式：

### 1. 定义产品类（复杂对象）
```typescript
// 产品：电脑（包含多个组件）
class Computer {
  public cpu!: string; // 非空断言，由建造者赋值
  public memory!: string;
  public hardDisk!: string;
  public graphicsCard!: string;
  public os!: string;

  // 展示产品信息
  showInfo(): void {
    console.log(`电脑配置：
      CPU：${this.cpu}
      内存：${this.memory}
      硬盘：${this.hardDisk}
      显卡：${this.graphicsCard}
      系统：${this.os}
    `);
  }
}
```

### 2. 定义抽象建造者（约束构建步骤）
```typescript
// 抽象建造者：定义构建电脑的步骤接口
interface ComputerBuilder {
  setCPU(cpu: string): this; // 链式调用，返回this更易用
  setMemory(memory: string): this;
  setHardDisk(hardDisk: string): this;
  setGraphicsCard(graphicsCard: string): this;
  setOS(os: string): this;
  build(): Computer; // 最终构建出产品
}
```

### 3. 定义具体建造者（实现分步构建）
针对不同配置的电脑，实现具体的建造逻辑：
```typescript
// 具体建造者1：游戏本建造者
class GameComputerBuilder implements ComputerBuilder {
  private computer: Computer;

  constructor() {
    this.computer = new Computer(); // 初始化空产品
  }

  setCPU(cpu: string): this {
    this.computer.cpu = cpu;
    return this;
  }

  setMemory(memory: string): this {
    this.computer.memory = memory;
    return this;
  }

  setHardDisk(hardDisk: string): this {
    this.computer.hardDisk = hardDisk;
    return this;
  }

  setGraphicsCard(graphicsCard: string): this {
    this.computer.graphicsCard = graphicsCard;
    return this;
  }

  setOS(os: string): this {
    this.computer.os = os;
    return this;
  }

  build(): Computer {
    // 可添加校验逻辑（如游戏本必须有独立显卡）
    if (this.computer.graphicsCard === "核显") {
      throw new Error("游戏本必须配置独立显卡！");
    }
    return this.computer;
  }
}

// 具体建造者2：办公本建造者
class OfficeComputerBuilder implements ComputerBuilder {
  private computer: Computer;

  constructor() {
    this.computer = new Computer();
  }

  setCPU(cpu: string): this {
    this.computer.cpu = cpu;
    return this;
  }

  setMemory(memory: string): this {
    this.computer.memory = memory;
    return this;
  }

  setHardDisk(hardDisk: string): this {
    this.computer.hardDisk = hardDisk;
    return this;
  }

  setGraphicsCard(graphicsCard: string): this {
    this.computer.graphicsCard = graphicsCard;
    return this;
  }

  setOS(os: string): this {
    this.computer.os = os;
    return this;
  }

  build(): Computer {
    // 办公本默认补全系统（未设置则用Windows 11）
    if (!this.computer.os) {
      this.computer.os = "Windows 11";
    }
    return this.computer;
  }
}
```

### 4. 定义指挥者（控制构建流程）
指挥者封装“固定构建流程”，避免使用者重复编写步骤：
```typescript
// 指挥者：控制电脑构建的固定流程
class ComputerDirector {
  // 构建游戏本（固定流程）
  constructGameComputer(builder: ComputerBuilder): Computer {
    return builder
      .setCPU("i9-14900K")
      .setMemory("32GB DDR5")
      .setHardDisk("2TB SSD")
      .setGraphicsCard("RTX 4090")
      .setOS("Windows 11")
      .build();
  }

  // 构建办公本（固定流程）
  constructOfficeComputer(builder: ComputerBuilder): Computer {
    return builder
      .setCPU("i5-14500H")
      .setMemory("16GB DDR4")
      .setHardDisk("1TB SSD")
      .setGraphicsCard("核显")
      .build(); // 办公本未设置OS，建造者会补全默认值
  }
}
```

### 5. 使用建造者模式创建对象
```typescript
// 1. 直接使用建造者（灵活定制）
const customBuilder = new OfficeComputerBuilder();
const customComputer = customBuilder
  .setCPU("i7-14700H") // 自定义CPU
  .setMemory("24GB DDR4") // 自定义内存
  .setHardDisk("1TB SSD")
  .setGraphicsCard("MX550")
  .setOS("macOS") // 自定义系统
  .build();
customComputer.showInfo();

// 2. 通过指挥者（固定流程）
const director = new ComputerDirector();
const gameComputer = director.constructGameComputer(new GameComputerBuilder());
const officeComputer = director.constructOfficeComputer(new OfficeComputerBuilder());

gameComputer.showInfo();
officeComputer.showInfo();
```

## 四、简化版建造者（无指挥者，JavaScript风格）
在前端开发中，常省略“指挥者”角色，直接通过链式调用的建造者创建对象（更符合JS/TS的简洁风格）：
```typescript
// 简化版：无抽象建造者、无指挥者，直接实现链式建造
class ComputerBuilder {
  private computer: Computer;

  constructor() {
    this.computer = new Computer();
  }

  // 分步设置组件
  cpu(cpu: string): this {
    this.computer.cpu = cpu;
    return this;
  }

  memory(memory: string): this {
    this.computer.memory = memory;
    return this;
  }

  hardDisk(hardDisk: string): this {
    this.computer.hardDisk = hardDisk;
    return this;
  }

  graphicsCard(graphicsCard: string): this {
    this.computer.graphicsCard = graphicsCard;
    return this;
  }

  os(os: string): this {
    this.computer.os = os;
    return this;
  }

  // 最终构建
  build(): Computer {
    return this.computer;
  }
}

// 使用：链式调用，灵活定制
const thinComputer = new ComputerBuilder()
  .cpu("i5-1340P")
  .memory("16GB LPDDR5")
  .hardDisk("512GB SSD")
  .graphicsCard("核显")
  .os("Windows 11")
  .build();

thinComputer.showInfo();
```

## 五、建造者模式的核心特点
### 1. 优点
- **分步构建，灵活可控**：复杂对象的创建拆分为多个步骤，可按需跳过/调整步骤（如轻薄本无需设置独立显卡）；
- **代码复用性高**：相同的构建步骤可复用，不同建造者实现不同配置；
- **降低耦合**：构建过程与产品表示分离，修改组件无需修改创建逻辑；
- **参数清晰**：避免构造函数“超长参数列表”，链式调用更易读。

### 2. 缺点
- **结构复杂**：相比直接new，增加了建造者、指挥者等角色，简单对象使用会过度设计；
- **维护成本高**：新增产品组件时，需修改所有建造者的接口/实现。

## 六、建造者模式 vs 工厂模式（核心区别）
很多开发者会混淆建造者模式和工厂模式，核心差异如下：
| 维度                | 建造者模式                          | 工厂模式（简单/工厂方法/抽象工厂） |
|---------------------|-------------------------------------|------------------------------------|
| 核心目标            | 创建**复杂对象**（多组件、分步构建） | 创建**简单/单一/产品族对象**        |
| 构建方式            | 分步构建（先装CPU→再装内存→最后组装） | 一步创建（调用工厂方法直接返回对象） |
| 关注重点            | 「如何组装」（构建过程）| 「创建什么」（产品类型）|
| 灵活性              | 高（可定制每个组件）| 低（工厂固定返回某类产品）|
| 适用场景            | 复杂对象（如表单、配置项、实体类）| 简单/标准化对象（如axios实例、React VNode） |

**形象类比**：
- 工厂模式：去咖啡店直接点“拿铁”，店员直接给你做好的成品（一步获取）；
- 建造者模式：去奶茶店定制奶茶——选茶底→选甜度→选配料→加冰/热，分步组装（分步构建）。

## 七、建造者模式的实际应用场景
### 1. 前端常用场景
- **表单构建**：动态创建复杂表单（分步设置字段、校验规则、布局、提交逻辑）；
- **配置项构建**：如echarts图表配置（分步设置x轴、y轴、系列、样式、数据）；
- **请求参数构建**：复杂API请求（分步设置url、method、headers、params、data）；
- **UI组件构建**：如Modal弹窗（分步设置标题、内容、按钮、遮罩、关闭逻辑）。

### 2. 知名库中的应用
- **jQuery的链式调用**：`$('div').css('color', 'red').addClass('box').click(fn)` 本质是建造者模式（分步构建DOM操作）；

## 八、使用建议
1. **适合使用**：
   - 需要创建的对象包含多个组件，且组件组合灵活；
   - 希望分步构建对象，或需要不同配置的相同类型对象；
   - 构造函数参数过多（超过4个），导致调用混乱。
2. **避免使用**：
   - 简单对象（仅1-2个属性），直接new更简洁；
   - 对象构建步骤固定且无定制需求。

## 总结
建造者模式的核心是「拆分复杂对象的构建步骤，让构建过程可复用、可定制」。在前端开发中，无需严格遵循“抽象建造者+指挥者”的经典结构，更常用「链式调用的简化建造者」，既保留分步构建的灵活性，又符合JS/TS的简洁风格。相比工厂模式，建造者模式更适合解决“复杂对象的定制化创建”问题，是前端处理复杂配置、动态构建场景的重要模式。