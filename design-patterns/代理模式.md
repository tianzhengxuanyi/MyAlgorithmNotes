# 代理模式（Proxy Pattern）详解（TypeScript/JavaScript版）
代理模式是**结构型设计模式**的核心之一，核心思想是「为一个对象提供一个代用品或占位符，控制对原对象的访问」——简单说就是：**不直接访问目标对象，而是通过代理对象作为中间层，实现对目标对象的访问控制、功能增强或逻辑扩展**。

代理模式的核心价值在于：**分离“核心业务逻辑”和“非核心辅助逻辑”**（如缓存、权限校验、懒加载、日志），让目标对象专注于核心功能，代理对象处理辅助逻辑。

## 一、核心动机：解决“直接访问对象”的痛点
假设你有一个「图片加载器」，核心功能是加载图片，但需要添加“懒加载”“缓存”“加载占位符”等辅助逻辑：
```typescript
// 未使用代理模式：核心逻辑与辅助逻辑混杂
class ImageLoader {
  private url: string;
  constructor(url: string) {
    this.url = url;
  }

  load() {
    // 1. 非核心：缓存校验
    const cache = localStorage.getItem(this.url);
    if (cache) {
      console.log("从缓存加载图片");
      return cache;
    }
    // 2. 非核心：懒加载（判断是否在可视区域）
    if (!this.isInViewport()) {
      console.log("图片不在可视区域，延迟加载");
      setTimeout(() => this.load(), 1000);
      return;
    }
    // 3. 核心：加载图片
    console.log(`加载图片：${this.url}`);
    const result = `图片内容：${this.url}`;
    // 4. 非核心：缓存结果
    localStorage.setItem(this.url, result);
    return result;
  }

  private isInViewport() {
    // 模拟判断是否在可视区域
    return true;
  }
}
```
**问题**：
- 目标对象（`ImageLoader`）既负责核心的“加载图片”，又负责缓存、懒加载等非核心逻辑，违反“单一职责”；
- 辅助逻辑与核心逻辑强耦合，修改缓存规则需改动`ImageLoader`；
- 无法灵活开关辅助逻辑（如某些场景不需要缓存）。

代理模式的目标：**把辅助逻辑抽离到代理对象中，目标对象只保留核心功能，代理对象控制对目标对象的访问**。

## 二、核心角色
代理模式包含3个核心角色（TypeScript通过接口/类约束）：
| 角色               | 职责                                                                 |
|--------------------|----------------------------------------------------------------------|
| 抽象主题（Subject） | 定义目标对象和代理对象的共同接口（可选，JS/TS中可省略）|
| 真实主题（RealSubject） | 被代理的目标对象，实现核心业务逻辑                                   |
| 代理（Proxy）| 实现与目标对象相同的接口，持有目标对象的引用，控制对目标对象的访问，并添加辅助逻辑 |

## 三、完整实现（TypeScript版）
以“图片加载器”为例，用代理模式分离核心逻辑和辅助逻辑：

### 1. 定义目标对象（核心逻辑）
```typescript
// 真实主题：图片加载器（仅保留核心逻辑）
class ImageLoader {
  constructor(public url: string) {}

  // 核心：加载图片
  load(): string {
    console.log(`【核心逻辑】加载图片：${this.url}`);
    return `图片内容：${this.url}`;
  }
}
```

### 2. 定义代理对象（辅助逻辑）
```typescript
// 代理：图片加载代理（处理缓存、懒加载等辅助逻辑）
class ImageLoaderProxy {
  private target: ImageLoader;
  private cache: Record<string, string> = {}; // 内存缓存

  constructor(url: string) {
    this.target = new ImageLoader(url); // 持有目标对象引用
  }

  // 代理方法：与目标对象的load方法签名一致
  load(): string | void {
    const { url } = this.target;

    // 辅助逻辑1：缓存校验
    if (this.cache[url]) {
      console.log(`【代理逻辑】从缓存加载图片：${url}`);
      return this.cache[url];
    }

    // 辅助逻辑2：懒加载判断
    if (!this.isInViewport()) {
      console.log(`【代理逻辑】图片${url}不在可视区域，延迟加载`);
      setTimeout(() => this.load(), 1000);
      return;
    }

    // 访问目标对象的核心逻辑
    const result = this.target.load();

    // 辅助逻辑3：缓存结果
    this.cache[url] = result;
    localStorage.setItem(url, result); // 持久化缓存
    return result;
  }

  // 辅助方法：判断是否在可视区域
  private isInViewport(): boolean {
    // 模拟逻辑：随机返回true/false
    return Math.random() > 0.5;
  }
}
```

### 3. 使用代理模式
```typescript
// 不直接使用ImageLoader，而是通过代理访问
const imageProxy = new ImageLoaderProxy("https://example.com/photo.jpg");
imageProxy.load();
// 输出（随机）：
// 【代理逻辑】图片https://example.com/photo.jpg不在可视区域，延迟加载
// 1秒后输出：
// 【核心逻辑】加载图片：https://example.com/photo.jpg
// 再次调用load：
// 【代理逻辑】从缓存加载图片：https://example.com/photo.jpg
```

## 四、代理模式的常见类型
根据代理的功能，前端中常用的代理类型有5种：

### 1. 缓存代理（Cache Proxy）
**作用**：缓存目标对象的执行结果，避免重复计算/请求。
**示例**：
```typescript
// 目标对象：计算斐波那契数（耗时操作）
class Fibonacci {
  calculate(n: number): number {
    if (n <= 1) return n;
    return this.calculate(n - 1) + this.calculate(n - 2);
  }
}

// 缓存代理
class FibonacciProxy {
  private target = new Fibonacci();
  private cache: Record<number, number> = {};

  calculate(n: number): number {
    if (this.cache[n]) return this.cache[n];
    const result = this.target.calculate(n);
    this.cache[n] = result;
    return result;
  }
}

// 使用：第一次计算耗时，第二次直接取缓存
const fibProxy = new FibonacciProxy();
console.log(fibProxy.calculate(30)); // 耗时
console.log(fibProxy.calculate(30)); // 瞬间返回
```

### 2. 虚拟代理（Virtual Proxy）
**作用**：延迟创建/加载昂贵的目标对象（懒加载），直到真正需要时才初始化。
**示例**：懒加载图片（上文的ImageLoaderProxy）、懒加载大组件（如富文本编辑器）。

### 3. 保护代理（Protection Proxy）
**作用**：控制对目标对象的访问权限（如权限校验）。
**示例**：
```typescript
// 目标对象：管理员操作
class AdminService {
  deleteUser(id: string): void {
    console.log(`删除用户：${id}`);
  }
}

// 保护代理：校验权限
class AdminProxy {
  private target = new AdminService();
  private currentUser: { role: string } = { role: "guest" };

  constructor(user: { role: string }) {
    this.currentUser = user;
  }

  deleteUser(id: string): void {
    if (this.currentUser.role !== "admin") {
      console.log("权限不足：非管理员无法删除用户");
      return;
    }
    this.target.deleteUser(id);
  }
}

// 使用
const guestProxy = new AdminProxy({ role: "guest" });
guestProxy.deleteUser("123"); // 权限不足

const adminProxy = new AdminProxy({ role: "admin" });
adminProxy.deleteUser("123"); // 删除用户：123
```

### 4. 日志代理（Logging Proxy）
**作用**：记录目标对象的访问日志（如请求日志、操作日志）。
**示例**：
```typescript
// 目标对象：API请求
class ApiService {
  get(url: string): Promise<any> {
    return fetch(url).then(res => res.json());
  }
}

// 日志代理
class ApiProxy {
  private target = new ApiService();

  async get(url: string): Promise<any> {
    // 记录请求日志
    console.log(`[${new Date().toISOString()}] 请求URL：${url}`);
    const startTime = Date.now();
    try {
      const result = await this.target.get(url);
      // 记录成功日志
      console.log(`[${new Date().toISOString()}] 请求成功，耗时：${Date.now() - startTime}ms`);
      return result;
    } catch (e) {
      // 记录错误日志
      console.error(`[${new Date().toISOString()}] 请求失败：${e}`);
      throw e;
    }
  }
}
```

### 5. 防抖/节流代理（Debounce/Throttle Proxy）
**作用**：对目标对象的方法调用进行防抖/节流，避免频繁触发。
**示例**：
```typescript
// 目标对象：搜索功能
class SearchService {
  search(keyword: string): void {
    console.log(`搜索：${keyword}`);
  }
}

// 防抖代理
class DebounceSearchProxy {
  private target = new SearchService();
  private timer: number | null = null;

  search(keyword: string, delay = 500): void {
    if (this.timer) clearTimeout(this.timer);
    this.timer = setTimeout(() => {
      this.target.search(keyword);
      this.timer = null;
    }, delay);
  }
}

// 使用：频繁调用只会触发最后一次
const searchProxy = new DebounceSearchProxy();
searchProxy.search("js");
searchProxy.search("ts");
searchProxy.search("react"); // 最终只输出：搜索：react
```

## 五、前端中代理模式的实际应用场景&案例
### 1. 原生JS：Proxy对象（ES6）
ES6原生提供的`Proxy`是代理模式的终极实现，可拦截对象的任意操作（取值、赋值、函数调用等），是前端代理模式最核心的应用载体。

**案例1：响应式数据（Vue3核心）**
Vue3的响应式系统基于`Proxy`实现，代理对象拦截属性的`get/set`，触发依赖收集和更新：
```typescript
// 模拟Vue3响应式核心
function reactive<T extends object>(target: T): T {
  return new Proxy(target, {
    get(target, key, receiver) {
      // 辅助逻辑：依赖收集
      console.log(`收集依赖：${String(key)}`);
      return Reflect.get(target, key, receiver);
    },
    set(target, key, value, receiver) {
      // 辅助逻辑：触发更新
      console.log(`触发更新：${String(key)} = ${value}`);
      return Reflect.set(target, key, value, receiver);
    }
  });
}

// 使用
const state = reactive({ count: 0 });
state.count; // 收集依赖：count
state.count = 1; // 触发更新：count = 1
```

**案例2：对象校验**
通过`Proxy`拦截赋值操作，校验属性类型/值：
```typescript
const user = new Proxy({ name: "", age: 0 }, {
  set(target, key, value) {
    if (key === "age" && (typeof value !== "number" || value < 0)) {
      throw new Error("年龄必须是正数");
    }
    if (key === "name" && value.length > 10) {
      throw new Error("姓名长度不能超过10");
    }
    target[key as keyof typeof target] = value;
    return true;
  }
});

user.age = -1; // 报错：年龄必须是正数
user.name = "12345678901"; // 报错：姓名长度不能超过10
```

### 2. 懒加载图片/组件
**场景**：页面加载时不加载所有图片/组件，仅当元素进入可视区域时才加载，减少首屏加载时间。
**案例**：
```javascript
// 虚拟代理：图片懒加载
class LazyImage {
  constructor(private imgElement: HTMLImageElement, private src: string) {}

  load() {
    this.imgElement.src = this.src;
  }
}

class LazyImageProxy {
  private target: LazyImage;

  constructor(imgElement: HTMLImageElement, src: string) {
    this.target = new LazyImage(imgElement, src);
    // 初始显示占位图
    imgElement.src = "placeholder.png";
    // 监听滚动，判断是否进入可视区域
    window.addEventListener("scroll", () => this.checkViewport());
  }

  private checkViewport() {
    const rect = this.target.imgElement.getBoundingClientRect();
    if (rect.top < window.innerHeight && rect.bottom > 0) {
      this.target.load(); // 进入可视区域，加载真实图片
      window.removeEventListener("scroll", this.checkViewport);
    }
  }
}

// 使用：给所有图片添加懒加载代理
document.querySelectorAll("img[data-src]").forEach(img => {
  new LazyImageProxy(img, img.dataset.src!);
});
```

### 3. 网络请求代理
**场景**：统一处理请求的缓存、拦截、错误、日志，避免每个请求重复编写辅助逻辑。
**案例（Axios拦截器）**：
Axios的拦截器本质是代理模式，代理了原生的XHR/fetch请求：
```typescript
import axios from "axios";

// 请求代理（拦截器）：添加token、日志
axios.interceptors.request.use(config => {
  // 辅助逻辑1：添加token
  config.headers.Authorization = localStorage.getItem("token");
  // 辅助逻辑2：记录请求日志
  console.log(`请求：${config.method} ${config.url}`);
  return config;
});

// 响应代理（拦截器）：缓存、错误处理
axios.interceptors.response.use(
  response => {
    // 辅助逻辑1：缓存GET请求结果
    if (response.config.method === "get") {
      localStorage.setItem(response.config.url!, JSON.stringify(response.data));
    }
    return response.data;
  },
  error => {
    // 辅助逻辑2：统一错误处理
    console.error(`请求失败：${error.message}`);
    return Promise.reject(error);
  }
);

// 使用：核心请求逻辑不变，代理自动处理辅助逻辑
axios.get("https://api.example.com/user");
```

### 4. 权限控制代理
**场景**：控制用户对敏感操作/组件的访问权限，如管理员功能、付费功能。
**案例（React组件权限代理）**：
```tsx
import React from "react";

// 目标组件：管理员面板
const AdminPanel = () => {
  return <div>管理员面板：可删除用户、修改配置</div>;
};

// 代理组件：权限校验
const AdminPanelProxy = ({ userRole }: { userRole: string }) => {
  if (userRole !== "admin") {
    return <div>权限不足：仅管理员可访问</div>;
  }
  return <AdminPanel />;
};

// 使用：通过代理访问目标组件
const App = () => {
  const currentUser = { role: "guest" };
  return <AdminPanelProxy userRole={currentUser.role} />;
};
```

### 5. 缓存代理（计算/请求）
**场景**：对耗时计算、高频请求的结果进行缓存，提升性能。
**案例（React useMemo/useCallback）**：
React的`useMemo`/`useCallback`本质是缓存代理，代理了函数/计算结果的执行：
```tsx
import { useMemo } from "react";

// 目标函数：耗时计算
const heavyCalculation = (num: number) => {
  console.log("执行耗时计算");
  return num * 1000;
};

const MyComponent = ({ num }: { num: number }) => {
  // 缓存代理：仅当num变化时才重新计算
  const result = useMemo(() => heavyCalculation(num), [num]);

  return <div>计算结果：{result}</div>;
};
```

## 六、代理模式 vs 装饰器模式（核心区别）
前端开发者常混淆代理模式和装饰器模式，核心差异如下：
| 维度                | 代理模式                          | 装饰器模式                          |
|---------------------|-----------------------------------|-------------------------------------|
| 核心目标            | 控制对目标对象的**访问**（如权限、懒加载、缓存） | 增强目标对象的**功能**（如添加防抖、日志） |
| 关联时机            | 提前确定（代理对象持有目标对象引用） | 运行时动态添加（装饰器包裹目标对象） |
| 逻辑关注点          | 外部控制（代理层处理辅助逻辑）| 内部增强（装饰层与目标对象融合）|
| 示例                | Vue3响应式Proxy、图片懒加载       | React高阶组件（HOC）、函数防抖装饰器 |

**形象类比**：
- 代理模式：你想访问一个明星，必须通过经纪人（代理），经纪人控制你是否能见到明星，还会过滤无关请求；
- 装饰器模式：明星本身会唱歌，装饰器给明星添加“跳舞”“演戏”功能，明星的核心能力被增强。

## 七、使用建议
1. **适合使用**：
   - 需要控制对对象的访问（权限、懒加载、缓存）；
   - 需要给对象添加辅助逻辑，但不想污染核心代码；
   - 需要统一处理一类对象的通用逻辑（如所有请求的日志、所有图片的懒加载）。
2. **避免使用**：
   - 简单对象/逻辑，直接编写辅助逻辑更简洁；
   - 代理层过于复杂，导致代码可读性降低（如多层代理嵌套）。

## 总结
代理模式的核心是「通过中间层控制目标对象的访问」，ES6的`Proxy`是前端实现代理模式的最佳工具。在前端开发中，代理模式广泛应用于响应式数据、懒加载、权限控制、请求拦截、缓存等场景，是“单一职责”“开闭原则”的典型实践——让目标对象专注核心逻辑，代理对象处理通用辅助逻辑，既提升代码复用性，又降低维护成本。

相比其他模式，代理模式更关注“访问控制”，而装饰器模式关注“功能增强”，理解这一核心差异，就能准确选择合适的模式解决问题。