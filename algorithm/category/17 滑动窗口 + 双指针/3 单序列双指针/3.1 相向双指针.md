### 3.1 相向双指针

两个指针 left=0, right=n−1，从数组的两端开始，向中间移动，这叫相向双指针。上面的滑动窗口相当于同向双指针。

#### [1498. 满足条件的子序列数目](https://leetcode.cn/problems/number-of-subsequences-that-satisfy-the-given-sum-condition/description/)
 
给你一个整数数组 nums 和一个整数 target 。

请你统计并返回 nums 中能满足其最小元素与最大元素的 和 小于或等于 target 的 非空 子序列的数目。

由于答案可能很大，请将结果对 109 + 7 取余后返回。

```js
/**
 * 计算满足条件的子序列数目
 * @param {number[]} nums 输入数组
 * @param {number} target 目标和
 * @return {number} 满足条件的子序列数目
 */
var numSubseq = function (nums, target) {
    nums.sort((a, b) => a - b);  // 先排序数组，便于双指针操作
    const n = nums.length;
    let ans = 0;
    let left = 0, right = n - 1;  // 初始化相向双指针
    
    // 相向双指针遍历
    while (left <= right) {
        // 如果当前最小元素和最大元素的和满足条件
        if (nums[right] + nums[left] <= target) {
            // 计算以left为最小元素的子序列数目
            // C[right-left]表示在left + 1到right的元素可以任意选或不选
            // 应为最小元素和最大元素可以指向同一个元素，所以允许全不选，最小和最大元素都为left
            ans = (ans + C[right - left]) % MOD;
            left++;  // 尝试更大的最小元素
        } else {
            right--;  // 尝试更小的最大元素
        }
    }
    return ans;
};

// 预处理组合数数组
const MOD = 1e9 + 7;  // 模数
const MX = 100001;    // 最大预处理范围
const C = Array(MX);  // 组合数数组，C[k]表示2^k mod MOD
C[0] = 1;  // 2^0 = 1
for (let i = 1; i < MX; i++) {
    C[i] = (C[i - 1] * 2) % MOD;  // 预处理2的幂次
}

```

#### [11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/description/)
 
给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。

找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量。

说明：你不能倾斜容器。

```js
/**
 * 功能：计算盛最多水的容器的最大容量
 * 算法类型：相向双指针（双指针从数组两端向中间移动）
 * 输入参数：
 *   height - 包含非负整数的数组，表示容器各位置的高度
 * 返回值：
 *   number - 能容纳的最大水量
 * 算法核心思想：
 *   通过左右两个指针，计算当前两个指针形成的容器的水量，并向中间移动较短的一边，
 *   因为移动较长的一边无法得到更大的水量
 * 时间复杂度：O(n)，其中n是数组长度，每个元素最多被访问一次
 * 空间复杂度：O(1)，只使用常数额外空间
 */
var maxArea = function(height) {
    let ans = 0, left = 0, right = height.length - 1;  // 初始化最大面积、左指针（起始位置）、右指针（结束位置）
    // 当左右指针未相遇时继续循环
    while (left < right) {
        // 计算当前容器的容量：高度取左右指针中较小值，宽度为两指针距离
        ans = Math.max(ans, Math.min(height[left], height[right]) * (right - left));
        // 贪心策略：移动高度较小的一边指针
        if (height[left] < height[right]) {
            left++;  // 左指针高度较小，右移左指针
        } else {
            right--;  // 右指针高度较小或相等，左移右指针
        }
    }
    return ans;  // 返回找到的最大容量
};

```