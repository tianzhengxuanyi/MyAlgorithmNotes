
### 7.6 多维DP

#### [2222. 选择建筑的方案数](https://leetcode.cn/problems/number-of-ways-to-select-buildings/description/)

给你一个下标从 0 开始的二进制字符串 s ，它表示一条街沿途的建筑类型，其中：

s[i] = '0' 表示第 i 栋建筑是一栋办公楼，
s[i] = '1' 表示第 i 栋建筑是一间餐厅。
作为市政厅的官员，你需要随机 选择 3 栋建筑。然而，为了确保多样性，选出来的 3 栋建筑 相邻 的两栋不能是同一类型。

比方说，给你 s = "001101" ，我们不能选择第 1 ，3 和 5 栋建筑，因为得到的子序列是 "011" ，有相邻两栋建筑是同一类型，所以 不合 题意。
请你返回可以选择 3 栋建筑的 有效方案数 。

**动态规划：记忆化缓存  超时**

dfs(i, k, type) 表示 0 - i 栋建筑中，选择 k 栋建筑，且最后一栋建筑的类型为 type 的有效方案数。

- 状态转移方程：
  - 不选当前建筑：dfs(i - 1, k, type)
  - 选当前建筑：dfs(i - 1, k - 1, 1 ^ type)

- 边界条件：
  - 当 k = 0 时，返回 1，表示找到了一种有效的选择方案。
  - 当 i < 0 时，返回 0，表示没有找到有效的选择方案。

```js
/**
 * @param {string} s
 * @return {number}
 */
var numberOfWays = function (s) {
    const n = s.length;
    // 三维DP数组：dp[i][k][type]
    // i: 当前处理到的字符索引
    // k: 剩余需要选择的建筑数量 (3->2->1->0)
    // type: 最后一个选择的建筑类型 (0或1)
    const dp = Array.from({ length: n }, () => 
        Array.from({ length: 4 }, () => [-1, -1])); // 初始化记忆化缓存

    // 深度优先搜索（带记忆化）
    const dfs = (i, k, type) => {
        // 递归终止条件：已选够3个建筑
        if (k === 0) return 1;
        // 边界条件：索引越界
        if (i < 0) return 0;
        // 检查缓存
        if (dp[i][k][type] >= 0) return dp[i][k][type];
        
        // 不选当前建筑的情况
        let res = dfs(i - 1, k, type);
        // 如果当前建筑符合要求的类型（需要与前一个类型交替）
        if (s[i] == type) {  // 注意这里应该是严格等于字符类型比较
            // 选择当前建筑，并切换下一个需要的类型（1 ^ type取反）
            res += dfs(i - 1, k - 1, 1 ^ type);
        }

        return dp[i][k][type] = res; // 记录缓存
    }

    // 最终结果：以0结尾的方案数 + 以1结尾的方案数
    return dfs(n - 1, 3, 1) + dfs(n - 1, 3, 0);
};
```

**动态规划：空间优化**

dp[i][k][type] 只依赖于 dp[i-1][k][type] 和 dp[i-1][k-1][1^type]，因此可以去掉一维优化空间复杂度。

```js
/**
 * @param {string} s
 * @return {number}
 */
var numberOfWays = function (s) {
    const n = s.length;
    // 空间优化后的DP数组：dp[k][type]
    // k: 当前已选择的建筑数量 (1-3)
    // type: 最后一个选择的建筑类型 (0或1)
    const dp = Array.from({ length: 4 }, () => [0, 0]); // 初始化状态矩阵
    
    let prev; // 保存上一层状态
    for (let i = 1; i <= n; i++) {
        // 初始化第一层状态（选择1个建筑）
        prev = [1, 1];  // 基准情况：每个独立字符都可作为起点
        
        for (let k = 1; k <= 3; k++) {
            // 核心状态转移：当前字符类型为type时，累加上一层的相反类型数量
            // 1 ^ (s[i-1]-0) 实现类型翻转（0->1，1->0）
            dp[k][s[i - 1] - 0] += prev[1 ^ (s[i - 1] - 0)];
            
            // 保存当前层状态用于下一轮迭代
            prev = [...dp[k]]; // 解构赋值实现数组拷贝
        }
    }

    // 返回选择3个建筑的两种类型方案之和
    return dp[3][0] + dp[3][1];
};

```

**统计'010'和'101'的方案数：**
```js
var numberOfWays = function (s) {
    const n = s.length;
    // 统计字符串中总共有多少个0和1
    let total0 = 0, total1 = 0;
    for (let i = 0; i < n; i++) {
        if (s[i] == 0) {
            total0 += 1;
        } else {
            total1 += 1;
        }
    }

    let ans = 0;
    // 倒序遍历时，统计已遍历部分0和1的数量
    let cnt0 = 0, cnt1 = 0;
    for (let i = n - 1; i >= 0; i--) {
        if (s[i] == 0) {
            // 当遇到0时，组合模式为1-0-1：
            // cnt1是右侧已统计的1数量，(total1 - cnt1)是左侧剩余的1数量
            ans += cnt1 * (total1 - cnt1);
            cnt0 += 1;
        } else {
            // 当遇到1时，组合模式为0-1-0：
            // cnt0是右侧已统计的0数量，(total0 - cnt0)是左侧剩余的0数量
            ans += cnt0 * (total0 - cnt0);
            cnt1 += 1;
        }
    }

    return ans;
};

```

#### [2400. 恰好移动 k 步到达某一位置的方法数目](https://leetcode.cn/problems/number-of-ways-to-reach-a-position-after-exactly-k-steps/description/)
 
给你两个 正 整数 startPos 和 endPos 。最初，你站在 无限 数轴上位置 startPos 处。在一步移动中，你可以向左或者向右移动一个位置。

给你一个正整数 k ，返回从 startPos 出发、恰好 移动 k 步并到达 endPos 的 不同 方法数目。由于答案可能会很大，返回对 109 + 7 取余 的结果。

如果所执行移动的顺序不完全相同，则认为两种方法不同。

注意：数轴包含负整数。

**动态规划：记忆化缓存**

dfs(r, i) 表示剩余r步，在位置i时的最终方案数。

- 状态转移方程：
  - 向左移动一步：dfs(r - 1, i - 1)
  - 向右移动一步：dfs(r - 1, i + 1)

```js
var numberOfWays = function (startPos, endPos, k) {
    // 记忆化缓存：dp[r].get(i) 表示剩余r步时，在位置i的方案数
    const dp = Array.from({ length: k + 1 }, () => new Map());
    
    // 深度优先搜索函数
    const dfs = (r, i) => {
        if (dp[r].has(i)) return dp[r].get(i); // 已缓存的结果直接返回
        
        // 剪枝：剩余步数不足以到达目标位置
        if (Math.abs(endPos - i) > r) {
            dp[r].set(i, 0);
            return 0;
        }
        
        // 递归终止条件：步数用尽
        if (r == 0) {
            dp[r].set(i, i === endPos ? 1 : 0);
            return dp[r].get(i);
        }
        
        // 状态转移：向左或向右移动一步，结果取模
        dp[r].set(i, (dfs(r - 1, i + 1) + dfs(r - 1, i - 1)) % mod);
        return dp[r].get(i);
    }

    return dfs(k, startPos); // 从初始状态开始搜索
};

const mod = 1e9 + 7; // 题目要求的取模基数
```

**组合数学**

如果要在恰好 k 步内从 startPos 到达 endPos，假设endPos 大于 startPos，那么可以将这 k 步分成两部分：
- 先向右移动的步数：step = endPos - startPos，到达endPos
- 剩余步数：rest = k - step
- 其中，rest 必须是偶数，因为剩下向左和向右的步数必须相等，才能回到endPos。

所以问题转化为：在 k 步中，选择 step + rest / 2 步向右走，剩下的步数向左走的方案数。
- 方案数：C(k, step + rest / 2)

组合数 C(n, k) 可以通过动态规划或组合数学公式计算。
- 动态规划：C(n, k) = C(n-1, k-1) + C(n-1, k)

```js
/**
 * @param {number} startPos
 * @param {number} endPos
 * @param {number} k
 * @return {number}
 */
var numberOfWays = function (startPos, endPos, k) {
    // 计算起点到终点的绝对距离
    let step = Math.abs(startPos - endPos);
    // 剩余步数 = 总步数 - 必须步数
    let rest = k - step;
    
    // 剪枝条件：总步数不足 或 剩余步数为奇数时无法返回
    if (step > k || rest % 2) return 0;

    // 组合数学解法：C(k, m) 其中m = (必须步数 + 剩余步数/2)
    const C = Array.from({ length: k + 1 }, () => Array(k + 1).fill(0));

    // 构建组合数表（帕斯卡三角形）
    for (let i = 0; i <= k; i++) {
        C[i][0] = 1; // 任何数选0个的方案都是1
        for (let j = 1; j <= i; j++) {
            // 组合数递推公式，结果取模
            C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod;
        }
    }
    // 返回组合数结果：需要step步向目标方向，rest/2步来回抵消
    return C[k][step + rest / 2];
};

const mod = 1e9 + 7; // 题目要求的模数
```

#### [1262. 可被三整除的最大和](https://leetcode.cn/problems/greatest-sum-divisible-by-three/description/)
 
给你一个整数数组 nums，请你找出并返回能被三整除的元素 最大和。

**动态规划：空间优化**

dp[i][j] 表示前 i 个元素中，元素和 模 3 余 j 的最大值。

状态转移方程：
- dp[i][j] = max(dp[i-1][j], dp[i-1][(j-nums[i]%3+3)%3]+nums[i], nums[i] when nums[i]%3==j)
- 解释：
  - dp[i-1][j] 表示不选择当前元素的最大和。
  - dp[i-1][(j-nums[i]%3+3)%3]+nums[i] 表示选择当前元素的最大和。
  - (j-nums[i]%3+3)%3 计算出选择当前元素后，前i-1的数最大和模 3 的余数。
  - nums[i] when nums[i]%3==j 表示当前元素本身，**当且仅当当前元素本身模 3 余 j 时才选择**。

空间优化：
- 因为每次迭代只依赖于上一次的状态，所以可以使用滚动数组优化空间。


```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSumDivThree = function (nums) {
    let ans = 0;
    // 空间优化后的滚动数组：dp[当前索引%2][余数]
    // 初始化时将非初始状态设为 -Infinity (表示不可达)
    let dp = Array.from({ length: 2 }, () => Array(3).fill(-Infinity))
    // 初始状态：第一个元素的余数位置存储该元素值
    dp[0][nums[0] % 3] = nums[0];
    
    for (let i = 1; i < nums.length; i++) {
        let m = nums[i] % 3; // 当前元素模3的余数
        // 倒序遍历余数状态，避免覆盖未使用的状态
        for (let j = 2; j >= 0; j--) {
            // 状态转移：取不选当前元素 vs 选当前元素的最大值
            // (3 + j - m) % 3 是数学等价写法，避免负数取模
            dp[i % 2][j] = Math.max(
                dp[(i + 1) % 2][j], // 不选当前元素，继承上一状态
                dp[(i + 1) % 2][(3 + j - m) % 3] + nums[i] // 选当前元素
            );
            // 处理当前元素单独构成子集的情况（当余数匹配时）
            if (m === j) {
                dp[i % 2][j] = Math.max(dp[i % 2][j], nums[i]);
            }
        }
        // 更新最大值（仅关注能被3整除的情况）
        ans = Math.max(ans, dp[i % 2][0]);
    }
    return ans;
};

```

#### [3332. 旅客可以得到的最多点数 1828](https://leetcode.cn/problems/maximum-points-tourist-can-earn/)

给你两个整数 n 和 k ，和两个二维整数数组 stayScore 和 travelScore 。

一位旅客正在一个有 n 座城市的国家旅游，每座城市都 直接 与其他所有城市相连。这位游客会旅游 恰好 k 天（下标从 0 开始，**0 - k-1**），且旅客可以选择 任意 城市作为起点。

每一天，这位旅客都有两个选择：

- 留在当前城市：如果旅客在第 i 天停留在前一天所在的城市 curr ，旅客会获得 stayScore[i][curr] 点数。
- 前往另外一座城市：如果旅客从城市 curr 前往城市 dest ，旅客会获得 travelScore[curr][dest] 点数。

请你返回这位旅客可以获得的 最多 点数。

**动态规划：记忆化搜索**

dp[i][j] 表示在第 i 天位于 j 城市时,最终可获得的最大累计得分。

状态转移方程：
- dp[i][j] = max(dp[i+1][j] + stayScore[i][j], max(dp[i+1][next] + travelScore[j][next])) for next in range(n) if next != j
- 解释：
  - dp[i+1][j] + stayScore[i][j] 表示选择留在当前城市。
  - max(dp[i+1][next] + travelScore[j][next]) 表示选择前往其他城市。
    - 遍历所有可能的目标城市 next，选择得分最高的方案。

递归边界：
- 当 i == k 时，已经完成 k 天的旅游，返回 0 分（第k天不进行操作）。

```js
var maxScore = function(n, k, stayScore, travelScore) {
    // 记忆化缓存数组：dp[i][j] 表示在第i天位于j城市时的最大累计得分
    const dp = Array.from({length: k + 1}, () => Array(n).fill(-1));
    
    // 深度优先搜索函数
    const dfs = (i, j) => {
        if (i == k) return dp[i][j] = 0; // 递归终止条件：天数用尽
        if (dp[i][j] >= 0) return dp[i][j]; // 已计算过的状态直接返回
        
        // 选择1：留在当前城市
        let res = dfs(i + 1, j) + stayScore[i][j];
        
        // 选择2：移动到其他城市
        for (let next = 0; next < n; next++) {
            if (next === j) continue; // 不能停留在当前城市
            // 递归计算移动后的得分，取最大值
            res = Math.max(res, dfs(i+1, next) + travelScore[j][next]);
        }

        return dp[i][j] = res; // 记录并返回当前状态的最大值
    }

    // 遍历所有可能的起始城市，寻找最大得分
    let ans = 0;
    for (let j = 0; j < n; j++) {
        ans = Math.max(ans, dfs(0, j));
    }

    return ans;
};

```

**动态规划：空间优化**

空间优化：
- 因为第i天只依赖于后一天i+1的状态，所以可以使用滚动数组优化空间。

```js
/**
 * @param {number} n
 * @param {number} k
 * @param {number[][]} stayScore
 * @param {number[][]} travelScore
 * @return {number}
 */
var maxScore = function (n, k, stayScore, travelScore) {
    // 使用滚动数组优化空间复杂度：dp[当前天数%2][城市编号]
    const dp = Array.from({ length: 2 }, () => Array(n).fill(0));
    
    // 倒序处理每一天（从最后一天往前计算）
    for (let i = k - 1; i >= 0; i--) {
        // 遍历所有城市
        for (let j = 0; j < n; j++) {
            // 选择1：停留在当前城市（继承前一天同一城市的状态）
            dp[i % 2][j] = dp[(i + 1) % 2][j] + stayScore[i][j];
            
            // 选择2：移动到其他城市（遍历所有可能的目标城市）
            for (let next = 0; next < n; next++) {
                if (next === j) continue; // 跳过当前城市
                // 比较移动后的得分，取最大值（继承前一天目标城市的状态）
                dp[i % 2][j] = Math.max(
                    dp[i % 2][j],
                    dp[(i + 1) % 2][next] + travelScore[j][next]
                );
            }
        }
    }

    // 返回第0天所有城市中的最大得分
    return Math.max(...dp[0]);
};
```


#### [3176. 求出最长好子序列 I 1849](https://leetcode.cn/problems/find-the-maximum-length-of-a-good-subsequence-i/description/)

给你一个整数数组 nums 和一个 非负 整数 k 。如果一个整数序列 seq 满足在下标范围 [0, seq.length - 2] 中 最多只有 k 个下标 i 满足 seq[i] != seq[i + 1] ，那么我们称这个整数序列为 好 序列。

请你返回 nums 中 好 子序列 的最长长度。

**动态规划：记忆化缓存**

dfs(i, j) 表示以 nums[i] 为结尾的最长好子序列长度，其中至多有 j 个相邻元素不相同。

状态转移方程：
- 遍历所有可能的前驱元素 nums[next], next in range(i)
- 如果 nums[i] == nums[next]，则当前元素可以与前驱元素相同，不消耗机会，dfs(i, j) = max(dfs(i, j), dfs(next, j) + 1)。
- 如果 nums[i] != nums[next]，则当前元素与前驱元素不同，消耗一次机会，dfs(i, j) = max(dfs(i, j), dfs(next, j - 1) + 1)。

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var maximumLength = function (nums, k) {
    const n = nums.length;
    const dp = Array.from({ length: n }, () => Array(k + 1)) // DP缓存：dp[i][j]表示以nums[i]结尾，最多j次不同的最长子序列长度
    
    // 递归函数定义：计算以nums[i]结尾，剩余j次不同机会时的最大长度
    const dfs = (i, j) => {
        if (j < 0) return -Infinity;    // 无效状态：超过允许的不同次数
        if (i === 0) return dp[i][j] = 1; // 递归基：单个元素长度为1
        if (dp[i][j] !== undefined) return dp[i][j]; // 记忆化返回
        
        let res = 1; // 至少可以取当前元素自己（长度1）
        // 遍历所有可能的前驱元素
        for (let next = i - 1; next >= 0; next--) { 
            if (nums[i] === nums[next]) {
                // 元素相同：继承前驱的剩余次数
                res = Math.max(res, dfs(next, j) + 1);
            } else {
                // 元素不同：消耗一次机会，取前驱的j-1状态
                res = Math.max(res, dfs(next, j - 1) + 1);
            }
        }

        return dp[i][j] = res; // 记录并返回最优解
    }

    let ans = 0;
    // 遍历所有可能的结尾元素，取最大值
    for (let i = n - 1; i >= 0; i--) {
        ans = Math.max(ans, dfs(i, k));
    }

    return ans;
};

```

**动态规划：时间优化**

时间复杂度优化：

- 使用prevMx 记录前一层(j-1)的最大值数组，O(1)的时间计算dfs(next, j - 1) when nums[i] !== nums[next]
- 使用mxMap 记录相同数值的最大长度，O(1)的时间计算dfs(next, j) when nums[i] === nums[next]

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var maximumLength = function (nums, k) {
    const n = nums.length;
    // dp[j][i] 表示允许j次不同，以nums[i]结尾的最长好子序列长度
    const dp = Array.from({ length: k + 1 }, () => Array(n).fill(1));
    // prevMx 记录前一层(j-1)的最大值数组
    let prevMx = Array(n).fill(-Infinity);
    
    for (let j = 0; j <= k; j++) { // 遍历所有可能的差异次数
        // mxMap 记录相同数值的最大长度，currMax 当前全局最大值，temp 临时存储当前层最大值
        let mxMap = new Map(), currMax = -Infinity, temp = Array(n).fill(-Infinity);
        
        for (let i = 0; i < n; i++) { // 正序处理每个元素
            temp[i] = currMax; // 保存当前位置之前的全局最大值
            
            // 状态转移：取三种情况最大值
            // 1. 维持当前长度 2. 继承前层不同次数状态 3. 使用相同数值的缓存
            dp[j][i] = Math.max(
                dp[j][i], // 基础长度1
                prevMx[i] + 1, // 从前层不同次数状态转移
                (mxMap.get(nums[i]) ?? 0) + 1 // 相同数值的缓存转移
            );
            // currMax 包括了当前位置的所有可能的最大值
            // 其中有可能是从不同次数状态转移过来的，也可能是从相同数值的缓存转移过来的
            // 但是当nums[i] == nums[next]时 dfs(next, j) 一定大于等于 dfs(next, j - 1)
            // 所以不影响最终结果
            currMax = Math.max(currMax, dp[j][i]); // 更新全局最大值
            // 更新当前数值的最大长度缓存
            mxMap.set(nums[i], Math.max(dp[j][i], mxMap.get(nums[i]) ?? 0));
        }
        prevMx = temp; // 保存当前层结果供下一层使用
    }

    return Math.max(...dp[k]); // 返回允许k次差异时的全局最大值
};

```

**动态规划：空间优化**

状态转移中没有使用之前的结果可以省略dp数组

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var maximumLength = function (nums, k) {
    const n = nums.length;
    // 前一层最大长度数组，初始为负无穷表示不可达
    let prevMx = Array(n).fill(-Infinity), ans = -Infinity;
    
    // 遍历所有允许的差异次数 (0~k)
    for (let j = 0; j <= k; j++) {
        // mxMap: 存储相同数值的最大长度，currMax: 当前全局最大值，temp: 临时存储当前层最大值
        let mxMap = new Map(), currMax = -Infinity, temp = Array(n).fill(-Infinity);
        
        // 正序处理每个元素，维护前缀最大值
        for (let i = 0; i < n; i++) {
            temp[i] = currMax; // 记录当前位置之前的全局最大值
            
            // 状态转移：三种情况取最大值
            // 1.当前元素单独构成序列 2.继承前层不同次数状态 3.使用相同数值缓存
            let curr = Math.max(
                1, 
                prevMx[i] + 1, 
                (mxMap.get(nums[i]) ?? 0) + 1
            );
            
            currMax = Math.max(currMax, curr); // 更新全局最大值
            mxMap.set(nums[i], Math.max(curr, mxMap.get(nums[i]) ?? 0)); // 更新数值缓存
            ans = Math.max(ans, curr); // 维护全局答案
        }
        prevMx = temp; // 保存当前层结果供下一层使用
    }
    return ans;
};

```

#### [1269. 停在原地的方案数 1854](https://leetcode.cn/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/description/)

有一个长度为 arrLen 的数组，开始有一个指针在索引 0 处。

每一步操作中，你可以将指针向左或向右移动 1 步，或者停在原地（指针不能被移动到数组范围外）。

给你两个整数 steps 和 arrLen ，请你计算并返回：在恰好执行 steps 次操作以后，指针仍然指向索引 0 处的方案数。

由于答案可能会很大，请返回方案数 模 10^9 + 7 后的结果。

**动态规划: 滚动数组**

dp[i][j] 表示在 i 步操作后，指针停在 j 位置的最终方案数。

状态转移方程：
- dp[i][j] = dp[i+1][j] + dp[i+1][j-1] + dp[i+1][j+1] j in range(1, arrLen-1)
- dp[i][0] = dp[i+1][0] + dp[i+1][1], 边界情况 只能向右、停留
- dp[i][arrLen-1] = dp[i+1][arrLen-1] + dp[i+1][arrLen-2]，边界情况 只能向左、停留

```js
/**
 * @param {number} steps
 * @param {number} arrLen
 * @return {number}
 */
var numWays = function (steps, arrLen) {
    if (arrLen == 1) return 1; // 特殊情况处理：数组长度为1时只有原地停留一种方案
    const dp = Array.from({ length: 2 }, () => Array(arrLen).fill(0)); // 滚动数组优化，只需保留两步状态
    dp[0][0] = 1; // 初始状态：0步时位置0的方案数为1
    
    // 遍历每一步操作
    for (let i = 1; i <= steps; i++) {
        // 处理边界位置0（只能从位置0停留或从位置1左移过来）
        dp[i % 2][0] = (dp[(i - 1) % 2][1] + dp[(i - 1) % 2][0]) % mod;
        
        // 处理边界最后位置（只能从末尾位置停留或从倒数第二位置右移过来）
        dp[i % 2][arrLen - 1] = (dp[(i - 1) % 2][arrLen - 2] + dp[(i - 1) % 2][arrLen - 1]) % mod;
        
        // 处理中间位置（可停留/左移/右移）
        for (let j = 1; j < Math.min(arrLen - 1, i + 1); j++) { // 优化：j不可能超过当前步数+1
            dp[i % 2][j] = (
                dp[(i - 1) % 2][j] +     // 原地停留
                dp[(i - 1) % 2][j - 1] + // 从左侧移动过来 
                dp[(i - 1) % 2][j + 1]   // 从右侧移动过来
            ) % mod;
        }
    }
    return dp[steps % 2][0]; // 返回最终停留在位置0的方案数
};

const mod = 1e9 + 7; // 题目要求的模数

```

**动态规划：一个数组**

用prev记录dp[i-1][j-1]，使用一维数组优化空间复杂度

```js
/**
 * @param {number} steps
 * @param {number} arrLen
 * @return {number}
 */
var numWays = function (steps, arrLen) {
    if (arrLen == 1) return 1; // 数组长度为1时只能原地停留
    const dp = Array(arrLen).fill(0); // 一维数组空间优化
    dp[0] = 1; // 初始状态：0步时位置0的方案数为1
    let prev;   // 用于保存前一个位置的旧值
    
    // 遍历每一步操作
    for (let i = 1; i <= steps; i++) {
        prev = dp[0]; // 保存位置0的旧值
        // 优化遍历范围：当前位置j不可能超过当前步数i+1
        for (let j = 0; j <= Math.min(arrLen - 1, i + 1); j++) {
            let curr = dp[j]; // 保存当前位置的旧值
            
            // 状态转移分三种情况：
            if (j === 0) { 
                // 边界位置0：只能从原地停留或右侧移动过来
                dp[0] = (dp[1] + dp[0]) % mod;
            } else if (j === arrLen - 1) {
                // 边界末尾位置：只能从原地停留或左侧移动过来
                dp[arrLen - 1] = (prev + dp[arrLen - 1]) % mod;
            } else {
                // 中间位置：左移来 + 停留 + 右移来
                dp[j] = (dp[j] + prev + dp[j + 1]) % mod;
            }

            prev = curr; // 更新prev为当前处理前的旧值
        }
    }
    return dp[0]; // 返回最终停留在起始位置的方案数
};

const mod = 1e9 + 7; // 题目要求的模数

```

#### [3250. 单调数组对的数目 I 1898](https://leetcode.cn/problems/find-the-count-of-monotonic-pairs-i/description/)

给你一个长度为 n 的 正 整数数组 nums 。

如果两个 非负 整数数组 (arr1, arr2) 满足以下条件，我们称它们是 单调 数组对：

- 两个数组的长度都是 n 。
- arr1 是单调 非递减 的，换句话说 arr1[0] <= arr1[1] <= ... <= arr1[n - 1] 。
- arr2 是单调 非递增 的，换句话说 arr2[0] >= arr2[1] >= ... >= arr2[n - 1] 。
- 对于所有的 0 <= i <= n - 1 都有 arr1[i] + arr2[i] == nums[i] 。

请你返回所有 单调 数组对的数目。

由于答案可能很大，请你将它对 109 + 7 取余 后返回。

**动态规划**

dp[i][j] 表示以 nums[i] 为结尾，arr1 中最大值为 j 的单调数组对的数量。枚举dp[i-1][m]的所有可能方案数：

- m <= j
- m <= nums[i-1]
- nums[i-1] - m >= nums[i] - j => m <=  nums[i-1] - nums[i] + j

综上m的取值范围为：[0, min(nums[i-1] - nums[i] + j, nums[i-1], j)]

```js
/**
 * 计算满足特定条件的数对个数（动态规划解法）
 * @param {number[]} nums 输入数组，元素表示位置约束条件
 * @return {number} 返回符合条件的数对个数，模 1e9+7
 */
var countOfPairs = function (nums) {
    const n = nums.length, last = nums[n - 1]; // 数组长度和最后一个元素值
    // 以 nums[i] 为结尾，arr1 中最大值为 j 的单调数组对的数量
    const dp = Array.from({ length: n }, () => Array(last + 1).fill(-1)); // 记忆化数组，存储子问题结果

    // 递归记忆化搜索函数
    const dfs = (i, j) => {
        if (i == 0) return 1; // 基准情况：处理到第一个元素时只有一种组合方式
        if (dp[i][j] >= 0) return dp[i][j] // 已计算过的子问题直接返回
        
        let v = nums[i]; // 当前元素的约束值
        let res = 0;
        // 遍历可能的前一个元素的状态值 k
        for (let k = 0; k <= Math.min(j, nums[i - 1], nums[i - 1] - v + j); k++) {
            res = (res + dfs(i - 1, k)) % mod; // 累加前一个状态的所有可能情况
        }
        return dp[i][j] = res; // 存储并返回当前子问题的结果
    }

    let ans = 0;
    // 遍历所有可能的最终状态值
    for (let j = 0; j <= last; j++) {
        ans = (ans + dfs(n - 1, j))  % mod; // 累加所有终态情况的结果
    }
    return ans;
};

const mod = 1e9 + 7; // 模数常量，用于防止整数溢出
```

#### [3218. 切蛋糕的最小总开销 I ](https://leetcode.cn/problems/minimum-cost-for-cutting-cake-i/description/)

有一个 m x n 大小的矩形蛋糕，需要切成 1 x 1 的小块。

给你整数 m ，n 和两个数组：

- horizontalCut 的大小为 m - 1 ，其中 horizontalCut[i] 表示沿着水平线 i 切蛋糕的开销。
- verticalCut 的大小为 n - 1 ，其中 verticalCut[j] 表示沿着垂直线 j 切蛋糕的开销。
一次操作中，你可以选择任意不是 1 x 1 大小的矩形蛋糕并执行以下操作之一：

- 沿着水平线 i 切开蛋糕，开销为 horizontalCut[i] 。
- 沿着垂直线 j 切开蛋糕，开销为 verticalCut[j] 。
每次操作后，这块蛋糕都被切成两个独立的小蛋糕。

每次操作的开销都为最开始对应切割线的开销，并且不会改变。

请你返回将蛋糕全部切成 1 x 1 的蛋糕块的 最小 总开销。


**动态规划: 记忆化缓存**

dfs(startH, endH, startV, endV) 表示 水平线(startH - 1, endH + 1) 和 垂直线(startV - 1, endV + 1) 之间的矩形块的最小总开销（表示可切的水平线有startH-endH,垂直线有startV-endV）。

```js
/**
 * @param {number} m
 * @param {number} n
 * @param {number[]} horizontalCut
 * @param {number[]} verticalCut
 * @return {number}
 */
var minimumCost = function (m, n, horizontalCut, verticalCut) {
    // 初始化四维记忆化数组：dp[startH+1][endH+1][startV+1][endV+1] 表示切割区间的最小开销
    // +1偏移量用于处理边界情况（避免负索引）
    const dp = Array.from({ length: m + 1 },
        () => Array.from({ length: m + 1 },
            () => Array.from({ length: n + 1 },
                () => Array(n + 1).fill(-1))));

    // 深度优先搜索函数（区间DP）
    const dfs = (startH, endH, startV, endV) => {
        // 递归终止条件：当没有可切割的水平和垂直线时
        if (startH > endH && startV > endV) return 0;
        // 记忆化检查（+1偏移量处理索引）
        if (dp[startH + 1][endH + 1][startV + 1][endV + 1] >= 0) return dp[startH + 1][endH + 1][startV + 1][endV + 1];
        
        let res = Infinity;
        // 遍历所有水平切割点（horizontalCut数组长度为m-1，索引0~m-2）
        for (let i = startH; i <= endH; i++) {
            // 递归计算切割点左右区间，并累加当前切割开销
            res = Math.min(res, 
                dfs(startH, i - 1, startV, endV) +  // 左区间
                dfs(i + 1, endH, startV, endV) +     // 右区间
                horizontalCut[i]);                   // 当前切割开销
        }
        // 遍历所有垂直切割点（verticalCut数组长度为n-1，索引0~n-2）
        for (let i = startV; i <= endV; i++) {
            res = Math.min(res,
                dfs(startH, endH, startV, i - 1) +   // 上区间
                dfs(startH, endH, i + 1, endV) +     // 下区间
                verticalCut[i]);                     // 当前切割开销
        }
        return dp[startH + 1][endH + 1][startV + 1][endV + 1] = res;
    }

    // 初始调用：处理全部切割范围（水平0~m-2，垂直0~n-2）
    return dfs(0, m - 2, 0, n - 2)
};

```

#### [3122. 使矩阵满足条件的最少操作次数]

给你一个大小为 m x n 的二维矩形 grid 。每次 操作 中，你可以将 任一 格子的值修改为 任意 非负整数。完成所有操作后，你需要确保每个格子 grid[i][j] 的值满足：

- 如果下面相邻格子存在的话，它们的值相等，也就是 grid[i][j] == grid[i + 1][j]（如果存在）。
- 如果右边相邻格子存在的话，它们的值不相等，也就是 grid[i][j] != grid[i][j + 1]（如果存在）。
请你返回需要的 最少 操作数目。

- 1 <= n, m <= 1000
- 0 <= grid[i][j] <= 9

**动态规划：记忆化搜索**

dfs(i,k)表示0-i列，第i列的值为k的最少操作次数。

dfs(i, k) = count_i_k + min(dfs(i-1, j)) for j in range(10) if j != k，其中count_i_k表示第i列的值全部变为k的操作次数。

```js
var minimumOperations = function (grid) {
    const m = grid.length,
        n = grid[0].length;
    // 记忆化数组：memo[i][k] 表示处理到第i列，且该列全部改为k时的最小操作次数
    const memo = Array.from({length: n}, () => Array(10).fill(-1));
    
    // 递归函数：计算第i列全改为k时的最小操作次数
    const dfs = (i, k) => {
        // 计算修改当前列所有元素为k的操作次数
        let count = 0;
        for (let j = 0; j < m; j++) {
            if (grid[j][i] !== k) {
                count++;
            }
        }
        
        // 基准情况：处理到第一列时直接返回当前修改次数
        if (i === 0) return memo[i][k] = count;
        // 记忆化检查
        if (memo[i][k] >= 0) return memo[i][k];
        
        // 状态转移：取前一列所有非k值的方案中的最小值
        let res = Infinity;
        for (let v = 0; v <= 9; v++) {
            if (v === k) continue; // 相邻列不能相同
            res = Math.min(res, dfs(i - 1, v)); // 递归处理前一列
        }

        return memo[i][k] = res + count; // 累加当前列修改次数
    };

    // 遍历最后一列所有可能的修改值，取全局最小值
    let ans = Infinity;
    for (let k = 0; k <= 9; k++) {
        ans = Math.min(ans, dfs(n - 1, k));
    }
    return ans;
};

```

**动态规划：时间复杂度优化**

1. 预处理所有的count_i_k

2. 计算dp[i][k]的状态转移时需计算min(dfs(i-1, j)) for j in range(10) if j != k，前一列所有可能k的最小值。可以用一个变量mnK记录前一列的最小值对应的数字，用mn记录前一列的最小值，用pmn记录前一列的次小值。

    - 如果当前数字k与mnK相同，则使用pmn（避免相邻列相同）。
    - 如果当前数字k与mnK不同，则使用mn。

    用O(1)的时间计算出dp[i][k] = count_i_k + min(dfs(i-1, j)) for j in range(10) if j!= k。

```js

/** 
 * @param {number[][]} grid 输入矩阵
 * @return {number} 返回满足条件的最小操作次数
 */
var minimumOperations = function (grid) {
    const m = grid.length,        // 矩阵行数
        n = grid[0].length;       // 矩阵列数
    const dp = Array.from({ length: n }, () => Array(10).fill(0)); // dp[j][k] 表示处理到第j列且该列全改为k时的最小操作数
    const counts = Array.from({length: n}, () => Array(10).fill(0)); // 统计每列各数字出现次数

    // 统计每列数字出现频率
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            counts[j][grid[i][j]] += 1; // 记录第j列数字grid[i][j]的出现次数
        }
    }

    // 维护三个变量追踪前一列的状态：
    let mnK,  // 前一列最小值对应的数字
        mn,   // 前一列的最小值
        pmn,  // 前一列的次小值（第二小的值）
        currMnK, currMn, currPmn; // 当前列的临时值

    // 动态规划处理每一列
    for (let j = 0; j < n; j++) {
        (currMnK = 0), (currMn = Infinity), (currPmn = Infinity);
        // 计算当前列每个数字k的dp值
        for (let k = 0; k < 10; k++) {
            dp[j][k] = m - counts[j][k]; // 将当前列全部改为k需要改变的次数（总行数 - 已存在的数量）
            if (j != 0) {
                // 如果当前数字k与前一列的最小值数字相同，则必须使用次小值（避免相邻列相同）
                dp[j][k] += k == mnK ? pmn : mn;
            }

            // 更新当前列的最小值和次小值
            if (dp[j][k] <= currMn) {        // 发现新的最小值
                currPmn = currMn;            // 原最小值变为次小值
                currMn = dp[j][k];           // 更新最小值
                currMnK = k;                 // 记录最小值对应的数字
            } else if (dp[j][k] < currPmn) { // 发现新的次小值
                currPmn = dp[j][k];
            }
        }
        // 将当前列状态保存，供下一列使用
        (mnK = currMnK), (mn = currMn), (pmn = currPmn);
    }

    // 找出最后一列的最小值即为答案
    let ans = Infinity;
    for (let k = 0; k <= 9; k++) {
        ans = Math.min(ans, dp[n - 1][k]);
    }

    return ans;
};
```

#### [576. 出界的路径数](https://leetcode.cn/problems/out-of-boundary-paths/description/)
 
给你一个大小为 m x n 的网格和一个球。球的起始坐标为 [startRow, startColumn] 。你可以将球移到在四个方向上相邻的单元格内（可以穿过网格边界到达网格之外）。你 最多 可以移动 maxMove 次球。

给你五个整数 m、n、maxMove、startRow 以及 startColumn ，找出并返回可以将球移出边界的路径数量。因为答案可能非常大，返回对 109 + 7 取余 后的结果。

**动态规划：记忆化搜索**

dfs(i, j, k)表示从(i, j)出发，最多移动k步出界路径数。

状态转移：
- dfs(i, j, k) = dfs(i-1, j, k-1) + dfs(i+1, j, k-1) + dfs(i, j-1, k-1) + dfs(i, j+1, k-1)

边界条件：
- 当k小于0时，返回0。
- 当(i, j)在边界外时，返回1。

```js
/**
 * @param {number} m
 * @param {number} n
 * @param {number} maxMove
 * @param {number} startRow
 * @param {number} startColumn
 * @return {number}
 */
var findPaths = function (m, n, maxMove, startRow, startColumn) {
    // 定义记忆化数组：memo[i][j][k] 表示在位置(i,j)剩余k步时的路径数
    const memo = Array.from({length: m}, () => Array.from({length: n}, () => Array(maxMove + 1).fill(-1)));
    const direction = [[0, 1], [0, -1], [1, 0], [-1, 0]]; // 四个移动方向：右、左、下、上
    const dfs = (i, j, k) => {
        // 终止条件1：剩余步数不足
        if (k < 0) return 0;
        // 终止条件2：已出界，找到1条有效路径
        if (i < 0 || i >= m || j < 0 || j >= n) return 1;
        // 检查是否已缓存计算结果
        if (memo[i][j][k] >= 0) return memo[i][j][k];
        let res = 0;
        // 遍历四个移动方向并累加路径数
        for (let [x, y] of direction) {
            res = (res + dfs(i + x, j + y, k - 1)) % mod;
        }

        return  memo[i][j][k] = res; // 缓存并返回计算结果
    }

    return dfs(startRow, startColumn, maxMove);
};

const mod = 1e9 + 7;
```

**动态规划：递推(另外一种定义)**

dp[i][j][k]表示从(i, j)出发，恰好移动k步出界路径数。

状态转移：
- dp[i][j][k] = dp[i-1][j][k+1] + dp[i+1][j][k+1] + dp[i][j-1][k+1] + dp[i][j+1][k+1]

边界条件：
- 当(i,j)在边界外时，dp[i][j][k] = 1。
- 当k大于maxMove时，dp[i][j][k] = 0。

```js
/**
 * @param {number} m 网格行数
 * @param {number} n 网格列数
 * @param {number} maxMove 最大移动次数
 * @param {number} startRow 起始行坐标
 * @param {number} startColumn 起始列坐标
 * @return {number} 出界路径数（模1e9+7）
 */
var findPaths = function (m, n, maxMove, startRow, startColumn) {
    // 三维DP数组：dp[k][i][j] 表示剩余k步时在(i,j)位置的路径数
    // 使用扩展边界处理越界情况（原网格对应索引1-m，1-n）
    const dp = Array.from({ length: maxMove + 1 }, () => 
        Array.from({ length: m + 2 }, () => 
            Array(n + 2).fill(0)));

    const direction = [[0, 1], [0, -1], [1, 0], [-1, 0]]; // 四个移动方向：右、左、下、上

    // 初始化边界条件：当剩余maxMove步时，所有边界外的位置路径数都是1
    for (let i = 0; i < m + 2; i++) {
        dp[maxMove][i][0] = 1;        // 左边界外
        dp[maxMove][i][n + 1] = 1;     // 右边界外
    }
    for (let j = 0; j < n + 2; j++) {
        dp[maxMove][0][j] = 1;        // 上边界外
        dp[maxMove][m + 1][j] = 1;    // 下边界外
    }

    // 倒序计算所有步数状态（从maxMove-1到0）
    for (let k = maxMove - 1; k >= 0; k--) {
        // 遍历网格内的所有位置（原始网格对应索引1-m，1-n）
        for (let i = 1; i < m + 1; i++) {
            for (let j = 1; j < n + 1; j++) {
                // 遍历四个方向，累加下一步的路径数
                for (let [x, y] of direction) {
                    dp[k][i][j] = (dp[k][i][j] + dp[k + 1][i + x][j + y]) % mod;
                }
            }
        }
    }

    // 累加所有可能步数下的起始位置路径数
    let ans = 0;
    for (let k = 0; k <= maxMove; k++) {
        ans = (ans + dp[k][startRow + 1][startColumn + 1]) % mod;
    }
    return ans;
};

const mod = 1e9 + 7; // 题目要求的模数

```

#### [1900. 最佳运动员的比拼回合](https://leetcode.cn/problems/the-earliest-and-latest-rounds-where-players-compete/description)
 
n 名运动员参与一场锦标赛，所有运动员站成一排，并根据 最开始的 站位从 1 到 n 编号（运动员 1 是这一排中的第一个运动员，运动员 2 是第二个运动员，依此类推）。

锦标赛由多个回合组成（从回合 1 开始）。每一回合中，这一排从前往后数的第 i 名运动员需要与从后往前数的第 i 名运动员比拼，获胜者将会进入下一回合。如果当前回合中运动员数目为奇数，那么中间那位运动员将轮空晋级下一回合。

- 例如，当前回合中，运动员 1, 2, 4, 6, 7 站成一排
  - 运动员 1 需要和运动员 7 比拼
  - 运动员 2 需要和运动员 6 比拼
  - 运动员 4 轮空晋级下一回合
  
每回合结束后，获胜者将会基于最开始分配给他们的原始顺序（升序）重新排成一排。

编号为 firstPlayer 和 secondPlayer 的运动员是本场锦标赛中的最佳运动员。在他们开始比拼之前，完全可以战胜任何其他运动员。而任意两个其他运动员进行比拼时，其中任意一个都有获胜的可能，因此你可以 裁定 谁是这一回合的获胜者。

给你三个整数 n、firstPlayer 和 secondPlayer 。返回一个由两个值组成的整数数组，分别表示两位最佳运动员在本场锦标赛中比拼的 最早 回合数和 最晚 回合数。

**动态规划： 多维DP：**

- 当firstPlayer + secondPlayer === n + 1，表示firstPlayer和secondPlayer相遇
  - 因此只需要枚举每一轮中firstPlayer和secondPlayer的可能位置
  - 设left为firstPlayer左侧的运动员个数，mid为firstPlayer和secondPlayer之间的运动员个数，只需枚举left和mid，则下一轮firstPlayer和secondPlayer的位置就可得出left + 1、 left + mid + 2

- 状态定义： dfs(n, f, s) 表示在总共n个运动员，firstPlayer在位置f，secondPlayer在位置s的情况下，比拼的最早回合数和最晚回合数

- 下一轮的运动员个数 Math.floor((n + 1) / 2)

首先处理f和s的位置
 `f + s > n + 1`
将左边和右边的运动员调换位置，即将f = n + 1 - s, s = n + 1 - f，交换对应于m对称的位置，转换为情况1。且保证f < _s，无需判断f和_s的位置

设当前n中，位处中间的为m = Math.floor((n + 1) / 2)，f、s于m的位置关系有2种可能：
1. f < m < s
    mid的可能范围有两种情况，第一种m ~ s的所有的运动员都晋级。第二种f + 1~m的运动员都晋级（需要去掉secondPlayer的对手）
    mnMid = s - (Math.floor(n / 2) + 1), mxMid = Math.floor((n + 1) / 2) - f
2. f < s <= m
    mnMid = 0, mxMid =  s - f - 1

```js
var earliestAndLatest = function (n, firstPlayer, secondPlayer) {
    // 记忆化数组：memo[n][f][s] 存储n人比赛时，选手f和s的最早和最晚相遇回合数
    const memo = Array.from({ length: n + 1 }, () => Array.from({ length: n + 1 }, () => Array(n + 1)));
    
    // 深度优先搜索函数
    const dfs = (n, f, s) => {
        // 基本情况：当f和s对称时，他们将在本轮相遇
        if (f + s == n + 1) return memo[n][f][s] = [1, 1];
        // 如果已计算过，直接返回结果
        if (memo[n][f][s]) return memo[n][f][s];
        
        // 保证f在左侧，s在右侧（通过对称转换）
        // 且保证f < _s
        if (f + s > n + 1) {
            [f, s] = [n + 1 - s, n + 1 - f];
        }
        
        // 计算中间位置（区分奇偶情况）
        let m = Math.floor((n + 1) / 2);
        // 计算s在中间位置的左侧或右侧时的mid范围
        let mmin = s <= m ? 0 : s - (Math.floor(n / 2) + 1);
        let mmax = s <= m ? s - f : m - f;
        
        // 初始化结果为[最早回合=∞, 最晚回合=0]
        let res = [Infinity, 0];

        // 遍历所有可能的left和mid组合
        for (let left = 0; left < f; left++) {
            for (let mid = mmin; mid < mmax; mid++) {
                // 递归计算下一轮的状态
                let [e, l] = dfs(m, left + 1, left + mid + 2);
                // 更新最早和最晚回合数
                res[0] = Math.min(res[0], e + 1);
                res[1] = Math.max(res[1], l + 1);
            }
        }

        // 存储并返回结果
        return memo[n][f][s] = res;
    }
    
    // 从初始状态开始搜索
    return dfs(n, firstPlayer, secondPlayer)
};

```