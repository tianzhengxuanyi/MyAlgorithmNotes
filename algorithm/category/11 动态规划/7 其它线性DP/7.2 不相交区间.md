### 7.2 不相交区间

**分组 + 动态规划：**
- 将所有区间按照右端点分组。
- 枚举右端点(end)，计算以当前右端点为结尾的区间的最大价值(dp[i])。
   - 对于每个右端点，枚举所有以它为结尾的区间([start_i, end])。
   - dp[i]可以从dp[start_i - 1]转移而来，加上当前区间的价值。

**二分查找 + 动态规划：**
- 对每个区间按照右端点排序。
- 对于每个区间，使用二分查找找到最大的不相交区间，更新dp数组。

**复杂度分析：**
- 动态规划：
   - 时间复杂度：O(nlogn)，排序复杂度O(nlogn)，每个区间查找复杂度O(logn)。
   - 空间复杂度：O(n)，存储dp数组。


#### [2830. 销售利润最大化](https://leetcode.cn/problems/maximize-the-profit-as-the-salesman/description/)

给你一个整数 n 表示数轴上的房屋数量，编号从 0 到 n - 1 。

另给你一个二维整数数组 offers ，其中 offers[i] = [starti, endi, goldi] 表示第 i 个买家想要以 goldi 枚金币的价格购买从 starti 到 endi 的所有房屋。

作为一名销售，你需要有策略地选择并销售房屋使自己的收入最大化。

返回你可以赚取的金币的最大数目。

注意 同一所房屋不能卖给不同的买家，并且允许保留一些房屋不进行出售。

```js
/**
 * 动态规划解决房屋销售利润最大化问题
 * @param {number} n 房屋总数（0 到 n-1）
 * @param {number[][]} offers 买家报价数组 [start, end, gold]
 * @return {number} 最大利润
 */
var maximizeTheProfit = function (n, offers) {
  // 按结束位置分组存储报价（gorup应为group，可能是拼写错误）
  const gorup = new Map();
  for (let [start, end, offer] of offers) {
    let g = gorup.get(end) ?? [];
    g.push([start, offer]);  // 存储起始位置和对应报价
    gorup.set(end, g);
  }

  // 初始化DP数组，dp[i]表示前i个房屋的最大利润
  const dp = Array(n).fill(0);
  
  // 初始化第一个房屋的报价
  for (let [_, offer] of gorup.get(0) ?? []) {
    dp[0] = Math.max(dp[0], offer); // 取最大的报价
  }

  // 动态规划主循环
  for (let i = 1; i < n; i++) {
    dp[i] = dp[i - 1]; // 默认不选当前房屋
    
    // 检查所有以i为结束位置的报价
    let g = gorup.get(i) ?? [];
    for (let [start, offer] of g) {
      // 状态转移方程：选择当前报价 + 之前区间最大利润
      dp[i] = Math.max(dp[i], offer + (dp[start - 1] ?? 0));
    }
  }

  return dp[n - 1]; // 返回最终结果
};
```

#### [2008. 出租车的最大盈利](https://leetcode.cn/problems/maximum-earnings-from-taxi/submissions/487698835/)

你驾驶出租车行驶在一条有 n 个地点的路上。这 n 个地点从近到远编号为 1 到 n ，你想要从 1 开到 n ，通过接乘客订单盈利。你只能沿着编号递增的方向前进，不能改变方向。

乘客信息用一个下标从 0 开始的二维数组 rides 表示，其中 rides[i] = [starti, endi, tipi] 表示第 i 位乘客需要从地点 starti 前往 endi ，愿意支付 tipi 元的小费。

每一位 你选择接单的乘客 i ，你可以 盈利 endi - starti + tipi 元。你同时 最多 只能接一个订单。

给你 n 和 rides ，请你返回在最优接单方案下，你能盈利 最多 多少元。

注意：你可以在一个地点放下一位乘客，并在同一个地点接上另一位乘客

**动态规划 + 分组**

```js
/**
 * @param {number} n
 * @param {number[][]} rides
 * @return {number}
 */
var maxTaxiEarnings = function(n, rides) {
    const groups = new Map();

    for (let [s, e, t] of rides) {
        let g = groups.get(e) ?? [];
        g.push([s, t]);
        groups.set(e, g)
    }
    let dp = Array(n+1).fill(0);
    let ans = 0;
    for (let i = 1; i <= n; i++) {
        dp[i] = dp[i-1];
        let g = groups.get(i);
        if (g) {
            for (let [s, t] of g) {
                dp[i] = Math.max(dp[s] + i - s + t, dp[i]);
            }
        }
        ans = Math.max(ans, dp[i]);
    }
    return ans;
};
```

**动态规划 + 二分查找**

```js
/**
 * @param {number} n
 * @param {number[][]} rides
 * @return {number}
 */
var maxTaxiEarnings = function(n, rides) {
    rides.sort((a, b) => a[1] - b[1]);
    const binarySearch = (end, i) => {
        let left = 0, right = i;
        while (left < right) {
            let mid = ((right - left) >> 1) + left;
            if (rides[mid][1] > end) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        return left;
    }
    const m = rides.length;
    const dp = new Array(m + 1).fill(0);
    for (let i = 0; i < m; i++) {
        let j = binarySearch(rides[i][0], i);
        dp[i + 1] = Math.max(dp[i], dp[j] + rides[i][1] - rides[i][0] + rides[i][2]);
    }
    return dp[m];
};
```

#### [2054. 两个最好的不重叠活动](https://leetcode.cn/problems/two-best-non-overlapping-events/description/)
 
给你一个下标从 0 开始的二维整数数组 events ，其中 events[i] = [startTimei, endTimei, valuei] 。第 i 个活动开始于 startTimei ，结束于 endTimei ，如果你参加这个活动，那么你可以得到价值 valuei 。你 最多 可以参加 两个时间不重叠 活动，使得它们的价值之和 最大 。

请你返回价值之和的 最大值 。

注意，活动的开始时间和结束时间是 包括 在活动时间内的，也就是说，你不能参加两个活动且它们之一的开始时间等于另一个活动的结束时间。更具体的，如果你参加一个活动，且结束时间为 t ，那么下一个活动必须在 t + 1 或之后的时间开始。

```js
/**
 * 查找最多两个不重叠事件的最大价值之和
 * @param {number[][]} events - 事件数组，每个事件格式为 [start_time, end_time, value]
 * @return {number}
 */
var maxTwoEvents = function (events) {
    const n = events.length;
    // 按结束时间升序排序，便于后续二分查找
    events.sort((a, b) => a[1] - b[1]);
    
    // 初始化DP数组，dp[i][k] 表示前i个事件中选择k个的最大价值
    const dp = Array.from({ length: n }, () => Array(3).fill(0));
    dp[0][1] = dp[0][2] = events[0][2]; // 初始化第一个事件的选择
    
    for (let i = 1; i < n; i++) {
        const [s, e, v] = events[i];
        // 二分查找最后一个结束时间 < 当前事件开始时间的事件
        let next = lowerBound(events, 0, i - 1, s) - 1;
        
        // 转移方程：选择当前事件 + 前一个不重叠事件的最优解
        dp[i][2] = Math.max(dp[i - 1][2], (dp[next]?.[1] ?? 0) + v); // 选两个事件
        dp[i][1] = Math.max(dp[i - 1][1], (dp[next]?.[0] ?? 0) + v); // 选一个事件
    }

    return dp[n - 1][2]; // 返回选两个事件的最大值
};

/**
 * 二分查找第一个结束时间 >= target 的事件索引
 * @param {Array} nums - 已排序的事件数组
 * @param {number} start - 查找起始索引
 * @param {number} end - 查找结束索引
 * @param {number} target - 目标开始时间
 */
const lowerBound = (nums, start, end, target) => {
    let l = start,
        r = end;

    while (l <= r) {
        let mid = Math.floor((r - l) / 2) + l;
        // 比较事件的结束时间与目标开始时间
        if (target > nums[mid][1]) {
            l = mid + 1;  // 当前事件结束时间太小，向右查找
        } else {
            r = mid - 1;  // 当前事件结束时间符合，尝试找更早的
        }
    }

    return l; // 返回第一个不满足条件的位置
};
```

#### [1751. 最多可以参加的会议数目 II 2041](https://leetcode.cn/problems/maximum-number-of-events-that-can-be-attended-ii/description/)

给你一个 events 数组，其中 events[i] = [startDayi, endDayi, valuei] ，表示第 i 个会议在 startDayi 天开始，第 endDayi 天结束，如果你参加这个会议，你能得到价值 valuei 。同时给你一个整数 k 表示你能参加的最多会议数目。

你同一时间只能参加一个会议。如果你选择参加某个会议，那么你必须 完整 地参加完这个会议。会议结束日期是包含在会议内的，也就是说你不能同时参加一个开始日期与另一个结束日期相同的两个会议。

请你返回能得到的会议价值 最大和 。

**动态规划 + 二分查找：**

状态定义：`dp[i][j]` 表示从第 `i` 个会议开始选择 `j` 个的最大价值。

初始状态：`dp[n][j] = 0`，表示没有会议选择时价值为 0。

状态转移方程：对于第 `i` 个会议，有两种选择：参加或不参加。

- 不参加第 `i` 个会议：`dp[i][j] = dp[i + 1][j]`
- 参加第 `i` 个会议：需要找到后一个不重叠的会议 `p`，`dp[i][j] = dp[p][j - 1] + value[i]`

最终结果：`dp[0][k]` 表示从第 `0` 个开始的会议中选择 `k` 个的最大价值。

将会议按照开始时间升序排序，相同开始时间按照结束时间升序排序。

二分查找：查找第一个开始时间大于当前会议结束时间的会议索引。

```js
/**
 * @param {number[][]} events
 * @param {number} k
 * @return {number}
 */
var maxValue = function (events, k) {
    // 获取事件总数
    const n = events.length;
    // 对事件进行排序：先按开始时间升序，开始时间相同则按结束时间升序
    events.sort((a, b) => {
        if (a[0] === b[0]) {
            return a[1] - b[1];
        } else {
            return a[0] - b[0];
        }
    })

    // 初始化DP数组：f[i][j]表示从第i个事件开始选择j个事件的最大价值
    const f = Array.from({ length: n + 1 }, () => Array(k + 1).fill(0));

    // 二分查找函数：在[left, n-1]范围内查找第一个开始时间大于end的事件索引
    const lowerBound = (left, end) => {
        let l = left, r = n - 1;
        while (l <= r) {
            let m = Math.floor((r - l) / 2) + l;

            if (events[m][0] <= end) {
                l = m + 1;  // 当前事件开始时间太小，向右查找
            } else {
                r = m - 1;  // 当前事件开始时间符合条件，尝试找更小的
            }
        }

        return l;  // 返回第一个不满足条件的位置
    }

    // 动态规划主循环：从后向前处理每个事件
    for (let i = n - 1; i >= 0; i--) {
        const [s, e, v] = events[i];
        // 找到第一个不与当前事件冲突的事件索引
        let j = lowerBound(i + 1, e);
        // 对于每个可能的选取次数(1到k)
        for (let r = 1; r <= k; r++) {
            // 状态转移：不选当前事件 vs 选当前事件+后续最优解
            f[i][r] = Math.max(f[i + 1][r], f[j][r - 1] + v);
        }
    }

    // 返回从第0个事件开始选择k个事件的最大价值
    return f[0][k];
};


```