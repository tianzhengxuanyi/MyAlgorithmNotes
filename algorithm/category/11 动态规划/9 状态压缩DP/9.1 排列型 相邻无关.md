### 9.1 排列型 相邻无关

暴力做法是枚举所有排列，对每个排列计算和题目有关的值，时间复杂度（通常来说）是 O(n!)。可以解决 n≤10 的问题。

状压 DP 可以把时间复杂度（通常来说）优化至 O(n⋅2^n)。可以解决 n≤20 的问题。

一般有两种定义方式：

- 定义 f[S] 表示已经排列好的元素（下标）集合为 S 时，和题目有关的最优值。通过枚举当前位置要填的元素（下标）来转移。
- 定义 f[S] 表示可以选的元素（下标）集合为 S 时，和题目有关的最优值。通过枚举当前位置要填的元素（下标）来转移。

#### [526. 优美的排列](https://leetcode.cn/problems/beautiful-arrangement/description/)

假设有从 1 到 n 的 n 个整数。用这些整数构造一个数组 perm（下标从 1 开始），只要满足下述条件 之一 ，该数组就是一个 优美的排列 ：

- perm[i] 能够被 i 整除
- i 能够被 perm[i] 整除

给你一个整数 n ，返回可以构造的 优美排列 的 数量 。

**动态规划：状态压缩**

定义 dfs(s)表示已经选好的元素集合位 s 时，最终的优美排列数量。

状态转移：

- 枚举 s 中没有选的元素 x，满足 x 是 i 的倍数或 i 是 x 的倍数。

入口：dfs(0)，表示初始时没有选任何元素。

出口：当 s 包含 n 个元素时（统计 s 中位 1 的个数），返回 1。

```js
/**
 * 计算优美排列的数量
 * @param {number} n - 数字范围 [1, n]
 * @return {number} 优美排列的数量
 */
var countArrangement = function (n) {
  // 记忆化数组，memo[s]表示已选数字集合为s时的排列数
  const memo = Array(1 << n).fill(-1);

  // DFS函数，s是已选数字的位图表示
  const dfs = (s) => {
    // 终止条件：所有数字都已选中（所有位都为1）
    if (s === (1 << n) - 1) return (memo[s] = 1);
    // 记忆化：如果已计算过则直接返回
    if (memo[s] >= 0) return memo[s];

    let res = 0;
    // j表示当前要填的位置（第几个数字）
    const j = bitCount_32(s) + 1;

    // 枚举所有数字
    for (let i = 1; i <= n; i++) {
      // 跳过已选的数字
      if (s & (1 << (i - 1))) continue;
      // 检查优美排列条件
      if (i % j == 0 || j % i == 0) {
        // 递归计算选中i后的排列数
        res += dfs(s | (1 << (i - 1)));
      }
    }

    return (memo[s] = res);
  };

  return dfs(0); // 从空集合开始
};

/**
 * 计算32位整数中1的个数（汉明重量）
 * @param {number} n - 要计算的数字
 * @return {number} 1的个数
 */
function bitCount_32(n) {
  let cnt = 0;
  while (n) {
    cnt++;
    n &= n - 1; // 清除最低位的1
  }
  return cnt;
}
```

```js
/**
 * 计算优美排列的数量（迭代版）
 * @param {number} n - 数字范围 [1, n]
 * @return {number} 优美排列的数量
 */
var countArrangement = function (n) {
  // DP数组，f[s]表示已选数字集合为s时的排列数
  const f = Array(1 << n).fill(0);
  // 初始状态：空集合的排列数为1
  f[0] = 1;

  // 枚举所有可能的数字集合状态
  for (let s = 1; s < 1 << n; s++) {
    // j表示当前集合的大小（即已选数字的个数）
    const j = bitCount_32(s);

    // 枚举所有可能的数字
    for (let i = 1; i <= n; i++) {
      // 检查数字i是否在当前集合中，且满足优美排列条件
      if ((s >> (i - 1)) & 1 && (i % j == 0 || j % i == 0)) {
        // 状态转移：从去掉i的状态累加
        f[s] += f[s ^ (1 << (i - 1))];
      }
    }
  }

  // 返回所有数字都被选中的状态的结果
  return f[(1 << n) - 1];
};

/**
 * 计算32位整数中1的个数（汉明重量）
 * @param {number} n - 要计算的数字
 * @return {number} 1的个数
 */
function bitCount_32(n) {
  let cnt = 0;
  while (n) {
    cnt++;
    n &= n - 1; // 清除最低位的1
  }
  return cnt;
}
```

#### [3376. 破解锁的最少时间 I](https://leetcode.cn/problems/minimum-time-to-break-locks-i/description/)

Bob 被困在了一个地窖里，他需要破解 n 个锁才能逃出地窖，每一个锁都需要一定的 能量 才能打开。每一个锁需要的能量存放在一个数组 strength 里，其中 strength[i] 表示打开第 i 个锁需要的能量。

Bob 有一把剑，它具备以下的特征：

- 一开始剑的能量为 0 。
- 剑的能量增加因子 X 一开始的值为 1 。
- 每分钟，剑的能量都会增加当前的 X 值。
- 打开第 i 把锁，剑的能量需要到达 至少 strength[i] 。
- 打开一把锁以后，剑的能量会变回 0 ，X 的值会增加一个给定的值 K 。

你的任务是打开所有 n 把锁并逃出地窖，请你求出需要的 最少 分钟数。

请你返回 Bob 打开所有 n 把锁需要的 最少 时间。

**动态规划：状态压缩**

定义 f[s]表示已经打开的锁集合为 s 时，最终打开所有锁的最少时间。

状态转移：

- 枚举 s 中没有打开的锁 i，f[s] = min(f[s | (1 << i)] + Math.ceil(strength[i] / (1 + k * bitCount(s))))

入口：f[0] = 0，初始时没有打开任何锁。

```js
/**
 * @param {number[]} strength
 * @param {number} k
 * @return {number}
 */
/**
 * 计算破解所有锁所需的最少时间
 * @param {number[]} strength - 每个锁需要的能量值数组
 * @param {number} k - 每次解锁后X的增量值
 * @return {number} 最少需要的时间（分钟）
 */
var findMinimumTime = function (strength, k) {
    const n = strength.length, mx = (1 << n) - 1; // mx为全解锁状态（所有位为1）
    const f = Array(mx + 1).fill(Infinity);       // DP数组，f[s]表示状态s到全解锁的最少时间
    f[mx] = 0; // 基础状态：所有锁已打开时时间为0
    
    // 倒序枚举所有状态（从接近完成的状态往初始状态推）
    for (let i = mx - 1; i >= 0; i--) {
        // 遍历所有可能的锁
        for (let j = 0; j < n; j++) {
            if (i & (1 << j)) continue; // 跳过已解锁的
            
            // 计算解锁j号锁所需时间：strength[j] / (当前X值)
            // 当前X值 = 1 + 已解锁数 * k（digitCount32返回已解锁数量）
            let t = Math.ceil(strength[j] / (digitCount32(i) * k + 1));
            
            // 状态转移：当前状态i的最优解 = min(原有解, 解锁j后的解 + 解锁耗时)
            f[i] = Math.min(f[i], t + f[i | (1 << j)])
        }
    }
    return f[0]; // 返回初始空状态的最优解
};

/**
 * 计算32位整数中1的个数（汉明重量）
 * @param {number} num - 要计算的数字
 * @return {number} 1的个数（即已解锁的锁数量）
 */
function digitCount32(num) {
    let cnt = 0;
    while (num) {
        cnt++;
        num &= (num - 1); // 清除最低位的1（每次循环消去一个1）
    }
    return cnt;
}

```