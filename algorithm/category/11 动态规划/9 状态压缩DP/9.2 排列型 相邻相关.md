### 排列型 相邻相关

#### [996. 平方数组的数目](https://leetcode.cn/problems/number-of-squareful-arrays/description/)
 
如果一个数组的任意两个相邻元素之和都是 完全平方数 ，则该数组称为 平方数组 。

给定一个整数数组 nums，返回所有属于 平方数组 的 nums 的排列数量。

如果存在某个索引 i 使得 perm1[i] != perm2[i]，则认为两个排列 perm1 和 perm2 不同

**提示**
- 1 <= nums.length <= 12

**动态规划：状态压缩**

f[s][i]表示状态为s（nums中数的选择情况），且最后一个数为i的方案数。

s的二进制表示中，1表示该位置的数已经被选择，0表示未被选择。

**状态转移：**

- 枚举s中所有未选的数j，若i和j的和是完全平方数，则f[s][i] += f[s | (1 << j)][j]。

**边界条件：**

- 当s中所选个数等于nums.length时，f[s][i] = 1。

**去重：**

- 统计nums中每个数的出现次数，最终方案数除以每个数的阶乘。
   假设有3个2，最终方案数要除以 3 * 2 * 1；


```js
/**
 * 计算平方数组的排列数目
 * @param {number[]} nums - 输入数字数组
 * @return {number} 符合条件的排列数量
 */
var numSquarefulPerms = function (nums) {
    const n = nums.length;
    // 记忆化数组：memo[state][last] 表示状态为state且最后一个数为last时的方案数
    const memo = Array.from({ length: (1 << n) }, () => Array(n).fill(-1));
    
    // DFS递归函数：i为已选数字的位掩码，j为最后一个数字的索引
    const dfs = (i, j) => {
        let cnt = digitCount32(i);
        if (cnt === n) return memo[i][j] = 1; // 所有数字已选，找到一种合法排列
        if (memo[i][j] >= 0) return memo[i][j]; // 记忆化命中
        
        let res = 0;
        for (let k = 0; k < n; k++) {
            if (i & (1 << k)) continue; // 跳过已选数字
            let sqrt = Math.sqrt(nums[j] + nums[k]);
            if (sqrt !== Math.floor(sqrt)) continue; // 检查平方数条件
            
            res += dfs(i | (1 << k), k); // 递归计算选择k后的方案数
        }
        return memo[i][j] = res; // 记忆化存储结果
    }

    // 统计原始数组中各数字出现次数（用于去重）
    let ans = 0, map = new Map();
    for (let i = 0; i < n; i++) {
        map.set(nums[i], (map.get(nums[i]) ?? 0) + 1);
        ans += dfs(1 << i, i); // 枚举所有可能的起始数字
    }

    // 预处理阶乘数组用于去重计算
    const factorial = Array(20);
    factorial[0] = 1;
    for (let i = 1; i < 20; i++) {
        factorial[i] = i * factorial[i-1];
    }
    // 除以重复元素的阶乘消除重复排列
    for (let val of map.values()) {
        ans /= factorial[val];
    }

    return ans;
};

/**
 * 计算32位整数中1的个数（汉明重量）
 * @param {number} num - 输入的32位整数
 * @return {number} 二进制中1的个数
 */
const digitCount32 = (num) => {
    let cnt = 0;
    while (num) {
        cnt++;
        num &= (num - 1); // 清除最低位的1
    }
    return cnt;
}

```

#### [2741. 特别的排列](https://leetcode.cn/problems/special-permutations/description/)
 
给你一个下标从 0 开始的整数数组 nums ，它包含 n 个 互不相同 的正整数。如果 nums 的一个排列满足以下条件，我们称它是一个特别的排列：

对于 0 <= i < n - 1 的下标 i ，要么 nums[i] % nums[i+1] == 0 ，要么 nums[i+1] % nums[i] == 0 。
请你返回特别排列的总数目，由于答案可能很大，请将它对 109 + 7 取余 后返回。

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var specialPerm = function (nums) {
    const n = nums.length;
    
    // dp[状态掩码][最后一位索引] 的方案数
    const dp = Array.from({ length: 1 << n }, () => Array(n).fill(0));
    // 初始化：全选状态时方案数为1（边界条件）
    dp[(1 << n) - 1].fill(1);
    
    // 状态转移：从全选状态倒序枚举
    for (let s = (1 << n) - 1; s >= 0; s--) {
        for (let i = 0; i < n; i++) {  // 当前最后一位的索引
            for (let j = 0; j < n; j++) {  // 尝试选择的下一位索引
                if (s & (1 << j)) continue; // j已被选择则跳过
                // 检查相邻元素是否满足整除条件
                if (nums[i] % nums[j] == 0 || nums[j] % nums[i] == 0) {
                    // 状态转移：s | (1 << j) 表示选中j后的新状态
                    dp[s][i] = (dp[s][i] + dp[s | (1 << j)][j]) % mod;
                }
            }
        }
    }

    // 累加所有起始状态的方案数
    let ans = 0;
    for (let i = 0; i < n; i++) {
        ans = (ans + dp[1 << i][i]) % mod; // 1<<i 表示初始只选第i个元素
    }
    return ans;
};

const mod = 1e9 + 7; // 题目要求的取模值

```