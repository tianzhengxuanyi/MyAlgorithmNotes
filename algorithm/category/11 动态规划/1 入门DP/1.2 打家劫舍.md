### 打家劫舍

#### [198. 打家劫舍](https://leetcode.cn/problems/house-robber/description/)

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

> 从第i间房子开始偷，能偷到的最大金额为`dp[i]`
>
> 如果偷第i间房子，那么第i-1间房子就不能偷，所以能偷到的最大金额为`dp[i-2]+nums[i]`
>
> 如果不偷第i间房子，那么能偷到的最大金额为`dp[i-1]`
>
> 所以递推公式：`dp[i]=max(dp[i+2]+nums[i],dp[i+1])`

```js
/**
 * @param {number[]} nums
> 递推公式：`dp[i]=max(dp[i+2]+nums[i],dp[i+1])`

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var rob = function (nums) {
    let p = p1 = nums[nums.length - 1], p2 = 0;
    for (let i = nums.length - 2; i >= 0; i--) {
        p = Math.max(p1, nums[i] + p2);
        [p2, p1] = [p1, p];
    }
    return p;
};
```

#### [⭐740. 删除并获得点数](https://leetcode.cn/problems/delete-and-earn/description/) `值域打家劫舍`

给你一个整数数组 nums ，你可以对它进行一些操作。

每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除 所有 等于 nums[i] - 1 和 nums[i] + 1 的元素。

开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。

> `nums=[2,2,3,3,3,4]`, 把 nums 转换成一个值域数组 a，其中 a[i] 表示 nums 中的等于 i 的元素之和。上面的例子中，a=[0,0,4,9,4]。因为 nums 中有 3 个 3，所以 a[3]=3+3+3=9。
>
>计算数组 a 的  `198. 打家劫舍`，即为答案。

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var deleteAndEarn = function (nums) {
    const max = Math.max(...nums);
    const arr = Array(max + 1).fill(0);
    for (let num of nums) {
        arr[num] += num;
    }
    return robbed(arr);
};

function robbed(arr) {
    const n = arr.length;
    let p = p1 = arr[n - 1], p2 = 0;
    for (let i = n-2; i >= 0; i--) {
        p = Math.max(p1, arr[i] + p2);
        [p1, p2] = [p, p1];
    }
    return p;
}
```

#### [3186. 施咒的最大总伤害](https://leetcode.cn/problems/maximum-total-damage-with-spell-casting/description/)

一个魔法师有许多不同的咒语。

给你一个数组 `power` ，其中每个元素表示一个咒语的伤害值，可能会有多个咒语有相同的伤害值。

已知魔法师使用伤害值为 `power[i]` 的咒语时，他们就 **不能** 使用伤害为 `power[i] - 2` ，`power[i] - 1` ，`power[i] + 1` 或者 `power[i] + 2` 的咒语。

每个咒语最多只能被使用 **一次** 。

请你返回这个魔法师可以达到的伤害值之和的 **最大值** 。

**示例 1：**

**输入：**power = [1,1,3,4]

**输出：**6

**解释：**

可以使用咒语 0，1，3，伤害值分别为 1，1，4，总伤害值为 6 。

**示例 2：**

**输入：**power = [7,1,6,6]

**输出：**13

**解释：**

可以使用咒语 1，2，3，伤害值分别为 1，6，6，总伤害值为 13 。

**提示：**

* `1 <= power.length <= 105`
* `1 <= power[i] <= 109`

##### 值域打家劫舍 递推

```js
/**
 * @function maximumTotalDamage
 * @description 使用动态规划计算可以获得的最大总伤害，规则是不能选择相差小于等于2的伤害值
 * @param {number[]} power - 伤害值数组
 * @return {number} 最大总伤害值
 * @算法核心思想：自底向上动态规划，对于每个伤害值，决策选择或不选择当前值
 * @时间复杂度：O(n log n)，主要开销在排序上
 * @空间复杂度：O(n)，用于存储频率统计、排序后的数组和动态规划数组
 */
var maximumTotalDamage = function (power) {
    // 使用Map统计每个伤害值出现的频率
    const cnt = new Map();
    for (let p of power) {
        cnt.set(p, (cnt.get(p) ?? 0) + 1); // 如果键不存在则初始化为0，然后加1
    }
    
    // 提取所有不同的伤害值并按升序排序
    const vals = Array.from(cnt.keys()).sort((a, b) => a - b);
    const n = vals.length;

    // dp[i]表示从索引i开始到数组末尾能获得的最大伤害值
    const dp = Array(n + 1).fill(0);
    
    // 自底向上动态规划：从数组末尾向前遍历
    for (let i = n - 1; i >= 0; i--) {
        let j = i;
        // 找到第一个大于vals[i]+2的值的索引，即选择当前值后可以继续选择的值的起始位置
        while (j < n && vals[j] <= vals[i] + 2) {
            j++;
        }
        // 状态转移方程：取两种情况的最大值
        // 情况1：不选择当前值，最大伤害为dp[i+1]
        // 情况2：选择当前值，最大伤害为当前值的总伤害加上dp[j]
        dp[i] = Math.max(dp[i + 1], dp[j] + vals[i] * cnt.get(vals[i]));
    }

    // 返回从索引0开始的最大伤害值，即整个问题的解
    return dp[0];
};

```

##### 值域打家劫舍 dfs

```js
/**
 * @function maximumTotalDamage
 * @description 计算可以获得的最大总伤害，规则是不能选择相差小于等于2的伤害值
 * @param {number[]} power - 伤害值数组
 * @return {number} 最大总伤害值
 * @算法核心思想：动态规划（记忆化搜索），处理选择或不选择当前伤害值的情况
 * @时间复杂度：O(n log n)，主要开销在排序上
 * @空间复杂度：O(n)，用于存储频率统计、排序后的数组和记忆化数组
 */
var maximumTotalDamage = function(power) {
    // 使用Map统计每个伤害值出现的频率
    const cnt = new Map();
    for (let p of power) {
        cnt.set(p, (cnt.get(p) ?? 0) + 1); // 如果键不存在则初始化为0，然后加1
    }
    
    // 提取所有不同的伤害值并按升序排序
    const vals = Array.from(cnt.keys()).sort((a, b) => a - b);
    const n = vals.length;

    // 记忆化数组，存储子问题的解，避免重复计算
    const memo = Array(n).fill(-1);
    
    /**
     * @function dfs
     * @description 深度优先搜索函数，计算从索引i开始的最大总伤害
     * @param {number} i - 当前考虑的伤害值索引
     * @return {number} 从i开始的最大总伤害值
     */
    const dfs = (i) => {
        if (i >= n) return 0; // 递归终止条件：超出数组范围，返回0
        if (memo[i] >= 0) return memo[i]; // 如果已经计算过，直接返回记忆化的结果
        
        let cp = vals[i]; // 当前伤害值
        
        // 情况1：不选择当前伤害值，直接考虑下一个
        let res = dfs(i + 1);
        
        // 情况2：选择当前伤害值，需要跳过所有与当前值相差<=2的值
        let j = i;
        // 找到第一个大于cp+2的值的索引
        while (vals[j] <= cp + 2) {
            j++;
        }
        // 计算选择当前值的总伤害：当前值×频率 + 后续可选值的最大伤害
        res = Math.max(res, dfs(j) + cp * cnt.get(cp));
        
        // 记忆化结果并返回
        return memo[i] = res;
    };

    // 修正：原代码中dfs调用时传入了两个参数，但函数定义只有一个参数
    // 这里应该只传入一个参数i=0
    return dfs(0);
};

```

