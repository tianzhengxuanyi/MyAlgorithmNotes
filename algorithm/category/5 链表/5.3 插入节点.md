### 插入节点

#### [2807. 在链表中插入最大公约数](https://leetcode.cn/problems/insert-greatest-common-divisors-in-linked-list/description/)

给你一个链表的头 `head` ，每个结点包含一个整数值。

在相邻结点之间，请你插入一个新的结点，结点值为这两个相邻结点值的 **最大公约数** 。

请你返回插入之后的链表。

两个数的 **最大公约数** 是可以被两个数字整除的最大正整数。

**示例 1：**

![](https://assets.leetcode.com/uploads/2023/07/18/ex1_copy.png)

```
输入：head = [18,6,10,3]
输出：[18,6,6,2,10,1,3]
解释：第一幅图是一开始的链表，第二幅图是插入新结点后的图（蓝色结点为新插入结点）。
- 18 和 6 的最大公约数为 6 ，插入第一和第二个结点之间。
- 6 和 10 的最大公约数为 2 ，插入第二和第三个结点之间。
- 10 和 3 的最大公约数为 1 ，插入第三和第四个结点之间。
所有相邻结点之间都插入完毕，返回链表。
```

**示例 2：**

![](https://assets.leetcode.com/uploads/2023/07/18/ex2_copy1.png)

```
输入：head = [7]
输出：[7]
解释：第一幅图是一开始的链表，第二幅图是插入新结点后的图（蓝色结点为新插入结点）。
没有相邻结点，所以返回初始链表。
```

**提示：**

* 链表中结点数目在 `[1, 5000]` 之间。
* `1 <= Node.val <= 1000`

##### 模拟

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var insertGreatestCommonDivisors = function(head) {
    let node = head;
    while (node.next) {
        const next = node.next;
        const newVal = gcd(node.val, next.val);
        node.next = new ListNode(newVal, next);
        node = next;
    }

    return head;
};

const gcd = (x, y) => {
    while (y) {
        let t = x % y;
        x = y; y = t;
    }

    return x;
}
```

#### [147. 对链表进行插入排序](https://leetcode.cn/problems/insertion-sort-list/description/)

给定单个链表的头 `head` ，使用 **插入排序** 对链表进行排序，并返回 *排序后链表的头* 。

**插入排序** 算法的步骤:

1. 插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。
2. 每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。
3. 重复直到所有输入数据插入完为止。

下面是插入排序算法的一个图形示例。部分排序的列表(黑色)最初只包含列表中的第一个元素。每次迭代时，从输入数据中删除一个元素(红色)，并就地插入已排序的列表中。

对链表进行插入排序。

![](https://pic.leetcode.cn/1724130387-qxfMwx-Insertion-sort-example-300px.gif)

**示例 1：**

![](https://pic.leetcode.cn/1724130414-QbPAjl-image.png)

```
输入: head = [4,2,1,3]
输出: [1,2,3,4]
```

**示例 2：**

![](https://pic.leetcode.cn/1724130432-zoOvdI-image.png)

```
输入: head = [-1,5,3,4,0]
输出: [-1,0,3,4,5]
```

**提示：**

* 列表中的节点数在 `[1, 5000]`范围内
* `-5000 <= Node.val <= 5000`

##### 模拟插入排序，需记录lastSorted、curr、next三个节点，每次从dummy遍历查找插入点

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var insertionSortList = function (head) {
    const dummy = new ListNode(-5001, head);
    let lastSorted = dummy, // 已排序部分的最后一个节点
        curr = lastSorted.next, // 当前待排节点
        next = curr.next;
    while (curr) {
        if (curr.val >= lastSorted.val) { // 待排节点大于最后一个已排序节点，不需要插入
            lastSorted = curr, curr = next, next = next?.next;
            continue;
        }
        for (let node = dummy; node != curr; node = node.next) { // 从头查找插入点
            if (node.next.val >= curr.val && node.next !== curr) { // 找到插入点
                let insertNext = node.next; // 存储插入点的下一个节点
                node.next = curr;
                curr.next = insertNext; // 将待排节点插入 插入点和插入点下一个节点中间
                lastSorted.next = next; // 补上待排节点的位置
                break;
            }
        }
        curr = next, next = next?.next;
    }
    return dummy.next;
};
```

