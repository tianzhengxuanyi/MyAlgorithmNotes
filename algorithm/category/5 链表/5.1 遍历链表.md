### 遍历链表

#### [1290. 二进制链表转整数](https://leetcode.cn/problems/convert-binary-number-in-a-linked-list-to-integer/description/)

给你一个单链表的引用结点 head。链表中每个结点的值不是 0 就是 1。已知此链表是一个整数数字的二进制表示形式。

请你返回该链表所表示数字的 十进制值 。

最高位 在链表的头部。

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {number}
 */
var getDecimalValue = function(head) {
    let ans = 0;
    while (head) {
        ans = (ans << 1) | head.val;
        head = head.next;
    }

    return ans;
};
```


#### [2181. 合并零之间的节点](https://leetcode.cn/problems/merge-nodes-in-between-zeros/description/)

给你一个链表的头节点 `head` ，该链表包含由 `0` 分隔开的一连串整数。链表的 **开端** 和 **末尾** 的节点都满足 `Node.val == 0` 。

对于每两个相邻的 `0` ，请你将它们之间的所有节点合并成一个节点，其值是所有已合并节点的值之和。然后将所有 `0` 移除，修改后的链表不应该含有任何 `0` 。

 返回修改后链表的头节点 `head` 。

**示例 1：  
![](https://assets.leetcode.com/uploads/2022/02/02/ex1-1.png)**

```
输入：head = [0,3,1,0,4,5,2,0]
输出：[4,11]
解释：
上图表示输入的链表。修改后的链表包含：
- 标记为绿色的节点之和：3 + 1 = 4
- 标记为红色的节点之和：4 + 5 + 2 = 11
```

**示例 2：  
![](https://assets.leetcode.com/uploads/2022/02/02/ex2-1.png)**

```
输入：head = [0,1,0,3,0,2,2,0]
输出：[1,3,4]
解释：
上图表示输入的链表。修改后的链表包含：
- 标记为绿色的节点之和：1 = 1
- 标记为红色的节点之和：3 = 3
- 标记为黄色的节点之和：2 + 2 = 4
```

**提示：**

* 列表中的节点数目在范围 `[3, 2 * 105]` 内
* `0 <= Node.val <= 1000`
* **不** 存在连续两个 `Node.val == 0` 的节点
* 链表的 **开端** 和 **末尾** 节点都满足 `Node.val == 0`

##### 将值加到0节点上

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var mergeNodes = function(head) {
    let tail = head;
    for (let curr = head.next; curr.next; curr = curr.next) {
        if (curr.val) {
            tail.val += curr.val;
        } else {
            tail.next = curr;
            tail = curr;
        }
    }
    tail.next = null;
    return head;
};
```

##### val等于0节点直接跳过（node.next = next.next），否则while累加节点值到当前节点直到节点值为0，将当前节点next变为0节点继续主循环

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var mergeNodes = function (head) {
    const dummy = new ListNode(-1, head);
    let node = dummy;
    while (node) {
        let next = node.next;
        if (next.val == 0) {
            node.next = next.next;
            node = node.next;
        } else {
            while (next.val !== 0) {
                node.val += next.val;
                next = next.next;
            }
            node.next = next;
        }
    }
    return dummy.next;
};
```

#### [2058. 找出临界点之间的最小和最大距离](https://leetcode.cn/problems/find-the-minimum-and-maximum-number-of-nodes-between-critical-points/description/)

链表中的 **临界点** 定义为一个 **局部极大值点** **或** **局部极小值点 。**

如果当前节点的值 **严格大于** 前一个节点和后一个节点，那么这个节点就是一个**局部极大值点** 。

如果当前节点的值 **严格小于** 前一个节点和后一个节点，那么这个节点就是一个**局部极小值点** 。

注意：节点只有在同时存在前一个节点和后一个节点的情况下，才能成为一个 **局部极大值点 / 极小值点** 。

给你一个链表 `head` ，返回一个长度为 2 的数组`[minDistance, maxDistance]` ，其中`minDistance`是任意两个不同临界点之间的最小距离，`maxDistance` 是任意两个不同临界点之间的最大距离。如果临界点少于两个，则返回 `[-1，-1]` 。

**示例 1：**

![](https://assets.leetcode.com/uploads/2021/10/13/a1.png)

```
输入：head = [3,1]
输出：[-1,-1]
解释：链表 [3,1] 中不存在临界点。
```

**示例 2：**

![](https://assets.leetcode.com/uploads/2021/10/13/a2.png)

```
输入：head = [5,3,1,2,5,1,2]
输出：[1,3]
解释：存在三个临界点：
- [5,3,1,2,5,1,2]：第三个节点是一个局部极小值点，因为 1 比 3 和 2 小。
- [5,3,1,2,5,1,2]：第五个节点是一个局部极大值点，因为 5 比 2 和 1 大。
- [5,3,1,2,5,1,2]：第六个节点是一个局部极小值点，因为 1 比 5 和 2 小。
第五个节点和第六个节点之间距离最小。minDistance = 6 - 5 = 1 。
第三个节点和第六个节点之间距离最大。maxDistance = 6 - 3 = 3 。
```

**示例 3：**

![](https://assets.leetcode.com/uploads/2021/10/14/a5.png)

```
输入：head = [1,3,2,2,3,2,2,2,7]
输出：[3,3]
解释：存在两个临界点：
- [1,3,2,2,3,2,2,2,7]：第二个节点是一个局部极大值点，因为 3 比 1 和 2 大。
- [1,3,2,2,3,2,2,2,7]：第五个节点是一个局部极大值点，因为 3 比 2 和 2 大。
最小和最大距离都存在于第二个节点和第五个节点之间。
因此，minDistance 和 maxDistance 是 5 - 2 = 3 。
注意，最后一个节点不算一个局部极大值点，因为它之后就没有节点了。
```

**示例 4：**

![](https://assets.leetcode.com/uploads/2021/10/13/a4.png)

```
输入：head = [2,3,3,2]
输出：[-1,-1]
解释：链表 [2,3,3,2] 中不存在临界点。
```

**提示：**

* 链表中节点的数量在范围 `[2, 105]` 内
* `1 <= Node.val <= 105`

##### 维护第一个和上一个临界点位置

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {number[]}
 */
var nodesBetweenCriticalPoints = function (head) {
    let node = head.next;
    let prevVal = head.val;
    let mn = Infinity, first, prev;
    for (let i = 1; node.next; node = node.next, i++) {
        const val = node.val, nextVal = node.next.val;
        if (val > prevVal && val > nextVal ||
            val < prevVal && val < nextVal) {
            if (!first) {
                first = i;
            }
            if (prev) {
                mn = Math.min(mn, i - prev);
            }
            prev = i;
        }
        prevVal = val;
    }
    if (!first || first == prev) {
        return [-1, -1];
    }
    return [mn, prev - first];
};
```

