### 遍历链表

#### [1290. 二进制链表转整数](https://leetcode.cn/problems/convert-binary-number-in-a-linked-list-to-integer/description/)

给你一个单链表的引用结点 head。链表中每个结点的值不是 0 就是 1。已知此链表是一个整数数字的二进制表示形式。

请你返回该链表所表示数字的 十进制值 。

最高位 在链表的头部。

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {number}
 */
var getDecimalValue = function(head) {
    let ans = 0;
    while (head) {
        ans = (ans << 1) | head.val;
        head = head.next;
    }

    return ans;
};
```


#### [2181. 合并零之间的节点](https://leetcode.cn/problems/merge-nodes-in-between-zeros/description/)

给你一个链表的头节点 `head` ，该链表包含由 `0` 分隔开的一连串整数。链表的 **开端** 和 **末尾** 的节点都满足 `Node.val == 0` 。

对于每两个相邻的 `0` ，请你将它们之间的所有节点合并成一个节点，其值是所有已合并节点的值之和。然后将所有 `0` 移除，修改后的链表不应该含有任何 `0` 。

 返回修改后链表的头节点 `head` 。

**示例 1：  
![](https://assets.leetcode.com/uploads/2022/02/02/ex1-1.png)**

```
输入：head = [0,3,1,0,4,5,2,0]
输出：[4,11]
解释：
上图表示输入的链表。修改后的链表包含：
- 标记为绿色的节点之和：3 + 1 = 4
- 标记为红色的节点之和：4 + 5 + 2 = 11
```

**示例 2：  
![](https://assets.leetcode.com/uploads/2022/02/02/ex2-1.png)**

```
输入：head = [0,1,0,3,0,2,2,0]
输出：[1,3,4]
解释：
上图表示输入的链表。修改后的链表包含：
- 标记为绿色的节点之和：1 = 1
- 标记为红色的节点之和：3 = 3
- 标记为黄色的节点之和：2 + 2 = 4
```

**提示：**

* 列表中的节点数目在范围 `[3, 2 * 105]` 内
* `0 <= Node.val <= 1000`
* **不** 存在连续两个 `Node.val == 0` 的节点
* 链表的 **开端** 和 **末尾** 节点都满足 `Node.val == 0`

##### 将值加到0节点上

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var mergeNodes = function(head) {
    let tail = head;
    for (let curr = head.next; curr.next; curr = curr.next) {
        if (curr.val) {
            tail.val += curr.val;
        } else {
            tail.next = curr;
            tail = curr;
        }
    }
    tail.next = null;
    return head;
};
```

##### val等于0节点直接跳过（node.next = next.next），否则while累加节点值到当前节点直到节点值为0，将当前节点next变为0节点继续主循环

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var mergeNodes = function (head) {
    const dummy = new ListNode(-1, head);
    let node = dummy;
    while (node) {
        let next = node.next;
        if (next.val == 0) {
            node.next = next.next;
            node = node.next;
        } else {
            while (next.val !== 0) {
                node.val += next.val;
                next = next.next;
            }
            node.next = next;
        }
    }
    return dummy.next;
};
```

#### [2058. 找出临界点之间的最小和最大距离](https://leetcode.cn/problems/find-the-minimum-and-maximum-number-of-nodes-between-critical-points/description/)

链表中的 **临界点** 定义为一个 **局部极大值点** **或** **局部极小值点 。**

如果当前节点的值 **严格大于** 前一个节点和后一个节点，那么这个节点就是一个**局部极大值点** 。

如果当前节点的值 **严格小于** 前一个节点和后一个节点，那么这个节点就是一个**局部极小值点** 。

注意：节点只有在同时存在前一个节点和后一个节点的情况下，才能成为一个 **局部极大值点 / 极小值点** 。

给你一个链表 `head` ，返回一个长度为 2 的数组`[minDistance, maxDistance]` ，其中`minDistance`是任意两个不同临界点之间的最小距离，`maxDistance` 是任意两个不同临界点之间的最大距离。如果临界点少于两个，则返回 `[-1，-1]` 。

**示例 1：**

![](https://assets.leetcode.com/uploads/2021/10/13/a1.png)

```
输入：head = [3,1]
输出：[-1,-1]
解释：链表 [3,1] 中不存在临界点。
```

**示例 2：**

![](https://assets.leetcode.com/uploads/2021/10/13/a2.png)

```
输入：head = [5,3,1,2,5,1,2]
输出：[1,3]
解释：存在三个临界点：
- [5,3,1,2,5,1,2]：第三个节点是一个局部极小值点，因为 1 比 3 和 2 小。
- [5,3,1,2,5,1,2]：第五个节点是一个局部极大值点，因为 5 比 2 和 1 大。
- [5,3,1,2,5,1,2]：第六个节点是一个局部极小值点，因为 1 比 5 和 2 小。
第五个节点和第六个节点之间距离最小。minDistance = 6 - 5 = 1 。
第三个节点和第六个节点之间距离最大。maxDistance = 6 - 3 = 3 。
```

**示例 3：**

![](https://assets.leetcode.com/uploads/2021/10/14/a5.png)

```
输入：head = [1,3,2,2,3,2,2,2,7]
输出：[3,3]
解释：存在两个临界点：
- [1,3,2,2,3,2,2,2,7]：第二个节点是一个局部极大值点，因为 3 比 1 和 2 大。
- [1,3,2,2,3,2,2,2,7]：第五个节点是一个局部极大值点，因为 3 比 2 和 2 大。
最小和最大距离都存在于第二个节点和第五个节点之间。
因此，minDistance 和 maxDistance 是 5 - 2 = 3 。
注意，最后一个节点不算一个局部极大值点，因为它之后就没有节点了。
```

**示例 4：**

![](https://assets.leetcode.com/uploads/2021/10/13/a4.png)

```
输入：head = [2,3,3,2]
输出：[-1,-1]
解释：链表 [2,3,3,2] 中不存在临界点。
```

**提示：**

* 链表中节点的数量在范围 `[2, 105]` 内
* `1 <= Node.val <= 105`

##### 维护第一个和上一个临界点位置

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {number[]}
 */
var nodesBetweenCriticalPoints = function (head) {
    let node = head.next;
    let prevVal = head.val;
    let mn = Infinity, first, prev;
    for (let i = 1; node.next; node = node.next, i++) {
        const val = node.val, nextVal = node.next.val;
        if (val > prevVal && val > nextVal ||
            val < prevVal && val < nextVal) {
            if (!first) {
                first = i;
            }
            if (prev) {
                mn = Math.min(mn, i - prev);
            }
            prev = i;
        }
        prevVal = val;
    }
    if (!first || first == prev) {
        return [-1, -1];
    }
    return [mn, prev - first];
};
```

#### [817. 链表组件](https://leetcode.cn/problems/linked-list-components/description/)

给定链表头结点 `head`，该链表上的每个结点都有一个 **唯一的整型值** 。同时给定列表 `nums`，该列表是上述链表中整型值的一个子集。

返回列表 `nums` 中组件的个数，这里对组件的定义为：链表中一段最长连续结点的值（该值必须在列表 `nums` 中）构成的集合。

**示例 1：**

![](https://assets.leetcode.com/uploads/2021/07/22/lc-linkedlistcom1.jpg)

```
输入: head = [0,1,2,3], nums = [0,1,3]
输出: 2
解释: 链表中,0 和 1 是相连接的，且 nums 中不包含 2，所以 [0, 1] 是 nums 的一个组件，同理 [3] 也是一个组件，故返回 2。
```

**示例 2：**

![](https://assets.leetcode.com/uploads/2021/07/22/lc-linkedlistcom2.jpg)

```
输入: head = [0,1,2,3,4], nums = [0,3,1,4]
输出: 2
解释: 链表中，0 和 1 是相连接的，3 和 4 是相连接的，所以 [0, 1] 和 [3, 4] 是两个组件，故返回 2。
```

**提示：**

* 链表中节点数为`n`
* `1 <= n <= 104`
* `0 <= Node.val < n`
* `Node.val` 中所有值 **不同**
* `1 <= nums.length <= n`
* `0 <= nums[i] < n`
* `nums` 中所有值 **不同**

##### 组件的起始位置时ans加一，最后结束时要判断last是否有值额外再加1

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @param {number[]} nums
 * @return {number}
 */
var numComponents = function(head, nums) {
    const set = new Set(nums);
    let ans = 0, last;
    for (let node = head; node; node = node.next) {
        const val = node.val;
        if (set.has(val)) {
            last = node;
        } else {
            if (last) {
                ans++;
                last = null;
            }
        }
    }
    if (last) {
        ans++;
    }

    return ans;
};
```

#### [725. 分隔链表](https://leetcode.cn/problems/split-linked-list-in-parts/description/)

给你一个头结点为 `head` 的单链表和一个整数 `k` ，请你设计一个算法将链表分隔为 `k` 个连续的部分。

每部分的长度应该尽可能的相等：任意两部分的长度差距不能超过 1 。这可能会导致有些部分为 null 。

这 `k` 个部分应该按照在链表中出现的顺序排列，并且排在前面的部分的长度应该大于或等于排在后面的长度。

返回一个由上述 `k` 部分组成的数组。

**示例 1：**

![](https://assets.leetcode.com/uploads/2021/06/13/split1-lc.jpg)

```
输入：head = [1,2,3], k = 5
输出：[[1],[2],[3],[],[]]
解释：
第一个元素 output[0] 为 output[0].val = 1 ，output[0].next = null 。
最后一个元素 output[4] 为 null ，但它作为 ListNode 的字符串表示是 [] 。
```

**示例 2：**

![](https://assets.leetcode.com/uploads/2021/06/13/split2-lc.jpg)

```
输入：head = [1,2,3,4,5,6,7,8,9,10], k = 3
输出：[[1,2,3,4],[5,6,7],[8,9,10]]
解释：
输入被分成了几个连续的部分，并且每部分的长度相差不超过 1 。前面部分的长度大于等于后面部分的长度。
```

**提示：**

* 链表中节点的数目在范围 `[0, 1000]`
* `0 <= Node.val <= 1000`
* `1 <= k <= 50`

##### 模拟，链表长度与k的余数为m，前m个长度加一

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} k
 * @return {ListNode[]}
 */
var splitListToParts = function (head, k) {
    let len = 0, node = head;
    while (node) {
        node = node.next;
        len++;
    }
    let m = len % k, int = Math.floor(len / k);
    const ans = Array(k).fill(null);
    node = head
    for (let i = 0; i < k; i++) {
        let cnt = m > 0 ? int + 1 : int;
        if (cnt == 0) {
            break;
        }
        ans[i] = node;
        for (let j = 1; j < cnt; j++) {
            node = node.next;
        }
        let next = node.next;
        node.next = null;
        node = next;
        m--;
    }

    return ans;
};
```

