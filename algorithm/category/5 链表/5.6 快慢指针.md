### 快慢指针

#### [876. 链表的中间结点](https://leetcode.cn/problems/middle-of-the-linked-list/description/)

给你单链表的头结点 `head` ，请你找出并返回链表的中间结点。

如果有两个中间结点，则返回第二个中间结点。

**示例 1：**

![](https://assets.leetcode.com/uploads/2021/07/23/lc-midlist1.jpg)

```
输入：head = [1,2,3,4,5]
输出：[3,4,5]
解释：链表只有一个中间结点，值为 3 。
```

**示例 2：**

![](https://assets.leetcode.com/uploads/2021/07/23/lc-midlist2.jpg)

```
输入：head = [1,2,3,4,5,6]
输出：[4,5,6]
解释：该链表有两个中间结点，值分别为 3 和 4 ，返回第二个结点。
```

**提示：**

* 链表的结点数范围是 `[1, 100]`
* `1 <= Node.val <= 100`

##### 快慢指针

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var middleNode = function(head) {
    let fast = head, slow = head;
    while (fast?.next){
        fast = fast.next?.next;
        slow = slow.next;
    }

    return slow;
};
```

#### [234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/description/)

给你一个单链表的头节点 `head` ，请你判断该链表是否为回文链表。如果是，返回 `true` ；否则，返回 `false` 。

**示例 1：**

![](https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg)

```
输入：head = [1,2,2,1]
输出：true
```

**示例 2：**

![](https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg)

```
输入：head = [1,2]
输出：false
```

**提示：**

* 链表中节点数目在范围`[1, 105]` 内
* `0 <= Node.val <= 9`

**进阶：**你能否用 `O(n)` 时间复杂度和 `O(1)` 空间复杂度解决此题？

##### 快慢指针找到中间节点 + 反转链表

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {boolean}
 */
var isPalindrome = function(head) {
    const m = middleNode(head); // 找到中间节点
    const reverseHead = reverseNode(m); // 反转后半部分
    let node = head, rNode = reverseHead;
    while (node && rNode) {
        if (node.val !== rNode.val) {
            return false;
        }
        node = node.next, rNode = rNode.next;
    }
    return true;
};

const middleNode = (head) => {
    let fast = slow = head;
    while (fast && fast.next) {
        fast = fast.next.next;
        slow = slow.next;
    }

    return slow;
}

const reverseNode = (head) => {
    let node = head, prev = null;

    while (node.next) {
        let next = node.next;
        node.next = prev;
        prev = node, node = next;
    }

    node.next = prev;

    return node;
}
```

