### 双指针

#### [328. 奇偶链表](https://leetcode.cn/problems/odd-even-linked-list/description/)

给定单链表的头节点 `head` ，将所有索引为奇数的节点和索引为偶数的节点分别分组，保持它们原有的相对顺序，然后把偶数索引节点分组连接到奇数索引节点分组之后，返回重新排序的链表。

**第一个**节点的索引被认为是 **奇数** ， **第二个**节点的索引为 **偶数** ，以此类推。

请注意，偶数组和奇数组内部的相对顺序应该与输入时保持一致。

你必须在 `O(1)` 的额外空间复杂度和 `O(n)` 的时间复杂度下解决这个问题。

**示例 1:**

![](https://assets.leetcode.com/uploads/2021/03/10/oddeven-linked-list.jpg)

```
输入: head = [1,2,3,4,5]
输出: [1,3,5,2,4]
```

**示例 2:**

![](https://assets.leetcode.com/uploads/2021/03/10/oddeven2-linked-list.jpg)

```
输入: head = [2,1,3,5,6,4,7]
输出: [2,3,6,7,1,5,4]
```

**提示:**

* `n ==` 链表中的节点数
* `0 <= n <= 104`
* `-106 <= Node.val <= 106`

##### 双指针模拟

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var oddEvenList = function (head) {
    if (!head || !head.next) return head;
    let oddHead = head, evenHead = head.next;
    let odd = oddHead, even = evenHead;
    while (odd.next && even.next) {
        odd.next = odd.next?.next;
        odd = odd.next;
        even.next = even.next?.next;
        even = even.next;
    }
    odd.next = evenHead;
    return oddHead;
};
```

#### [86. 分隔链表](https://leetcode.cn/problems/partition-list/description/)

给你一个链表的头节点 `head` 和一个特定值`x` ，请你对链表进行分隔，使得所有 **小于** `x` 的节点都出现在 **大于或等于** `x` 的节点之前。

你应当 **保留** 两个分区中每个节点的初始相对位置。

**示例 1：**

![](https://assets.leetcode.com/uploads/2021/01/04/partition.jpg)

```
输入：head = [1,4,3,2,5,2], x = 3
输出：[1,2,2,4,3,5]
```

**示例 2：**

```
输入：head = [2,1], x = 2
输出：[1,2]
```

**提示：**

* 链表中节点的数目在范围 `[0, 200]` 内
* `-100 <= Node.val <= 100`
* `-200 <= x <= 200`

##### 双指针模拟，small和larger

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} x
 * @return {ListNode}
 */
var partition = function (head, x) {
    if (!head || !head.next) return head;
    let smallHead = null, largerHead = null;
    let small = null, larger = null;
    let curr = head;
    while (curr) {
        const next = curr.next;
        curr.next = null;
        if (curr.val < x) {
            if (!smallHead) {
                smallHead = small = curr;
            } else {
                small.next = curr
                small = curr;
            }
        } else {
            if (!largerHead) {
                largerHead = larger = curr;
            } else {
                larger.next = curr;
                larger = curr;
            }
        }
        curr = next;
    }
    if (smallHead) {
        small.next = largerHead;
    }

    return smallHead ? smallHead : largerHead;
};
```

