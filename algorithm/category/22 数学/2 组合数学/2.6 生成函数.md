### 生成函数

#### [629. K 个逆序对数组](https://leetcode.cn/problems/k-inverse-pairs-array/description/)

对于一个整数数组 `nums`，**逆序对**是一对满足 `0 <= i < j < nums.length` 且 `nums[i] > nums[j]`的整数对 `[i, j]` 。

给你两个整数 `n` 和 `k`，找出所有包含从 `1` 到 `n` 的数字，且恰好拥有 `k` 个 **逆序对** 的不同的数组的个数。由于答案可能很大，只需要返回对 `109 + 7` 取余的结果。

**示例 1：**

```
输入：n = 3, k = 0
输出：1
解释：
只有数组 [1,2,3] 包含了从1到3的整数并且正好拥有 0 个逆序对。
```

**示例 2：**

```
输入：n = 3, k = 1
输出：2
解释：
数组 [1,3,2] 和 [2,1,3] 都有 1 个逆序对。
```

**提示：**

* `1 <= n <= 1000`
* `0 <= k <= 1000`

##### 基础版 超时

```js
/**
 * @param {number} n
 * @param {number} k
 * @return {number}
 */
var kInversePairs = function (n, k) {
    // 定义1-i中有j个逆序对的可能方案数
    const dfs = (i, j) => {
        // baseCase1: 0个逆序对，1-i顺序排序为一个方案
        if (j == 0) return 1;
        // base case2: i小于1且j大于0，不存在可能方案
        if (i < 1) return 0;

        let res = 0;
        // 枚举把元素i放在位置p，左右还保持顺序排序
        // 左侧不产生逆序对，右侧产生i-p个逆序对
        for (let p = 1; p <= i; p++) {
            let pair = i - p;
            res += dfs(i - 1, j - pair);
        }

        return res;
    }

    return dfs(n, k);
};

const MOD = 1e9 + 7;
```

##### 状态设定 和转移方程 动态规划  前缀和优化

```js
/**
 * @param {number} n
 * @param {number} k
 * @return {number}
 */
var kInversePairs = function (n, k) {
    const dp = Array(k + 1).fill(0);
    const prefix = Array(k + 2).fill(0);
    for (let i = 1; i <= n; i++) {
        dp[0] = 1;
        for (let j = 1; j <= k; j++) {
            let p2 = j - i + Math.min(i, k - j + i), p1 = Math.max(j - i + 1, 0);
            dp[j] = (prefix[p2 + 1] - prefix[p1] + MOD) % MOD;
        }
        prefix[0] = 0;
        for (let j = 0; j <= k; j++) {
            prefix[j + 1] = (prefix[j] + dp[j]) % MOD
        }
    }
    return dp[k];
};

const MOD = 1e9 + 7;
```

