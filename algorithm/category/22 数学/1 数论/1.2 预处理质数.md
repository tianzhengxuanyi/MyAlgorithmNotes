### 预处理质数(筛质数)

#### [204. 计数质数](https://leetcode.cn/problems/count-primes/description/)
 
给定整数 n ，返回 所有小于非负整数 n 的质数的数量 。

**题解：**

如果当前数为质数，则将其所有倍数标记为合数。

```js
/**
 * 功能：计算小于n的质数个数
 * 算法类型：预处理 + 查表
 * 输入参数：
 *   n - 目标数值
 * 返回值：
 *   number - 小于n的质数个数
 * 算法核心思想：
 *   利用全局预处理好的质数标记数组isPrimes，直接统计其中小于n的质数数量
 * 时间复杂度：O(1)，查询操作，不考虑预处理时间
 * 空间复杂度：O(1)，只使用常数额外空间
 */
var countPrimes = function (n) {
    let ans = 0;  // 初始化质数计数器
    // 遍历所有小于n的数字，统计其中的质数
    for (let i = 2; i < n; i++) {  // 从2开始，因为2是最小的质数
        if (isPrimes[i]) {  // 如果i是质数（isPrimes[i]为1）
            ans++;  // 质数计数器加1
        }
    }
    return ans;  // 返回质数个数
};

// 全局常量和预处理
const MX = 5 * 1e6;  // 预处理的最大数值（500万）
const isPrimes = Array(MX).fill(1);  // 初始化质数标记数组，1表示是质数，0表示非质数

// 使用埃拉托斯特尼筛法预处理所有质数
for (let i = 2; i < MX; i++) {  // 从2开始遍历
    if (isPrimes[i]) {  // 如果i是质数
        // 标记i的所有倍数为非质数
        for (let j = i; i * j < MX; j++) {  // j从i开始，避免重复标记
            isPrimes[i * j] = 0;  // 将i*j标记为非质数
        }
    }
}

```

#### [2601. 质数减法运算](https://leetcode.cn/problems/prime-subtraction-operation/description/)

给你一个下标从 **0** 开始的整数数组 `nums` ，数组长度为 `n` 。

你可以执行无限次下述运算：

* 选择一个之前未选过的下标 `i` ，并选择一个 **严格小于** `nums[i]` 的质数 `p` ，从 `nums[i]` 中减去 `p` 。

如果你能通过上述运算使得 `nums` 成为严格递增数组，则返回 `true` ；否则返回 `false` 。

**严格递增数组** 中的每个元素都严格大于其前面的元素。

**示例 1：**

```
输入：nums = [4,9,6,10]
输出：true
解释：
在第一次运算中：选择 i = 0 和 p = 3 ，然后从 nums[0] 减去 3 ，nums 变为 [1,9,6,10] 。
在第二次运算中：选择 i = 1 和 p = 7 ，然后从 nums[1] 减去 7 ，nums 变为 [1,2,6,10] 。
第二次运算后，nums 按严格递增顺序排序，因此答案为 true 。
```

**示例 2：**

```
输入：nums = [6,8,11,12]
输出：true
解释：nums 从一开始就按严格递增顺序排序，因此不需要执行任何运算。
```

**示例 3：**

```
输入：nums = [5,8,3]
输出：false
解释：可以证明，执行运算无法使 nums 按严格递增顺序排序，因此答案是 false 。
```

**提示：**

* `1 <= nums.length <= 1000`
* `1 <= nums[i] <= 1000`
* `nums.length == n`

##### 预处理质数  二分查找

```js
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var primeSubOperation = function (nums) {
    for (let i = 0; i < nums.length; i++) {
        if (nums[i] <= nums[i - 1]) return false;
        // a b    b - p > a   p < b - a
        let mxD = nums[i] - (nums[i - 1] ?? 0);
        let pIdx = lowerBound(mxD) - 1;
        nums[i] -= primes[pIdx] ?? 0;
    }
    return true;
};

const MX = 1001;
const isPrime = Array(MX).fill(1);
const primes = [];

for (let i = 2; i < MX; i++) {
    if (isPrime[i]) {
        primes.push(i);
        for (let j = i; i * j < MX; j++) {
            isPrime[i * j] = 0;
        }
    }
}

function lowerBound(x) {
    let l = 0, r = primes.length - 1;
    while (l <= r) {
        let m = Math.floor((r - l) / 2) + l;
        if (primes[m] < x) {
            l = m + 1;
        } else {
            r = m - 1;
        }
    }
    return l;
}
```

#### [3233. 统计不是特殊数字的数字数量](https://leetcode.cn/problems/find-the-count-of-numbers-which-are-not-special/description/)

给你两个 **正整数** `l` 和 `r`。对于任何数字 `x`，`x` 的所有正因数（除了 `x` 本身）被称为 `x` 的 **真因数**。

如果一个数字恰好仅有两个 **真因数**，则称该数字为 **特殊数字**。例如：

* 数字 4 是 **特殊数字**，因为它的真因数为 1 和 2。
* 数字 6 不是 **特殊数字**，因为它的真因数为 1、2 和 3。

返回区间 `[l, r]` 内 **不是 特殊数字** 的数字数量。

**示例 1：**

**输入：** l = 5, r = 7

**输出：** 3

**解释：**

区间 `[5, 7]` 内不存在特殊数字。

**示例 2：**

**输入：** l = 4, r = 16

**输出：** 11

**解释：**

区间 `[4, 16]` 内的特殊数字为 4 和 9。

**提示：**

* `1 <= l <= r <= 109`

##### 筛质数（只有质数的平方才只有两个因子）

```js
/**
 * LeetCode 提交代码 - 非特殊数字计数问题
 * @file leetcode_submissions_2025-10-12.md
 * @description 该文件包含计算区间内非特殊数字个数的代码实现
 * @author 用户
 * @date 2025-10-12
 * @version 1.0
 */

/**
 * 计算区间[l, r]内非特殊数字的个数
 * @param {number} l - 区间左端点（包含）
 * @param {number} r - 区间右端点（包含）
 * @return {number} 区间内非特殊数字的个数
 * @note 特殊数字定义为素数的平方，如4(2²)、9(3²)、25(5²)等
 */
var nonSpecialCount = function (l, r) {
    let cnt = 0;  // 计数器，用于记录区间内特殊数字的个数
    
    // 使用二分查找找到第一个大于等于l的特殊数字的索引
    let i = lowerBound(l);
    
    // 遍历所有在区间[l, r]内的特殊数字
    for (; Fact[i] <= r; i++) {
        cnt++;  // 每找到一个特殊数字，计数器加1
    }
    
    // 区间内总数字个数减去特殊数字个数，得到非特殊数字个数
    return r - l + 1 - cnt;
};

/**
 * 预计算常量和数据结构
 * @constant {number} MX - 最大数值范围，取1e9+1的平方根向下取整
 * @constant {boolean[]} isPrime - 素数标记数组，isPrime[i]为1表示i是素数
 * @constant {number[]} Fact - 存储所有素数平方的数组
 */
const MX = Math.floor(Math.sqrt(1e9 + 1));  // 确定素数筛选的上限
const isPrime = Array(MX).fill(1);  // 初始化数组，假设所有数都是素数(1表示是素数)

// 0和1不是素数，特殊标记
isPrime[0] = isPrime[1] = 0;

// 埃拉托斯特尼筛法筛选素数
for (let i = 2; i < MX; i++) {
    for (let j = i; i * j < MX; j++) {
        isPrime[i * j] = 0;  // 标记i的倍数为非素数(0表示非素数)
    }
}

// 生成所有素数的平方数数组
const Fact = [];
for (let i = 2; i < MX; i++) {
    if (isPrime[i]) {  // 如果i是素数
        Fact.push(i * i);  // 将i的平方加入Fact数组
    }
}

/**
 * 二分查找函数，找到数组中第一个大于等于目标值的元素索引
 * @param {number} target - 目标值
 * @return {number} 第一个大于等于target的元素索引
 */
const lowerBound = (target) => {
    let l = 0, r = Fact.length - 1;  // 初始化左右指针
    
    // 二分查找过程
    while (l <= r) {
        // 计算中间索引（避免整数溢出的写法）
        let m = Math.floor((r - l) / 2) + l;
        
        if (Fact[m] < target) {
            // 中间值小于目标值，在右半部分查找
            l = m + 1;
        } else {
            // 中间值大于等于目标值，在左半部分查找
            r = m - 1;
        }
    }
    
    // 返回第一个大于等于target的元素索引
    return l;
}

```

#### [3618. 根据质数下标分割数组](https://leetcode.cn/problems/split-array-by-prime-indices/description/)

给你一个整数数组 `nums`。

根据以下规则将 `nums` 分割成两个数组 `A` 和 `B`：

* `nums` 中位于 **质数** 下标的元素必须放入数组 `A`。
* 所有其他元素必须放入数组 `B`。

返回两个数组和的 **绝对**差值：`|sum(A) - sum(B)|`。

**质数**是一个大于 1 的自然数，它只有两个因子，1和它本身。

**注意**：空数组的和为 0。

**示例 1:**

**输入:** nums = [2,3,4]

**输出:** 1

**解释:**

* 数组中唯一的质数下标是 2，所以 `nums[2] = 4` 被放入数组 `A`。
* 其余元素 `nums[0] = 2` 和 `nums[1] = 3` 被放入数组 `B`。
* `sum(A) = 4`，`sum(B) = 2 + 3 = 5`。
* 绝对差值是 `|4 - 5| = 1`。

**示例 2:**

**输入:** nums = [-1,5,7,0]

**输出:** 3

**解释:**

* 数组中的质数下标是 2 和 3，所以 `nums[2] = 7` 和 `nums[3] = 0` 被放入数组 `A`。
* 其余元素 `nums[0] = -1` 和 `nums[1] = 5` 被放入数组 `B`。
* `sum(A) = 7 + 0 = 7`，`sum(B) = -1 + 5 = 4`。
* 绝对差值是 `|7 - 4| = 3`。

**提示:**

* `1 <= nums.length <= 105`
* `-109 <= nums[i] <= 109`

##### 筛质数

```js
/**
 * LeetCode 提交代码 - 数组分割问题
 * @file leetcode_submissions_2025-10-12.md
 * @description 该文件包含解决数组按素数索引分割问题的代码实现
 * @author 用户
 * @date 2025-10-12
 * @version 1.0
 */

/**
 * 计算数组按素数索引分割后的元素和绝对差
 * @param {number[]} nums - 输入的整数数组
 * @return {number} 素数索引元素和与非素数索引元素和的绝对差值
 * @note 索引从0开始，0和1不是素数
 */
var splitArray = function(nums) {
    let sumA = 0, sumB = 0;
    
    // 遍历数组，根据索引是否为素数分别累加元素值
    for (let i = 0; i < nums.length; i++) {
        if (isPrime[i]) {  // 如果索引i是素数
            sumA += nums[i];  // 累加到素数索引元素和
        } else {
            sumB += nums[i];  // 累加到非素数索引元素和
        }
    }
    
    // 返回两个和的绝对差值
    return Math.abs(sumA - sumB);
};

/**
 * 预计算最大范围内的素数表
 * 使用埃拉托斯特尼筛法(Euclidean Algorithm)高效筛选素数
 * @constant {number} MX - 最大数值范围，设为1e5+1
 * @constant {boolean[]} isPrime - 素数标记数组，isPrime[i]为true表示i是素数
 */
const MX = 1e5 + 1;
const isPrime = Array(MX).fill(1);  // 初始假设所有数都是素数(1表示是素数)

// 0和1不是素数，特殊标记
isPrime[0] = isPrime[1] = 0;

// 埃拉托斯特尼筛法实现
for (let i = 2; i < MX; i++) {
    if (isPrime[i]) {  // 如果i是素数
        // 标记所有i的倍数为非素数
        for (let j = i; i * j < MX; j++) {
            isPrime[i * j] = 0;  // 0表示非素数
        }
    }
}

```