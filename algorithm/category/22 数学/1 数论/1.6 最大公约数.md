### 最大公约数

#### 辗转相除法

**迭代：**

```js
/**
 * @param {number} a
 * @param {number} b
 * @return {number}
 */
var gcd = function (x, y) {
    while (y !== 0) {
        let temp = y;
        y = x % y;
        x = temp;
    }
    return x;
};
```

**递归：**

```js
/**
 * @param {number} a
 * @param {number} b
 * @return {number}
 */
var gcd = function (x, y) {
    if (y === 0) return x;
    return gcd(y, x % y);
};
```

#### [1979. 找出数组的最大公约数](https://leetcode.cn/problems/find-greatest-common-divisor-of-array/description/)

给你一个整数数组 `nums` ，返回数组中最大数和最小数的 **最大公约数** 。

两个数的 **最大公约数** 是能够被两个数整除的最大正整数。

**示例 1：**

```
输入：nums = [2,5,6,9,10]
输出：2
解释：
nums 中最小的数是 2
nums 中最大的数是 10
2 和 10 的最大公约数是 2
```

**示例 2：**

```
输入：nums = [7,5,6,8,3]
输出：1
解释：
nums 中最小的数是 3
nums 中最大的数是 8
3 和 8 的最大公约数是 1
```

**示例 3：**

```
输入：nums = [3,3]
输出：3
解释：
nums 中最小的数是 3
nums 中最大的数是 3
3 和 3 的最大公约数是 3
```

**提示：**

* `2 <= nums.length <= 1000`
* `1 <= nums[i] <= 1000`

##### 最大公约数模板

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var findGCD = function(nums) {
    let mn = Infinity, mx = -Infinity;
    for (let x of nums) {
        mn = Math.min(mn, x);
        mx = Math.max(mx, x);
    }

    while (mn) {
        let t = mx % mn;
        mx = mn, mn = t; 
    }

    return mx;
};
```

#### [914. 卡牌分组](https://leetcode.cn/problems/x-of-a-kind-in-a-deck-of-cards/description/)

给定一副牌，每张牌上都写着一个整数。

此时，你需要选定一个数字 `X`，使我们可以将整副牌按下述规则分成 1 组或更多组：

* 每组都有 `X` 张牌。
* 组内所有的牌上都写着相同的整数。

仅当你可选的 `X >= 2` 时返回 `true`。

**示例 1：**

```
输入：deck = [1,2,3,4,4,3,2,1]
输出：true
解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4]
```

**示例 2：**

```
输入：deck = [1,1,1,2,2,2,3,3]
输出：false
解释：没有满足要求的分组。
```

**提示：**

* `1 <= deck.length <= 104`
* `0 <= deck[i] < 104`

##### 计数的最大公约数

```js
/**
 * 功能：判断一副牌是否可以被分成若干个大小为X的组，其中X >= 2
 * 核心思想：计算所有卡牌数量的最大公约数(GCD)，若GCD >= 2则可以分组
 * 
 * @param {number[]} deck - 输入的卡牌数组，每个元素代表卡牌的数值
 * @return {boolean} 如果可以分组返回true，否则返回false
 * 
 * 时间复杂度：O(n + m log k)，其中n是数组长度，m是不同卡牌的数量，k是最大卡牌数量
 * 空间复杂度：O(m)，需要存储不同卡牌的出现次数
 */
var hasGroupsSizeX = function (deck) {
    // 使用哈希表统计每个卡牌的出现次数
    const cnt = new Map();
    for (let x of deck) {
        cnt.set(x, (cnt.get(x) ?? 0) + 1);
    }
    
    // 将所有卡牌数量提取到数组中
    const vals = Array.from(cnt.values());
    
    // 特殊情况处理：如果只有一种卡牌，只需检查其数量是否大于等于2
    if (vals.length == 1) return vals[0] >= 2;
    
    // 初始化最大公约数为第一个卡牌的数量
    let g = vals[0];
    
    // 遍历所有卡牌数量，计算它们的最大公约数
    for (let i = 1; i < vals.length; i++) {
        g = gcd(g, vals[i]);
        
        // 剪枝优化：如果当前最大公约数已经为1，则无法分组，可以提前返回
        if (g == 1) {
            return false;
        }
    }
    
    // 所有卡牌数量的最大公约数大于等于2时，可以分组
    return true;
};

/**
 * 辅助函数：使用欧几里得算法计算两个数的最大公约数
 * 
 * @param {number} x - 第一个数
 * @param {number} y - 第二个数
 * @return {number} x和y的最大公约数
 */
const gcd = (x, y) => {
    // 欧几里得算法：用较大数除以较小数，然后用余数继续除以除数，直到余数为0
    while (y) {
        let t = x % y;
        x = y;  // 交换x和y的值
        y = t;  // y变为余数
    }
    
    // 当y为0时，x就是最大公约数
    return x;
};

```


#### [1250. 检查「好数组」](https://leetcode.cn/problems/check-if-it-is-a-good-array/description/)

给你一个正整数数组 `nums`，你需要从中任选一些子集，然后将子集中每一个数乘以一个 **任意整数**，并求出他们的和。

假如该和结果为 `1`，那么原数组就是一个「**好数组**」，则返回 `True`；否则请返回 `False`。

**示例 1：**

```
输入：nums = [12,5,7,23]
输出：true
解释：挑选数字 5 和 7。
5*3 + 7*(-2) = 1
```

**示例 2：**

```
输入：nums = [29,6,10]
输出：true
解释：挑选数字 29, 6 和 10。
29*1 + 6*(-3) + 10*(-1) = 1
```

**示例 3：**

```
输入：nums = [3,6]
输出：false
```

**提示：**

* `1 <= nums.length <= 10^5`
* `1 <= nums[i] <= 10^9`

##### 裴蜀定理 ax +by = gcd(a, b)

```js
/**
 * 判断一个数组是否为「好数组」
 * 好数组定义：如果存在不全部为0的整数组合 a1, a2, ..., an，使得 a1*nums[0] + a2*nums[1] + ... + an*nums[n-1] = 1
 * @param {number[]} nums - 输入的整数数组
 * @return {boolean} 如果数组是好数组则返回true，否则返回false
 * @note 算法基于贝祖定理：一组数的最大公约数为1当且仅当它们的线性组合可以得到1
 *       因此问题转化为求数组所有元素的最大公约数是否为1
 */
var isGoodArray = function(nums) {
    // 处理边界情况：如果数组只有一个元素，则该元素必须为1才是好数组
    if (nums.length == 1) return nums[0] == 1;
    
    // 初始化最大公约数为第一个元素
    let g = nums[0];
    
    // 遍历数组，逐步计算当前最大公约数与下一个元素的最大公约数
    for (let i = 1; i < nums.length; i++) {
        g = gcd(g, nums[i]);
        
        // 优化：如果当前最大公约数已经为1，可以提前返回true
        if (g == 1) return true;
    }
    
    // 如果遍历完数组后最大公约数仍不为1，则返回false
    return false;
};

/**
 * 计算两个非负整数的最大公约数（GCD）
 * 使用欧几里得算法（辗转相除法）实现
 * @param {number} x - 第一个非负整数
 * @param {number} y - 第二个非负整数
 * @return {number} 两个数的最大公约数
 * @complexity 时间复杂度 O(log(min(x,y)))，空间复杂度 O(1)
 */
const gcd = (x, y) => {
    // 欧几里得算法核心逻辑：不断用较大数对较小数取模，直到余数为0
    while (y) {
        let t = x % y; // 计算余数
        x = y;        // 将除数作为新的被除数
        y = t;        // 将余数作为新的除数
    }
    // 当余数为0时，被除数即为最大公约数
    return x;
};

```

#### [1071. 字符串的最大公因子](https://leetcode.cn/problems/greatest-common-divisor-of-strings/description/)

对于字符串 `s` 和 `t`，只有在 `s = t + t + t + ... + t + t`（`t` 自身连接 1 次或多次）时，我们才认定 “`t` 能除尽 `s`”。

给定两个字符串 `str1` 和 `str2` 。返回 *最长字符串 `x`，要求满足 `x` 能除尽 `str1` 且 `x` 能除尽 `str2`* 。

**示例 1：**

```
输入：str1 = "ABCABC", str2 = "ABC"
输出："ABC"
```

**示例 2：**

```
输入：str1 = "ABABAB", str2 = "ABAB"
输出："AB"
```

**示例 3：**

```
输入：str1 = "LEET", str2 = "CODE"
输出：""
```

**提示：**

* `1 <= str1.length, str2.length <= 1000`
* `str1` 和 `str2` 由大写英文字母组成

##### 数学 + gcd

```js
/**
 * 计算两个字符串的最大公约数字符串
 * 如果两个字符串可以通过某个子串重复多次组成，则返回该子串的最大可能长度版本
 * @param {string} str1 - 第一个输入字符串
 * @param {string} str2 - 第二个输入字符串
 * @return {string} 两个字符串的最大公约数字符串，如果不存在则返回空字符串
 * @note 算法思路：首先验证两个字符串是否可以通过某个子串重复组成，
 *       验证方法是检查str1+str2是否等于str2+str1
 */
var gcdOfStrings = function(str1, str2) {
    // 关键验证：如果两个字符串可以通过子串重复组成，则它们的拼接顺序不影响结果
    if (str1 + str2 != str2 + str1) return "";
    
    // 计算两个字符串长度的最大公约数，并截取该长度的前缀作为结果
    return str1.slice(0, gcd(str1.length, str2.length));
};

/**
 * 计算两个非负整数的最大公约数（GCD）
 * 使用欧几里得算法（辗转相除法）实现
 * @param {number} x - 第一个非负整数
 * @param {number} y - 第二个非负整数
 * @return {number} 两个数的最大公约数
 * @complexity 时间复杂度 O(log(min(x,y)))，空间复杂度 O(1)
 */
const gcd = (x, y) => {
    // 欧几里得算法核心逻辑：不断用较大数对较小数取模，直到余数为0
    while (y) {
        let t = x % y; // 计算余数
        x = y;        // 将除数作为新的被除数
        y = t;        // 将余数作为新的除数
    }
    // 当余数为0时，被除数即为最大公约数
    return x;
};

```

