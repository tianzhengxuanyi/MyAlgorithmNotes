### 质因数分解

#### [2521. 数组乘积中的不同质因数数目](https://leetcode.cn/problems/distinct-prime-factors-of-product-of-array/description/)

给你一个正整数数组 `nums` ，对 `nums` 所有元素求积之后，找出并返回乘积中 **不同质因数** 的数目。

**注意：**

* **质数** 是指大于 `1` 且仅能被 `1` 及自身整除的数字。
* 如果 `val2 / val1` 是一个整数，则整数 `val1` 是另一个整数 `val2` 的一个因数。

**示例 1：**

```
输入：nums = [2,4,3,7,10,6]
输出：4
解释：
nums 中所有元素的乘积是：2 * 4 * 3 * 7 * 10 * 6 = 10080 = 25 * 32 * 5 * 7 。
共有 4 个不同的质因数，所以返回 4 。
```

**示例 2：**

```
输入：nums = [2,4,8,16]
输出：1
解释：
nums 中所有元素的乘积是：2 * 4 * 8 * 16 = 1024 = 210 。
共有 1 个不同的质因数，所以返回 1 。
```

**提示：**

* `1 <= nums.length <= 104`
* `2 <= nums[i] <= 1000`

##### 分解质因子

```js
/**
 * LeetCode 提交代码 - 不同质因子计数问题
 * @file leetcode_submissions_2025-10-12.md
 * @description 该文件包含计算数组元素所有不同质因子数量的代码实现
 * @author 用户
 * @date 2025-10-12
 * @version 1.0
 */

/**
 * 计算数组中所有元素的不同质因子数量
 * @param {number[]} nums - 输入的正整数数组
 * @return {number} 数组中所有元素的不同质因子的总数
 * @note 质因子是指能整除给定正整数的质数
 * @example 输入: [2,4,3,7,10,6] 输出: 4 (质因子为2,3,5,7)
 */
var distinctPrimeFactors = function(nums) {
    // 使用Set数据结构存储质因子，确保自动去重
    const set = new Set();
    
    // 遍历数组中的每个数字
    for (let x of nums) {
        // 从2开始试除，寻找质因子
        let i = 2;
        
        // 只需要试除到x的平方根
        while (i * i <= x) {
            // 如果i是x的因子
            if (x % i == 0) {
                // 将i加入质因子集合
                set.add(i);
                // 完全分解i因子，去除x中所有的i因子
                while (x % i == 0) {
                    x /= i;
                }
            }
            // 继续尝试下一个可能的因子
            i += 1;
        }
        
        // 如果分解后x仍大于1，说明x本身是一个质因子
        // 例如：当x是质数时，上面的循环不会添加任何因子
        if (x > 1) {
            set.add(x);
        }
    }
    
    // 返回集合的大小，即不同质因子的数量
    return set.size;
};

```

##### 预处理所有质因子

```js
/**
 * LeetCode 提交代码 - 不同质因子计数问题（预计算优化版本）
 * @file leetcode_submissions_2025-10-12.md
 * @description 该文件包含使用预计算方法计算数组元素所有不同质因子数量的代码实现
 * @author 用户
 * @date 2025-10-12
 * @version 1.0
 */

/**
 * 计算数组中所有元素的不同质因子数量（使用预计算优化）
 * @param {number[]} nums - 输入的正整数数组（元素范围应小于MX）
 * @return {number} 数组中所有元素的不同质因子的总数
 * @note 该实现使用预计算的质因子表来提高查询效率
 * @example 输入: [2,4,3,7,10,6] 输出: 4 (质因子为2,3,5,7)
 */
var distinctPrimeFactors = function(nums) {
    // 使用Set数据结构存储质因子，确保自动去重
    const set = new Set();
    
    // 遍历数组中的每个数字
    for (let x of nums) {
        // 直接从预计算的质因子表中获取x的所有质因子
        for (let pf of primeFactors[x]) {
            set.add(pf);  // 将质因子添加到集合中
        }
    }
    
    // 返回集合的大小，即不同质因子的数量
    return set.size;
};

/**
 * 预计算常量和数据结构
 * @constant {number} MX - 预计算的最大数值范围
 * @constant {Array<Array<number>>} primeFactors - 二维数组，primeFactors[i]存储i的所有质因子
 */
const MX = 1001;  // 设置预计算的最大数值为1000
// 初始化二维数组，每个元素初始化为空数组
const primeFactors = Array.from({length: MX}, () => []);

/**
 * 预计算每个数的质因子
 * 使用埃拉托斯特尼筛法的变种，为每个数记录其所有质因子
 */
for (let i = 2; i < MX; i++) {
    // 如果primeFactors[i]为空，说明i是质数
    if (primeFactors[i].length == 0) {
        // 对于每个质数i，将其添加到所有i的倍数的质因子列表中
        for (let j = i; j < MX; j += i) {
            primeFactors[j].push(i);  // j能被i整除，i是j的质因子
        }
    }
}

```

