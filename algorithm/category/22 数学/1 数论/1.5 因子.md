### 因子分解

#### [2427. 公因子的数目](https://leetcode.cn/problems/number-of-common-factors/description/)

给你两个正整数 `a` 和 `b` ，返回 `a` 和 `b` 的 **公** 因子的数目。

如果 `x` 可以同时整除 `a` 和 `b` ，则认为 `x` 是 `a` 和 `b` 的一个 **公因子** 。

**示例 1：**

```
输入：a = 12, b = 6
输出：4
解释：12 和 6 的公因子是 1、2、3、6 。
```

**示例 2：**

```
输入：a = 25, b = 30
输出：2
解释：25 和 30 的公因子是 1、5 。
```

**提示：**

* `1 <= a, b <= 1000`

##### 最大公约数

```js
/**
 * 功能：计算两个正整数的公共因子数量
 * 参数：a - 第一个正整数，b - 第二个正整数
 * 返回：两个数的公共因子个数
 * 算法核心思想：利用最大公约数性质，两个数的公共因子就是它们最大公约数的所有因子
 * 时间复杂度：O(√gcd(a,b))，空间复杂度：O(1)
 * @param {number} a
 * @param {number} b
 * @return {number}
 */
var commonFactors = function(a, b) {
    // 计算a和b的最大公约数，因为两个数的公共因子就是它们最大公约数的因子
    let c = gcd(a, b), ans = 0;
    
    // 只需遍历到√c，大大减少了遍历次数
    // 数学原理：如果x是c的因子，那么c/x也是c的因子
    for (let x = 1; x * x <= c; x++) {
        // 检查x是否是c的因子
        if (c % x == 0) {
            ans++; // 找到一个因子x，计数器加1
            
            // 避免重复计数：当x*x != c时，c/x是另一个不同的因子
            if (x * x != c) ans++; // 找到配对因子c/x，计数器再加1
        }
    }
    
    return ans; // 返回公共因子的总数
};

/**
 * 功能：使用欧几里得算法计算两个数的最大公约数
 * 参数：x - 第一个正整数，y - 第二个正整数
 * 返回：x和y的最大公约数
 * 算法原理：gcd(x,y) = gcd(y, x mod y)，当y=0时，gcd为x
 * 时间复杂度：O(log min(x,y))，空间复杂度：O(1)
 * @param {number} x
 * @param {number} y
 * @return {number}
 */
const gcd = (x, y) => {
    // 当y不为0时，循环计算
    while (y) {
        // 计算x除以y的余数
        let t = x % y;
        // 更新x为y，y为余数t
        x = y, y = t;
    }
    // 当y=0时，x就是最大公约数
    return x;
}

```

##### 预处理因数

```js
/**
 * 功能：计算两个正整数的公共因子数量
 * 参数：a - 第一个正整数，b - 第二个正整数
 * 返回：两个数的公共因子个数
 * 算法核心思想：利用预计算的因子数组和集合的交集操作快速求解
 * 时间复杂度：预计算O(MX log MX)，查询O(min(numberOfFactors(a), numberOfFactors(b)))
 * 空间复杂度：O(MX log MX)，用于存储预计算的因子数组
 * @param {number} a
 * @param {number} b
 * @return {number}
 */
var commonFactors = function(a, b) {
    // 将a的因子数组转换为Set集合以提高查找效率
    let factA = new Set(Factory[a]);
    // 获取b的因子数组
    let factB = Factory[b];
    let ans = 0; // 用于计数公共因子的数量
    
    // 遍历b的所有因子，检查是否也存在于a的因子集合中
    for (let f of factB) {
        if (factA.has(f)) ans++; // 如果是公共因子，计数器加1
    }
    
    return ans; // 返回公共因子的总数
};

// 定义预计算因子的最大值范围
const MX = 1001;
// 初始化因子数组，每个元素初始化为只包含因子1的数组
// Factory[i]将存储i的所有正因子
const Factory = Array.from({length: MX}, () => [1]);

// 预计算阶段：使用埃拉托斯特尼筛法的思想生成所有数的因子
// 外层循环遍历可能的因子i（从2开始）
for (let i = 2; i < MX; i++) {
    // 内层循环遍历i的所有倍数j
    for (let j = i; j < MX; j += i) {
        // 将i添加到j的因子列表中
        Factory[j].push(i);
    }
}

```

#### [507. 完美数](https://leetcode.cn/problems/perfect-number/description/)

对于一个 **正整数**，如果它和除了它自身以外的所有 **正因子** 之和相等，我们称它为 **「完美数」**。

给定一个 **整数**`n`， 如果是完美数，返回 `true`；否则返回 `false`。

**示例 1：**

```
输入：num = 28
输出：true
解释：28 = 1 + 2 + 4 + 7 + 14
1, 2, 4, 7, 和 14 是 28 的所有正因子。
```

**示例 2：**

```
输入：num = 7
输出：false
```

**提示：**

* `1 <= num <= 108`

##### 因子分解

```js
/**
 * 功能：检查一个整数是否为完美数
 * 参数：num - 待检查的整数
 * 返回：布尔值，表示num是否为完美数
 * 算法核心思想：遍历所有可能的因子，计算真因子之和并与原数比较
 * 时间复杂度：O(√n)，只需要遍历到num的平方根
 * 空间复杂度：O(1)，只使用常数额外空间
 * 注：完美数是指一个数等于它所有真因子（除了自身以外的因子）的和
 */
var checkPerfectNumber = function (num) {
    // 初始化真因子和为1（1是任何数的真因子）
    let s = 1;
    
    // 遍历可能的因子，只需遍历到num的平方根
    // 这样可以将时间复杂度优化到O(√n)
    for (let i = 2; i * i <= num; i++) {
        // 如果i是num的因子
        if (num % i == 0) {
            s += i;
            // 注意：当i*i != num时，i和num/i是不同的因子
            if (i * i != num) {
                s += num / i;
            }
        }
    }
    
    // 特殊情况处理：1没有真因子，不是完美数
    // 其他情况下，如果真因子和等于原数，则为完美数
    return num == 1 ? false : s == num;
};

```

#### [1390. 四因数](https://leetcode.cn/problems/four-divisors/description/)

给你一个整数数组 `nums`，请你返回该数组中恰有四个因数的这些整数的各因数之和。如果数组中不存在满足题意的整数，则返回 `0` 。

**示例 1：**

```
输入：nums = [21,4,7]
输出：32
解释：
21 有 4 个因数：1, 3, 7, 21
4 有 3 个因数：1, 2, 4
7 有 2 个因数：1, 7
答案仅为 21 的所有因数的和。
```

**示例 2:**

```
输入: nums = [21,21]
输出: 64
```

**示例 3:**

```
输入: nums = [1,2,3,4,5]
输出: 0
```

**提示：**

* `1 <= nums.length <= 104`
* `1 <= nums[i] <= 105`

```js
/**
 * 功能：计算数组中所有恰好有4个除数的元素的除数之和
 * 核心思想：通过因数分解，检查每个数的除数数量是否为4
 * 
 * @param {number[]} nums - 输入的数字数组
 * @return {number} 所有恰好有4个除数的元素的除数之和
 * 
 * 时间复杂度：O(n*√m)，其中n是数组长度，m是数组中的最大元素值
 * 空间复杂度：O(1)，仅使用常数额外空间
 */
var sumFourDivisors = function(nums) {
    let ans = 0;  // 存储最终结果：所有恰好有4个除数的元素的除数和
    
    // 外层循环：遍历数组中的每个元素
    outer: for (let x of nums) {
        // 初始化除数计数和除数和
        // 每个数至少有1和它本身两个除数
        let cnt = 2, s = x + 1;
        
        // 内层循环：检查2到√x之间的所有可能因数
        for (let i = 2; i * i <= x; i++) {
            // 找到一个因数i
            if (x % i == 0) {
                // 如果i是平方根（完全平方数的情况）
                if (i * i == x) {
                    cnt += 1;  // 平方根只算一个除数
                    s += i;
                } else {
                    cnt += 2;  // 找到一对因数i和x/i，各算一个除数
                    s += i + (x / i);
                }
            }
            
            // 剪枝：如果除数数量已经超过4，直接跳过当前数
            if (cnt > 4) continue outer;
        }
        
        // 只有当除数数量恰好为4时，才将其除数和加入结果
        if (cnt == 4) ans += s;
    }
    
    return ans;
};

```




#### [3447. 将元素分配给有约束条件的组](https://leetcode.cn/problems/assign-elements-to-groups-with-constraints/description/)

给你一个整数数组 `groups`，其中 `groups[i]` 表示第 `i` 组的大小。另给你一个整数数组 `elements`。

请你根据以下规则为每个组分配 **一个**元素：

* 如果 `groups[i]` 能被 `elements[j]` 整除，则下标为 `j` 的元素可以分配给组 `i`。
* 如果有多个元素满足条件，则分配 **最小的下标** `j` 的元素。
* 如果没有元素满足条件，则分配 -1 。

返回一个整数数组 `assigned`，其中 `assigned[i]` 是分配给组 `i` 的元素的索引，若无合适的元素，则为 -1。

**注意：**一个元素可以分配给多个组。

**示例 1：**

**输入：** groups = [8,4,3,2,4], elements = [4,2]

**输出：** [0,0,-1,1,0]

**解释：**

* `elements[0] = 4` 被分配给组 0、1 和 4。
* `elements[1] = 2` 被分配给组 3。
* 无法为组 2 分配任何元素，分配 -1 。

**示例 2：**

**输入：** groups = [2,3,5,7], elements = [5,3,3]

**输出：** [-1,1,0,-1]

**解释：**

* `elements[1] = 3` 被分配给组 1。
* `elements[0] = 5` 被分配给组 2。
* 无法为组 0 和组 3 分配任何元素，分配 -1 。

**示例 3：**

**输入：** groups = [10,21,30,41], elements = [2,1]

**输出：** [0,1,0,1]

**解释：**

`elements[0] = 2` 被分配给所有偶数值的组，而 `elements[1] = 1` 被分配给所有奇数值的组。

**提示：**

* `1 <= groups.length <= 105`
* `1 <= elements.length <= 105`
* `1 <= groups[i] <= 105`
* `1 <= elements[i] <= 105`

##### 枚举element的倍数

```js
/**
 * 功能：将元素数组中的元素分配给组数组中的每个组
 * 核心思想：贪心策略 - 为每个可能的组值分配可用的最小元素（按索引顺序）
 * 
 * @param {number[]} groups - 组值数组，表示需要分配元素的各个组
 * @param {number[]} elements - 可用元素数组，每个元素可以分配给其倍数的组值
 * @return {number[]} 分配结果数组，每个元素表示对应组分配到的元素索引
 * 
 * 时间复杂度：O(n + m * log(MX))，其中n是groups长度，m是elements长度，MX是groups中的最大值
 * 空间复杂度：O(MX)，需要额外数组存储分配信息
 */
var assignElements = function (groups, elements) {
    const n = groups.length, m = elements.length;
    
    // 找到组数组中的最大值，用于确定分配数组的大小
    let MX = Math.max(...groups);
    
    // 创建分配目标数组，初始值为-1（表示未分配）
    const target = Array(MX + 1).fill(-1);
    
    // 遍历元素数组，进行分配
    for (let j = 0; j < m; j++) {
        let e = elements[j];
        
        // 剪枝：如果元素超过最大组值或已被分配过，则跳过
        if (e > MX || target[e] >= 0) continue;
        
        // 贪心策略：为当前元素的所有倍数分配该元素（如果这些倍数尚未分配）
        // 这确保了每个组值会被分配到索引最小的可用元素
        for (let f = 1; f * e <= MX; f++) {
            if (target[f * e] < 0) {
                target[f * e] = j;
            }
        }
    }
    
    // 根据分配结果，更新组数组中的每个值
    for (let i = 0; i < n; i++) {
        groups[i] = target[groups[i]];
    }
    
    return groups;
};

```

#### [3164. 优质数对的总数 II](https://leetcode.cn/problems/find-the-number-of-good-pairs-ii/description/)

给你两个整数数组 `nums1` 和 `nums2`，长度分别为 `n` 和 `m`。同时给你一个**正整数** `k`。

如果 `nums1[i]` 可以被 `nums2[j] * k` 整除，则称数对 `(i, j)` 为 **优质数对**（`0 <= i <= n - 1`, `0 <= j <= m - 1`）。

返回 **优质数对** 的总数。

**示例 1：**

**输入：**nums1 = [1,3,4], nums2 = [1,3,4], k = 1

**输出：**5

**解释：**

5个优质数对分别是 `(0, 0)`, `(1, 0)`, `(1, 1)`, `(2, 0)`, 和 `(2, 2)`。

**示例 2：**

**输入：**nums1 = [1,2,4,12], nums2 = [2,4], k = 3

**输出：**2

**解释：**

2个优质数对分别是 `(3, 0)` 和 `(3, 1)`。

**提示：**

* `1 <= n, m <= 105`
* `1 <= nums1[i], nums2[j] <= 106`
* `1 <= k <= 103`

##### 用map去重后枚举nums2倍数

```js
/**
 * 功能：计算满足条件的数对(i,j)的数量，其中nums1[i]能被nums2[j]*k整除
 * 核心思想：预处理+哈希表优化 - 通过预处理nums2数组中每个元素的倍数，快速统计符合条件的数对
 * 
 * @param {number[]} nums1 - 第一个数字数组
 * @param {number[]} nums2 - 第二个数字数组
 * @param {number} k - 给定的倍数因子
 * @return {number} 满足条件的数对数量
 * 
 * 时间复杂度：O(n + m + MX/k)，其中n是nums1长度，m是nums2长度，MX是nums1中的最大值
 * 空间复杂度：O(m + MX)，需要哈希表存储nums2元素频率和数组存储预处理结果
 */
var numberOfPairs = function(nums1, nums2, k) {
    // 找到nums1中的最大值，用于确定预处理数组的大小
    const MX = Math.max(...nums1);
    
    // 创建预处理数组，记录每个可能的数值能被多少个nums2[j]*k的倍数整除
    const target = Array(MX + 1).fill(0);
    
    // 使用哈希表统计nums2中每个元素出现的频率
    const cnt2 = new Map();
    for (let x of nums2) {
        cnt2.set(x, (cnt2.get(x) ?? 0) + 1);
    }
    
    // 预处理阶段：对nums2中的每个元素x，计算x*k的所有倍数在target中的出现次数
    for (let [x, c] of cnt2.entries()) {
        x *= k;  // 计算x*k的值
        
        // 剪枝：如果x*k超过nums1中的最大值，则无法形成有效数对，跳过
        if (x > MX) continue;
        
        // 对于x*k的每个倍数j*x，增加其在target中的计数
        for (let j = 1; j * x <= MX; j++) {
            target[j * x] += c;
        }
    }
    
    // 统计阶段：遍历nums1中的每个元素，累加其在预处理数组中的计数
    let ans = 0;
    for (let x of nums1) {
        ans += target[x];
    }
    
    return ans;
};

```
