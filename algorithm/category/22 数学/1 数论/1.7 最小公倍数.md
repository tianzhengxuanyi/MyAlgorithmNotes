### 最小公倍数

#### [3334. 数组的最大因子得分](https://leetcode.cn/problems/find-the-maximum-factor-score-of-array/description/)

给你一个整数数组 `nums`。

**因子得分** 定义为数组所有元素的最小公倍数（LCM）与最大公约数（GCD）的 **乘积**。

在 **最多** 移除一个元素的情况下，返回 `nums` 的 **最大因子得分**。

**注意**，单个数字的 LCM 和 GCD 都是其本身，而**空数组** 的因子得分为 0。

**示例 1：**

**输入：** nums = [2,4,8,16]

**输出：** 64

**解释：**

移除数字 2 后，剩余元素的 GCD 为 4，LCM 为 16，因此最大因子得分为 `4 * 16 = 64`。

**示例 2：**

**输入：** nums = [1,2,3,4,5]

**输出：** 60

**解释：**

无需移除任何元素即可获得最大因子得分 60。

**示例 3：**

**输入：** nums = [3]

**输出：** 9

**提示：**

* `1 <= nums.length <= 100`
* `1 <= nums[i] <= 30`

##### 前、后缀gcd、lcm

```js
/**
 * 功能：计算数组的最大分数
 * 参数：nums - 输入的数字数组
 * 返回：最大分数值（将BigInt结果转换为Number返回）
 * 算法核心思想：使用前缀数组和后缀数组优化计算，尝试排除数组中的每一个元素，计算剩余元素的最小公倍数(LCM)和最大公约数(GCD)的乘积，找出其中的最大值
 * 时间复杂度：O(n log m)，其中n是数组长度，m是数组中的最大值（GCD和LCM操作的复杂度）
 * 空间复杂度：O(n)，使用了两个额外的数组存储后缀GCD和后缀LCM
 */
var maxScore = function (nums) {
    const n = nums.length;
    
    // 初始化后缀GCD和后缀LCM数组，使用BigInt避免大数溢出
    const suffixGcd = Array(n + 1).fill(0n), suffixLcm = Array(n + 1).fill(1n);
    
    // 从后向前计算后缀GCD和后缀LCM
    // suffixGcd[i]表示从nums[i]到nums[n-1]的所有元素的GCD
    // suffixLcm[i]表示从nums[i]到nums[n-1]的所有元素的LCM
    for (let i = n - 1; i >= 0; i--) {
        suffixGcd[i] = gcd(BigInt(nums[i]), suffixGcd[i + 1]);
        suffixLcm[i] = lcm(BigInt(nums[i]), suffixLcm[i + 1]);
    }
    
    // 初始化前缀GCD和前缀LCM
    // prefixGcd表示从nums[0]到nums[i-1]的所有元素的GCD
    // prefixLcm表示从nums[0]到nums[i-1]的所有元素的LCM
    let prefixGcd = 0n, prefixLcm = 1n;
    
    // 初始答案为整个数组的GCD和LCM的乘积
    let ans = suffixGcd[0] * suffixLcm[0];
    
    // 遍历数组，尝试排除每一个元素nums[i]
    for (let i = 0; i < n; i++) {
        // 计算排除nums[i]后的GCD：前缀GCD和后缀GCD的GCD
        let g = gcd(prefixGcd, suffixGcd[i + 1]);
        // 计算排除nums[i]后的LCM：前缀LCM和后缀LCM的LCM
        let l = lcm(prefixLcm, suffixLcm[i + 1]);
        // 更新最大分数
        ans = ans > g * l ? ans : g * l;
        
        // 更新前缀GCD和前缀LCM，将当前元素nums[i]包含进来
        prefixGcd = gcd(prefixGcd, BigInt(nums[i]));
        prefixLcm = lcm(prefixLcm, BigInt(nums[i]));
    }

    // 将BigInt结果转换为Number返回
    return Number(ans);
};

/**
 * 功能：计算两个BigInt类型数的最大公约数
 * 参数：x, y - 两个BigInt类型的正整数
 * 返回：x和y的最大公约数（BigInt类型）
 * 算法：欧几里得算法（辗转相除法）
 */
const gcd = (x, y) => {
    while (y) {
        let t = x % y;
        x = y, y = t;
    }
    return x;
}

/**
 * 功能：计算两个BigInt类型数的最小公倍数
 * 参数：x, y - 两个BigInt类型的正整数
 * 返回：x和y的最小公倍数（BigInt类型）
 * 公式：LCM(x,y) = (x * y) / GCD(x,y)
 */
const lcm = (x, y) => (x * y) / gcd(x, y);

```

##### 遍历

```js
/**
 * 功能：计算数组的最大分数
 * 参数：nums - 输入的数字数组
 * 返回：最大分数值
 * 算法核心思想：尝试排除数组中的每一个元素，计算剩余元素的最小公倍数(LCM)和最大公约数(GCD)的乘积，找出其中的最大值
 * 时间复杂度：O(n² log m)，其中n是数组长度，m是数组中的最大值（GCD和LCM操作的复杂度）
 * 空间复杂度：O(1)，只使用了常数额外空间
 */
var maxScore = function (nums) {
    let ans = 0, n = nums.length; // ans存储最大分数，n存储数组长度
    
    // 边界情况处理：如果数组只有一个元素，返回该元素的平方
    if (n == 1) return nums[0] * nums[0];
    
    let l = nums[0], g = nums[0]; // l用于计算LCM，g用于计算GCD
    
    // 遍历数组，尝试排除每一个元素i
    for (let i = 0; i <= n; i++) {
        // 初始化LCM和GCD的起始值
        if (i == 0) {
            // 特殊情况：当排除第一个元素时，从第二个元素开始初始化
            l = nums[1], g = nums[1];
        } else {
            // 正常情况：从第一个元素开始初始化
            l = nums[0], g = nums[0];
        }
        
        // 遍历数组中的其他元素（排除元素i）
        for (let j = i == 0 ? 2 : 0; j < n; j++) {
            // 跳过当前被排除的元素
            if (i == j) continue;
            
            // 更新剩余元素的最小公倍数
            l = lcm(l, nums[j]);
            // 更新剩余元素的最大公约数
            g = gcd(g, nums[j]);
        }
        
        // 更新最大分数
        ans = Math.max(ans, l * g);
    }
    
    return ans;
};

/**
 * 功能：计算两个数的最大公约数
 * 参数：x, y - 两个正整数
 * 返回：x和y的最大公约数
 * 算法：欧几里得算法（辗转相除法）
 */
const gcd = (x, y) => {
    while (y) {
        let t = x % y;
        x = y, y = t;
    }
    return x;
}

/**
 * 功能：计算两个数的最小公倍数
 * 参数：x, y - 两个正整数
 * 返回：x和y的最小公倍数
 * 公式：LCM(x,y) = (x * y) / GCD(x,y)
 */
const lcm = (x, y) => (x * y) / gcd(x, y);

```

#### [2413. 最小偶倍数](https://leetcode.cn/problems/smallest-even-multiple/description/)

给你一个正整数 `n` ，返回 `2`和`n` 的最小公倍数（正整数）。

**示例 1：**

```
输入：n = 5
输出：10
解释：5 和 2 的最小公倍数是 10 。
```

**示例 2：**

```
输入：n = 6
输出：6
解释：6 和 2 的最小公倍数是 6 。注意数字会是它自身的倍数。
```

**提示：**

* `1 <= n <= 150`

##### 2与偶数的gcd为2,2与奇数gcd为1

```js
/**
 * @param {number} n
 * @return {number}
 */
var smallestEvenMultiple = function(n) {
    return n % 2 ? 2 * n : n;
};
```

##### 最小公倍数

```js
/**
 * @param {number} n
 * @return {number}
 */
var smallestEvenMultiple = function(n) {
    return 2 * n / gcd(n, 2);
};

const gcd = (x, y) => {
    while (y) {
        let t = x % y;
        x = y, y = t;
    }
    return x;
}
```