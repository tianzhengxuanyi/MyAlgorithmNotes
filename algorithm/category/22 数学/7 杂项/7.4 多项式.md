### 多项式

#### [611. 有效三角形的个数](https://leetcode.cn/problems/valid-triangle-number/description/)

给定一个包含非负整数的数组 `nums` ，返回其中可以组成三角形三条边的三元组个数。

**示例 1:**

```
输入: nums = [2,2,3,4]
输出: 3
解释:有效的组合是: 
2,3,4 (使用第一个 2)
2,3,4 (使用第二个 2)
2,2,3
```

**示例 2:**

```
输入: nums = [4,2,3,4]
输出: 4
```

**提示:**

* `1 <= nums.length <= 1000`
* `0 <= nums[i] <= 1000`

##### 优化相向双指针

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var triangleNumber = function(nums) {
    const n = nums.length;
    nums.sort((a, b) => a - b);
    let ans = 0;
    for (let i = n - 1; i >= 2; i--) {
        const c = nums[i];
        // 此时任意两个数相加都大于c，表示任意两个数相加都大于任意[0, i]中的数
        // 所以从k+1中任意选取3个数
        if (nums[0] + nums[1] > c) {
            ans += (i + 1) * (i - 1) * i / 6;
            break;
        }
        if (nums[i - 2] + nums[i - 1] <= c) {
            continue;
        }
        let l = 0, r = i - 1;
        while (l < r) {
            if (nums[l] + nums[r] > c) {
                ans += r - l;
                r--;
            } else {
                l++;
            }
        }
    }
    return ans;
};
```

##### 两数之和大于一个数，相向双指针

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var triangleNumber = function(nums) {
    const n = nums.length;
    nums.sort((a, b) => a - b);
    let ans = 0;
    for (let i = n - 1; i >= 2; i--) {
        const c = nums[i];
        let l = 0, r = i - 1;
        while (l < r) {
            if (nums[l] + nums[r] > c) {
                ans += r - l;
                r--;
            } else {
                l++;
            }
        }
    }
    return ans;
};
```

#### [923. 三数之和的多种可能](https://leetcode.cn/problems/3sum-with-multiplicity/description/)

给定一个整数数组 `arr` ，以及一个整数 `target` 作为目标值，返回满足 `i < j < k` 且 `arr[i] + arr[j] + arr[k] == target` 的元组 `i, j, k` 的数量。

由于结果会非常大，请返回 `109 + 7` 的模。

**示例 1：**

```
输入：arr = [1,1,2,2,3,3,4,4,5,5], target = 8
输出：20
解释：
按值枚举(arr[i], arr[j], arr[k])：
(1, 2, 5) 出现 8 次；
(1, 3, 4) 出现 8 次；
(2, 2, 4) 出现 2 次；
(2, 3, 3) 出现 2 次。
```

**示例 2：**

```
输入：arr = [1,1,2,2,2,2], target = 5
输出：12
解释：
arr[i] = 1, arr[j] = arr[k] = 2 出现 12 次：
我们从 [1,1] 中选择一个 1，有 2 种情况，
从 [2,2,2,2] 中选出两个 2，有 6 种情况。
```

**提示：**

* `3 <= arr.length <= 3000`
* `0 <= arr[i] <= 100`
* `0 <= target <= 300`

##### 统计词频，枚举三个数相等、三个数不相等(x < y < z，固定顺序去重)、两个数相等的情况，用组合数计算每种情况的方案数

```js
/**
 * @param {number[]} arr
 * @param {number} target
 * @return {number}
 */
var threeSumMulti = function (arr, target) {
    const cnt = new Map();
    for (let x of arr) {
        cnt.set(x, (cnt.get(x) ?? 0) + 1);
    }
    const keys = Array.from(cnt.keys()).sort((a, b) => a - b);
    const n = keys.length;
    let ans = 0;
    // 三个数都不相等
    for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
            let z = target - keys[i] - keys[j];
            if (cnt.has(z) && z < keys[i]) {
                ans += cnt.get(keys[i]) * cnt.get(keys[j]) * cnt.get(z);
            }
        }
    }
    // 三个数相等
    if (cnt.has(target / 3)) {
        let count = cnt.get(target / 3);
        ans += count * (count - 1) * (count - 2) / 6;
    }
    // x == y != z
    for (let i = 0; i < n; i++) {
        let z = target - 2 * keys[i];
        if (z == keys[i]) continue;
        if (cnt.has(z)) {
            let count = cnt.get(keys[i]);
            ans += (count * (count - 1) / 2) * cnt.get(z);
        }
    }

    return ans % (1e9 + 7);
};
```

##### 优化三指针

```js
/**
 * @param {number[]} arr
 * @param {number} target
 * @return {number}
 */
var threeSumMulti = function (arr, target) {
    arr.sort((a, b) => a - b);
    const n = arr.length;
    let ans = 0;
    for (let i = n - 1; i >= 2; i--) {
        let c = arr[i];
        let l = 0, r = i - 1;
        if (arr[0] + arr[1] > target - c) continue;
        // 最大的三个数和小于target，终止循环
        if (arr[i - 2] + arr[i - 1] < target - c) break;
        while (l < r) {
            if (arr[l] + arr[r] > target - c) {
                r--
            } else if (arr[l] + arr[r] < target - c) {
                l++
            } else {
                // 判断可选的方案数
                // arr[l] 和arr[r] 相等，则从元素值等于arr[l]的元素中任意选取两个
                if (arr[l] == arr[r]) {
                    ans += (r - l + 1) * (r - l) / 2;
                    break;
                } else {
                    // 从arr[l]中任取一个数，arr[r]中任取一个数
                    let _l = l, _r = r;
                    while (arr[l] == arr[_l]) {
                        _l++;
                    }
                    while (arr[r] == arr[_r]) {
                        _r--
                    }
                    ans += (_l - l) * (r - _r);
                    // 跳过选过的元素值
                    l = _l, r = _r;
                }
            }
        }
    }
    return ans % (1e9 + 7);
};
```

