### 回文数

#### 生成顺序回文数模板

```js
/**
 * @var {Array} palindrome - 存储预生成的回文数
 */
const palindrome = [];

/**
 * @constant {number} MX - 预生成回文数的最大值
 */
const MX = 2e8;

/**
 * 预生成所有小于MX的回文数
 * 分为奇数长度和偶数长度两种情况生成
 */
outer: for (let base = 1; ; base *= 10) {
    // 生成奇数长度的回文数
    for (let i = base; i < base * 10; i++) {
        let x = i;
        // 将i的前几位逆序追加到i后面，形成奇数长度回文数
        for (let t = Math.floor(x / 10); t > 0; t = Math.floor(t / 10)) {
            x = x * 10 + t % 10;
        }
        if (x > MX) {
            break outer;
        }
        palindrome.push(x);
    }
    
    // 生成偶数长度的回文数
    for (let i = base; i < base * 10; i++) {
        let x = i;
        // 将i完全逆序追加到i后面，形成偶数长度回文数
        for (let t = x; t > 0; t = Math.floor(t / 10)) {
            x = x * 10 + t % 10;
        }
        if (x > MX) {
            break outer;
        }
        palindrome.push(x);
    }
}
```

#### [9. 回文数](https://leetcode.cn/problems/palindrome-number/description/)

给你一个整数 `x` ，如果 `x` 是一个回文整数，返回 `true` ；否则，返回 `false` 。

回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

* 例如，`121` 是回文，而 `123` 不是。

**示例 1：**

```
输入：x = 121
输出：true
```

**示例 2：**

```
输入：x = -121
输出：false
解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
```

**示例 3：**

```
输入：x = 10
输出：false
解释：从右向左读, 为 01 。因此它不是一个回文数。
```

**提示：**

* `-231 <= x <= 231 - 1`

**进阶：**你能不将整数转为字符串来解决这个问题吗？

##### 如果可被10整除，且不为0直接返回false；
翻转一半数字，判断前后否相等

```js
/**
 * @param {number} x
 * @return {boolean}
 */
var isPalindrome = function(x) {
    if (x < 0 || (x % 10 == 0 && x != 0)) return false;
    let rev = 0;
    while (x > rev) {
        rev = rev * 10 + x % 10;
        x = Math.floor(x / 10);
    }

    return x == rev || Math.floor(rev / 10) == x;
};
```

#### [2217. 找到指定长度的回文数](https://leetcode.cn/problems/find-palindrome-with-fixed-length/description/)

给你一个整数数组 `queries` 和一个 **正** 整数 `intLength` ，请你返回一个数组 `answer` ，其中 `answer[i]` 是长度为 `intLength` 的 **正回文数** 中第`queries[i]` 小的数字，如果不存在这样的回文数，则为 `-1` 。

**回文数** 指的是从前往后和从后往前读一模一样的数字。回文数不能有前导 0 。

**示例 1：**

```
输入：queries = [1,2,3,4,5,90], intLength = 3
输出：[101,111,121,131,141,999]
解释：
长度为 3 的最小回文数依次是：
101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 202, ...
第 90 个长度为 3 的回文数是 999 。
```

**示例 2：**

```
输入：queries = [2,4,6], intLength = 4
输出：[1111,1331,1551]
解释：
长度为 4 的前 6 个回文数是：
1001, 1111, 1221, 1331, 1441 和 1551 。
```

**提示：**

* `1 <= queries.length <= 5 * 104`
* `1 <= queries[i] <= 109`
* `1 <= intLength <= 15`

##### 只看左半部分，长度为l的第q个回文数的左半部分为10^a + q - 1, a为ceil(l/2)。再反转拼接回文数

```js
/**
 * @param {number[]} queries
 * @param {number} intLength
 * @return {number[]}
 */
var kthPalindrome = function (queries, intLength) {
    const odd = intLength % 2;
    const base = Math.pow(10, Math.ceil(intLength / 2) - 1);
    const ans = Array(queries.length).fill(-1);
    for (let i = 0; i < queries.length; i++) {
        let k = base + queries[i] - 1;
        if (k >= base * 10) {
            continue;
        }
        ans[i] = genPalindrome(k, odd);
    }

    return ans;
};

const genPalindrome = (i, odd) => {
    let x = odd ? Math.floor(i / 10) : i, p = i;
    while (x) {
        p = p * 10 + x % 10;
        x = Math.floor(x / 10);
    }
    return p;
}
```

#### [2396. 严格回文的数字](https://leetcode.cn/problems/strictly-palindromic-number/description/)

如果一个整数 `n` 在 `b` 进制下（`b` 为 `2` 到 `n - 2` 之间的所有整数）对应的字符串 **全部** 都是 **回文的** ，那么我们称这个数 `n` 是 **严格回文** 的。

给你一个整数 `n` ，如果 `n` 是 **严格回文** 的，请返回 `true` ，否则返回`false` 。

如果一个字符串从前往后读和从后往前读完全相同，那么这个字符串是 **回文的** 。

**示例 1：**

```
输入：n = 9
输出：false
解释：在 2 进制下：9 = 1001 ，是回文的。
在 3 进制下：9 = 100 ，不是回文的。
所以，9 不是严格回文数字，我们返回 false 。
注意在 4, 5, 6 和 7 进制下，n = 9 都不是回文的。
```

**示例 2：**

```
输入：n = 4
输出：false
解释：我们只考虑 2 进制：4 = 100 ，不是回文的。
所以我们返回 false 。
```

**提示：**

* `4 <= n <= 105`

##### n的n-2进制为12，不是回文数，且4也不是严格回文数，对任意n直接返回false

```js
/**
 * @param {number} n
 * @return {boolean}
 */
var isStrictlyPalindromic = function(n) {
    return false;
};
```

##### 任意进制回文数

```js
/**
 * @param {number} n
 * @return {boolean}
 */
var isStrictlyPalindromic = function(n) {
    for (let b = 2; b <= n - 2; b++) {
        let x = n, rev = 0;
        while (x) {
            rev = rev * b + x % b;
            x = Math.floor(x / b);
        }
        if (rev !== n) return false;
    }

    return true;
};
```

#### [866. 回文质数](https://leetcode.cn/problems/prime-palindrome/description/)

给你一个整数 `n` ，返回大于或等于 `n` 的最小 **回文质数**。

一个整数如果恰好有两个除数：`1` 和它本身，那么它是 **质数** 。注意，`1` 不是质数。

* 例如，`2`、`3`、`5`、`7`、`11` 和 `13` 都是质数。

一个整数如果从左向右读和从右向左读是相同的，那么它是 **回文数** 。

* 例如，`101` 和 `12321` 都是回文数。

测试用例保证答案总是存在，并且在 `[2, 2 * 108]` 范围内。

**示例 1：**

```
输入：n = 6
输出：7
```

**示例 2：**

```
输入：n = 8
输出：11
```

**示例 3：**

```
输入：n = 13
输出：101
```

**提示：**

* `1 <= n <= 108`

##### 生成所有回文质数 二分

- 生成所有的回文数
- 过滤出所有的回文质数
- 二分查找第一个大于等于n的回文质数

```js
/**
 * @function primePalindrome
 * @description 查找大于等于给定数字的最小素数回文数
 * @param {number} n - 输入的目标数字
 * @return {number} 大于等于n的最小素数回文数
 * @算法核心思想：预生成所有可能的回文数，筛选出素数后，使用二分查找快速定位目标值
 * @时间复杂度：O(1) - 预计算阶段完成后查询为O(log n)
 * @空间复杂度：O(k) - k为预生成的素数回文数数量
 */
var primePalindrome = function (n) {
    return lowerBound(n);
};

/**
 * @var {Array} palindrome - 存储预生成的回文数
 */
const palindrome = [];

/**
 * @constant {number} MX - 预生成回文数的最大值
 */
const MX = 2e8;

/**
 * 预生成所有小于MX的回文数
 * 分为奇数长度和偶数长度两种情况生成
 */
outer: for (let base = 1; ; base *= 10) {
    // 生成奇数长度的回文数
    for (let i = base; i < base * 10; i++) {
        let x = i;
        // 将i的前几位逆序追加到i后面，形成奇数长度回文数
        for (let t = Math.floor(x / 10); t > 0; t = Math.floor(t / 10)) {
            x = x * 10 + t % 10;
        }
        if (x > MX) {
            break outer;
        }
        palindrome.push(x);
    }
    
    // 生成偶数长度的回文数
    for (let i = base; i < base * 10; i++) {
        let x = i;
        // 将i完全逆序追加到i后面，形成偶数长度回文数
        for (let t = x; t > 0; t = Math.floor(t / 10)) {
            x = x * 10 + t % 10;
        }
        if (x > MX) {
            break outer;
        }
        palindrome.push(x);
    }
}

/**
 * @function isPrime
 * @description 判断一个数是否为素数
 * @param {number} x - 待判断的数字
 * @return {boolean} 如果是素数返回true，否则返回false
 * @算法核心思想：检查从2到√x的所有整数是否能整除x
 * @时间复杂度：O(√n)
 * @空间复杂度：O(1)
 */
const isPrime = (x) => {
    if (x < 2) return false; // 小于2的数不是素数
    let sqrt = Math.sqrt(x);
    for (let i = 2; i <= sqrt; i++) {
        if (x % i == 0) return false; // 能被i整除，不是素数
    }
    return true;
};

/**
 * @var {Array} primes - 存储所有是素数的回文数
 */
const primes = palindrome.filter(isPrime);

/**
 * @function lowerBound
 * @description 使用二分查找找到大于等于目标值的最小素数回文数
 * @param {number} target - 目标值
 * @return {number} 大于等于target的最小素数回文数
 * @算法核心思想：二分查找有序数组中的下界
 * @时间复杂度：O(log n)
 * @空间复杂度：O(1)
 */
const lowerBound = (target) => {
    let l = 0, r = primes.length;
    while (l <= r) {
        // 计算中间位置（避免整数溢出的写法）
        let m = Math.floor((r - l) / 2) + l;
        if (primes[m] < target) {
            l = m + 1; // 目标值在右半部分
        } else {
            r = m - 1; // 目标值在左半部分或等于中间值
        }
    }
    return primes[l]; // 返回下界位置的元素
};

```

