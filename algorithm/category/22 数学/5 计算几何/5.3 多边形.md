### 多边形

#### [963. 最小面积矩形 II](https://leetcode.cn/problems/minimum-area-rectangle-ii/description/)

给你一个  **X-Y**平面上的点数组 `points`，其中 `points[i] = [xi, yi]`。

返回由这些点形成的任意矩形的最小面积，矩形的边  **不一定** 平行于 X 轴和 Y 轴。如果不存在这样的矩形，则返回 `0`。

答案只需在`10-5` 的误差范围内即可被视作正确答案。

**示例 1：**

![](https://assets.leetcode.com/uploads/2018/12/21/1a.png)

```
输入： points = [[1,2],[2,1],[1,0],[0,1]]
输出： 2.00000
解释： 最小面积矩形由 [1,2]、[2,1]、[1,0]、[0,1] 组成，其面积为 2。
```

**示例 2：**

![](https://assets.leetcode.com/uploads/2018/12/22/2.png)

```
输入： points = [[0,1],[2,1],[1,1],[1,0],[2,0]]
输出： 1.00000
解释： 最小面积矩形由 [1,0]、[1,1]、[2,1]、[2,0] 组成，其面积为 1。
```

**示例 3：**

![](https://assets.leetcode.com/uploads/2018/12/22/3.png)

```
输入： points = [[0,3],[1,2],[3,1],[1,3],[2,1]]
输出： 0
解释： 无法由这些点组成任何矩形。
```

**提示：**

- `1 <= points.length <= 50`
- `points[i].length == 2`
- `0 <= xi, yi <= 4 * 104`
- 所有给定的点都是  **唯一**的。

##### 向量

```js
/**
 * @param {number[][]} points
 * @return {number}
 */
var minAreaFreeRect = function (points) {
  const n = points.length;
  points.sort((a, b) => a[0] - b[0] || a[1] - b[1]);
  const set = {};
  for (let p of points) {
    set[p] = true;
  }
  let ans = Infinity;
  for (let i = 0; i < n; i++) {
    let p1 = points[i];
    for (let j = 0; j < n; j++) {
      if (i == j) continue;
      let p2 = points[j];
      for (let k = j + 1; k < n; k++) {
        if (i == k) continue;
        let p3 = points[k];
        // 根据向量得出第四个点
        let p4 = [p3[0] + p2[0] - p1[0], p3[1] + p2[1] - p1[1]];
        if (!set[p4]) {
          continue;
        }
        const d1 = distance(p1, p3),
          d2 = distance(p1, p2),
          d3 = distance(p2, p3);
        // 判断是否直角三角形
        if (d3 == d1 + d2) {
          ans = Math.min(ans, d1 * d2);
        }
      }
    }
  }
  return ans == Infinity ? 0 : Math.sqrt(ans);
};

const distance = (p1, p2) => {
  return Math.pow(p2[0] - p1[0], 2) + Math.pow(p2[1] - p1[1], 2);
};
```

##### 枚举四个点判断是否为矩形

```js
/**
 * @param {number[][]} points
 * @return {number}
 */
var minAreaFreeRect = function (points) {
  const n = points.length;
  points.sort((a, b) => a[0] - b[0] || a[1] - b[1]);
  let ans = Infinity;
  for (let i = 0; i < n - 3; i++) {
    for (let j = i + 1; j < n - 2; j++) {
      for (let k = j + 1; k < n - 1; k++) {
        for (let m = k + 1; m < n; m++) {
          ans = Math.min(
            ans,
            isRect(points[i], points[j], points[k], points[m])
          );
        }
      }
    }
  }
  return ans == Infinity ? 0 : ans;
};

const isRect = (p1, p2, p3, p4) => {
  const p = [p1, p2, p3, p4];
  let d1 = distance(p[0], p[1]),
    d2 = distance(p[0], p[2]),
    d3 = distance(p[3], p[1]),
    d4 = distance(p[3], p[2]),
    d5 = distance(p[0], p[3]),
    d6 = distance(p[1], p[2]);
  return d1 == d4 && d2 == d3 && d1 + d2 == d6 ? Math.sqrt(d1 * d2) : Infinity;
};

const distance = (p1, p2) => {
  return Math.pow(p2[0] - p1[0], 2) + Math.pow(p2[1] - p1[1], 2);
};
```

#### [939. 最小面积矩形](https://leetcode.cn/problems/minimum-area-rectangle/description/)

给你一个  **X-Y**平面上的点数组 `points`，其中 `points[i] = [xi, yi]`。

返回由这些点形成的矩形的最小面积，矩形的边与 X 轴和 Y 轴平行。如果不存在这样的矩形，则返回 `0`。

**示例 1：**

![](https://assets.leetcode.com/uploads/2021/08/03/rec1.JPG)

```
输入： points = [[1,1],[1,3],[3,1],[3,3],[2,2]]
输出： 4
```

**示例 2：**

![](https://assets.leetcode.com/uploads/2021/08/03/rec2.JPG)

```
输入： points = [[1,1],[1,3],[3,1],[3,3],[4,1],[4,3]]
输出： 2
```

**提示：**

- `1 <= points.length <= 500`
- `points[i].length == 2`
- `0 <= xi, yi <= 4 * 104`
- 所有给定的点都是  **唯一**的。

##### 枚举四个点

```js
/**
 * @param {number[][]} points
 * @return {number}
 */
var minAreaRect = function (points) {
  const xLines = new Map();
  for (let [x, y] of points) {
    const line = xLines.get(x) ?? new Set();
    line.add(y);
    xLines.set(x, line);
  }
  let ans = Infinity;
  for (const [x, line] of xLines.entries()) {
    for (const [x2, line2] of xLines.entries()) {
      if (x == x2) continue;
      let dx = Math.abs(x2 - x);
      const yLines = [];
      for (let y of line.keys()) {
        if (line2.has(y)) {
          yLines.push(y);
        }
      }
      if (yLines.length < 2) continue;
      yLines.sort((a, b) => a - b);
      let dy = yLines[1] - yLines[0];
      for (let i = 2; i < yLines.length; i++) {
        dy = Math.min(dy, yLines[i] - yLines[i - 1]);
      }
      ans = Math.min(ans, dx * dy);
    }
  }

  return ans == Infinity ? 0 : ans;
};
```

#### [593. 有效的正方形](https://leetcode.cn/problems/valid-square/description/)

给定 2D 空间中四个点的坐标  `p1`, `p2`, `p3`  和  `p4`，如果这四个点构成一个正方形，则返回 `true` 。

点的坐标  `pi` 表示为 `[xi, yi]` 。 `输入没有任何顺序` 。

一个 **有效的正方形** 有四条等边和四个等角(90 度角)。

**示例 1:**

```
输入: p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1]
输出: true
```

**示例 2:**

```
输入：p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,12]
输出：false
```

**示例 3:**

```
输入：p1 = [1,0], p2 = [-1,0], p3 = [0,1], p4 = [0,-1]
输出：true
```

**提示:**

- `p1.length == p2.length == p3.length == p4.length == 2`
- `-104 <= xi, yi <= 104`

##### 对点进行排序后计算距离，判断四条边是否相等且两条边和对应的对角线是否为直角 a^2+b^2 = c^2

```js
/**
 * @param {number[]} p1
 * @param {number[]} p2
 * @param {number[]} p3
 * @param {number[]} p4
 * @return {boolean}
 */
var validSquare = function (p1, p2, p3, p4) {
  const p = [p1, p2, p3, p4];
  p.sort((a, b) => a[0] - b[0] || a[1] - b[1]);
  let d1 = distance(p[0], p[1]),
    d2 = distance(p[0], p[2]),
    d3 = distance(p[3], p[1]),
    d4 = distance(p[3], p[2]),
    d5 = distance(p[0], p[3]);
  return d1 != 0 && d1 == d2 && d1 == d3 && d1 == d4 && d1 + d3 == d5;
};

const distance = (p1, p2) => {
  return Math.pow(p2[0] - p1[0], 2) + Math.pow(p2[1] - p1[1], 2);
};
```

#### [223. 矩形面积](https://leetcode.cn/problems/rectangle-area/description/)

给你 **二维** 平面上两个 **由直线构成且边与坐标轴平行/垂直** 的矩形，请你计算并返回两个矩形覆盖的总面积。

每个矩形由其 **左下** 顶点和 **右上** 顶点坐标表示：

- 第一个矩形由其左下顶点 `(ax1, ay1)` 和右上顶点 `(ax2, ay2)` 定义。
- 第二个矩形由其左下顶点 `(bx1, by1)` 和右上顶点 `(bx2, by2)` 定义。

**示例 1：**

![Rectangle Area](https://assets.leetcode.com/uploads/2021/05/08/rectangle-plane.png)

```
输入：ax1 = -3, ay1 = 0, ax2 = 3, ay2 = 4, bx1 = 0, by1 = -1, bx2 = 9, by2 = 2
输出：45
```

**示例 2：**

```
输入：ax1 = -2, ay1 = -2, ax2 = 2, ay2 = 2, bx1 = -2, by1 = -2, bx2 = 2, by2 = 2
输出：16
```

**提示：**

- `-104 <= ax1 <= ax2 <= 104`
- `-104 <= ay1 <= ay2 <= 104`
- `-104 <= bx1 <= bx2 <= 104`
- `-104 <= by1 <= by2 <= 104`

##### 根据投影计算重叠区域面积

```js
/**
 * @param {number} ax1
 * @param {number} ay1
 * @param {number} ax2
 * @param {number} ay2
 * @param {number} bx1
 * @param {number} by1
 * @param {number} bx2
 * @param {number} by2
 * @return {number}
 */
var computeArea = function (ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) {
  let unionx = Math.max(0, Math.min(ax2, bx2) - Math.max(ax1, bx1)),
    uniony = Math.max(0, Math.min(ay2, by2) - Math.max(ay1, by1));
  return (
    (ax2 - ax1) * (ay2 - ay1) + (bx2 - bx1) * (by2 - by1) - unionx * uniony
  );
};
```

#### [836. 矩形重叠](https://leetcode.cn/problems/rectangle-overlap/description/)

矩形以列表 `[x1, y1, x2, y2]` 的形式表示，其中 `(x1, y1)` 为左下角的坐标，`(x2, y2)` 是右上角的坐标。矩形的上下边平行于 x 轴，左右边平行于 y 轴。

如果相交的面积为 **正** ，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。

给出两个矩形 `rec1` 和 `rec2` 。如果它们重叠，返回 `true`；否则，返回 `false` 。

**示例 1：**

```
输入：rec1 = [0,0,2,2], rec2 = [1,1,3,3]
输出：true
```

**示例 2：**

```
输入：rec1 = [0,0,1,1], rec2 = [1,0,2,1]
输出：false
```

**示例 3：**

```
输入：rec1 = [0,0,1,1], rec2 = [2,2,3,3]
输出：false
```

**提示：**

- `rect1.length == 4`
- `rect2.length == 4`
- `-109 <= rec1[i], rec2[i] <= 109`
- `rec1` 和 `rec2` 表示一个面积不为零的有效矩形

##### 根据 x、y 轴投影判断

```js
/**
 * @param {number[]} rec1
 * @param {number[]} rec2
 * @return {boolean}
 */
var isRectangleOverlap = function (rec1, rec2) {
  return (
    Math.max(rec1[1], rec2[1]) < Math.min(rec1[3], rec2[3]) &&
    Math.min(rec1[2], rec2[2]) > Math.max(rec1[0], rec2[0])
  );
};
```
