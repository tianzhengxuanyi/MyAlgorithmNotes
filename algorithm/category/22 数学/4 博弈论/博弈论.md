### 博弈论

#### [1140. 石子游戏 II](https://leetcode.cn/problems/stone-game-ii/description/)

Alice 和 Bob 继续他们的石子游戏。许多堆石子 **排成一行**，每堆都有正整数颗石子 `piles[i]`。游戏以谁手中的石子最多来决出胜负。

Alice 和 Bob 轮流进行，Alice 先开始。最初，`M = 1`。

在每个玩家的回合中，该玩家可以拿走剩下的 **前** `X` 堆的所有石子，其中 `1 <= X <= 2M`。然后，令 `M = max(M, X)`。

游戏一直持续到所有石子都被拿走。

假设 Alice 和 Bob 都发挥出最佳水平，返回 Alice 可以得到的最大数量的石头。

**示例 1：**

```
输入：piles = [2,7,9,4,4]
输出：10
解释：如果一开始 Alice 取了一堆，Bob 取了两堆，然后 Alice 再取两堆。Alice 可以得到 2 + 4 + 4 = 10 堆。
如果 Alice 一开始拿走了两堆，那么 Bob 可以拿走剩下的三堆。在这种情况下，Alice 得到 2 + 7 = 9 堆。返回 10，因为它更大。
```

**示例 2:**

```
输入：piles = [1,2,3,4,5,100]
输出：104
```

**提示：**

* `1 <= piles.length <= 100`
* `1 <= piles[i] <= 104`

##### dp：计算两人差值最大

```js
/**
 * @param {number[]} piles
 * @return {number}
 */
var stoneGameII = function (piles) {
    const n = piles.length;
    const prefix = Array(n + 1).fill(0);
    for (let i = 0; i < n; i++) {
        prefix[i + 1] = prefix[i] + piles[i];
    }
    // 从第i堆开始，M为m时，A和B数量的差值最大
    const memo = Array.from({ length: n }, () => Array(n).fill(-1));
    const dfs = (i, m) => {
        if (i + 2 * m >= n) return memo[i][m] = prefix[n] - prefix[i];
        if (memo[i][m] >= 0) return memo[i][m];
        let res = -Infinity;
        for (let x = 1; x <= Math.min(2 * m, n - i); x++) {
            // 当前拿走的数量
            let cnt = prefix[i + x] - prefix[i];
            // nextD = bc - ac  , currD = ac + cnt - bc = cnt - nextD
            res = Math.max(res, cnt - dfs(i + x, Math.max(m, x)))
        }
        return memo[i][m] = res;
    }

    const diff = dfs(0, 1);
    return (diff + prefix[n]) / 2
};
```

#### [464. 我能赢吗](https://leetcode.cn/problems/can-i-win/description/)

在 "100 game" 这个游戏中，两名玩家轮流选择从 `1` 到 `10` 的任意整数，累计整数和，先使得累计整数和 **达到或超过**  100 的玩家，即为胜者。

如果我们将游戏规则改为 “玩家 **不能** 重复使用整数” 呢？

例如，两个玩家可以轮流从公共整数池中抽取从 1 到 15 的整数（不放回），直到累计整数和 >= 100。

给定两个整数 `maxChoosableInteger` （整数池中可选择的最大数）和 `desiredTotal`（累计和），若先出手的玩家能稳赢则返回 `true` ，否则返回 `false` 。假设两位玩家游戏时都表现 **最佳** 。

**示例 1：**

```
输入：maxChoosableInteger = 10, desiredTotal = 11
输出：false
解释：
无论第一个玩家选择哪个整数，他都会失败。
第一个玩家可以选择从 1 到 10 的整数。
如果第一个玩家选择 1，那么第二个玩家只能选择从 2 到 10 的整数。
第二个玩家可以通过选择整数 10（那么累积和为 11 >= desiredTotal），从而取得胜利.
同样地，第一个玩家选择任意其他整数，第二个玩家都会赢。
```

**示例 2:**

```
输入：maxChoosableInteger = 10, desiredTotal = 0
输出：true
```

**示例 3:**

```
输入：maxChoosableInteger = 10, desiredTotal = 1
输出：true
```

**提示:**

* `1 <= maxChoosableInteger <= 20`
* `0 <= desiredTotal <= 300`

```js
/**
 * @param {number} maxChoosableInteger
 * @param {number} desiredTotal
 * @return {boolean}
 */
var canIWin = function (maxChoosableInteger, desiredTotal) {
    let total = maxChoosableInteger * (maxChoosableInteger + 1) / 2;
    if (total < desiredTotal) return false;
    const memo = Array(1 << maxChoosableInteger);
    const dfs = (mask, r) => {
        if (typeof memo[mask] != "undefined") return memo[mask];
        for (let i = 1; i <= maxChoosableInteger; i++) {
            if (mask & (1 << i)) continue;
            if (i >= r || !dfs(mask | (1 << i), r - i)) {
                return memo[mask] = true;
            }
        }
        return memo[mask] = false;
    }

    return dfs(0, desiredTotal)
};
```

#### [292. Nim 游戏](https://leetcode.cn/problems/nim-game/description/)

你和你的朋友，两个人一起玩 [Nim 游戏](https://baike.baidu.com/item/Nim游戏/6737105)：

* 桌子上有一堆石头。
* 你们轮流进行自己的回合， **你作为先手**。
* 每一回合，轮到的人拿掉 1 - 3 块石头。
* 拿掉最后一块石头的人就是获胜者。

假设你们每一步都是最优解。请编写一个函数，来判断你是否可以在给定石头数量为 `n` 的情况下赢得游戏。如果可以赢，返回 `true`；否则，返回 `false` 。

**示例 1：**

```
输入：n = 4
输出：false 
解释：以下是可能的结果:
1. 移除1颗石头。你的朋友移走了3块石头，包括最后一块。你的朋友赢了。
2. 移除2个石子。你的朋友移走2块石头，包括最后一块。你的朋友赢了。
3.你移走3颗石子。你的朋友移走了最后一块石头。你的朋友赢了。
在所有结果中，你的朋友是赢家。
```

**示例 2：**

```
输入：n = 1
输出：true
```

**示例 3：**

```
输入：n = 2
输出：true
```

**提示：**

* `1 <= n <= 231 - 1`

##### 数学 巴什博弈 ： 4必输 567必赢 8必输

```js
/**
 * @param {number} n
 * @return {boolean}
 */
var canWinNim = function (n) {
    return n % 4 != 0;
};
// 1 2 3
// 4 false
// 5 true
// 6 true
// 7 true
// 8 false
// 9 true

```

#### [1406. 石子游戏 III](https://leetcode.cn/problems/stone-game-iii/description/)

Alice 和 Bob 继续他们的石子游戏。几堆石子 **排成一行** ，每堆石子都对应一个得分，由数组 `stoneValue` 给出。

Alice 和 Bob 轮流取石子，**Alice** 总是先开始。在每个玩家的回合中，该玩家可以拿走剩下石子中的的前 **1、2 或 3 堆石子** 。比赛一直持续到所有石头都被拿走。

每个玩家的最终得分为他所拿到的每堆石子的对应得分之和。每个玩家的初始分数都是 **0** 。

比赛的目标是决出最高分，得分最高的选手将会赢得比赛，比赛也可能会出现平局。

假设 Alice 和 Bob 都采取 **最优策略** 。

如果 Alice 赢了就返回 `"Alice"` *，*Bob 赢了就返回`"Bob"`*，*分数相同返回 `"Tie"` 。

**示例 1：**

```
输入：values = [1,2,3,7]
输出："Bob"
解释：Alice 总是会输，她的最佳选择是拿走前三堆，得分变成 6 。但是 Bob 的得分为 7，Bob 获胜。
```

**示例 2：**

```
输入：values = [1,2,3,-9]
输出："Alice"
解释：Alice 要想获胜就必须在第一个回合拿走前三堆石子，给 Bob 留下负分。
如果 Alice 只拿走第一堆，那么她的得分为 1，接下来 Bob 拿走第二、三堆，得分为 5 。之后 Alice 只能拿到分数 -9 的石子堆，输掉比赛。
如果 Alice 拿走前两堆，那么她的得分为 3，接下来 Bob 拿走第三堆，得分为 3 。之后 Alice 只能拿到分数 -9 的石子堆，同样会输掉比赛。
注意，他们都应该采取 最优策略 ，所以在这里 Alice 将选择能够使她获胜的方案。
```

**示例 3：**

```
输入：values = [1,2,3,6]
输出："Tie"
解释：Alice 无法赢得比赛。如果她决定选择前三堆，她可以以平局结束比赛，否则她就会输。
```

**提示：**

* `1 <= stoneValue.length <= 5 * 104`
* `-1000 <= stoneValue[i] <= 1000`

##### 递推优化

```js
/**
 * @param {number[]} stoneValue
 * @return {string}
 */
var stoneGameIII = function (stoneValue) {
    const n = stoneValue.length;
    const dp = [stoneValue[n - 1], 0, 0];
    for (let i = n - 2; i >= 0; i--) {
        let score = 0, curr = -Infinity;
        for (let j = 0; j < 3 && i + j < n; j++) {
            score += stoneValue[i + j];
            curr = Math.max(curr, score - dp[j]);
        }
        dp[2] = dp[1], dp[1] = dp[0], dp[0] = curr;
    }
    return dp[0] == 0 ? "Tie" : dp[0] > 0 ? "Alice" : "Bob";
};
```

##### 递推

```js
/**
 * @param {number[]} stoneValue
 * @return {string}
 */
var stoneGameIII = function (stoneValue) {
    const n = stoneValue.length;
    const dp = Array(n + 1).fill(-Infinity);
    dp[n] = 0, dp[n - 1] = stoneValue[n - 1];
    for (let i = n - 2; i >= 0; i--) {
        let score = 0;
        for (let j = 0; j < 3 && i + j < n; j++) {
            score += stoneValue[i + j];
            dp[i] = Math.max(dp[i], score - dp[i + j + 1]);
        }
    }
    return dp[0] == 0 ? "Tie" : dp[0] > 0 ? "Alice" : "Bob";
};
```

##### DP 记忆化缓存

```js
/**
 * @param {number[]} stoneValue
 * @return {string}
 */
var stoneGameIII = function (stoneValue) {
    const n = stoneValue.length;
    const memo = Array(n);
    const dfs = (i) => {
        if (i >= n) return 0;
        if (typeof memo[i] != "undefined") return memo[i];
        let res = -Infinity;
        let score = 0;
        for (let j = 0; j < 3 && i + j < n; j++) {
            score += stoneValue[i + j];
            res = Math.max(res, score - dfs(i + j + 1));
        }
        return memo[i] = res;
    }
    const diff = dfs(0);
    return diff == 0 ? "Tie" : diff > 0 ? "Alice" : "Bob";
};
```


#### [1927. 求和游戏](https://leetcode.cn/problems/sum-game/description/)

Alice 和 Bob 玩一个游戏，两人轮流行动，**Alice 先手** 。

给你一个 **偶数长度** 的字符串 `num` ，每一个字符为数字字符或者 `'?'` 。每一次操作中，如果 `num` 中至少有一个 `'?'` ，那么玩家可以执行以下操作：

1. 选择一个下标 `i` 满足 `num[i] == '?'` 。
2. 将 `num[i]` 用 `'0'` 到 `'9'` 之间的一个数字字符替代。

当 `num` 中没有 `'?'` 时，游戏结束。

Bob 获胜的条件是 `num` 中前一半数字的和 **等于** 后一半数字的和。Alice 获胜的条件是前一半的和与后一半的和 **不相等** 。

* 比方说，游戏结束时 `num = "243801"` ，那么 Bob 获胜，因为 `2+4+3 = 8+0+1` 。如果游戏结束时 `num = "243803"` ，那么 Alice 获胜，因为 `2+4+3 != 8+0+3` 。

在 Alice 和 Bob 都采取 **最优** 策略的前提下，如果 Alice 获胜，请返回 `true` ，如果 Bob 获胜，请返回 `false` 。

**示例 1：**

```
输入：num = "5023"
输出：false
解释：num 中没有 '?' ，没法进行任何操作。
前一半的和等于后一半的和：5 + 0 = 2 + 3 。
```

**示例 2：**

```
输入：num = "25??"
输出：true
解释：Alice 可以将两个 '?' 中的一个替换为 '9' ，Bob 无论如何都无法使前一半的和等于后一半的和。
```

**示例 3：**

```
输入：num = "?3295???"
输出：false
解释：Bob 总是能赢。一种可能的结果是：
- Alice 将第一个 '?' 用 '9' 替换。num = "93295???" 。
- Bob 将后面一半中的一个 '?' 替换为 '9' 。num = "932959??" 。
- Alice 将后面一半中的一个 '?' 替换为 '2' 。num = "9329592?" 。
- Bob 将后面一半中最后一个 '?' 替换为 '7' 。num = "93295927" 。
Bob 获胜，因为 9 + 3 + 2 + 9 = 5 + 9 + 2 + 7 。
```

**提示：**

* `2 <= num.length <= 105`
* `num.length` 是 **偶数** 。
* `num` 只包含数字字符和 `'?'` 。

```js
/**
 * @param {string} num
 * @return {boolean}
 */
var sumGame = function (num) {
    const n = num.length, half = n / 2;
    let leftCnt = 0, rightCnt = 0, leftSum = 0, rightSum = 0;
    for (let i = 0; i < n; i++) {
        let x = num[i];
        if (i < half) {
            leftCnt += x == "?" ? 1 : 0;
            leftSum += x == "?" ? 0 : +x;
        } else {
            rightCnt += x == "?" ? 1 : 0;
            rightSum += x == "?" ? 0 : +x;
        }
    }
    let totalCnt = leftCnt + rightCnt, diff = leftSum - rightSum;
    // case1 问号总数为奇数
    if (totalCnt % 2) return true;
    // case2 问号总数为0
    if (totalCnt == 0) return diff != 0;
    // case3 问号在左右两侧都有
    if (leftCnt > 0 && rightCnt > 0) {
        let restCnt = Math.abs(leftCnt - rightCnt);
        if ((diff > 0) && (leftCnt >= rightCnt) || (diff < 0 && (rightCnt >= leftCnt))) return true;
        return Math.abs(diff) != restCnt * 9 / 2;
    } else {
        // case4 问号在单侧
        if ((diff > 0 && leftCnt) || (diff < 0 && rightCnt)) return true;
        return Math.abs(diff) != totalCnt * 9 / 2;
    }
};
```

