### 博弈论

#### [1140. 石子游戏 II](https://leetcode.cn/problems/stone-game-ii/description/)

Alice 和 Bob 继续他们的石子游戏。许多堆石子 **排成一行**，每堆都有正整数颗石子 `piles[i]`。游戏以谁手中的石子最多来决出胜负。

Alice 和 Bob 轮流进行，Alice 先开始。最初，`M = 1`。

在每个玩家的回合中，该玩家可以拿走剩下的 **前** `X` 堆的所有石子，其中 `1 <= X <= 2M`。然后，令 `M = max(M, X)`。

游戏一直持续到所有石子都被拿走。

假设 Alice 和 Bob 都发挥出最佳水平，返回 Alice 可以得到的最大数量的石头。

**示例 1：**

```
输入：piles = [2,7,9,4,4]
输出：10
解释：如果一开始 Alice 取了一堆，Bob 取了两堆，然后 Alice 再取两堆。Alice 可以得到 2 + 4 + 4 = 10 堆。
如果 Alice 一开始拿走了两堆，那么 Bob 可以拿走剩下的三堆。在这种情况下，Alice 得到 2 + 7 = 9 堆。返回 10，因为它更大。
```

**示例 2:**

```
输入：piles = [1,2,3,4,5,100]
输出：104
```

**提示：**

* `1 <= piles.length <= 100`
* `1 <= piles[i] <= 104`

##### dp：计算两人差值最大

```js
/**
 * @param {number[]} piles
 * @return {number}
 */
var stoneGameII = function (piles) {
    const n = piles.length;
    const prefix = Array(n + 1).fill(0);
    for (let i = 0; i < n; i++) {
        prefix[i + 1] = prefix[i] + piles[i];
    }
    // 从第i堆开始，M为m时，A和B数量的差值最大
    const memo = Array.from({ length: n }, () => Array(n).fill(-1));
    const dfs = (i, m) => {
        if (i + 2 * m >= n) return memo[i][m] = prefix[n] - prefix[i];
        if (memo[i][m] >= 0) return memo[i][m];
        let res = -Infinity;
        for (let x = 1; x <= Math.min(2 * m, n - i); x++) {
            // 当前拿走的数量
            let cnt = prefix[i + x] - prefix[i];
            // nextD = bc - ac  , currD = ac + cnt - bc = cnt - nextD
            res = Math.max(res, cnt - dfs(i + x, Math.max(m, x)))
        }
        return memo[i][m] = res;
    }

    const diff = dfs(0, 1);
    return (diff + prefix[n]) / 2
};
```

#### [464. 我能赢吗](https://leetcode.cn/problems/can-i-win/description/)

在 "100 game" 这个游戏中，两名玩家轮流选择从 `1` 到 `10` 的任意整数，累计整数和，先使得累计整数和 **达到或超过**  100 的玩家，即为胜者。

如果我们将游戏规则改为 “玩家 **不能** 重复使用整数” 呢？

例如，两个玩家可以轮流从公共整数池中抽取从 1 到 15 的整数（不放回），直到累计整数和 >= 100。

给定两个整数 `maxChoosableInteger` （整数池中可选择的最大数）和 `desiredTotal`（累计和），若先出手的玩家能稳赢则返回 `true` ，否则返回 `false` 。假设两位玩家游戏时都表现 **最佳** 。

**示例 1：**

```
输入：maxChoosableInteger = 10, desiredTotal = 11
输出：false
解释：
无论第一个玩家选择哪个整数，他都会失败。
第一个玩家可以选择从 1 到 10 的整数。
如果第一个玩家选择 1，那么第二个玩家只能选择从 2 到 10 的整数。
第二个玩家可以通过选择整数 10（那么累积和为 11 >= desiredTotal），从而取得胜利.
同样地，第一个玩家选择任意其他整数，第二个玩家都会赢。
```

**示例 2:**

```
输入：maxChoosableInteger = 10, desiredTotal = 0
输出：true
```

**示例 3:**

```
输入：maxChoosableInteger = 10, desiredTotal = 1
输出：true
```

**提示:**

* `1 <= maxChoosableInteger <= 20`
* `0 <= desiredTotal <= 300`

```js
/**
 * @param {number} maxChoosableInteger
 * @param {number} desiredTotal
 * @return {boolean}
 */
var canIWin = function (maxChoosableInteger, desiredTotal) {
    let total = maxChoosableInteger * (maxChoosableInteger + 1) / 2;
    if (total < desiredTotal) return false;
    const memo = Array(1 << maxChoosableInteger);
    const dfs = (mask, r) => {
        if (typeof memo[mask] != "undefined") return memo[mask];
        for (let i = 1; i <= maxChoosableInteger; i++) {
            if (mask & (1 << i)) continue;
            if (i >= r || !dfs(mask | (1 << i), r - i)) {
                return memo[mask] = true;
            }
        }
        return memo[mask] = false;
    }

    return dfs(0, desiredTotal)
};
```

#### [292. Nim 游戏](https://leetcode.cn/problems/nim-game/description/)

你和你的朋友，两个人一起玩 [Nim 游戏](https://baike.baidu.com/item/Nim游戏/6737105)：

* 桌子上有一堆石头。
* 你们轮流进行自己的回合， **你作为先手**。
* 每一回合，轮到的人拿掉 1 - 3 块石头。
* 拿掉最后一块石头的人就是获胜者。

假设你们每一步都是最优解。请编写一个函数，来判断你是否可以在给定石头数量为 `n` 的情况下赢得游戏。如果可以赢，返回 `true`；否则，返回 `false` 。

**示例 1：**

```
输入：n = 4
输出：false 
解释：以下是可能的结果:
1. 移除1颗石头。你的朋友移走了3块石头，包括最后一块。你的朋友赢了。
2. 移除2个石子。你的朋友移走2块石头，包括最后一块。你的朋友赢了。
3.你移走3颗石子。你的朋友移走了最后一块石头。你的朋友赢了。
在所有结果中，你的朋友是赢家。
```

**示例 2：**

```
输入：n = 1
输出：true
```

**示例 3：**

```
输入：n = 2
输出：true
```

**提示：**

* `1 <= n <= 231 - 1`

##### 数学 巴什博弈 ： 4必输 567必赢 8必输

```js
/**
 * @param {number} n
 * @return {boolean}
 */
var canWinNim = function (n) {
    return n % 4 != 0;
};
// 1 2 3
// 4 false
// 5 true
// 6 true
// 7 true
// 8 false
// 9 true

```

