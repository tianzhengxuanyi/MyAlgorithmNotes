### 随机数

#### 洗牌算法

#### 蓄水池抽样算法

第i个接收到的数据最后能够留在蓄水池中的概率=第i个数据进入过蓄水池的概率*之后第i个数据不被替换的概率（第i+1到第N次处理数据都不会被替换）。

1. 当i<=m时，数据直接放进蓄水池，所以第i个数据进入过蓄水池的概率=1。
3. 当i>m时，在[1,i]内选取随机数d，如果d<=m，则使用第i个数据替换蓄水池中第d个数据，因此第i个数据进入过蓄水池的概率=m/i。
3. 当i<=m时，程序从接收到第m+1个数据时开始执行替换操作，第m+1次处理会替换池中数据的为m/(m+1)，会替换掉第i个数据的概率为1/m，则第m+1次处理替换掉第i个数据的概率为(m/(m+1))*(1/m)=1/(m+1)，不被替换的概率为1-1/(m+1)=m/(m+1)。依次，第m+2次处理不替换掉第i个数据概率为(m+1)/(m+2)...第N次处理不替换掉第i个数据的概率为(N-1)/N。所以，之后第i个数据不被替换的概率=m/(m+1)*(m+1)/(m+2)*...*(N-1)/N=m/N。
4. 当i>m时，程序从接收到第i+1个数据时开始有可能替换第i个数据。则参考上述第3点，之后第i个数据不被替换的概率=i/N。
5. 结合第1点和第3点可知，当i<=m时，第i个接收到的数据最后留在蓄水池中的概率=1*m/N=m/N。结合第2点和第4点可知，当i>m时，第i个接收到的数据留在蓄水池中的概率=m/i*i/N=m/N。综上可知，每个数据最后被选中留在蓄水池中的概率为m/N。

#### [528. 按权重随机选择](https://leetcode.cn/problems/random-pick-with-weight/description/)

给你一个 **下标从 0 开始** 的正整数数组 `w` ，其中 `w[i]` 代表第 `i` 个下标的权重。

请你实现一个函数 `pickIndex` ，它可以 **随机地** 从范围 `[0, w.length - 1]` 内（含 `0` 和 `w.length - 1`）选出并返回一个下标。选取下标 `i` 的 **概率** 为 `w[i] / sum(w)` 。



* 例如，对于 `w = [1, 3]`，挑选下标 `0` 的概率为 `1 / (1 + 3) = 0.25` （即，25%），而选取下标 `1` 的概率为 `3 / (1 + 3) = 0.75`（即，`75%`）。

**示例 1：**

```
输入：
["Solution","pickIndex"]
[[[1]],[]]
输出：
[null,0]
解释：
Solution solution = new Solution([1]);
solution.pickIndex(); // 返回 0，因为数组中只有一个元素，所以唯一的选择是返回下标 0。
```

**示例 2：**

```
输入：
["Solution","pickIndex","pickIndex","pickIndex","pickIndex","pickIndex"]
[[[1,3]],[],[],[],[],[]]
输出：
[null,1,1,1,1,0]
解释：
Solution solution = new Solution([1, 3]);
solution.pickIndex(); // 返回 1，返回下标 1，返回该下标概率为 3/4 。
solution.pickIndex(); // 返回 1
solution.pickIndex(); // 返回 1
solution.pickIndex(); // 返回 1
solution.pickIndex(); // 返回 0，返回下标 0，返回该下标概率为 1/4 。

由于这是一个随机问题，允许多个答案，因此下列输出都可以被认为是正确的:
[null,1,1,1,1,0]
[null,1,1,1,1,1]
[null,1,1,1,0,0]
[null,1,1,1,0,1]
[null,1,0,1,0,0]
......
诸若此类。
```

**提示：**

* `1 <= w.length <= 104`
* `1 <= w[i] <= 105`
* `pickIndex` 将被调用不超过 `104` 次

##### 前缀和 + 二分

```js
/**
 * @param {number[]} w
 */
var Solution = function (w) {
    const n = w.length;
    let sum = w[0];
    for (let i = 1; i < n; i++) {
        sum += w[i];
        w[i] += w[i - 1];
    }
    this.w = w, this.sum = sum;
};

/**
 * @return {number}
 */
Solution.prototype.pickIndex = function () {
    let rand = Math.floor(Math.random() * this.sum) + 1;
    // 二分大于等于rand的下标
    let l = 0, r = this.w.length - 1;
    while (l <= r) {
        let m = Math.floor((r - l) / 2) + l;
        if (this.w[m] < rand) {
            l = m + 1;
        } else {
            r = m - 1;
        }
    }
    
    return l;
};

/** 
 * Your Solution object will be instantiated and called as such:
 * var obj = new Solution(w)
 * var param_1 = obj.pickIndex()
 */
```

#### [470. 用 Rand7() 实现 Rand10()](https://leetcode.cn/problems/implement-rand10-using-rand7/description/)

给定方法 `rand7` 可生成 `[1,7]` 范围内的均匀随机整数，试写一个方法 `rand10` 生成 `[1,10]` 范围内的均匀随机整数。

你只能调用 `rand7()` 且不能调用其他方法。请不要使用系统的 `Math.random()` 方法。



每个测试用例将有一个内部参数 `n`，即你实现的函数 `rand10()` 在测试时将被调用的次数。请注意，这不是传递给 `rand10()` 的参数。

**示例 1:**

```
输入: 1
输出: [2]
```

**示例 2:**

```
输入: 2
输出: [2,8]
```

**示例 3:**

```
输入: 3
输出: [3,8,10]
```

**提示:**

* `1 <= n <= 105`

**进阶:**

* `rand7()`调用次数的 [期望值](https://en.wikipedia.org/wiki/Expected_value) 是多少 ?
* 你能否尽量少调用 `rand7()` ?

##### 拒绝采样，生成二位七进制

```js
/**
 * The rand7() API is already defined for you.
 * var rand7 = function() {}
 * @return {number} a random integer in the range 1 to 7
 */
var rand10 = function () {
    while (true) {
        // 两位的七进制，等概率 1 / 48
        let r = (rand7() - 1) * 7 + (rand7() - 1);
        if (r < 40) return r % 10 + 1;
    }
};
```

##### 将rand7变成等概率返回 0 1的f函数，用f生成四位二进制，返回小于10的数

```js
/**
 * The rand7() API is already defined for you.
 * var rand7 = function() {}
 * @return {number} a random integer in the range 1 to 7
 */
var rand10 = function() {
    const f = () => {
        let r;
        do {
            r = rand7();
        } while (r == 4);

        return r < 4 ? 0 : 1;
    }

    const g = () => {
        let r;
        do {
            r = (f() << 3) | (f() << 2) | (f() << 1) | f()
        } while (r >= 10);

        return r + 1;
    }

    return g();
};
// 10 => 1010
```

#### [384. 打乱数组](https://leetcode.cn/problems/shuffle-an-array/description/)

给你一个整数数组 `nums` ，设计算法来打乱一个没有重复元素的数组。打乱后，数组的所有排列应该是 **等可能** 的。

实现 `Solution` class:

* `Solution(int[] nums)` 使用整数数组 `nums` 初始化对象
* `int[] reset()` 重设数组到它的初始状态并返回
* `int[] shuffle()` 返回数组随机打乱后的结果

**示例 1：**

```
输入
["Solution", "shuffle", "reset", "shuffle"]
[[[1, 2, 3]], [], [], []]
输出
[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]

解释
Solution solution = new Solution([1, 2, 3]);
solution.shuffle();    // 打乱数组 [1,2,3] 并返回结果。任何 [1,2,3]的排列返回的概率应该相同。例如，返回 [3, 1, 2]
solution.reset();      // 重设数组到它的初始状态 [1, 2, 3] 。返回 [1, 2, 3]
solution.shuffle();    // 随机返回数组 [1, 2, 3] 打乱后的结果。例如，返回 [1, 3, 2]
```

**提示：**

* `1 <= nums.length <= 50`
* `-106 <= nums[i] <= 106`
* `nums` 中的所有元素都是 **唯一的**
* 最多可以调用 `104` 次 `reset` 和 `shuffle`

##### 洗牌算法，原地乱序

```js
/**
 * @param {number[]} nums
 */
var Solution = function(nums) {
    this.nums = nums;
};

/**
 * @return {number[]}
 */
Solution.prototype.reset = function() {
    return this.nums;
};

/**
 * @return {number[]}
 */
Solution.prototype.shuffle = function() {
    const shuffle = this.nums.slice();
    // 随机的数与剩余的数最后一位交换
    for (let i = shuffle.length - 1; i >= 0; i--) {
        let rand = randRange(i + 1);
        [shuffle[i], shuffle[rand]] = [shuffle[rand], shuffle[i]];
    }

    return shuffle;
};

const randRange = (n) => {
    return Math.floor(Math.random() * n);
}

/** 
 * Your Solution object will be instantiated and called as such:
 * var obj = new Solution(nums)
 * var param_1 = obj.reset()
 * var param_2 = obj.shuffle()
 */
```

##### 从[0, n-1]中随机抽取i，排除i，继续在剩下的下标中随机抽取，直到下标数组为空

```js
/**
 * @param {number[]} nums
 */
var Solution = function(nums) {
    this.nums = nums;
};

/**
 * @return {number[]}
 */
Solution.prototype.reset = function() {
    return this.nums;
};

/**
 * @return {number[]}
 */
Solution.prototype.shuffle = function() {
    const n = this.nums.length;
    let indices = Array.from({length: n}, (_, i) => i);
    const shuffleIndex = [];
    while (indices.length) {
        let i = randRange(indices.length);
        shuffleIndex.push(indices[i]);
        indices.splice(i, 1);
    }
    return shuffleIndex.map((i) => this.nums[i]);
};

const randRange = (n) => {
    return Math.floor(Math.random() * n);
}

/** 
 * Your Solution object will be instantiated and called as such:
 * var obj = new Solution(nums)
 * var param_1 = obj.reset()
 * var param_2 = obj.shuffle()
 */
```

#### [382. 链表随机节点](https://leetcode.cn/problems/linked-list-random-node/description/)

给你一个单链表，随机选择链表的一个节点，并返回相应的节点值。每个节点 **被选中的概率一样** 。

实现 `Solution` 类：

* `Solution(ListNode head)` 使用整数数组初始化对象。
* `int getRandom()` 从链表中随机选择一个节点并返回该节点的值。链表中所有节点被选中的概率相等。

**示例：**

![](https://assets.leetcode.com/uploads/2021/03/16/getrand-linked-list.jpg)

```
输入
["Solution", "getRandom", "getRandom", "getRandom", "getRandom", "getRandom"]
[[[1, 2, 3]], [], [], [], [], []]
输出
[null, 1, 3, 2, 2, 3]

解释
Solution solution = new Solution([1, 2, 3]);
solution.getRandom(); // 返回 1
solution.getRandom(); // 返回 3
solution.getRandom(); // 返回 2
solution.getRandom(); // 返回 2
solution.getRandom(); // 返回 3
// getRandom() 方法应随机返回 1、2、3中的一个，每个元素被返回的概率相等。
```

**提示：**

* 链表中的节点数在范围 `[1, 104]` 内
* `-104 <= Node.val <= 104`
* 至多调用 `getRandom` 方法 `104` 次

**进阶：**

* 如果链表非常大且长度未知，该怎么处理？
* 你能否在不使用额外空间的情况下解决此问题？

##### 蓄水池算法

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 */
var Solution = function (head) {
    this.head = head;
};

/**
 * @return {number}
 */
Solution.prototype.getRandom = function () {
    let ans = 0;
    // i从1开始，抽一个样本
    // 从[0, i - 1]随机，如果随机数为0，则替换蓄水池中样本
    for (let i = 1, node = this.head; node; i++, node = node.next) {
        if (Math.floor(Math.random() * i) == 0) {
            ans = node.val;
        }
    }
    return ans;
};

/** 
 * Your Solution object will be instantiated and called as such:
 * var obj = new Solution(head)
 * var param_1 = obj.getRandom()
 */
```

##### 预处理为数组，随机下标

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 */
var Solution = function(head) {
    this.nums = [];
    let node = head;
    while (node) {
        this.nums.push(node.val);
        node = node.next;
    }
    this.n = this.nums.length;
};

/**
 * @return {number}
 */
Solution.prototype.getRandom = function() {
    return this.nums[Math.floor(Math.random() * this.n)]
};

/** 
 * Your Solution object will be instantiated and called as such:
 * var obj = new Solution(head)
 * var param_1 = obj.getRandom()
 */
```

#### [398. 随机数索引](https://leetcode.cn/problems/random-pick-index/description/)

给你一个可能含有 **重复元素** 的整数数组 `nums` ，请你随机输出给定的目标数字 `target` 的索引。你可以假设给定的数字一定存在于数组中。

实现 `Solution` 类：

* `Solution(int[] nums)` 用数组 `nums` 初始化对象。
* `int pick(int target)` 从 `nums` 中选出一个满足 `nums[i] == target` 的随机索引 `i` 。如果存在多个有效的索引，则每个索引的返回概率应当相等。

**示例：**

```
输入
["Solution", "pick", "pick", "pick"]
[[[1, 2, 3, 3, 3]], [3], [1], [3]]
输出
[null, 4, 0, 2]

解释
Solution solution = new Solution([1, 2, 3, 3, 3]);
solution.pick(3); // 随机返回索引 2, 3 或者 4 之一。每个索引的返回概率应该相等。
solution.pick(1); // 返回 0 。因为只有 nums[0] 等于 1 。
solution.pick(3); // 随机返回索引 2, 3 或者 4 之一。每个索引的返回概率应该相等。
```

**提示：**

* `1 <= nums.length <= 2 * 104`
* `-231 <= nums[i] <= 231 - 1`
* `target` 是 `nums` 中的一个整数
* 最多调用 `pick` 函数 `104` 次

##### 哈希表

```js
/**
 * @param {number[]} nums
 */
var Solution = function(nums) {
    this.idx = new Map();
    for (let i = 0; i < nums.length; i++) {
        const arr = this.idx.get(nums[i]) ?? [];
        arr.push(i);
        this.idx.set(nums[i], arr);
    }
};

/** 
 * @param {number} target
 * @return {number}
 */
Solution.prototype.pick = function(target) {
    const arr = this.idx.get(target);
    return arr[rand(arr.length)];
};

// 0 - n-1随机输出
const rand = (n) => {
    return Math.floor(Math.random() * n);
}

/** 
 * Your Solution object will be instantiated and called as such:
 * var obj = new Solution(nums)
 * var param_1 = obj.pick(target)
 */
```

#### [478. 在圆内随机生成点](https://leetcode.cn/problems/generate-random-point-in-a-circle/description/)

给定圆的半径和圆心的位置，实现函数 `randPoint` ，在圆中产生均匀随机点。

实现 `Solution` 类:

* `Solution(double radius, double x_center, double y_center)` 用圆的半径 `radius` 和圆心的位置 `(x_center, y_center)` 初始化对象
* `randPoint()` 返回圆内的一个随机点。圆周上的一点被认为在圆内。答案作为数组返回 `[x, y]` 。

**示例 1：**

```
输入: 
["Solution","randPoint","randPoint","randPoint"]
[[1.0, 0.0, 0.0], [], [], []]
输出: [null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]
解释:
Solution solution = new Solution(1.0, 0.0, 0.0);
solution.randPoint ();//返回[-0.02493，-0.38077]
solution.randPoint ();//返回[0.82314,0.38945]
solution.randPoint ();//返回[0.36572,0.17248]
```

**提示：**

* `0 < radius <= 108`
* `-107 <= x_center, y_center <= 107`
* `randPoint` 最多被调用 `3 * 104` 次

##### 拒绝抽样

```js
/**
 * @param {number} radius
 * @param {number} x_center
 * @param {number} y_center
 */
var Solution = function (radius, x_center, y_center) {
    this.r = radius, this.x = x_center, this.y = y_center;
};

/**
 * @return {number[]}
 */
Solution.prototype.randPoint = function () {
    while (true) {
        const x = Math.random() * (2 * this.r) - this.r;
        const y = Math.random() * (2 * this.r) - this.r;
        if (x * x + y * y <= this.r * this.r) {
            return [this.x + x, this.y + y];
        }
    }
};

/** 
 * Your Solution object will be instantiated and called as such:
 * var obj = new Solution(radius, x_center, y_center)
 * var param_1 = obj.randPoint()
 */
```

#### [710. 黑名单中的随机数](https://leetcode.cn/problems/random-pick-with-blacklist/description/)

给定一个整数 `n` 和一个 **无重复** 黑名单整数数组 `blacklist` 。设计一种算法，从 `[0, n - 1]` 范围内的任意整数中选取一个 **未加入**黑名单 `blacklist` 的整数。任何在上述范围内且不在黑名单 `blacklist` 中的整数都应该有 **同等的可能性** 被返回。

优化你的算法，使它最小化调用语言 **内置** 随机函数的次数。

实现 `Solution` 类:

* `Solution(int n, int[] blacklist)` 初始化整数 `n` 和被加入黑名单 `blacklist` 的整数
* `int pick()` 返回一个范围为 `[0, n - 1]` 且不在黑名单 `blacklist` 中的随机整数

**示例 1：**

```
输入
["Solution", "pick", "pick", "pick", "pick", "pick", "pick", "pick"]
[[7, [2, 3, 5]], [], [], [], [], [], [], []]
输出
[null, 0, 4, 1, 6, 1, 0, 4]

解释
Solution solution = new Solution(7, [2, 3, 5]);
solution.pick(); // 返回0，任何[0,1,4,6]的整数都可以。注意，对于每一个pick的调用，
                 // 0、1、4和6的返回概率必须相等(即概率为1/4)。
solution.pick(); // 返回 4
solution.pick(); // 返回 1
solution.pick(); // 返回 6
solution.pick(); // 返回 1
solution.pick(); // 返回 0
solution.pick(); // 返回 4
```

**提示:**

* `1 <= n <= 109`
* `0 <= blacklist.length <= min(105, n - 1)`
* `0 <= blacklist[i] < n`
* `blacklist` 中所有值都 **不同**
* `pick` 最多被调用 `2 * 104` 次

##### 设[n-m, n)为黑名单区域，将[0, n-m)中的黑名单和[n-m, n)中的白名单做映射，在[0, n-m)中随机，如果存在b2w存在映射则返回映射

```js
/**
 * @param {number} n
 * @param {number[]} blacklist
 */
var Solution = function(n, blacklist) {
    const m = blacklist.length;
    const b2w = new Map();
    const wLen = n - m;
    const black = new Set();
    for (const b of blacklist) {
        if (b >= wLen) {
            black.add(b);
        }
    }
    let w = wLen;
    for (let b of blacklist) {
        if (b < wLen) {
            while (black.has(w)) {
                w++;
            }
            b2w.set(b, w++);
        }
    }
    this.b2w = b2w;
    this.wLen = wLen;
};

/**
 * @return {number}
 */
Solution.prototype.pick = function() {
    const rand = Math.floor((Math.random() * this.wLen));
    return this.b2w.get(rand) || rand;
};

/** 
 * Your Solution object will be instantiated and called as such:
 * var obj = new Solution(n, blacklist)
 * var param_1 = obj.pick()
 */
```

#### [519. 随机翻转矩阵](https://leetcode.cn/problems/random-flip-matrix/description/)

给你一个 `m x n` 的二元矩阵 `matrix` ，且所有值被初始化为 `0` 。请你设计一个算法，随机选取一个满足 `matrix[i][j] == 0` 的下标 `(i, j)` ，并将它的值变为 `1` 。所有满足 `matrix[i][j] == 0` 的下标 `(i, j)` 被选取的概率应当均等。

尽量最少调用内置的随机函数，并且优化时间和空间复杂度。

实现 `Solution` 类：

* `Solution(int m, int n)` 使用二元矩阵的大小 `m` 和 `n` 初始化该对象
* `int[] flip()` 返回一个满足 `matrix[i][j] == 0` 的随机下标 `[i, j]` ，并将其对应格子中的值变为 `1`
* `void reset()` 将矩阵中所有的值重置为 `0`

**示例：**

```
输入
["Solution", "flip", "flip", "flip", "reset", "flip"]
[[3, 1], [], [], [], [], []]
输出
[null, [1, 0], [2, 0], [0, 0], null, [2, 0]]

解释
Solution solution = new Solution(3, 1);
solution.flip();  // 返回 [1, 0]，此时返回 [0,0]、[1,0] 和 [2,0] 的概率应当相同
solution.flip();  // 返回 [2, 0]，因为 [1,0] 已经返回过了，此时返回 [2,0] 和 [0,0] 的概率应当相同
solution.flip();  // 返回 [0, 0]，根据前面已经返回过的下标，此时只能返回 [0,0]
solution.reset(); // 所有值都重置为 0 ，并可以再次选择下标返回
solution.flip();  // 返回 [2, 0]，此时返回 [0,0]、[1,0] 和 [2,0] 的概率应当相同
```

**提示：**

* `1 <= m, n <= 104`
* 每次调用`flip` 时，矩阵中至少存在一个值为 0 的格子。
* 最多调用 `1000` 次 `flip` 和 `reset` 方法。

##### 随机一个数，然后左右找未加入set的数返回

```js
/**
 * @param {number} m
 * @param {number} n
 */
var Solution = function (m, n) {
    this.fliped = new Set();
    this.cnt = m * n;
    this.m = m, this.n = n;
};

/**
 * @return {number[]}
 */
Solution.prototype.flip = function () {
    let a = Math.floor(Math.random() * this.cnt), b = a;
    while (a >= 0 && this.fliped.has(a)) a--;
    while (a < 0 && b < this.cnt && this.fliped.has(b)) b++;
    let c = a < 0 ? b : a;
    this.fliped.add(c);
    return [Math.floor(c / this.n), c % this.n];
};

/**
 * @return {void}
 */
Solution.prototype.reset = function () {
    this.fliped.clear();
};

/** 
 * Your Solution object will be instantiated and called as such:
 * var obj = new Solution(m, n)
 * var param_1 = obj.flip()
 * obj.reset()
 */
```

##### 拒绝采样

```js
/**
 * @param {number} m
 * @param {number} n
 */
var Solution = function (m, n) {
    this.fliped = new Set();
    this.cnt = m * n;
    this.m = m, this.n = n;
};

/**
 * @return {number[]}
 */
Solution.prototype.flip = function () {
    while (true) {
        const rand = Math.floor(Math.random() * this.cnt);
        if (!this.fliped.has(rand)) {
            this.fliped.add(rand);
            return [Math.floor(rand / this.n), rand % this.n];
        }
    }
};

/**
 * @return {void}
 */
Solution.prototype.reset = function () {
    this.fliped.clear();
};

/** 
 * Your Solution object will be instantiated and called as such:
 * var obj = new Solution(m, n)
 * var param_1 = obj.flip()
 * obj.reset()
 */
```

#### [497. 非重叠矩形中的随机点](https://leetcode.cn/problems/random-point-in-non-overlapping-rectangles/description/)

给定一个由非重叠的轴对齐矩形的数组 `rects` ，其中 `rects[i] = [ai, bi, xi, yi]` 表示 `(ai, bi)` 是第 `i` 个矩形的左下角点，`(xi, yi)` 是第 `i` 个矩形的右上角点。设计一个算法来随机挑选一个被某一矩形覆盖的整数点。矩形周长上的点也算做是被矩形覆盖。所有满足要求的点必须等概率被返回。

在给定的矩形覆盖的空间内的任何整数点都有可能被返回。

**请注意**，整数点是具有整数坐标的点。

实现 `Solution` 类:

* `Solution(int[][] rects)` 用给定的矩形数组 `rects` 初始化对象。
* `int[] pick()` 返回一个随机的整数点 `[u, v]` 在给定的矩形所覆盖的空间内。



**示例 1：**

![](https://assets.leetcode.com/uploads/2021/07/24/lc-pickrandomrec.jpg)

```
输入: 
["Solution", "pick", "pick", "pick", "pick", "pick"]
[[[[-2, -2, 1, 1], [2, 2, 4, 6]]], [], [], [], [], []]
输出: 
[null, [1, -2], [1, -1], [-1, -2], [-2, -2], [0, 0]]

解释：
Solution solution = new Solution([[-2, -2, 1, 1], [2, 2, 4, 6]]);
solution.pick(); // 返回 [1, -2]
solution.pick(); // 返回 [1, -1]
solution.pick(); // 返回 [-1, -2]
solution.pick(); // 返回 [-2, -2]
solution.pick(); // 返回 [0, 0]
```

**提示：**

* `1 <= rects.length <= 100`
* `rects[i].length == 4`
* `-109 <= ai < xi <= 109`
* `-109 <= bi < yi <= 109`
* `xi - ai <= 2000`
* `yi - bi <= 2000`
* 所有的矩形不重叠。
* `pick` 最多被调用 `104` 次。

##### 根据矩阵中的点的数量确定权重，前缀和；先随机矩阵，在随机矩阵中的点

```js
/**
 * @param {number[][]} rects
 */
var Solution = function(rects) {
    const n = rects.length;
    this.rects = rects;
    this.areas = Array(n).fill(0);
    for (let i = 0; i < n; i++) {
        const [a, b, x, y] = rects[i];
        // 根据矩阵内的点数而不是面积
        this.areas[i] = (this.areas[i - 1] ?? 0) + (x - a + 1) * (y - b + 1);
    }
};

/**
 * @return {number[]}
 */
Solution.prototype.pick = function() {
    const n = this.rects.length;
    const areaBound = this.areas[n - 1];
    const randArea = Math.floor(Math.random() * areaBound) + 1;
    let l = 0, r = n - 1;
    while (l <= r) {
        let m = Math.floor((r - l) / 2) + l;
        if (this.areas[m] < randArea) {
            l = m + 1;
        } else {
            r = m - 1;
        }
    }
    const [a, b, x, y] = this.rects[l];
    const w = x - a, h = y - b;
    const randX = Math.floor(Math.random() * (w + 1));
    const randY = Math.floor(Math.random() * (h + 1));
    return [a + randX, b + randY];
};


/** 
 * Your Solution object will be instantiated and called as such:
 * var obj = new Solution(rects)
 * var param_1 = obj.pick()
 */
```

