## 单调栈

> ————单调栈十六字真言：及时去掉无用数据，保证栈中元素有序。————

### 下一个更大元素

**方法一：从右到左**

从右往左倒着遍历，栈中记录下一个更大元素的「候选项」。

由于左边更大元素会「挡住」右边更小的元素，所以右边更小的元素是无用信息（不会成为左边元素的下一个更大元素），这会导致栈底（右边）大，栈顶（左边）小。

- 从右往左倒着遍历
- 将当前遍历元素与栈顶对应的元素比较
  - 如果当前元素**大于等于**栈顶对应的元素，则弹出栈顶，继续这个操作，直到栈空或不满足条件
- 得出当前遍历元素的「下一个更大元素」：
  - 栈不为空，则栈顶对应的元素为「下一个更大元素」
  - 栈为空，当前元素无「下一个更大元素」
- 将当前元素的下标入栈

```js
const st = [],
  n = nums.length,
  res = Array(n).fill(-1);
for (let i = n - 1; i >= 0; i--) {
  while (st.length && nums[i] >= nums[st[st.length - 1]]) {
    st.pop();
  }
  if (st.length) {
    res[i] = nums[st[st.length - 1]];
  }
  st.push(i);
}
```

**方法二：从左到右**

栈中记录还没算出「下一个更大元素」的那些数。

只要遍历到比栈顶元素更大的数，就意味着栈顶元素找到了答案，记录答案，并弹出栈顶。

- 从左到右遍历
- 将当前遍历元素与栈顶对应的元素比较
  - 如果当前元素**大于**栈顶对应的元素，则弹出栈顶
  - 弹出的栈顶元素的「下一个更大元素」为当前遍历元素
  - 继续这个操作，直到栈空或不满足条件
- 将当前元素的下标入栈

```js
const st = [],
  n = nums.length,
  res = Array(n).fill(-1);
for (let i = 0; i < n; i++) {
  while (st.length && nums[i] > nums[st[st.length - 1]]) {
    let top = st.pop();
    res[top] = nums[i];
  }
  st.push(i);
}
```

- [739. 每日温度](https://leetcode.cn/problems/daily-temperatures/description/)
- [1475. 商品折扣后的最终价格](https://leetcode.cn/problems/final-prices-with-a-special-discount-in-a-shop/description/)
- [496. 下一个更大元素 I](https://leetcode.cn/problems/next-greater-element-i/)
- [503. 下一个更大元素 II](https://leetcode.cn/problems/next-greater-element-ii/description/)
- [1019. 链表中的下一个更大节点 1571](https://leetcode.cn/problems/next-greater-node-in-linked-list/)

### 距离最远的更大元素

1. 正序遍历数组 A，将以 A[0] 开始的递减序列的元素下标依次存入栈中。
2. 逆序遍历数组 A，若以栈顶元素为下标的元素值 A[stack.peek()] 小于等于当前遍历的元素 A[i]，即 A[stack.peek()] <= A[i]。此时就是一个满足条件的坡的宽度，并且这个宽度一定是栈顶这个坡底 i 能形成的最大宽度，将栈顶元素出栈并计算当前坡的宽度，保留最大值即可。

#### [962. 最大宽度坡](https://leetcode.cn/problems/maximum-width-ramp/description/)

给定一个整数数组 A，坡是元组 (i, j)，其中 i < j 且 A[i] <= A[j]。这样的坡的宽度为 j - i。

找出 A 中的坡的最大宽度，如果不存在，返回 0 。

**解法一、 单调栈**

```js
var maxWidthRamp = function (nums) {
  let n = nums.length;
  let st = [0];
  for (let i = 1; i < n; i++) {
    if (nums[i] < nums[st[st.length - 1]]) st.push(i);
  }
  let ans = 0;
  for (let i = n - 1; i >= 0; i--) {
    while (st.length && nums[st[st.length - 1]] <= nums[i]) {
      ans = Math.max(ans, i - st.pop());
    }
  }
  return ans;
};
```

**解法二、 排序**

1. 将数组下标按对应值升序排序
2. 遍历 indexs
   1. 维护已遍历 index 的最小值
   2. 当前遍历 index 与左侧最小值的差值为满足条件的距离，维护其最大值

```js
var maxWidthRamp = function (nums) {
  let n = nums.length;
  let indexs = nums.map((_, i) => i);
  indexs.sort((a, b) => nums[a] - nums[b]);
  let ans = 0,
    m = n;
  for (let i of indexs) {
    ans = Math.max(ans, i - m);
    m = Math.min(i, m);
  }

  return ans;
};
```

### 矩形

> 1. 枚举以 nums[i]为高度的矩形，左边界和右边界通过单调栈求出
>
> 2. 如果求二维数组的矩形，枚举每一行 row 作为基座的情况，高度为之前行的累加，转化为问题 1

#### [84. 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/description/)

给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。

```js
/**
 * @param {number[]} heights
 * @return {number}
 */
var largestRectangleArea = function (heights) {
  const n = heights.length,
    leftMin = Array(n).fill(-1),
    st = [];
  let ans = 0;
  for (let i = 0; i < n; i++) {
    // 维护一个单调递增的栈
    // 此处`<=`根据题意不同可换成`<`
    while (st.length && heights[i] <= heights[st[st.length - 1]]) {
      // 栈顶元素的右侧下一个更小元素
      const curr = st.pop(),
        left = leftMin[curr],
        right = i;
      ans = Math.max(ans, heights[curr] * (right - left - 1));
    }
    // 如果栈不为空，则栈顶元素为当前元素的左侧下一个更小元素
    // 如果栈为空，则当前元素左侧无更小元素，取leftMin的默认值-1
    if (st.length) {
      leftMin[i] = st[st.length - 1];
    }
    st.push(i);
  }
  // 如果此时栈不为空，则栈中的元素右侧无更小元素，右边界取n
  while (st.length) {
    const curr = st.pop(),
      left = leftMin[curr],
      right = n;
    ans = Math.max(ans, heights[curr] * (right - left - 1));
  }
  return ans;
};
```

#### [1793. 好子数组的最大分数](https://leetcode.cn/problems/maximum-score-of-a-good-subarray/description/)

给你一个整数数组 nums （下标从 0 开始）和一个整数 k 。

一个子数组 (i, j) 的 分数 定义为 min(nums[i], nums[i+1], ..., nums[j]) \* (j - i + 1) 。一个 好 子数组的两个端点下标需要满足 i <= k <= j 。

请你返回 好 子数组的最大可能 分数 。

> 单调栈：枚举以 nums[i]为最小值时的分数

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var maximumScore = function (nums, k) {
  const n = nums.length,
    left = Array(n).fill(-1),
    st = [];
  let ans = 0;
  for (let i = 0; i < n; i++) {
    while (st.length && nums[i] < nums[st[st.length - 1]]) {
      // 计算分数时判断k是否在左右边界中
      ans = Math.max(ans, calc(nums, k, st, left, i));
    }
    if (st.length) {
      left[i] = st[st.length - 1];
    }
    st.push(i);
  }
  while (st.length) {
    ans = Math.max(ans, calc(nums, k, st, left, n));
  }
  return ans;
};

function calc(nums, k, st, left, right) {
  let mn = st.pop(),
    l = left[mn];

  if (l < k && right > k) {
    return nums[mn] * (right - l - 1);
  }
  return 0;
}
```

> 双指针：尝试从 i=k, j=k 出发，通过不断移动指针来找到最大矩形。比较 nums[i−1]和 nums[j+1]的大小，谁大就移动谁（一样大移动哪个都可以）

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var maximumScore = function (nums, k) {
  const n = nums.length;
  let left = k,
    right = k,
    min = nums[k],
    ans = nums[k];
  for (let i = 0; i < n - 1; i++) {
    if (right >= n - 1 || (left > 0 && nums[left - 1] >= nums[right + 1])) {
      min = Math.min(min, nums[--left]);
    } else {
      min = Math.min(min, nums[++right]);
    }
    ans = Math.max(ans, (right - left + 1) * min);
  }
  return ans;
};
```

#### [85. 最大矩形](https://leetcode.cn/problems/maximal-rectangle/description/)

给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。

```js
/**
 * @param {character[][]} matrix
 * @return {number}
 */
var maximalRectangle = function (matrix) {
  const m = matrix.length,
    n = matrix[0].length,
    nums = Array(n).fill(0);
  let ans = 0;
  for (let i = 0; i < m; i++) {
    for (let j = 0; j < n; j++) {
      // 累计高度
      if (matrix[i][j] == 1) {
        nums[j] += matrix[i][j] - 0;
      } else {
        nums[j] = 0;
      }
    }
    // 计算以当前行为底座的答案
    // 转化为84. 柱状图中最大的矩形
    ans = Math.max(ans, maxRect(nums));
  }
  return ans;
};

function maxRect(nums) {
  const n = nums.length,
    st = [],
    leftMin = Array(n).fill(-1);
  let ans = 0;
  for (let i = 0; i < n; i++) {
    while (st.length && nums[i] < nums[st[st.length - 1]]) {
      let idx = st.pop(),
        left = leftMin[idx],
        right = i;
      ans = Math.max(ans, nums[idx] * (right - left - 1));
    }
    if (st.length) {
      leftMin[i] = st[st.length - 1];
    }
    st.push(i);
  }
  while (st.length) {
    let idx = st.pop(),
      left = leftMin[idx],
      right = n;
    ans = Math.max(ans, nums[idx] * (right - left - 1));
  }
  return ans;
}
```

#### 1504. 统计全 1 子矩形
 
给你一个 m x n 的二进制矩阵 mat ，请你返回有多少个 子矩形 的元素全部都是 1 。

##### 单调栈

```js
/**
 * 计算二进制矩阵中所有全1子矩阵的数量
 * @param {number[][]} mat - 二进制矩阵，元素为0或1
 * @return {number} 矩阵中全1子矩阵的总数
 * @note 该算法使用单调栈优化，时间复杂度为O(m*n)，其中m为矩阵行数，n为矩阵列数
 * @algorithm 核心思路是将矩阵按行转化为柱状图，然后对每一行柱状图使用单调栈计算矩形数量
 */
var numSubmat = function(mat) {
    const m = mat.length, n = mat[0].length;
    // 高度数组，记录每一列连续1的高度，模拟柱状图
    const height = Array(n).fill(0);
    let ans = 0;
    
    // 遍历矩阵的每一行
    for (let i = 0; i < m; i++) {
        // 更新高度数组：当前行为1则高度+1，否则重置为0
        for (let j = 0; j < n; j++) {
            if (mat[i][j]) {
                height[j] += 1;
            } else {
                height[j] = 0;
            }
        }
        
        // 使用单调栈计算当前行柱状图中的矩形数量
        // 栈元素格式：[索引, 累计矩形数, 高度]
        const st = [[-1, 0, -1]];  // 初始栈，设置左边界
        for (let j = 0; j < n; j++) {
            // 保持栈的单调性：弹出高度大于等于当前高度的元素
            while (st[st.length - 1][2] >= height[j]) {
                st.pop();
            }
            
            // 获取栈顶元素（左边界）
            let [left, f, _] = st[st.length - 1];
            // 计算新增的矩形数量：(当前索引-左边界索引) * 当前高度 + 左边界累计值
            f += (j - left) * height[j];
            // 将新增数量累加到答案中
            ans += f;
            // 将当前元素入栈
            st.push([j, f, height[j]]);
        }
    }

    return ans;
};

```

##### 枚举top和bottom + 压缩矩阵 + 全为0的子数组数量

```js
/**
 * 计算二进制矩阵中所有全1子矩阵的数量（双层边界优化版）
 * @param {number[][]} mat - 二进制矩阵，元素为0或1
 * @return {number} 矩阵中全1子矩阵的总数
 * @note 该算法通过枚举上下边界并统计连续1的列来计算子矩阵数量
 * @algorithm 核心思路：
 *   1. 枚举所有可能的上边界(top)和下边界(bottom)
 *   2. 对每个边界组合，统计每列从top到bottom是否全为1
 *   3. 计算连续全1列可组成的子矩阵数量
 * @complexity 时间复杂度O(m²n)，空间复杂度O(n)，其中m为矩阵行数，n为矩阵列数
 */
var numSubmat = function (mat) {
    const m = mat.length, n = mat[0].length;
    let ans = 0;
    
    // 枚举矩阵的上边界
    for (let top = 0; top < m; top++) {
        // 记录每列从top开始的连续1的数量
        let cnts = Array(n).fill(0);
        
        // 枚举矩阵的下边界（从top开始向下延伸）
        for (let bottom = top; bottom < m; bottom++) {
            // 当前子矩阵的高度
            let h = bottom - top + 1;
            // 记录上一个出现非全1列的位置
            let last = -1;
            
            // 遍历每一列，更新计数
            for (let j = 0; j < n; j++) {
                // 累加当前列从top到bottom的1的数量
                cnts[j] += mat[bottom][j];
                
                // 如果当前列从top到bottom全为1（计数等于高度）
                if (h == cnts[j]) {
                    // 新增的子矩阵数量 = 当前列索引 - 上一个非全1列的索引
                    ans += j - last;
                } else {
                    // 更新上一个非全1列的位置
                    last = j;
                }
            }
        }
    }

    return ans;
};

```

### 贡献法

- 907. 子数组的最小值之和 1976
- 2104. 子数组范围和（最大值-最小值）
- 1856. 子数组最小乘积的最大值 2051
- 2818. 操作使得分最大 2397
- 2281. 巫师的总力量和（最小值 × 和） 2621

#### [907. 子数组的最小值之和](https://leetcode.cn/problems/sum-of-subarray-minimums/description/)

给定一个整数数组 arr，找到 min(b) 的总和，其中 b 的范围为 arr 的每个（连续）子数组。

由于答案可能很大，因此 返回答案模 10^9 + 7 。

[贡献法+单调栈+三种实现版本（附题单）](https://leetcode.cn/problems/sum-of-subarray-minimums/solutions/1930857/gong-xian-fa-dan-diao-zhan-san-chong-shi-gxa5/)

> 计算以 nums[i]为最小值时的子数组个数
>
> 为避免重复统计，可以修改边界的定义，把右边界改为「找小于或等于 arr[i]的数的下标」

```js
/**
 * @param {number[]} arr
 * @return {number}
 */
var sumSubarrayMins = function (arr) {
  const n = arr.length,
    mod = 1e9 + 7,
    st = [],
    leftMin = Array(n).fill(-1);
  let ans = 0;
  for (let i = 0; i < n; i++) {
    while (st.length && arr[i] <= arr[st[st.length - 1]]) {
      let curr = st.pop(),
        left = leftMin[curr],
        right = i;
      ans = (ans + arr[curr] * (curr - left) * (right - curr)) % mod;
    }
    if (st.length) {
      leftMin[i] = st[st.length - 1];
    }
    st.push(i);
  }
  while (st.length) {
    let curr = st.pop(),
      left = leftMin[curr],
      right = n;
    ans = (ans + arr[curr] * (curr - left) * (right - curr)) % mod;
  }

  return ans;
};
```

### 最小字典序

- 402.  移掉 K 位数字 ~1800
- 1673. 找出最具竞争力的子序列 1802
- 316.  去除重复字母 2185
- 316 扩展：重复个数不超过 limit
- 1081. 不同字符的最小子序列 同 316 题
- 321.  拼接最大数
- 2030. 含特定字母的最小子序列 2562

#### [402. 移掉 K 位数字](https://leetcode.cn/problems/remove-k-digits/description/)

给你一个以字符串表示的非负整数 num 和一个整数 k ，移除这个数中的 k 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。

> 维护字典序递增的单调栈,栈中元素弹出时 k--
>
> - 当 k 等于 0 时不再弹出栈中元素
> - 当 num 遍历结束后 k 大于 0,依次弹出栈顶元素至 k 为 0
>
> 额外处理前导 0 和空栈的情况

```js
/**
 * @param {string} num
 * @param {number} k
 * @return {string}
 */
var removeKdigits = function (num, k) {
  const n = num.length,
    st = [];
  for (let i = 0; i < num.length; i++) {
    while (k > 0 && st.length && num[i] < st[st.length - 1]) {
      st.pop();
      k--;
    }
    // 去除前导0
    if (st.length === 0 && num[i] == 0) continue;
    st.push(num[i]);
  }
  while (k > 0) {
    st.pop();
    k--;
  }
  // 处理栈为空
  return st.length > 0 ? st.join("") : "0";
};
```

#### [1673. 找出最具竞争力的子序列](https://leetcode.cn/problems/find-the-most-competitive-subsequence/description/)

给你一个整数数组 nums 和一个正整数 k ，返回长度为 k 且最具 竞争力 的 nums 子序列。

数组的子序列是从数组中删除一些元素（可能不删除元素）得到的序列。

在子序列 a 和子序列 b 第一个不相同的位置上，如果 a 中的数字小于 b 中对应的数字，那么我们称子序列 a 比子序列 b（相同长度下）更具 竞争力 。

例如，[1,3,4] 比 [1,3,5] 更具竞争力，在第一个不相同的位置，也就是最后一个位置上， 4 小于 5 。

> 维护字典序递增的单调栈, 如果栈中元素加上剩余未入栈元素的个数小于等于 k 时, 栈中元素就不能再弹出，否则最终得到的数组长度小于 k
>
> 最终数组长度如果大于 k，依次弹出栈顶元素

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
var mostCompetitive = function (nums, k) {
  const n = nums.length,
    st = [];
  for (let i = 0; i < n; i++) {
    while (
      st.length &&
      nums[i] < st[st.length - 1] &&
      st.length + (n - i) > k
    ) {
      st.pop();
    }
    st.push(nums[i]);
  }
  while (st.length > k) {
    st.pop();
  }
  return st;
};
```

#### [316. 去除重复字母](https://leetcode.cn/problems/remove-duplicate-letters/description/)

给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 返回结果的字典序最小（要求不能打乱其他字符的相对位置）。

> 1. 维护字典序递增的单调栈
> 2. 如果当前字母已经在栈中，跳过当前循环（set集合）
> 3. 当字母从栈中弹出时，判断后续未遍历字母中是否还存在弹出字母（词频map）
>   - 如果存在，则当前字母弹出
>   - 如果不存在，则当前字母不弹出，保证每个字母只出现一次

```js
/**
 * @param {string} s
 * @return {string}
 */
var removeDuplicateLetters = function (s) {
  const n = s.length,
    cnt = Array(26).fill(0),
    st = [],
    set = Array(26).fill(0);
  for (let i = 0; i < n; i++) {
    cnt[s[i].charCodeAt() - 97] += 1;
  }

  for (let i = 0; i < n; i++) {
    cnt[s[i].charCodeAt() - 97] -= 1;
    if (set[s[i].charCodeAt() - 97]) {
      continue;
    }
    while (
      st.length &&
      s[i] < st[st.length - 1] &&
      cnt[st[st.length - 1].charCodeAt() - 97] > 0
    ) {
      set[st.pop().charCodeAt() - 97] = 0;
    }
    st.push(s[i]);
    set[s[i].charCodeAt() - 97] = 1;
  }
  return st.join("");
};
```

#### [321. 拼接最大数](https://leetcode.cn/problems/create-maximum-number/description/)

给你两个整数数组 nums1 和 nums2，它们的长度分别为 m 和 n。数组 nums1 和 nums2 分别代表两个数各位上的数字。同时你也会得到一个整数 k。

请你利用这两个数组中的数字创建一个长度为 k <= m + n 的最大数。同一数组中数字的相对顺序必须保持不变。

返回代表答案的长度为 k 的数组。

> 1. 遍历num1和nums2中选取数字的可能情况
> 2. 子问题转化为从nums中选取i个数，使得字典序最大（1673. 找出最具竞争力的子序列）
> 3. 将nums1和nums2选取的数组merge
>   - num1和nums2字典序大的数组中shift首个元素加入mergeArr中

**NOTE: JavaScript中数组可直接通过nums1 > nums2比较字典序**

```js
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @param {number} k
 * @return {number[]}
 */
var maxNumber = function (nums1, nums2, k) {
    const m = nums1.length,
        n = nums2.length;
    let ans = Array(k).fill(-1);
    // 枚举从nums1和nums2中选取个数
    for (let i = 0; i <= k; i++) {
        let j = k - i;
        if (i > m || j > n) {
            continue;
        }
        let newAns = merge(pickK(nums1, i), pickK(nums2, j));
        ans = ans > newAns ? ans : newAns;
    }
    return ans;
};

function pickK(nums, k) {
    const n = nums.length,
        st = [];
    for (let i = 0; i < n; i++) {
        while (
            st.length &&
            nums[i] > st[st.length - 1] &&
            st.length + (n - i) > k
        ) {
            st.pop();
        }
        st.push(nums[i]);
    }
    while (st.length > k) {
        st.pop();
    }
    return st;
}

function merge(nums1, nums2) {
    const res = [];
    while (nums1.length || nums2.length) {
        let bigger = nums1 > nums2 ? nums1 : nums2;
        res.push(bigger.shift());
    }
    return res;
}
```


#### [3170. 删除星号以后字典序最小的字符串]()

给你一个字符串 s 。它可能包含任意数量的 '*' 字符。你的任务是删除所有的 '*' 字符。

当字符串还存在至少一个 '*' 字符时，你可以执行以下操作：

- 删除最左边的 '*' 字符，同时删除该星号字符左边一个字典序 最小 的字符。如果有多个字典序最小的字符，你可以删除它们中的任意一个。

请你返回删除所有 '*' 字符以后，剩余字符连接而成的 字典序最小 的字符串。

**单调栈：**

每次遇见*时，需要弹出左边字典序最小的字符，如果有多个字典序最小的字符，弹出最靠右边的字符。

对于26个字母，每个字母都维护一个单调栈，栈顶元素为当前字母的最靠右边的位置。

每次遇见*时，遍历26个字母，找到字典序最小的字母，弹出栈顶元素。

```js
/**
 * @param {string} s
 * @return {string}
 */
var clearStars = function(s) {
    const n = s.length;
    const cnt = Array.from({length: 26}, () => []); // 26字母的索引栈（a-z）
    const arr = s.split("") // 转换为数组便于修改
    
    // 第一遍遍历处理星号
    for (let i = 0; i < n; i++) {
        if (arr[i] === '*') {
            // 寻找最小字典序的非空字符栈
            for (let j = 0; j < 26; j++) {
                if (cnt[j].length > 0) {
                    arr[cnt[j].pop()] = '*' // 标记要删除的字符
                    break;
                }
            }
        } else {
            // 记录字符索引到对应字母的栈
            cnt[arr[i].charCodeAt() - 97].push(i);
        }
    }

    // 构建最终结果（过滤星号）
    let ans = '';
    for (let i of arr) {
        if (i !== '*') ans += i;
    }

    return ans;
};
```