### 一维差分

#### [2848. 与车相交的点](https://leetcode.cn/problems/points-that-intersect-with-cars/description/)

给你一个下标从 0 开始的二维整数数组 nums 表示汽车停放在数轴上的坐标。对于任意下标 i，nums[i] = [starti, endi] ，其中 starti 是第 i 辆车的起点，endi 是第 i 辆车的终点。

返回数轴上被车 任意部分 覆盖的整数点的数目。

##### 差分数组
```js
/**
 * @param {number[][]} nums
 * @return {number}
 */
var numberOfPoints = function(nums) {
    const MX = Math.max(...nums.map(a => a[1]));
    const arr = Array(MX + 2).fill(0);
    for (let [s, e] of nums) {
        arr[s] += 1;
        arr[e+1] -= 1;
    }
    let ans = 0, sum =  0;
    for (let d of arr) {
        sum += d;
        if (sum > 0) ans++;
    }
    return ans;
};
```

##### 区间合并

```js
/**
 * @param {number[][]} nums
 * @return {number}
 */
var numberOfPoints = function(nums) {
    nums.sort((a, b) => a[0] - b[0] || a[1] - b[1]);
    let [s, e] = nums[0];
    let ans = 0;
    for (let i = 1; i < nums.length; i++) {
        let [cs, ce] = nums[i];
        if (cs > e) {
            ans += e - s + 1;
            s = cs;
        }
        e = Math.max(e, ce);
    }
    ans += e - s + 1;
    return ans;
};
```

#### [1893. 检查是否区域内所有整数都被覆盖](https://leetcode.cn/problems/check-if-all-the-integers-in-a-range-are-covered/description/)

给你一个二维整数数组 ranges 和两个整数 left 和 right 。每个 ranges[i] = [starti, endi] 表示一个从 starti 到 endi 的 闭区间 。

如果闭区间 [left, right] 内每个整数都被 ranges 中 至少一个 区间覆盖，那么请你返回 true ，否则返回 false 。

已知区间 ranges[i] = [starti, endi] ，如果整数 x 满足 starti <= x <= endi ，那么我们称整数x 被覆盖了。

```js
/**
 * @param {number[][]} ranges
 * @param {number} left
 * @param {number} right
 * @return {boolean}
 */
var isCovered = function(ranges, left, right) {
    const MX = Math.max(...ranges.map(a => a[1]));
    if (MX < right) return false;
    const diffs = Array(MX + 2).fill(0);
    for (let [s, e] of ranges) {
        diffs[s]++, diffs[e+1]--;
    }
    let sum = 0, cnt = 0;
    for (let i = 0; i <= right; i++) {
        sum += diffs[i];
        if (i >= left && sum > 0) {
            cnt++;
        }
    }

    return cnt == right - left + 1;
};
```

#### [732. 我的日程安排表 III](https://leetcode.cn/problems/my-calendar-iii/description/)
 
当 k 个日程存在一些非空交集时（即, k 个日程包含了一些相同时间），就会产生 k 次预订。

给你一些日程安排 [startTime, endTime) ，请你在每个日程安排添加后，返回一个整数 k ，表示所有先前日程安排会产生的最大 k 次预订。

实现一个 MyCalendarThree 类来存放你的日程安排，你可以一直添加新的日程安排。

- MyCalendarThree() 初始化对象。
- int book(int startTime, int endTime) 返回一个整数 k ，表示日历中存在的 k 次预订的最大值。

```js

var MyCalendarThree = function() {
    this.diffs = new Map();
};

/** 
 * @param {number} startTime 
 * @param {number} endTime
 * @return {number}
 */
MyCalendarThree.prototype.book = function(startTime, endTime) {
    this.diffs.set(startTime, (this.diffs.get(startTime) ?? 0) + 1);
    this.diffs.set(endTime, (this.diffs.get(endTime) ?? 0) - 1);
    const times = [...this.diffs.keys()].sort((a, b) => a - b);
    const cnts = times.map((t) => this.diffs.get(t));
    let sum = 0, k = 0;
    for (let c of cnts) {
        sum += c;
        k = Math.max(k, sum);
    }
    return k;
};

/** 
 * Your MyCalendarThree object will be instantiated and called as such:
 * var obj = new MyCalendarThree()
 * var param_1 = obj.book(startTime,endTime)
 */
```

#### [2406. 将区间分为最少组数](https://leetcode.cn/problems/divide-intervals-into-minimum-number-of-groups/description/)
 
给你一个二维整数数组 intervals ，其中 intervals[i] = [lefti, righti] 表示 闭 区间 [lefti, righti] 。

你需要将 intervals 划分为一个或者多个区间 组 ，每个区间 只 属于一个组，且同一个组中任意两个区间 不相交 。

请你返回 最少 需要划分成多少个组。

如果两个区间覆盖的范围有重叠（即至少有一个公共数字），那么我们称这两个区间是 相交 的。比方说区间 [1, 5] 和 [5, 8] 相交。

```js
/**
 * @param {number[][]} intervals
 * @return {number}
 */
var minGroups = function(intervals) {
    const MX = Math.max(...intervals.map(i => i[1]));
    const diffs = Array(MX + 2).fill(0);
    for (let [l, r] of intervals) {
        diffs[l] += 1;
        diffs[r + 1] -= 1;
    }

    let sum = 0, ans = 0;
    for (let i of diffs) {
        sum += i;
        ans = Math.max(ans, sum);
    }
    return ans;
};
```