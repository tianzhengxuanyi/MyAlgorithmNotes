### 6.1 基础

#### [208. 实现 Trie (前缀树)](https://leetcode.cn/problems/implement-trie-prefix-tree/description/)

Trie（发音类似 "try"）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补全和拼写检查。

请你实现 Trie 类：

- Trie() 初始化前缀树对象。
- void insert(String word) 向前缀树中插入字符串 word 。
- boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。
- boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。
 

```js

/**
 * 定义 Trie 类，用于实现前缀树数据结构。
 */
var Trie = function () {
    // 初始化前缀树的根节点
    this.head = new TrieNode();
};

/**
 * 定义 TrieNode 类，代表前缀树的节点。
 */
var TrieNode = function () {
    // 标记该节点是否为一个单词的结尾
    this.end = false;
    // 存储 26 个小写英文字母对应的子节点，初始化为空数组
    this.next = Array(26);
}

/** 
 * 向前缀树中插入字符串 word。
 * @param {string} word - 要插入的字符串。
 * @return {void}
 */
Trie.prototype.insert = function (word) {
    // 从根节点开始遍历
    let node = this.head;

    // 遍历字符串中的每个字符
    for (let w of word) {
        // 计算字符对应的索引（a 对应 0，b 对应 1，以此类推）
        let code = w.charCodeAt() - 97;
        // 如果该字符对应的子节点不存在，则创建一个新的 TrieNode
        if (!node.next[code]) {
            node.next[code] = new TrieNode();
        }
        // 移动到下一个节点
        node = node.next[code];
    }
    // 标记该节点为一个单词的结尾
    node.end = true;
};

/** 
 * 在前缀树中查找字符串 word。
 * @param {string} word - 要查找的字符串。
 * @return {number} - 返回 0 表示未找到，1 表示找到前缀，2 表示找到完整单词。
 */
Trie.prototype.find = function (word) {
    // 从根节点开始遍历
    let node = this.head;
    // 遍历字符串中的每个字符
    for (let w of word) {
        // 计算字符对应的索引（a 对应 0，b 对应 1，以此类推）
        let code = w.charCodeAt() - 97;
        // 如果该字符对应的子节点不存在，说明未找到，返回 0
        if (!node.next[code]) {
            return 0;
        }
        // 移动到下一个节点
        node = node.next[code];
    }

    // 如果该节点是一个单词的结尾，返回 2；否则返回 1
    return node.end ? 2 : 1;
};

/** 
 * 检查字符串 word 是否在前缀树中。
 * @param {string} word - 要检查的字符串。
 * @return {boolean} - 如果存在返回 true，否则返回 false。
 */
Trie.prototype.search = function (word) {
    // 调用 find 方法，只有找到完整单词时返回 true
    return this.find(word) === 2;
};

/** 
 * 检查是否存在以 prefix 为前缀的字符串。
 * @param {string} prefix - 要检查的前缀。
 * @return {boolean} - 如果存在返回 true，否则返回 false。
 */
Trie.prototype.startsWith = function (prefix) {
    // 调用 find 方法，只要找到前缀或完整单词就返回 true
    return this.find(prefix) > 0;
};


/** 
 * Your Trie object will be instantiated and called as such:
 * var obj = new Trie()
 * obj.insert(word)
 * var param_2 = obj.search(word)
 * var param_3 = obj.startsWith(prefix)
 */
```

#### [1233. 删除子文件夹](https://leetcode.cn/problems/remove-sub-folders-from-the-filesystem/description/)

你是一位系统管理员，手里有一份文件夹列表 folder，你的任务是要删除该列表中的所有 子文件夹，并以 任意顺序 返回剩下的文件夹。

如果文件夹 folder[i] 位于另一个文件夹 folder[j] 下，那么 folder[i] 就是 folder[j] 的 子文件夹 。folder[j] 的子文件夹必须以 folder[j] 开头，后跟一个 "/"。例如，"/a/b" 是 "/a" 的一个子文件夹，但 "/b" 不是 "/a/b/c" 的一个子文件夹。

文件夹的「路径」是由一个或多个按以下格式串联形成的字符串：'/' 后跟一个或者多个小写英文字母。

例如，"/leetcode" 和 "/leetcode/problems" 都是有效的路径，而空字符串和 "/" 不是。

**字典树：**
```js
/**
 * 从文件夹列表中删除所有子文件夹，并返回剩余的文件夹列表。
 * @param {string[]} folder - 包含文件夹路径的字符串数组。
 * @return {string[]} - 删除子文件夹后剩余的文件夹路径数组。
 */
var removeSubfolders = function(folder) {
    // 初始化前缀树的根节点
    const head = new TrieNode();
    // 遍历文件夹列表，将每个文件夹路径插入到前缀树中
    for (let path of folder) {
        // 从根节点开始遍历
        let curr = head;
        // 将路径按 '/' 分割成多个部分，并遍历每一部分
        for (let s of path.split("/")) {
            // 如果当前部分为空字符串，跳过
            if (s === '') continue;
            // 如果当前节点的子节点中不包含当前部分
            if (!curr.nexts.has(s)) {
                // 创建一个新的 TrieNode 作为当前部分的子节点
                curr.nexts.set(s, new TrieNode());
            }
            // 移动到当前部分对应的子节点
            curr = curr.nexts.get(s);
            // 记录当前节点对应的文件夹名称
            curr.name = s;
        }
        // 标记该节点为一个完整文件夹路径的结尾
        curr.end = true;
    }

    // 用于存储最终结果的数组
    const ans = [];
    // 用于构建文件夹路径的数组，初始包含一个空字符串
    const path = [''];
    
    // 遍历根节点的所有子节点
    for (let node of head.nexts.values()) {
        // 对每个子节点进行深度优先搜索
        dfs(node, ans, path)
    }

    // 返回最终结果数组
    return ans;
};

/**
 * 定义 TrieNode 类，代表前缀树的节点。
 */
class TrieNode {
    constructor() {
        // 使用 Map 存储子节点，键为文件夹名称，值为对应的 TrieNode
        this.nexts = new Map();
        // 标记该节点是否为一个完整文件夹路径的结尾
        this.end = false;
        // 记录当前节点对应的文件夹名称
        this.name = '';
    }
}

/**
 * 深度优先搜索函数，用于遍历前缀树并收集非子文件夹的路径。
 * @param {TrieNode} node - 当前遍历到的节点。
 * @param {string[]} ans - 用于存储最终结果的数组。
 * @param {string[]} path - 用于构建文件夹路径的数组。
 */
const dfs = (node, ans, path) => {
    // 将当前节点的文件夹名称添加到路径数组中
    path.push(node.name);
    // 如果当前节点是一个完整文件夹路径的结尾
    if (node.end) {
        // 将当前路径数组用 '/' 连接成字符串，并添加到结果数组中
        ans.push(path.join('/'))
    } else {
        // 否则，继续遍历当前节点的所有子节点
        for (let next of node.nexts.values()) {
            dfs(next, ans, path);
        }
    }
    // 回溯，移除当前节点的文件夹名称
    path.pop();
}

```

**排序：**

```js
/**
 * 从文件夹列表中删除所有子文件夹，并返回剩余的文件夹列表。
 * @param {string[]} folder - 包含文件夹路径的字符串数组。
 * @return {string[]} - 删除子文件夹后剩余的文件夹路径数组。
 */
var removeSubfolders = function(folder) {
    // 对文件夹列表按字典序进行排序
    folder.sort();
    // 初始化结果数组，将排序后的第一个文件夹路径添加进去
    const ans = [folder[0]];

    // 从第二个文件夹开始遍历排序后的文件夹列表
    for (let i = 1; i < folder.length; i++) {
        // 获取结果数组中最后一个文件夹路径
        let pre = ans[ans.length - 1];
        // 检查当前文件夹是否为结果数组中最后一个文件夹的子文件夹
        // 若不是子文件夹，则需要满足以下条件之一：
        // 1. 当前文件夹长度不大于前一个文件夹长度
        // 2. 当前文件夹的前部分与前一个文件夹不相同
        // 3. 当前文件夹在前一个文件夹长度位置的字符不是 '/'
        if (!(folder[i].length > pre.length && folder[i].slice(0, pre.length) == pre && folder[i][pre.length] === '/')) {
            // 若不是子文件夹，将其添加到结果数组中
            ans.push(folder[i]);
        }
    }

    // 返回删除子文件夹后的结果数组
    return ans;
};

```

#### [3597. 分割字符串](https://leetcode.cn/problems/partition-string/description/)
 
给你一个字符串 s，按照以下步骤将其分割为 互不相同的段 ：

- 从下标 0 开始构建一个段。
- 逐字符扩展当前段，直到该段之前未曾出现过。
- 只要当前段是唯一的，就将其加入段列表，标记为已经出现过，并从下一个下标开始构建新的段。
- 重复上述步骤，直到处理完整个字符串 s。

返回字符串数组 segments，其中 segments[i] 表示创建的第 i 段。


```js
// 功能：使用字典树（Trie）对字符串进行分割，使得每个分割片段都是字典树中的唯一路径
// 参数：s - 输入字符串
// 返回：字符串数组，包含按字典树路径分割的片段
// 时间复杂度：O(n)，空间复杂度：O(26 * n) 最坏情况
var partitionString = function (s) {
    const tree = new TrieNode();  // 创建字典树根节点
    const ans = [];               // 存储分割结果
    const n = s.length;           // 字符串长度

    // 遍历字符串的每个字符
    for (let i = 0; i < n; i++) {
        let node = tree;          // 从根节点开始
        let segment = "";         // 当前分割片段
        
        // 沿着字典树路径匹配字符，直到遇到新字符
        while (i < n && node.next[s[i].charCodeAt() - 97]) {
            node = node.next[s[i].charCodeAt() - 97];  // 移动到子节点
            segment += s[i++];                         // 添加字符到片段并移动指针
        }
        
        // 处理新字符：创建新节点并完成当前片段
        if (i < n) {
            node.next[s[i].charCodeAt() - 97] = new TrieNode(s[i]);  // 创建新节点
            segment += s[i];                                        // 添加字符到片段
            ans.push(segment)                                      // 将片段加入结果
        }
    }

    return ans;  // 返回分割结果
};

// 字典树节点构造函数
// 功能：创建字典树节点，存储字符值和子节点指针数组
// 参数：val - 节点对应的字符值（可选）
function TrieNode(val) {
    this.name = val ?? "";        // 节点存储的字符，默认为空字符串
    this.next = Array(26);        // 26个子节点指针数组（对应26个小写字母）
    this.end = false;             // 标记是否为单词结尾（当前算法未使用）
}

```

#### [648. 单词替换](https://leetcode.cn/problems/replace-words/description/)
 
在英语中，我们有一个叫做 词根(root) 的概念，可以词根 后面 添加其他一些词组成另一个较长的单词——我们称这个词为 衍生词 (derivative)。例如，词根 help，跟随着 继承词 "ful"，可以形成新的单词 "helpful"。

现在，给定一个由许多 词根 组成的词典 dictionary 和一个用空格分隔单词形成的句子 sentence。你需要将句子中的所有 衍生词 用 词根 替换掉。如果 衍生词 有许多可以形成它的 词根，则用 最短 的 词根 替换它。

你需要输出替换之后的句子。

```js
// 功能：使用字典树将句子中的单词替换为其最短词根
// 参数：dictionary - 词根字典数组，sentence - 输入句子
// 返回：替换后的句子字符串
// 时间复杂度：O(n*m)，空间复杂度：O(26 * k) 其中k为字典树节点数
var replaceWords = function (dictionary, sentence) {
    const tree = new TriedTree();           // 创建字典树实例
    for (let dict of dictionary) {          // 构建字典树
        tree.insert(dict);
    }
    const words = sentence.split(" ");      // 分割句子为单词数组
    const ans = [];
    for (let word of words) {               // 处理每个单词
        ans.push(tree.find(word));          // 查找并替换为词根
    }
    return ans.join(" ");                   // 重新组合为句子
};

// 字典树节点构造函数
// 功能：创建字典树节点，存储字符值和状态信息
// 参数：val - 节点对应的字符值
function TriedNode(val) {
    this.name = val;                        // 节点存储的字符
    this.next = Array(26);                 // 26个子节点指针数组
    this.end = false;                       // 标记是否为词根结尾
}

// 字典树类封装
// 功能：提供字典树的插入和查找操作接口
class TriedTree {
    constructor() {
        this.head = new TriedNode();        // 创建根节点
    }

    // 功能：向字典树中插入词根
    // 参数：word - 要插入的词根字符串
    // 时间复杂度：O(m)，m为词根长度
    insert(word) {
        let node = this.head;               // 从根节点开始
        for (let chr of word) {             // 遍历词根每个字符
            let code = chr.charCodeAt() - 97;  // 计算字符索引（a=0, z=25）
            if (!node.next[code]) {         // 如果路径不存在
                node.next[code] = new TriedNode(chr);  // 创建新节点
            }
            node = node.next[code];         // 移动到子节点
        }
        node.end = true;                    // 标记词根结尾
    }

    // 功能：查找单词的最短词根前缀
    // 参数：word - 要查找的单词
    // 返回：找到的词根或原单词
    // 时间复杂度：O(n)，n为单词长度
    find(word) {
        let node = this.head;               // 从根节点开始
        let rt = "";                        // 存储匹配的词根前缀
        for (let chr of word) {             // 遍历单词每个字符
            let code = chr.charCodeAt() - 97;  // 计算字符索引
            if (!node.next[code]) {         // 如果路径中断
                return word;                // 返回原单词
            }
            node = node.next[code];         // 移动到子节点
            rt += node.name;                // 累积匹配的前缀
            if (node.end) return rt;       // 找到词根，立即返回
        }
        return word;                        // 未找到完整词根，返回原单词
    }
}

```