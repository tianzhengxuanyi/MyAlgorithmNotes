### 字典树优化DP

#### [139. 单词拆分](https://leetcode.cn/problems/word-break/description/)

给你一个字符串 s 和一个字符串列表 wordDict 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 s 则返回 true。

注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

```js
/**
 * 功能：使用字典树优化动态规划，判断字符串是否能被字典中的单词分割
 * 参数：s - 输入字符串，wordDict - 单词字典数组
 * 返回：boolean - 字符串是否能被字典单词分割
 * 时间复杂度：O(n * maxLen)，空间复杂度：O(n + 26 * k)
 */
var wordBreak = function (s, wordDict) {
    const n = s.length;
    const trie = new TrieNode();  // 创建字典树根节点
    let maxLen = 0;               // 记录字典中最长单词长度
    
    // 构建字典树并记录最长单词长度
    for (let word of wordDict) {
        let node = trie;
        maxLen = Math.max(maxLen, word.length);  // 更新最大长度
        for (let chr of word) {
            let code = chr.charCodeAt() - 97;    // 计算字符索引
            if (!node.next[code]) {
                node.next[code] = new TrieNode(chr);  // 创建新节点
            }
            node = node.next[code];               // 移动到子节点
        }
        node.end = true;                          // 标记单词结尾
    }

    // 动态规划数组：dp[i]表示从位置i到字符串末尾是否能被分割
    const dp = Array(n + 1).fill(false);
    dp[n] = true;  // 空字符串可以被分割（基础情况）

    // 从后向前进行动态规划
    for (let i = n - 1; i >= 0; i--) {
        let node = trie;  // 每次从字典树根节点开始
        
        // 遍历从位置i开始的子串，长度不超过maxLen
        for (let j = i; j <= Math.min(n, i + maxLen); j++) {
            // 如果当前路径构成完整单词且剩余部分可分割
            if (node.end && dp[j]) {
                dp[i] = true;  // 标记当前位置可分割
                break;         // 找到一种分割方式即可
            }
            
            // 检查下一个字符是否在字典树中
            let code = s[j]?.charCodeAt() - 97;
            if (!node.next[code]) {
                break;  // 路径中断，提前结束
            }
            node = node.next[code];  // 继续沿字典树路径前进
        }
    }

    return dp[0];  // 返回整个字符串是否能被分割
};

// 字典树节点构造函数
function TrieNode(val) {
    this.name = val;        // 节点存储的字符
    this.next = Array(26);  // 26个子节点指针数组
    this.end = false;       // 标记是否为单词结尾
}

```



#### [140. 单词拆分 II](https://leetcode.cn/problems/word-break-ii/description/)

给定一个字符串 s 和一个字符串字典 wordDict ，在字符串 s 中增加空格来构建一个句子，使得句子中所有的单词都在词典中。以任意顺序 返回所有这些可能的句子。

注意：词典中的同一个单词可能在分段中被重复使用多次。

```js
/**
 * 功能：使用字典树优化DFS，返回字符串所有可能的分割方案
 * 参数：s - 输入字符串，wordDict - 单词字典数组
 * 返回：string[] - 所有可能的分割方案数组
 * 时间复杂度：O(2^n)，空间复杂度：O(n + 26 * k)
 */
var wordBreak = function(s, wordDict) {
    const n = s.length;
    const trie = new TrieNode();  // 创建字典树根节点
    
    // 构建字典树
    for (let word of wordDict) {
        let node = trie;
        for (let chr of word) {
            let code = chr.charCodeAt() - 97;    // 计算字符索引
            if (!node.next[code]) {
                node.next[code] = new TrieNode(chr);  // 创建新节点
            }
            node = node.next[code];               // 移动到子节点
        }
        node.end = true;                          // 标记单词结尾
    }
    
    const set = new Set();  // 使用Set存储结果，自动去重
    
    /**
     * 深度优先搜索函数
     * 参数：i - 当前字符索引，path - 当前路径数组，node - 当前字典树节点
     */
    const dfs = (i, path, node) => {
        // 边界条件：到达字符串末尾
        if (i == n) {
            // 如果当前路径构成完整单词，添加到结果集
            if (node.end) set.add(path.join("").trim());
            return;
        }
        
        let code = s[i].charCodeAt() - 97;  // 计算当前字符索引
        if (!node.next[code]) return;        // 路径中断，提前返回
        
        node = node.next[code];              // 移动到子节点
        path.push(s[i]);                     // 添加当前字符到路径
        
        // 如果当前路径构成完整单词，考虑分割
        if (node.end) {
            // 分割单词：添加空格并重新从字典树根节点开始
            path.push(" ")
            dfs(i + 1, path, trie)           // 从头开始匹配字典树
            path.pop();                      // 回溯：移除空格
        }
        
        // 继续当前单词的匹配（不分割）
        dfs(i + 1, path, node); 
        path.pop();                          // 回溯：移除当前字符
    }
    
    dfs(0, [], trie)  // 从索引0、空路径、根节点开始搜索
    return [...set]   // 将Set转换为数组返回
};

// 字典树节点构造函数
function TrieNode(val) {
    this.name = val;        // 节点存储的字符
    this.next = Array(26);  // 26个子节点指针数组
    this.end = false;       // 标记是否为单词结尾
}

```