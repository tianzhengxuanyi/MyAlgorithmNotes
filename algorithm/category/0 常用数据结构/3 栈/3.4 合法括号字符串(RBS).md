### 3.4 合法括号字符串(RBS)

#### [1021. 删除最外层的括号](https://leetcode.cn/problems/remove-outermost-parentheses/description/)
 
有效括号字符串为空 ""、"(" + A + ")" 或 A + B ，其中 A 和 B 都是有效的括号字符串，+ 代表字符串的连接。

例如，""，"()"，"(())()" 和 "(()(()))" 都是有效的括号字符串。
如果有效字符串 s 非空，且不存在将其拆分为 s = A + B 的方法，我们称其为原语（primitive），其中 A 和 B 都是非空有效括号字符串。

给出一个非空有效字符串 s，考虑将其进行原语化分解，使得：s = P_1 + P_2 + ... + P_k，其中 P_i 是有效括号字符串原语。

对 s 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 s 。

**题解：**

用leftCnt记录左括号的数量，遍历字符串：
    - 如果是左括号，leftCnt++
        - 如果leftCnt大于1，说明当前是一个原语，将左括号添加到结果中
        - 否则跳过这个左括号（最外层的左括号）
    - 如果是右括号，leftCnt--
        - 如果leftCnt等于0，跳过这个右括号（最外层的右括号）      
        - 否则将右括号添加到结果中

```js
/**
 * @param {string} s
 * @return {string}
 */
var removeOuterParentheses = function (s) {
    // 记录左括号数量，用于判断是否为最外层括号
    let leftCnt = 0;
    // 存储结果字符串
    let ans = "";
    
    // 遍历输入字符串的每个字符
    for (let chr of s) {
        if (chr == "(") {
            // 遇到左括号，计数器加1
            leftCnt++;
            // 如果是第一个左括号（最外层左括号），不添加到结果
            if (leftCnt == 1) continue;
        } else {
            // 遇到右括号，计数器减1
            leftCnt--;
            // 如果是最后一个右括号（最外层右括号），不添加到结果
            if (leftCnt == 0) continue;
        }
        // 将非最外层括号添加到结果
        ans += chr;
    }

    return ans;
};

```

#### [856. 括号的分数](https://leetcode.cn/problems/score-of-parentheses/description/)
 
给定一个平衡括号字符串 S，按下述规则计算该字符串的分数：

- () 得 1 分。
- AB 得 A + B 分，其中 A 和 B 是平衡括号字符串。
- (A) 得 2 * A 分，其中 A 是平衡括号字符串。

**题解：**

- 只有()会得分，其他情况都是对()分数的倍数
- 当遇到()时，分数为2的leftCnt次方

```js
/**
 * 计算合法括号字符串的得分
 * 根据平衡因子法实现，时间复杂度O(n)，空间复杂度O(1)
 * @param {string} s - 合法括号字符串，仅包含'('和')'
 * @returns {number} 根据嵌套深度计算的累计得分
 * @description 得分规则：每个匹配的'()'得分为2^(当前嵌套深度)
 * @example
 * scoreOfParentheses("(()(()))")) // 返回 2^2 + 2^1*2 = 4 + 4 = 8
 */
var scoreOfParentheses = function(s) {
    let leftCnt = 0, // 左括号计数器，用于追踪当前嵌套深度
        ans = 0;    // 累计得分

    for (let i = 0; i < s.length; i++) {
        // 更新当前平衡因子：遇到左括号+1，右括号-1
        leftCnt += s[i] == "(" ? 1 : -1;

        // 检测到有效'()'时计算得分（仅当连续两个字符构成括号对）
        if (s[i-1] == "(" && s[i] == ")") {
            // 得分累加规则：2的当前左括号数（即实际嵌套深度）次方
            ans += Math.pow(2, leftCnt);
        }
    }
    return ans;
};

```

#### [1190. 反转每对括号间的子串](https://leetcode.cn/problems/reverse-substrings-between-each-pair-of-parentheses/description/)
 
给出一个字符串 s（仅含有小写英文字母和括号）。

请你按照从括号内到外的顺序，逐层反转每对匹配括号中的字符串，并返回最终的结果。

注意，您的结果中 不应 包含任何括号。

```js
/**
 * 反转括号内的子字符串（包含多层嵌套括号）
 * 采用双向遍历法，时间复杂度O(n)，空间复杂度O(n)
 * @param {string} s - 包含括号的输入字符串
 * @return {string} 所有括号内字符反转后的结果
 * @description 算法特点：
 * 1. 使用栈预计算括号匹配关系
 * 2. 通过方向控制实现智能跳转
 * @example
 * reverseParentheses("(abcd)") // 返回 "dcba"
 * reverseParentheses("(u(love)i)") // 返回 "iloveu"
 */
var reverseParentheses = function (s) {
    const n = s.length,
        st = [],        // 括号索引栈
        pairs = Array(n); // 括号匹配关系映射表

    // 构建括号匹配映射（时间复杂度O(n)）
    for (let i = 0; i < n; i++) {
        if (s[i] === "(") {
            st.push(i);  // 记录左括号位置
        } else if (s[i] === ")") {
            let j = st.pop();
            pairs[i] = j; // 右括号→左括号映射
            pairs[j] = i; // 左括号→右括号映射
        }
    }

    let r = "",     // 结果字符串
        d = 1,      // 遍历方向：1表示正向，-1表示逆向
        i = 0;      // 当前指针位置

    // 智能跳转遍历（时间复杂度O(n)）
    while (i < n) {
        if (s[i] === "(" || s[i] === ")") {
            // 遇到括号时跳转到匹配位置，并反转遍历方向
            i = pairs[i];
            d = -d;
        } else {
            // 收集非括号字符（按当前遍历顺序）
            r += s[i];
        }
        i += d; // 按当前方向移动指针
    }
    return r;
};

```