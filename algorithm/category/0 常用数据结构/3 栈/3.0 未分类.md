### 距离最远的更大(更小)元素

1. 正序遍历数组 A，将以 A[0] 开始的递减序列的元素下标依次存入栈中。
2. 逆序遍历数组 A，若以栈顶元素为下标的元素值 A[stack.peek()] 小于等于当前遍历的元素 A[i]，即 A[stack.peek()] <= A[i]。此时就是一个满足条件的坡的宽度，并且这个宽度一定是栈顶这个坡底 i 能形成的最大宽度，将栈顶元素出栈并计算当前坡的宽度，保留最大值即可。

#### [962. 最大宽度坡](https://leetcode.cn/problems/maximum-width-ramp/description/)

给定一个整数数组 A，坡是元组 (i, j)，其中 i < j 且 A[i] <= A[j]。这样的坡的宽度为 j - i。

找出 A 中的坡的最大宽度，如果不存在，返回 0 。

**解法一、 单调栈**

```js
var maxWidthRamp = function (nums) {
  let n = nums.length;
  let st = [0];
  for (let i = 1; i < n; i++) {
    if (nums[i] < nums[st[st.length - 1]]) st.push(i);
  }
  let ans = 0;
  for (let i = n - 1; i >= 0; i--) {
    while (st.length && nums[st[st.length - 1]] <= nums[i]) {
      ans = Math.max(ans, i - st.pop());
    }
  }
  return ans;
};
```

**解法二、 排序**

1. 将数组下标按对应值升序排序
2. 遍历 indexs
   1. 维护已遍历 index 的最小值
   2. 当前遍历 index 与左侧最小值的差值为满足条件的距离，维护其最大值

```js
var maxWidthRamp = function (nums) {
  let n = nums.length;
  let indexs = nums.map((_, i) => i);
  indexs.sort((a, b) => nums[a] - nums[b]);
  let ans = 0,
    m = n;
  for (let i of indexs) {
    ans = Math.max(ans, i - m);
    m = Math.min(i, m);
  }

  return ans;
};
```

#### [1124. 表现良好的最长时间段](https://leetcode.cn/problems/longest-well-performing-interval/description/)
 
给你一份工作时间表 hours，上面记录着某一位员工每天的工作小时数。

我们认为当员工一天中的工作小时数大于 8 小时的时候，那么这一天就是「劳累的一天」。

所谓「表现良好的时间段」，意味在这段时间内，「劳累的天数」是严格 大于「不劳累的天数」。

请你返回「表现良好时间段」的最大长度。

##### 单调栈

**单调递减栈的作用：** 筛选最优左边界候选
栈 st 中存储的是 prefix 数组索引，且这些索引对应的 prefix 值严格单调递减。这样做的原因是：

- 排除非最优候选：若存在两个索引 i1 < i2，且 prefix[i1] ≤ prefix[i2]，则 i2 永远不可能成为最优左边界。
因为对任意 j > i2，若 prefix[j] > prefix[i2]，则 prefix[j] 必然也 > prefix[i1]，且 j - i1 > j - i2（i1 更小），此时 i2 无意义，可被舍弃。
- 保留潜在最优候选：栈中只保留 prefix 值更小的索引，确保每个元素都是可能的“最小 i”（即未来可能与最大 j 匹配的最优左边界）。

**逆序遍历查找距离最远的更大元素**
当逆序遍历 j（从后往前查找右边界）时：

- 由于栈是单调递减的，若 prefix[j] > prefix[栈顶索引]，则栈顶索引就是当前 j 能匹配的最小 i（此时 j - i 最大）。
- 弹出栈顶后，继续检查新栈顶是否满足条件，直到栈为空或不满足 prefix[j] > prefix[栈顶索引]，确保不遗漏更大的 j - i。

```js
/**
 * @param {number[]} hours - 员工每天的工作小时数数组
 * @return {number} - 表现良好时间段的最大长度
 */
var longestWPI = function (hours) {
    const n = hours.length;
    // prefix[i]表示前i天的"劳累度差值"：劳累天数(>8小时) - 不劳累天数(<=8小时)
    const prefix = Array(n + 1).fill(0);
    // 单调栈：存储prefix数组中递减序列的索引（用于后续快速查找有效区间）
    const st = [0]; 
    let ans = 0; // 记录最大长度结果

    // 第一遍遍历：计算prefix数组并构建单调栈
    for (let i = 0; i < n; i++) {
        // 计算当前prefix值：若当天劳累则+1，否则-1
        prefix[i + 1] = prefix[i] + (hours[i] > 8 ? 1 : -1);
        
        // 若当前prefix值>0，说明从第0天到第i天是有效区间，直接更新结果
        if (prefix[i + 1] > 0) {
            ans = Math.max(ans, i + 1);
        }
        
        // 维护单调栈：只保留prefix值递减的索引（确保栈内元素对应prefix值严格递减）
        // 当栈为空或当前prefix值小于栈顶索引对应的prefix值时，将当前索引入栈
        if (!st.length || prefix[i + 1] < prefix[st[st.length - 1] + 1]) {
            st.push(i);
        }
    }

    // 第二遍遍历：从后往前查找最大有效区间
    for (let i = n - 1; i >= 0; i--) {
        // 当栈非空且当前prefix值大于栈顶索引对应的prefix值时，说明找到了有效区间
        // 弹出栈顶元素并计算区间长度，更新最大长度
        while (st.length && prefix[i + 1] > prefix[st[st.length - 1] + 1]) {
            ans = Math.max(ans, i - st.pop());
        }
    }

    return ans;
};

```

##### **前缀和 + 哈希表**

hours 中，大于 8 小时的为 1，小于等于 8 小时的为 -1。

遍历 hours，计算前缀和 sum，用 map 记录 sum 第一次出现的位置。

假设当前遍历到i，前缀和为 sum:
- 如果sum > 0，说明0-i-1中，劳累的天数大于不劳累的天数，直接更新ans为i+1
- 如果sum <= 0，，需要寻找0-i-1中前缀和小于sum的最左侧下标。
  - 因为hours转换为1和-1，所以前缀和sum - 1一定存在，且为前缀和小于sum的最左侧下标。如果存在比sum-1更小的前缀和，那么它一定要从sum-1的位置-1才能到达。

```js
/**
 * 计算最长表现良好时间段（表现良好天数 > 非良好天数）
 * @param {number[]} hours - 每日工作时间数组
 * @returns {number} 最长符合条件的时间段长度
 * @note 使用前缀和+哈希表优化，时间复杂度O(n)
 */
var longestWPI = function (hours) {
    const n = hours.length;
    const map = new Map([[0, -1]]); // 初始化哈希表，key为前缀和，value为首次出现索引
    let ans = 0, sum = 0; // ans记录最大长度，sum为前缀和

    // 遍历每个小时记录
    for (let i = 0; i < n; i++) {
        // 计算当前前缀和（表现良好+1，否则-1）
        sum += (hours[i] > 8 ? 1 : -1);

        // 当前前缀和>0时，整个数组都满足条件
        if (sum > 0) {
            ans = Math.max(ans, i + 1);
        } else {
            // 查找是否存在sum-1的前缀和，确保有更多表现良好天数
            if (map.has(sum - 1)) {
                ans = Math.max(ans, i - map.get(sum - 1));
            }
        }

        // 仅记录前缀和的首次出现位置
        if (!map.has(sum)) {
            map.set(sum, i);
        }
    }
    return ans;
};

```