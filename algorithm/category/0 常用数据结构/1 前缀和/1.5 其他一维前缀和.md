### 其他一维前缀和

#### [1895. 最大的幻方](https://leetcode.cn/problems/largest-magic-square/description/)
 
一个 k x k 的 幻方 指的是一个 k x k 填满整数的方格阵，且每一行、每一列以及两条对角线的和 全部相等 。幻方中的整数 不需要互不相同 。显然，每个 1 x 1 的方格都是一个幻方。

给你一个 m x n 的整数矩阵 grid ，请你返回矩阵中 最大幻方 的 尺寸 （即边长 k）。

**题解：**

```js
/**
 * @param {number[][]} grid
 * @return {number}
 */
var largestMagicSquare = function (grid) {
    const m = grid.length,
        n = grid[0].length;
    // 行前缀和: rowPrefix[i][j] 表示第j列前i行的元素和 (i从0开始)
    const rowPrefix = Array.from({ length: m + 1 }, () => Array(n).fill(0));
    // 列前缀和: colPrefix[j][i] 表示第i行前j列的元素和 (j从0开始)
    const colPrefix = Array.from({ length: n + 1 }, () => Array(m).fill(0));
    
    // 填充前缀和数组
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            rowPrefix[i + 1][j] = rowPrefix[i][j] + grid[i][j];
            colPrefix[j + 1][i] = colPrefix[j][i] + grid[i][j];
        }
    }
    
    let ans = 1; // 最小幻方尺寸为1x1
    // 遍历每个可能的幻方左上角顶点(i,j)
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            // 计算从(i,j)开始的最大可能幻方尺寸 (受矩阵边界限制)
            let d = Math.min(m - 1 - i, n - 1 - j);
            let sum = grid[i][j]; // 主对角线初始和 (左上角第一个元素)
            
            // 尝试从尺寸2x2开始增大幻方 (k为当前边长-1)
            outer: for (let k = 1; k <= d; k++) {
                sum += grid[i + k][j + k]; // 累加主对角线元素和 (当前幻方右下角元素)
                
                // 校验所有行的和是否等于主对角线和
                for (let r = i; r <= i + k; r++) {
                    // 第r行从j到j+k列的和 = 列前缀和[j+k+1][r] - 列前缀和[j][r]
                    if (sum != colPrefix[j + k + 1][r] - colPrefix[j][r])
                        continue outer; // 行和不相等，跳过当前尺寸
                }
                
                // 校验所有列的和是否等于主对角线和
                for (let c = j; c <= j + k; c++) {
                    // 第c列从i到i+k行的和 = 行前缀和[i+k+1][c] - 行前缀和[i][c]
                    if (sum != rowPrefix[i + k + 1][c] - rowPrefix[i][c])
                        continue outer; // 列和不相等，跳过当前尺寸
                }
                
                // 校验反对角线(从左上到右下的另一条对角线)的和
                let ri = i,
                    rj = j + k, // 反对角线起点(右上角)
                    rSum = grid[ri][rj];
                // 累加反对角线元素和 (共k个步长，因为已包含起点)
                for (let s = 0; s < k; s++) {
                    (ri += 1), (rj -= 1); // 向下左方向移动
                    rSum += grid[ri][rj];
                }
                if (rSum != sum) continue outer; // 反对角线和不相等，跳过当前尺寸
                
                // 所有条件满足，更新最大幻方尺寸
                ans = Math.max(ans, k + 1);
            }
        }
    }

    return ans;
};

```

#### [1878. 矩阵中最大的三个菱形和](https://leetcode.cn/problems/get-biggest-three-rhombus-sums-in-a-grid/description/)
 
给你一个 m x n 的整数矩阵 grid 。

菱形和 指的是 grid 中一个正菱形 边界 上的元素之和。本题中的菱形必须为正方形旋转45度，且四个角都在一个格子当中。下图是四个可行的菱形，每个菱形和应该包含的格子都用了相应颜色标注在图中。


注意，菱形可以是一个面积为 0 的区域，如上图中右下角的紫色菱形所示。

请你按照 降序 返回 grid 中三个最大的 互不相同的菱形和 。如果不同的和少于三个，则将它们全部返回。

```js
/**
 * @param {number[][]} grid - 输入的m x n整数矩阵
 * @return {number[]} - 按降序排列的三个最大互不相同的菱形和（不足三个则返回全部）
 */
var getBiggestThree = function (grid) {
    const m = grid.length, n = grid[0].length;
    // 初始化前三名的菱形和（mx:最大, sMx:第二大, tMx:第三大）
    let mx = sMx = tMx = 0;
    
    /**
     * 更新前三名的菱形和
     * @param {number} v - 当前计算的菱形和
     */
    const update = (v) => {
        if (v > mx) {
            // 当前值大于最大值，依次后移原前三名
            tMx = sMx, sMx = mx, mx = v;
        } else if (v < mx && v > sMx) {
            // 当前值介于最大和第二大之间，更新后两名
            tMx = sMx, sMx = v;
        } else if (v < sMx && v > tMx) {
            // 当前值介于第二大和第三大之间，更新第三名
            tMx = v;
        }
    }
    
    // 遍历矩阵中的每个单元格，作为菱形的中心
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            // 1x1的单元格本身也是一个菱形（退化菱形）
            update(grid[i][j]);
            
            // 计算以(i,j)为中心的菱形最大可能半径k
            // 受限于矩阵边界，取上下左右四个方向的最小值
            let d = Math.min(i, j, m - i - 1, n - 1 - j);
            
            // 遍历所有可能的菱形半径（从1开始，k=1表示边长为3的菱形）
            for (let k = 1; k <= d; k++) {
                let sum = 0;
                // 起始位置：中心正上方k个单位
                let sr = i, sc = j - k, dIdx = 0;
                
                // 遍历菱形边界上的所有点（共4k个点，每个方向k个点）
                for (let s = 0; s < k * 4; s++) {
                    sum += grid[sr][sc];  // 累加边界点的值
                    
                    // 每移动k个点后切换方向（完成一个边的移动）
                    if (s > 0 && s % k === 0) {
                        dIdx++;  // 切换到下一个方向
                    }
                    
                    // 获取当前方向的偏移量并移动
                    let [dr, dc] = direct[dIdx];
                    sr += dr, sc += dc;
                }
                
                // 更新前三名菱形和
                update(sum);
            }
        }
    }

    // 整理结果：移除末尾的0（如果存在）
    let ans = [mx, sMx, tMx];
    while (ans.length && ans[ans.length - 1] === 0) {
        ans.pop();
    }

    return ans;
};

// 菱形边界移动方向数组（四个方向）
// [-1,1]: 左上到右下, [1,1]: 左下到右上, [1,-1]: 右下到左上, [-1,-1]: 右上到左下
const direct = [[-1, 1], [1, 1], [1, -1], [-1, -1]];

```