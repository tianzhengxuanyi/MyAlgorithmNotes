### 数组上的并查集

#### [1562. 查找大小为 M 的最新分组](https://leetcode.cn/problems/find-latest-group-of-size-m/)
 
给你一个数组 arr ，该数组表示一个从 1 到 n 的数字排列。有一个长度为 n 的二进制字符串，该字符串上的所有位最初都设置为 0 。

在从 1 到 n 的每个步骤 i 中（假设二进制字符串和 arr 都是从 1 开始索引的情况下），二进制字符串上位于位置 arr[i] 的位将会设为 1 。

给你一个整数 m ，请你找出二进制字符串上存在长度为 m 的一组 1 的最后步骤。一组 1 是一个连续的、由 1 组成的子串，且左右两边不再有可以延伸的 1 。

返回存在长度 恰好 为 m 的 一组 1  的最后步骤。如果不存在这样的步骤，请返回 -1 。

**题解：**

```js
/**
 * 寻找数组中最后一次出现长度为m的连续1的步骤
 * @param {number[]} arr - 表示步骤的数组，arr[i]表示第i+1步将arr[i]位置设为1
 * @param {number} m - 目标连续1的长度
 * @return {number} - 最后一次出现长度为m的连续1的步骤序号，如果从未出现则返回-1
 * @算法思想：使用并查集(UnionFind)跟踪连续1的区间大小，通过正负标记记录已访问的位置
 * @时间复杂度：O(n α(n))，其中α是阿克曼函数的反函数，近似为常数
 * @空间复杂度：O(n)
 */
var findLatestStep = function (arr, m) {
    const n = arr.length; // 数组长度
    const uf = new UnionFind(n); // 初始化并查集
    let cnt = 0; // 当前长度为m的连续1区间数量
    let ans = -1; // 记录最后一次出现长度为m的步骤
    
    // 遍历每一步操作
    for (let i = 0; i < n; i++) {
        // 将1-based的索引转换为0-based，并处理绝对值
        let x = Math.abs(arr[i]) - 1;
        
        // 检查左侧相邻位置是否已被访问（负值标记）
        if (x > 0 && (arr[x - 1] < 0)) {
            // 如果左侧区间长度正好为m，合并后该区间将消失，cnt减1
            if (uf.getSize(x - 1) == m) cnt--;
            uf.union(x, x - 1); // 合并当前位置与左侧区间
        }
        
        // 检查右侧相邻位置是否已被访问（负值标记）
        if (x < n - 1 && (arr[x + 1] < 0)) {
            // 如果右侧区间长度正好为m，合并后该区间将消失，cnt减1
            if (uf.getSize(x + 1) == m) cnt--;
            uf.union(x, x + 1); // 合并当前位置与右侧区间
        }
        
        // 检查合并后的当前区间长度是否为m，若是则cnt加1
        if (uf.getSize(x) == m) cnt++;
        
        // 如果当前存在长度为m的区间，更新答案为当前步骤
        if (cnt > 0) ans = i + 1;
        
        // 标记当前位置已被访问（取负值）
        arr[x] = -arr[x];
    }

    return ans; // 返回最后一次出现满足条件的步骤
};

/**
 * 并查集(Union-Find)数据结构实现
 * 用于高效地解决动态连通性问题，支持查找根节点、合并集合和获取集合大小
 */
class UnionFind {
    /**
     * 初始化并查集
     * @param {number} n - 元素数量
     */
    constructor(n) {
        this.fa = Array.from({ length: n }, (_, i) => i); // 父节点数组，初始时每个元素的父节点是自己
        this.size = Array(n).fill(1); // 记录每个集合的大小
        this.cc = n; // 连通分量数量，初始为n
    }

    /**
     * 查找元素所在集合的根节点（带路径压缩优化）
     * @param {number} x - 要查找的元素
     * @return {number} - 元素所在集合的根节点
     */
    find(x) {
        if (x == this.fa[x]) return this.fa[x]; // 根节点的父节点是自身
        this.fa[x] = this.find(this.fa[x]); // 路径压缩：将x的父节点直接设为根节点
        return this.fa[x];
    }

    /**
     * 合并两个元素所在的集合（带按秩合并优化）
     * @param {number} x - 第一个元素
     * @param {number} y - 第二个元素
     */
    union(x, y) {
        let fx = this.find(x), fy = this.find(y); // 找到x和y的根节点
        if (fx == fy) return; // 如果已在同一集合中，无需合并
        
        // 按秩合并：将较小的集合合并到较大的集合中
        if (this.size[fx] > this.size[fy]) {
            this.fa[fy] = fx;
            this.size[fx] += this.size[fy];
        } else {
            this.fa[fx] = fy;
            this.size[fy] += this.size[fx];
        }
        this.cc--; // 连通分量数量减1
    }

    /**
     * 获取元素所在集合的大小
     * @param {number} x - 要查询的元素
     * @return {number} - 元素所在集合的大小
     */
    getSize(x) {
        let fa = this.find(x); // 先找到根节点
        return this.size[fa]; // 返回根节点对应的集合大小
    }
}

```

#### [1488. 避免洪水泛滥](https://leetcode.cn/problems/avoid-flood-in-the-city/)
 
你的国家有无数个湖泊，所有湖泊一开始都是空的。当第 n 个湖泊下雨前是空的，那么它就会装满水。如果第 n 个湖泊下雨前是 满的 ，这个湖泊会发生 洪水 。你的目标是避免任意一个湖泊发生洪水。

给你一个整数数组 rains ，其中：
- rains[i] > 0 表示第 i 天时，第 rains[i] 个湖泊会下雨。
- rains[i] == 0 表示第 i 天没有湖泊会下雨，你可以选择 一个 湖泊并 抽干 这个湖泊的水。

请返回一个数组 ans ，满足：
- ans.length == rains.length
- 如果 rains[i] > 0 ，那么ans[i] == -1 。
- 如果 rains[i] == 0 ，ans[i] 是你第 i 天选择抽干的湖泊。

如果有多种可行解，请返回它们中的 任意一个 。如果没办法阻止洪水，请返回一个 空的数组 。

请注意，如果你选择抽干一个装满水的湖泊，它会变成一个空的湖泊。但如果你选择抽干一个空的湖泊，那么将无事发生。

##### 贪心 + 优先队列
贪心（抽水日找右侧最近的满的湖抽水）+ 优先队列（维护满的湖的最小下标）
```js
/**
 * @param {number[]} rains
 * @return {number[]}
 */
var avoidFlood = function (rains) {
    const n = rains.length;
    const ans = Array(n).fill(-1);
    const enqualRightIdx = Array(n).fill(n);
    const lakeToIdx = new Map();
    for (let i = n - 1; i >= 0; i--) {
        let lake = rains[i];
        if (lakeToIdx.has(lake)) {
            enqualRightIdx[i] = lakeToIdx.get(lake);
        }
        lakeToIdx.set(lake, i);
    }
    const pq = new MinPriorityQueue((p) => p[1]);
    const full = new Set();
    for (let i = 0; i < n; i++) {
        let lake = rains[i];
        if (rains[i] == 0) {
            let res = 1;
            if (!pq.isEmpty()) {
                let [fullLake, _] = pq.dequeue();
                res = fullLake;
                full.delete(fullLake);
            }
            ans[i] = res;
        } else {
            if (full.has(lake)) return [];
            pq.enqueue([lake, enqualRightIdx[i]]);
            full.add(lake);
        }
    }
    return ans;
};
```

##### 贪心 + 并查集
贪心（满的湖找最早的抽水日） + 并查集（find查找最早的抽水日， 不是抽水日、已经抽过水的抽水日的fa指向i + 1）
```js
/**
 * @param {number[]} rains
 * @return {number[]}
 */
var avoidFlood = function (rains) {
    const n = rains.length;
    const ans = Array(n).fill(-1);
    const fa = Array.from({ length: n }, (_, i) => i);
    const find = (x) => {
        if (x !== fa[x]) {
            fa[x] = find(fa[x]);
        }
        return fa[x];
    }
    const full = new Map();
    for (let i = 0; i < n; i++) {
        let lake = rains[i];
        if (lake == 0) {
            ans[i] = 1;
            continue;
        }
        if (full.has(lake)) {
            let lastFullDay = full.get(lake)
            let dry = find(lastFullDay + 1);
            if (dry >= i) return [];
            ans[dry] = lake;
            fa[dry] = dry + 1;
        }
        full.set(lake, i);
        fa[i] = i + 1;
    }
    return ans;
};
```