### 区间并查集

#### [1851. 包含每个查询的最小区间](https://leetcode.cn/problems/minimum-interval-to-include-each-query/)

给你一个二维整数数组 intervals ，其中 intervals[i] = [lefti, righti] 表示第 i 个区间开始于 lefti 、结束于 righti（包含两侧取值，闭区间）。区间的 长度 定义为区间中包含的整数数目，更正式地表达是 righti - lefti + 1 。

再给你一个整数数组 queries 。第 j 个查询的答案是满足 lefti <= queries[j] <= righti 的 长度最小区间 i 的长度 。如果不存在这样的区间，那么答案是 -1 。

以数组形式返回对应查询的所有答案。

##### 排序 + 双指针 + 优先队列

```js
/**
 * 为每个查询点找到包含它的最小长度区间
 * @param {number[][]} intervals - 区间数组，每个区间格式为[左边界, 右边界]
 * @param {number[]} queries - 查询点数组
 * @return {number[]} - 结果数组，每个位置对应查询点的最小区间长度，不存在则为-1
 * @算法思想：排序+最小堆优化，通过预处理排序和优先队列高效匹配查询点与可能的区间
 * @时间复杂度：O(m log m + n log n + n log m)，其中m是区间数量，n是查询数量
 * @空间复杂度：O(m + n)
 */
var minInterval = function (intervals, queries) {
  const n = queries.length, // 查询点数量
        m = intervals.length; // 区间数量
  const ans = Array(n).fill(-1); // 初始化结果数组，默认值为-1
  
  // 按区间左边界升序排序区间数组
  intervals.sort((a, b) => {
    return a[0] - b[0];
  });
  
  // 创建最小优先队列，按区间长度（右边界-左边界）排序
  // 注：这里假设MinPriorityQueue已实现，队列中的元素为区间[left, right]
  const pq = new MinPriorityQueue((p) => p[1] - p[0]);
  
  // 创建查询索引数组，并按查询值升序排序
  const sorted = Array.from({ length: n }, (_, i) => i).sort(
    (a, b) => queries[a] - queries[b]
  );
  
  // 双指针遍历：i指向当前查询，j指向当前区间
  for (let i = 0, j = 0; i < n; i++) {
    let x = queries[sorted[i]]; // 获取当前查询值
    
    // 将所有左边界<=当前查询值的区间加入优先队列
    while (j < m && intervals[j][0] <= x) {
      pq.enqueue(intervals[j]);
      j++;
    }
    
    // 移除优先队列中所有右边界<当前查询值的区间（不包含当前查询点）
    while (!pq.isEmpty() && pq.front()[1] < x) {
      pq.dequeue();
    }
    
    // 如果队列不为空，队列头部就是包含当前查询点的最小长度区间
    if (!pq.isEmpty()) {
      let [l, r] = pq.front();
      ans[sorted[i]] = r - l + 1; // 计算区间长度并保存到结果数组对应位置
    }
  }

  return ans; // 返回结果数组
};

```

##### 并查集

```js
/**
 * 为每个查询点找到包含它的最小长度区间（并查集优化版）
 * @param {number[][]} intervals - 区间数组，每个区间格式为[左边界, 右边界]
 * @param {number[]} queries - 查询点数组
 * @return {number[]} - 结果数组，每个位置对应查询点的最小区间长度，不存在则为-1
 * @算法思想：排序+并查集优化，通过区间长度排序和并查集路径压缩减少重复计算
 * @时间复杂度：O(m log m + n log n + m log n)，其中m是区间数量，n是查询数量
 * @空间复杂度：O(n)
 */
var minInterval = function (intervals, queries) {
  const n = queries.length; // 查询点数量
  const ans = Array(n).fill(-1); // 初始化结果数组，默认值为-1
  
  // 按区间长度升序排序区间，确保先处理长度较小的区间
  intervals.sort((a, b) => {
    return a[1] - a[0] - (b[1] - b[0]);
  });
  
  // 创建查询索引数组，并按查询值升序排序
  const sorted = Array.from({ length: n }, (_, i) => i).sort(
    (a, b) => queries[a] - queries[b]
  );
  
  // 初始化并查集，用于记录已处理的查询点，避免重复处理
  const uf = new UnionFind(n);

  /**
   * 二分查找：找到第一个大于等于target的查询点索引
   * @param {number} target - 目标值
   * @return {number} - 找到的索引位置
   */
  const lowerBound = (target) => {
    let l = 0, r = n - 1;
    while (l <= r) {
      let m = Math.floor((r - l) / 2) + l; // 计算中间位置（避免整数溢出）
      if (queries[sorted[m]] < target) {
        l = m + 1; // 目标在右半部分
      } else {
        r = m - 1; // 目标在左半部分或当前位置
      }
    }
    return l; // 返回第一个大于等于target的位置
  };
  
  // 遍历每个区间（已按长度升序排序）
  for (let [l, r] of intervals) {
    let len = r - l + 1; // 当前区间的长度
    let i = lowerBound(l); // 找到第一个大于等于区间左边界的查询点索引
    
    // 使用并查集优化的循环：跳过已处理的查询点
    // i = uf.find(i) 确保每次都从最左侧未处理的查询点开始
    for (i = uf.find(i); i < n && queries[sorted[i]] <= r; i = uf.find(i + 1)) {
      ans[sorted[i]] = len; // 记录当前查询点的最小区间长度
      uf.union(i, i + 1); // 将当前查询点与下一个查询点合并，标记为已处理
    }
  }

  return ans; // 返回结果数组
};

/**
 * 并查集(Union-Find)数据结构实现
 * 用于高效地解决动态连通性问题，支持查找根节点和合并集合
 * 这里用于优化区间查询，记录已处理的查询点
 */
class UnionFind {
  /**
   * 初始化并查集
   * @param {number} n - 元素数量
   */
  constructor(n) {
    // 初始化父节点数组，每个元素的父节点初始为自身
    this.fa = Array.from({ length: n }, (_, i) => i);
  }

  /**
   * 查找元素所在集合的根节点（带路径压缩优化）
   * @param {number} x - 要查找的元素
   * @return {number} - 元素所在集合的根节点
   */
  find(x) {
    if (x !== this.fa[x]) {
      // 路径压缩：将x的父节点直接设为根节点
      this.fa[x] = this.find(this.fa[x]);
    }
    return this.fa[x];
  }

  /**
   * 合并两个元素所在的集合
   * @param {number} x - 第一个元素
   * @param {number} y - 第二个元素
   */
  union(x, y) {
    let fx = this.find(x), fy = this.find(y); // 找到x和y的根节点
    if (fx == fy) return; // 如果已在同一集合中，无需合并
    this.fa[fx] = fy; // 将x的集合合并到y的集合中
  }
}

```
