### 边权并查集

#### [399. 除法求值](https://leetcode.cn/problems/evaluate-division/)
 
给你一个变量对数组 equations 和一个实数值数组 values 作为已知条件，其中 equations[i] = [Ai, Bi] 和 values[i] 共同表示等式 Ai / Bi = values[i] 。每个 Ai 或 Bi 是一个表示单个变量的字符串。

另有一些以数组 queries 表示的问题，其中 queries[j] = [Cj, Dj] 表示第 j 个问题，请你根据已知条件找出 Cj / Dj = ? 的结果作为答案。

返回 所有问题的答案 。如果存在某个无法确定的答案，则用 -1.0 替代这个答案。如果问题中出现了给定的已知条件中没有出现的字符串，也需要用 -1.0 替代这个答案。

注意：输入总是有效的。你可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。

注意：未在等式列表中出现的变量是未定义的，因此无法确定它们的答案。


##### 带权并查集

```js
/**
 * 计算方程方程组中查询变量对之间的比例关系
 * @param {string[][]} equations - 方程数组，每个方程格式为["变量1", "变量2"]，表示变量1/变量2=对应的值
 * @param {number[]} values - 方程结果数组，values[i]表示equations[i]对应的比值
 * @param {string[][]} queries - 查询数组，每个查询格式为["变量1", "变量2"]，求变量1/变量2的值
 * @return {number[]} - 结果数组，每个位置对应查询的结果，无法计算则为-1
 * @算法思想：使用边权并查集维护变量之间的比例关系，通过路径压缩优化查找效率
 * @时间复杂度：O((m+q)α(n))，其中m是方程数量，q是查询数量，α是阿克曼函数的反函数，近似为常数
 * @空间复杂度：O(n)，其中n是不同变量的数量
 */
var calcEquation = function(equations, values, queries) {
    // 初始化边权并查集
    const uf = new UnionFind();
    
    // 处理所有方程，建立变量间的关系
    for (let i = 0; i < equations.length; i++) {
        let [x, y] = equations[i], v = values[i];
        uf.add(x), uf.add(y); // 确保两个变量都在并查集中
        uf.union(x, y, v); // 合并x和y所在的集合，并记录它们的比率关系
    }
    
    const n = queries.length; // 查询数量
    const ans = Array(n).fill(-1); // 初始化结果数组，默认值为-1
    
    // 处理每个查询
    for (let i = 0; i < n; i++) {
        let [x, y] = queries[i];
        
        // 如果x和y不在同一个连通分量中，无法计算比率，跳过
        if (!uf.isSame(x, y)) continue;
        
        // 查找x和y的根节点及对应的权值
        let [fx, vx] = uf.find(x), [fy, vy] = uf.find(y);
        
        // x/y = (x/fx) / (y/fy) = vx / vy
        ans[i] = vx / vy;
    }
    
    return ans; // 返回结果数组
};

/**
 * 边权并查集(Weighted Union-Find)数据结构实现
 * 用于维护带权重（比率关系）的集合，支持查找和合并操作
 * 每个节点存储[父节点, 当前节点到父节点的权值（比率）]
 */
class UnionFind {
    constructor() {
        // 使用Map存储每个节点的父节点和权值，格式为：节点名 => [父节点, 权值]
        this.fa = new Map();
    }

    /**
     * 添加节点到并查集（如果不存在）
     * @param {string} x - 要添加的节点名
     */
    add(x) {
        if (!this.fa.has(x)) {
            this.fa.set(x, [x, 1]); // 初始时，节点的父节点是自己，权值为1（x/x=1）
        }
    }

    /**
     * 检查节点是否在并查集中
     * @param {string} x - 要检查的节点名
     * @return {boolean} - 节点是否存在
     */
    has(x) {
        return this.fa.has(x);
    }

    /**
     * 查找节点所在集合的根节点，并进行路径压缩
     * @param {string} x - 要查找的节点
     * @return {Array} - [根节点, x到根节点的权值]
     */
    find(x) {
        // 递归终止条件：根节点的父节点是自己
        if (x == this.fa.get(x)[0]) return this.fa.get(x);
        
        // 保存当前节点的父节点和权值
        let [fx, vx] = this.fa.get(x);
        // 递归查找父节点的根节点
        let [fr, vr] = this.find(fx);
        
        // 路径压缩：更新当前节点直接指向根节点，并重新计算权值
        // x到父节点fx的权值是vx，fx到根节点fr的权值是vr
        // 因此x到根节点fr的权值是vx * vr
        this.fa.set(x, [fr, vx * vr]);
        
        return this.fa.get(x); // 返回更新后的节点信息
    }

    /**
     * 合并两个节点所在的集合，并维护它们之间的比率关系
     * @param {string} x - 第一个节点
     * @param {string} y - 第二个节点
     * @param {number} v - x/y的值
     */
    union(x, y, v) {
        // 查找x和y的根节点及对应权值
        let [fx, vx] = this.find(x), [fy, vy] = this.find(y);
        
        // 如果已经在同一个集合中，无需合并
        if (fx == fy) return;
        
        // 推导fx到fy的权值:
        // x/fx = vx --> fx = x/vx
        // y/fy = vy --> fy = y/vy
        // x/y = v   --> x = v*y
        // 因此: fx/fy = (x/vx) / (y/vy) = (v*y/vx) / (y/vy) = v * vy / vx
        this.fa.set(fx, [fy, v * (vy / vx)]);
    }

    /**
     * 检查两个节点是否在同一个连通分量中
     * @param {string} x - 第一个节点
     * @param {string} y - 第二个节点
     * @return {boolean} - 是否在同一个连通分量中
     */
    isSame(x, y) {
        // 如果任一节点不存在，则不在同一连通分量
        if (!this.has(x) || !this.has(y)) return false;
        
        // 查找x和y的根节点
        let [fx, vx] = this.find(x), [fy, vy] = this.find(y);
        
        // 如果根节点相同，则在同一连通分量中
        return fx == fy;
    }
}

```


##### BFS
```js
/**
 * 功能：计算方程式中变量间的比例关系，解决多个查询的变量比值问题
 * 参数：
 *   equations - 二维字符串数组，表示变量间的等式关系，如[["a","b"],["b","c"]]
 *   values - 一维数字数组，表示对应equations中变量的比值
 *   queries - 二维字符串数组，表示需要查询的变量比值关系
 * 返回：一维数字数组，表示每个查询的结果，若无法计算则为-1
 * 算法核心思想：使用图的邻接表表示变量间的比例关系，通过广度优先搜索(BFS)遍历图求解查询
 * 时间复杂度：O(n + q*(n+m))，其中n是变量数量，m是等式数量，q是查询数量
 * 空间复杂度：O(n+m)，用于存储图结构和访问状态
 */
var calcEquation = function (equations, values, queries) {
    // n为等式数量，m为查询数量
    const n = equations.length, m = queries.length;
    // vars用于将变量名映射到整数索引，便于图的存储和访问
    const vars = new Map();
    // vbase用于生成唯一的变量索引
    let vbase = 0;
    // 遍历所有等式，为每个变量分配唯一索引
    for (let [x, y] of equations) {
        if (!vars.has(x)) {
            vars.set(x, vbase++);
        }
        if (!vars.has(y)) {
            vars.set(y, vbase++);
        }
    }

    // 构建图的邻接表表示，每个节点存储与之相连的节点及对应的比例值
    const graph = Array.from({ length: vbase }, () => []);
    // 将每个等式及其倒数关系添加到图中
    for (let i = 0; i < n; i++) {
        let [x, y] = equations[i], v = values[i];
        let xIdx = vars.get(x), yIdx = vars.get(y);
        // 添加x到y的有向边，权重为v
        graph[xIdx].push([yIdx, v]);
        // 添加y到x的有向边，权重为1/v（倒数关系）
        graph[yIdx].push([xIdx, 1 / v]);
    }

    // 初始化结果数组，默认值为-1（表示无法计算）
    const ans = Array(m).fill(-1);
    // 处理每个查询
    for (let i = 0; i < m; i++) {
        let [c, d] = queries[i];
        // 如果查询中的任一变量不存在于已知变量集合中，跳过该查询
        if (!vars.has(c) || !vars.has(d)) continue;
        let cIdx = vars.get(c), dIdx = vars.get(d);
        // 使用队列进行BFS搜索
        const q = [[cIdx, 1]];  // 队列中存储[当前节点索引, 当前累积比例值]
        // rates数组记录从起始节点到各节点的比例值，初始为-1表示未访问
        const rates = Array(vbase).fill(-1);
        // 设置起始节点的比例值为1（自身与自身的比例为1）
        rates[cIdx] = 1;
        // BFS遍历过程
        while (q.length) {
            let [curr, currv] = q.shift();  // 取出队列头部节点
            // 遍历当前节点的所有邻接节点
            for (let [nx, nxv] of graph[curr]) {
                // 如果邻接节点未访问过
                if (rates[nx] < 0) {
                    // 计算从起始节点到邻接节点的比例值
                    rates[nx] = nxv * currv;
                    // 将邻接节点加入队列，继续搜索
                    q.push([nx, rates[nx]]);
                }
            }
        }
        // 将查询结果存入结果数组
        ans[i] = rates[dIdx];
    }

    return ans;
};

```

##### Floyd多源最短路

```js
/**
 * 功能：计算方程式中变量间的比例关系，解决多个查询的变量比值问题
 * 参数：
 *   equations - 二维字符串数组，表示变量间的等式关系，如[["a","b"],["b","c"]]
 *   values - 一维数字数组，表示对应equations中变量的比值
 *   queries - 二维字符串数组，表示需要查询的变量比值关系
 * 返回：一维数字数组，表示每个查询的结果，若无法计算则为-1
 * 算法核心思想：使用图的邻接矩阵表示变量间的比例关系，通过Floyd-Warshall算法预处理所有点对间的可达关系
 * 时间复杂度：O(n³)，其中n是变量数量
 * 空间复杂度：O(n²)，用于存储邻接矩阵
 */
var calcEquation = function (equations, values, queries) {
    // n为等式数量，m为查询数量
    const n = equations.length, m = queries.length;
    // vars用于将变量名映射到整数索引，便于矩阵存储和访问
    const vars = new Map();
    // nvars记录唯一变量的数量
    let nvars = 0;
    // 遍历所有等式，为每个变量分配唯一索引
    for (let [x, y] of equations) {
        if (!vars.has(x)) {
            vars.set(x, nvars++);
        }
        if (!vars.has(y)) {
            vars.set(y, nvars++);
        }
    }

    // 创建邻接矩阵表示图，graph[i][j]表示从变量i到变量j的比例值
    // 初始值为-1表示不可达或未计算
    const graph = Array.from({ length: nvars }, () => Array(nvars).fill(-1));
    // 填充已知的等式关系到邻接矩阵
    for (let i = 0; i < n; i++) {
        let [x, y] = equations[i], v = values[i];
        let xIdx = vars.get(x), yIdx = vars.get(y);
        // 设置x到y的比例值
        graph[xIdx][yIdx] = v;
        // 设置y到x的比例值（倒数关系）
        graph[yIdx][xIdx] = 1 / v;
    }

    // Floyd-Warshall算法核心：通过中间节点k，更新所有节点对(i,j)的可达性和比例值
    for (let k = 0; k < nvars; k++) {
        for (let i = 0; i < nvars; i++) {
            // 如果i到k不可达，则跳过
            if (graph[i][k] < 0) continue;
            for (let j = 0; j < nvars; j++) {
                // 如果k到j可达，且i到j尚未计算过
                if (graph[i][k] > 0 && graph[k][j] > 0 && graph[i][j] < 0) {
                    // 通过中间节点k计算i到j的比例：i->j = i->k * k->j
                    graph[i][j] = graph[i][k] * graph[k][j]
                    // 同时设置j到i的比例（倒数关系）
                    graph[j][i] = 1 / graph[i][j];
                }
            }
        }
    }

    // 初始化结果数组，默认值为-1
    const ans = Array(m).fill(-1);
    // 处理每个查询
    for (let i = 0; i < m; i++) {
        let [c, d] = queries[i];
        // 如果查询中的任一变量不存在于已知变量集合中，跳过该查询
        if (!vars.has(c) || !vars.has(d)) continue;
        let cIdx = vars.get(c), dIdx = vars.get(d);
        // 如果从c到d可达，则直接从预处理的邻接矩阵中获取结果
        if (graph[cIdx][dIdx] > 0) ans[i] = graph[cIdx][dIdx];
    }

    return ans;
};

```