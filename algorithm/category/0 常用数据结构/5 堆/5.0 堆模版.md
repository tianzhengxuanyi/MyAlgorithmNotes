### 5.0 堆模版

```js
/**
 * 通用堆实现类（支持快速删除任意元素）
 * @class
 * @template T
 * @param {(a: T, b: T) => number} [comp] - 比较函数，默认小根堆
 * @property {T[]} heap - 堆存储数组
 * @property {Map<T, number>} idxMap - 元素索引映射
 * 
 * @example
 * // 创建大根堆
 * const maxHeap = new _Heap((a, b) => b - a);
 */
class _Heap {
    /**
     * @constructor
     * @param {Function} [comp=(a, b) => a - b] - 自定义比较函数
     */
    constructor(comp = (a, b) => a - b) {
        this.heap = [];
        this.idxMap = new Map();
        this.comp = comp;
    }

    /**
     * 获取堆顶元素
     * @returns {T|number} 堆顶元素，空堆返回-1
     * @complexity O(1)
     */
    front() {
        return this.heap[0] ?? -1;
    }

    /**
     * 获取堆大小
     * @returns {number}
     */
    size() {
        return this.heap.length;
    }

    /**
     * 插入元素
     * @param {T} val - 待插入值
     * @returns {void}
     * @complexity O(log n)
     */
    enqueue(val) {
        this.heap.push(val);
        this.idxMap.set(val, this.heap.length - 1);
        this.siftUp(this.heap.length - 1);
    }

    /**
     * 弹出堆顶元素
     * @returns {T|number} 被移除的堆顶元素，空堆返回-1
     * @complexity O(log n)
     */
    dequeue() {
        if (this.heap.length == 0) return -1;
        let front = this.heap[0];
        this.swap(0, this.heap.length - 1);
        this.idxMap.delete(front);
        this.heap.pop();
        this.sink(0);
        return front;
    }

    /**
     * 上浮调整（内部方法）
     * @protected
     * @param {number} index - 需要上浮的节点索引
     * @complexity O(log n)
     */
    siftUp(index) {
        let parent = Math.floor((index - 1) / 2);
        while (parent >= 0 && this.comp(this.heap[index], this.heap[parent]) > 0) {
            this.swap(index, parent);
            index = parent, parent = Math.floor((index - 1) / 2);
        }
    }

    /**
     * 下沉调整（内部方法）
     * @protected
     * @param {number} index - 需要下沉的节点索引
     * @complexity O(log n)
     */
    sink(index) {
        let n = this.heap.length;
        while (2 * index + 1 < n) {
            let child = 2 * index + 1;
            if (child + 1 < n && this.comp(this.heap[child + 1], this.heap[child]) > 0) {
                child++;
            }
            if (this.comp(this.heap[index], this.heap[child]) >= 0) break;
            this.swap(index, child);
            index = child;
        }
    }

    /**
     * 交换元素并更新索引映射
     * @private
     * @param {number} i - 索引1
     * @param {number} j - 索引2
     */
    swap(i, j) {
        this.idxMap.set(this.heap[i], j), this.idxMap.set(this.heap[j], i);
        [this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]];
    }

    /**
     * 删除指定元素
     * @param {T} val - 需要删除的值
     * @returns {void}
     * @throws {Error} 当元素不存在时静默返回
     * @complexity O(log n)
     * @note 使用索引映射实现快速删除，实际复杂度包含哈希表操作
     */
    remove(val) {
        if (!this.idxMap.has(val)) return;
        let index = this.idxMap.get(val);
        let last = this.heap[this.heap.length - 1];
        this.swap(index, this.heap.length - 1);
        this.idxMap.delete(val);
        this.heap.pop();
        if (this.comp(last, val) > 0) {
            this.siftUp(index)
        } else {
            this.sink(index);
        }
    }
}

```