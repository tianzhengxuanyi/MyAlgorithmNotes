### 5.6 懒删除堆

#### [2349. 设计数字容器系统](https://leetcode.cn/problems/design-a-number-container-system/description/)
 
设计一个数字容器系统，可以实现以下功能：

- 在系统中给定下标处 插入 或者 替换 一个数字。
- 返回 系统中给定数字的最小下标。

请你实现一个 NumberContainers 类：

- NumberContainers() 初始化数字容器系统。
- void change(int index, int number) 在下标 index 处填入 number 。如果该下标 index 处已经有数字了，那么用 number 替换该数字。
- int find(int number) 返回给定数字 number 在系统中的最小下标。如果系统中没有 number ，那么返回 -1 。

```js
/**
 * 数字容器管理系统（支持懒删除堆优化）
 * @class
 * @author YourName
 * @created 2023-08-01
 * @version 1.0
 */
var NumberContainers = function() {
    /** @type {Map<number, number>} 索引到数字的映射 */
    this.idxToNumber = new Map();
    
    /** 
     * @type {Map<number, MinPriorityQueue>} 数字到索引堆的映射
     * @description 使用最小堆维护每个数字对应的最小可用索引
     */
    this.numberToIdx = new Map();
};

/**
 * 更新指定索引的数字
 * @param {number} index - 需要更新的索引位置
 * @param {number} number - 需要设置的新数字
 * @returns {void}
 * @note 时间复杂度 O(log n)，使用最小堆维护索引顺序
 */
NumberContainers.prototype.change = function(index, number) {
    let idxs = this.numberToIdx.get(number) ?? new MinPriorityQueue();
    idxs.enqueue(index);
    this.numberToIdx.set(number, idxs);
    this.idxToNumber.set(index, number);
};

/**
 * 查找指定数字的最小可用索引
 * @param {number} number - 需要查找的数字
 * @returns {number} 最小有效索引或-1（未找到）
 * @throws {Error} 当堆中存在脏数据时自动清理
 * @complexity 最坏情况 O(k log n)（k为需要清理的无效条目数）
 */
NumberContainers.prototype.find = function(number) {
    let idxs = this.numberToIdx.get(number);
    if (!idxs) return -1;
    
    // 懒删除机制：移除已被修改的无效索引
    while (!idxs.isEmpty() && 
           this.idxToNumber.get(idxs.front()) !== number) {
        idxs.dequeue();
    }
    
    return idxs.isEmpty() ? -1 : idxs.front();
};


/** 
 * Your NumberContainers object will be instantiated and called as such:
 * var obj = new NumberContainers()
 * obj.change(index,number)
 * var param_2 = obj.find(number)
 */
```

#### [3607. 电网维护](https://leetcode.cn/problems/power-grid-maintenance/description/)
 
给你一个整数 c，表示 c 个电站，每个电站有一个唯一标识符 id，从 1 到 c 编号。

这些电站通过 n 条 双向 电缆互相连接，表示为一个二维数组 connections，其中每个元素 connections[i] = [ui, vi] 表示电站 ui 和电站 vi 之间的连接。直接或间接连接的电站组成了一个 电网 。

最初，所有 电站均处于在线（正常运行）状态。

另给你一个二维数组 queries，其中每个查询属于以下 两种类型之一 ：

- [1, x]：请求对电站 x 进行维护检查。如果电站 x 在线，则它自行解决检查。如果电站 x 已离线，则检查由与 x 同一 电网 中 编号最小 的在线电站解决。如果该电网中 不存在 任何 在线 电站，则返回 -1。

- [2, x]：电站 x 离线（即变为非运行状态）。

返回一个整数数组，表示按照查询中出现的顺序，所有类型为 [1, x] 的查询结果。

注意：电网的结构是固定的；离线（非运行）的节点仍然属于其所在的电网，且离线操作不会改变电网的连接性。

```js
/**
 * 处理网络连接查询（支持离线操作）
 * @param {number} c - 节点总数
 * @param {number[][]} connections - 初始连接集合
 * @param {number[][]} queries - 查询集合
 * @returns {number[]} 查询结果数组
 * @complexity 时间复杂度 O(q log n)，q为查询次数
 */
var processQueries = function (c, connections, queries) {
    // 初始化并查集
    const us = new UnionSet(c + 1);
    
    // 建立初始连接
    for (let [x, y] of connections) {
        us.union(x, y);
    }

    // 为每个连通分量创建优先队列
    let rootQueue = new Map();
    for (let i = 1; i <= c; i++) {
        let fa = us.find(i);
        let q = rootQueue.get(fa) ?? new MinPriorityQueue();
        q.enqueue(i);
        rootQueue.set(fa, q);
    };

    let ans = [], 
        // 离线标记数组
        offlines = Array(c + 1).fill(0);

    // 处理查询请求
    for (let [p, x] of queries) {
        if (p == 1) {  // 在线查询
            if (offlines[x] == 0) {
                ans.push(x);
            } else {
                // 懒删除机制：清理失效节点
                let q = rootQueue.get(us.find(x));
                while (!q.isEmpty() && offlines[q.front()]) {
                    q.dequeue();
                }
                ans.push(q.isEmpty() ? -1 : q.front());
            }
        } else {  // 离线标记
            offlines[x] = 1;
        }
    }
    return ans;
};

/**
 * 并查集实现类
 * @class
 * @description 支持路径压缩和按秩合并优化
 */
class UnionSet {
    /**
     * @constructor
     * @param {number} n - 初始元素数量
     */
    constructor(n) {
        /** @type {number[]} 父节点数组 */
        this.fa = Array.from({ length: n }, (_, i) => i);
        /** @type {number[]} 子树大小数组 */
        this.size = Array(n).fill(0);
    }

    /**
     * 带路径压缩的查找
     * @param {number} x - 目标节点
     * @returns {number} 根节点
     * @complexity 近似 O(α(n)) */
    find(x) {
        if (x !== this.fa[x]) {
            this.fa[x] = this.find(this.fa[x]);
        }
        return this.fa[x];
    }

    /**
     * 按秩合并
     * @param {number} x - 节点1
     * @param {number} y - 节点2
     * @returns {boolean} 是否成功合并
     * @throws {Error} 当节点超出范围时抛出异常
     */
    union(x, y) {
        let fax = this.find(x), 
            fay = this.find(y);
        if (fax == fay) return false;

        // 按秩合并优化
        if (this.size[fax] > this.size[fay]) {
            this.size[fax] += this.size[fay];
            this.fa[fay] = fax;
        } else {
            this.size[fay] += this.size[fax];
            this.fa[fax] = fay;
        }
        return true;
    }
}
```

#### [3408. 设计任务管理器](https://leetcode.cn/problems/design-task-manager/description/)
 
一个任务管理器系统可以让用户管理他们的任务，每个任务有一个优先级。这个系统需要高效地处理添加、修改、执行和删除任务的操作。

请你设计一个 TaskManager 类：

- TaskManager 初始化任务管理器，初始化的数组格式为 [userId, taskId, priority] ，表示给 userId 添加一个优先级为 priority 的任务 taskId 。

- void add(int userId, int taskId, int priority) 表示给用户 userId 添加一个优先级为 priority 的任务 taskId ，输入 保证 taskId 不在系统中。

- void edit(int taskId, int newPriority) 更新已经存在的任务 taskId 的优先级为 newPriority 。输入 保证 taskId 存在于系统中。

- void rmv(int taskId) 从系统中删除任务 taskId 。输入 保证 taskId 存在于系统中。

- int execTop() 执行所有用户的任务中优先级 最高 的任务，如果有多个任务优先级相同且都为 最高 ，执行 taskId 最大的一个任务。执行完任务后，taskId 从系统中 删除 。同时请你返回这个任务所属的用户 userId 。如果不存在任何任务，返回 -1 。

注意 ，一个用户可能被安排多个任务。


```js
/**
 * 任务管理系统（基于懒删除堆实现）
 * 核心算法：最大优先队列 + 哈希表标记删除
 * 时间复杂度：
 *  - add/edit: O(log n)
 *  - rmv: O(1)
 *  - execTop: 最坏O(n log n)，均摊O(log n)
 * 空间复杂度：O(n)
 * @param {number[][]} tasks 初始任务列表[[userId, taskId, priority], ...]
 */
var TaskManager = function (tasks) {
    // 维护任务状态映射
    this.taskToUser = new Map();  // 任务ID => 用户ID
    this.taskPriority = new Map(); // 任务ID => 最新优先级
    
    // 最大优先队列（按优先级降序，次键taskId升序）
    this.pq = new MaxPriorityQueue({
        compare: (a, b) => {
            // 先比较优先级（降序），同优先级时按任务ID升序
            return b[1] - a[1] || a[0] - b[0];
        }
    });

    // 初始化任务队列
    for (let task of tasks) {
        this.add(...task);
    }
};

/** 
 * 添加/更新任务（懒删除关键操作）
 * @param {number} userId - 用户标识
 * @param {number} taskId - 任务唯一标识
 * @param {number} priority - 任务优先级（值越大优先级越高）
 */
TaskManager.prototype.add = function (userId, taskId, priority) {
    // 总是将新版本任务入队（旧版本通过标记删除过滤）
    this.pq.enqueue([taskId, priority, userId]);
    // 更新最新状态记录
    this.taskPriority.set(taskId, priority);
    this.taskToUser.set(taskId, userId);
};

/**
 * 执行最高优先级任务（含懒删除处理）
 * @return {number} 成功执行返回用户ID，无可用任务返回-1
 */
TaskManager.prototype.execTop = function () {
    while (!this.pq.isEmpty()) {
        // 取出队列头部元素
        let [taskId, priority, userId] = this.pq.dequeue();
        
        // 验证任务状态（关键懒删除检查）
        if (this.taskPriority.get(taskId) === priority && 
            this.taskToUser.get(taskId) === userId) {
            
            // 标记为已删除（实际删除延迟到后续操作）
            this.rmv(taskId);
            return userId;
        }
        // 状态不匹配的任务自动过期，继续循环查找
    }
    return -1; // 队列已空
};

/** 
 * Your TaskManager object will be instantiated and called as such:
 * var obj = new TaskManager(tasks)
 * obj.add(userId,taskId,priority)
 * obj.edit(taskId,newPriority)
 * obj.rmv(taskId)
 * var param_4 = obj.execTop()
 */
```