### 设计队列

#### [1670. 设计前中后队列](https://leetcode.cn/problems/design-front-middle-back-queue/description/)
 
请你设计一个队列，支持在前，中，后三个位置的 push 和 pop 操作。

请你完成 FrontMiddleBack 类：

- FrontMiddleBack() 初始化队列。
- void pushFront(int val) 将 val 添加到队列的 最前面 。
- void pushMiddle(int val) 将 val 添加到队列的 正中间 。
- void pushBack(int val) 将 val 添加到队里的 最后面 。
- int popFront() 将 最前面 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 -1 。
- int popMiddle() 将 正中间 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 -1 。
- int popBack() 将 最后面 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 -1 。

请注意当有 两个 中间位置的时候，选择靠前面的位置进行操作。比方说：

- 将 6 添加到 [1, 2, 3, 4, 5] 的中间位置，结果数组为 [1, 2, 6, 3, 4, 5] 。
- 从 [1, 2, 3, 4, 5, 6] 的中间位置弹出元素，返回 3 ，数组变为 [1, 2, 4, 5, 6] 。

**题解：**

用两个队列来模拟操作，一个队列(frontQueue)用来存储前半部分元素，一个队列(backQueue)用来存储后半部分元素，全程需要b保证frontQueue.length == backQueue.length 或者 frontQueue.length == backQueue.length + 1，这样popMiddle()是确保从frontQueue队尾弹出。
- void pushFront(int val) 将 val 添加到frontQueue队列的 最前面，然后平衡两个队列长度 。
- void pushMiddle(int val) 
  - 如果frontQueue.length == backQueue.length，直接将val添加到frontQueue队列的队尾。
  - 如果frontQueue.length == backQueue.length + 1，需要将frontQueue队尾元素弹出，添加到backQueue队头，然后将val添加到frontQueue队尾。
- void pushBack(int val) 将 val 添加到backQueue队里的 最后面 ，然后平衡两个队列长度 。
- int popFront() 将 frontQueue 队头元素弹出，如果删除之前队列为空，那么返回 -1，然后平衡两个队列长度  。
- int popMiddle() 将 frontQueue 队尾元素弹出，然后平衡两个队列长度 。
- int popBack()
  - 如果backQueue队列长度不为0，弹出队尾元素，然后平衡两个队列长度  。
  - 如果frontQueue队列长度为0，那么返回 -1。
  - 如果frontQueue队列长度为1，那么直接弹出frontQueue队头元素。


```js

/**
 * 前中后队列构造函数
 * 采用两个数组分割存储队列元素，以高效支持前、中、后位置的操作
 * stFront: 存储队列前半部分元素（长度 >= stBack，最多比stBack多1个元素）
 * stBack: 存储队列后半部分元素
 */
var FrontMiddleBackQueue = function () {
    this.stFront = [];  // 前半部分存储数组
    this.stBack = [];   // 后半部分存储数组
};

/** 
 * @param {number} val
 * @return {void}
 * 向队列最前面添加元素
 */
FrontMiddleBackQueue.prototype.pushFront = function (val) {
    this.stFront.unshift(val);  // 将元素添加到前半部分数组的头部
    // 平衡前后数组长度：确保前半部分最多比后半部分多1个元素
    if (this.stFront.length > this.stBack.length + 1) {
        // 当前半部分过长时，将前半部分尾部元素移到后半部分头部
        this.stBack.unshift(this.stFront.pop());
    }
};

/** 
 * @param {number} val
 * @return {void}
 * 向队列正中间添加元素
 */
FrontMiddleBackQueue.prototype.pushMiddle = function (val) {
    // 当前半部分比后半部分多1个元素时，先将前半部分尾部元素移到后半部分头部
    // 使前后两部分长度相等，确保新元素能添加到正确的中间位置
    if (this.stFront.length == this.stBack.length + 1) {
        this.stBack.unshift(this.stFront.pop());
    }
    this.stFront.push(val);  // 将元素添加到前半部分数组的尾部（此时为中间位置）
};

/** 
 * @param {number} val
 * @return {void}
 * 向队列最后面添加元素
 */
FrontMiddleBackQueue.prototype.pushBack = function (val) {
    this.stBack.push(val);  // 将元素添加到后半部分数组的尾部
    // 平衡前后数组长度：确保后半部分长度不超过前半部分
    if (this.stBack.length > this.stFront.length) {
        // 当后半部分过长时，将后半部分头部元素移到前半部分尾部
        this.stFront.push(this.stBack.shift());
    }
};

/**
 * @return {number}
 * 从队列最前面删除并返回元素，队列为空时返回-1
 */
FrontMiddleBackQueue.prototype.popFront = function () {
    if (this.stFront.length == 0) return -1;  // 队列为空（前半部分为空则整体为空）
    let ret = this.stFront.shift();  // 从前半部分头部删除元素
    // 平衡前后数组长度：确保后半部分长度不超过前半部分
    if (this.stBack.length > this.stFront.length) {
        // 当后半部分较长时，将后半部分头部元素移到前半部分尾部
        this.stFront.push(this.stBack.shift());
    }
    return ret;
};

/**
 * @return {number}
 * 从队列正中间删除并返回元素，队列为空时返回-1
 * 中间位置定义：当元素总数为偶数时，取靠前的中间位置
 */
FrontMiddleBackQueue.prototype.popMiddle = function () {
    if (this.stFront.length == 0) return -1;  // 队列为空
    let ret = this.stFront.pop();  // 从前半部分尾部删除元素（中间位置）
    // 平衡前后数组长度：确保后半部分长度不超过前半部分
    if (this.stBack.length > this.stFront.length) {
        // 当后半部分较长时，将后半部分头部元素移到前半部分尾部
        this.stFront.push(this.stBack.shift());
    }
    return ret;
};

/**
 * @return {number}
 * 从队列最后面删除并返回元素，队列为空时返回-1
 */
FrontMiddleBackQueue.prototype.popBack = function () {
    if (this.stBack.length == 0) {  // 后半部分为空时
        if (this.stFront.length == 0) return -1;  // 整体队列为空
        return this.stFront.pop();  // 直接从前半部分尾部删除（此时队列只有前半部分有元素）
    }
    let ret = this.stBack.pop();  // 从后半部分尾部删除元素
    // 平衡前后数组长度：确保前半部分最多比后半部分多1个元素
    if (this.stFront.length > this.stBack.length + 1) {
        // 当前半部分过长时，将前半部分尾部元素移到后半部分头部
        this.stBack.unshift(this.stFront.pop());
    }
    return ret;
};

/** 
 * Your FrontMiddleBackQueue object will be instantiated and called as such:
 * var obj = new FrontMiddleBackQueue()
 * obj.pushFront(val)
 * obj.pushMiddle(val)
 * obj.pushBack(val)
 * var param_4 = obj.popFront()
 * var param_5 = obj.popMiddle()
 * var param_6 = obj.popBack()
 */
```

#### [3508. 设计路由器](https://leetcode.cn/problems/implement-router/description/)
 
请你设计一个数据结构来高效管理网络路由器中的数据包。每个数据包包含以下属性：

- source：生成该数据包的机器的唯一标识符。
- destination：目标机器的唯一标识符。
- timestamp：该数据包到达路由器的时间戳。

实现 Router 类：

Router(int memoryLimit)：初始化路由器对象，并设置固定的内存限制。

- memoryLimit 是路由器在任意时间点可以存储的 最大 数据包数量。
- 如果添加一个新数据包会超过这个限制，则必须移除 最旧的 数据包以腾出空间。

bool addPacket(int source, int destination, int timestamp)：将具有给定属性的数据包添加到路由器。

- 如果路由器中已经存在一个具有相同 source、destination 和 timestamp 的数据包，则视为重复数据包。
- 如果数据包成功添加（即不是重复数据包），返回 true；否则返回 false。

int[] forwardPacket()：以 FIFO（先进先出）顺序转发下一个数据包。

- 从存储中移除该数据包。
- 以数组 [source, destination, timestamp] 的形式返回该数据包。
- 如果没有数据包可以转发，则返回空数组。

int getCount(int destination, int startTime, int endTime)：

- 返回当前存储在路由器中（即尚未转发）的，且目标地址为指定 destination 且时间戳在范围 [startTime, endTime]（包括两端）内的数据包数量。

注意：对于 addPacket 的查询会按照 timestamp 的递增顺序进行。

**题解：**

- 初始长度为memoryLimit的队列，记录数据包[source, destination, timestamp]
- 用哈希表记录[source, destination, timestamp]的数据包，判断是否是重复数据包
- 用哈希表<destination, timestamp[]>记录每个destination的时间戳队列，getCount二分查找数量

```js
/**
 * 路由器数据结构，用于高效管理网络数据包
 * 支持添加、转发数据包及按目标地址和时间范围统计数据包
 * @param {number} memoryLimit - 路由器可存储的最大数据包数量
 */
var Router = function (memoryLimit) {
    this.limit = memoryLimit;       // 内存限制（最大存储数据包数量）
    this.queue = [];                // FIFO队列，存储所有数据包（[source, destination, timestamp]）
    this.cnt = {};                  // 哈希表，记录数据包唯一性（键：数据包字符串，值：存在计数）
    this.timeMap = {};              // 哈希表，按目标地址分组存储时间戳（键：destination，值：timestamp数组）
};

/** 
 * 添加数据包到路由器
 * @param {number} source - 源机器标识符
 * @param {number} destination - 目标机器标识符
 * @param {number} timestamp - 数据包到达时间戳（输入保证按递增顺序）
 * @return {boolean} - 成功添加（非重复）返回true，否则返回false
 */
Router.prototype.addPacket = function (source, destination, timestamp) {
    // 将数据包属性组合为数组，用于后续操作
    let curr = [source, destination, timestamp];
    // 检查是否为重复数据包（通过字符串化数组作为哈希表键）
    if (this.cnt[curr] > 0) {
        return false;
    }

    // 若超出内存限制，移除最旧的数据包（FIFO）
    if (this.queue.length == this.limit) {
        let old = this.queue.shift();  // 移除队列头部（最旧）数据包
        this.cnt[old]--;               // 更新重复计数
        // 从timeMap中移除对应目标地址的时间戳（保持与队列同步）
        this.timeMap[old[1]].shift();
    }

    // 添加新数据包到队列尾部
    this.queue.push(curr);
    // 更新重复计数（首次添加则初始化为1）
    this.cnt[curr] = (this.cnt[curr] ?? 0) + 1;
    // 初始化目标地址的时间戳数组（若不存在）
    if (!this.timeMap[destination]) {
        this.timeMap[destination] = [];
    }
    // 将时间戳添加到对应目标地址的数组（保持递增顺序，因输入timestamp递增）
    this.timeMap[destination].push(timestamp);
    return true;
};

/**
 * 按FIFO顺序转发下一个数据包
 * @return {number[]} - 转发的数据包 [source, destination, timestamp]，无数据包时返回空数组
 */
Router.prototype.forwardPacket = function () {
    // 队列为空时返回空数组
    if (this.queue.length == 0) return [];
    // 移除并获取队列头部（最早进入）的数据包
    let ret = this.queue.shift();
    // 更新重复计数（移除该数据包）
    this.cnt[ret]--;
    // 从timeMap中移除对应目标地址的时间戳（保持与队列同步）
    this.timeMap[ret[1]].shift();
    return ret;
};

/** 
 * 统计目标地址为destination且时间戳在[startTime, endTime]内的数据包数量
 * @param {number} destination - 目标机器标识符
 * @param {number} startTime - 时间范围起始值（包含）
 * @param {number} endTime - 时间范围结束值（包含）
 * @return {number} - 符合条件的数据包数量
 */
Router.prototype.getCount = function (destination, startTime, endTime) {
    // 获取目标地址对应的时间戳数组（不存在则返回0）
    let times = this.timeMap[destination];
    if (!times) return 0;
    
    // 利用二分查找计算范围内的时间戳数量：
    // lowerBound(times, endTime)：返回第一个>endTime的索引，减1得到最后一个<=endTime的索引
    // lowerBound(times, startTime-1)：返回第一个>startTime-1的索引（即第一个>=startTime的索引）
    // 两者差值+1即为[startTime, endTime]范围内的元素数量
    return (lowerBound(times, endTime) - 1) - lowerBound(times, startTime - 1) + 1;
};

/** 
 * Your Router object will be instantiated and called as such:
 * var obj = new Router(memoryLimit)
 * var param_1 = obj.addPacket(source,destination,timestamp)
 * var param_2 = obj.forwardPacket()
 * var param_3 = obj.getCount(destination,startTime,endTime)
 */

/**
 * 二分查找辅助函数：寻找数组中第一个大于target的元素索引
 * @param {number[]} arr - 有序数组（此处为递增的时间戳数组）
 * @param {number} target - 目标值
 * @return {number} - 第一个大于target的元素索引，若所有元素<=target则返回数组长度
 */
function lowerBound(arr, target) {
    let l = 0, r = arr.length;  // 初始左边界0，右边界n（确保能返回n）
    while (l <= r) {
        let m = Math.floor((r - l) / 2) + l;  // 计算中间索引（避免溢出）
        if (arr[m] <= target) {
            // 中间元素<=target，目标在右半部分（含m+1）
            l = m + 1;
        } else {
            // 中间元素>target，目标在左半部分（含m）
            r = m - 1;
        }
    }
    return l;  // 返回第一个>target的索引
}

```