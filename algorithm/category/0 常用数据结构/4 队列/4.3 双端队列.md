### 双端队列

#### [2810. 故障键盘](https://leetcode.cn/problems/faulty-keyboard/description/)
 
你的笔记本键盘存在故障，每当你在上面输入字符 'i' 时，它会反转你所写的字符串。而输入其他字符则可以正常工作。

给你一个下标从 0 开始的字符串 s ，请你用故障键盘依次输入每个字符。

返回最终笔记本屏幕上输出的字符串。

**题解：**

用一个双端队列来模拟键盘输入的过程，head = true表示从头部插入，否则从队尾插入。
- 遍历字符串s，当遇到字符'i'时，将head取反，否则根据head的值判断是从头部插入还是从队尾插入。
- 最后将双端队列中的字符按照head的值转换为字符串返回即可。

```js
/**
 * @param {string} s
 * @return {string}
 */
var finalString = function(s) {
    // 双端队列数组，用于模拟字符的前后插入操作
    let q = [];
    // 插入方向标志：true表示从队头插入，false表示从队尾插入（初始为队尾插入）
    let head = false;
    
    // 遍历输入字符串的每个字符
    for (let chr of s) {
        // 遇到'i'时切换插入方向，不插入字符
        if (chr == 'i') {
            head = !head;  // 翻转插入方向标志
            continue;      // 跳过当前字符的插入操作
        }
        
        // 根据当前插入方向，将字符插入队头或队尾
        if (head) {
            q.unshift(chr);  // 队头插入（数组头部）
        } else {
            q.push(chr);     // 队尾插入（数组尾部）
        }
    }
    
    // 若最终方向为队头插入模式，需先反转数组再拼接（因为实际存储顺序与输出顺序相反）
    // 若为队尾插入模式，直接拼接数组元素即可
    return head ? q.reverse().join("") : q.join("");
};

```

#### [2071. 你可以安排的最多任务数目](https://leetcode.cn/problems/maximum-number-of-tasks-you-can-assign/description/)
 
给你 n 个任务和 m 个工人。每个任务需要一定的力量值才能完成，需要的力量值保存在下标从 0 开始的整数数组 tasks 中，第 i 个任务需要 tasks[i] 的力量才能完成。每个工人的力量值保存在下标从 0 开始的整数数组 workers 中，第 j 个工人的力量值为 workers[j] 。每个工人只能完成 一个 任务，且力量值需要 大于等于 该任务的力量要求值（即 workers[j] >= tasks[i] ）。

除此以外，你还有 pills 个神奇药丸，可以给 一个工人的力量值 增加 strength 。你可以决定给哪些工人使用药丸，但每个工人 最多 只能使用 一片 药丸。

给你下标从 0 开始的整数数组tasks 和 workers 以及两个整数 pills 和 strength ，请你返回 最多 有多少个任务可以被完成。

**题解：**

二分查找最多可以完成的任务，需要完成的任务越多，越不可能完成，满足二分查找的单调条件。

判断是否可以完成k个任务：
    - 贪心：将任务和工人都排序，看力量值最大的k个工人，是否能完成最简单的k个任务。
    - 遍历前k个工人：
      - 如果当前工人能完成最简单的任务，则让当前工人完成（因为后续的工人也能完成，但是后续工人的力量值更大，所以让当前工人完成最优）
      - 如果当前工人不能完成最简单的任务，则看是否有药丸可以使用：
        - 如果有药丸可以使用，则使用药丸，让当前工人完成能完成**最困难**的任务（因为药丸可以增加力量值，所以使用药丸最优）
        - 如果没有药丸可以使用，则当前工人无法完成任务，返回false

为了维护当前工人吃药后可以完成最困难的任务，使用双端队列记录工人吃药后可以完成的任务的索引。
    - 因为工人按力量值排序，所以遍历到work_i时，双端队列中的任务work_i都可以吃完药后完成
    - 完成最简单任务和最困难任务对应双端队列从队头、队尾出队

```js
/**
 * 使用二分查找和双端队列解决任务分配问题
 * @param {number[]} tasks - 待分配的任务数组（升序排序后）
 * @param {number[]} workers - 工人能力数组（降序排序后）
 * @param {number} pills - 可用药丸总数（每粒药丸可增强工人力量）
 * @param {number} strength - 药丸增强的力量值
 * @returns {number} 可完成的最大任务数量
 * @note 算法时间复杂度 O(n log n)，空间复杂度 O(n)
 * @algorithm
 * 1. 对任务升序排序，工人降序排序
 * 2. 二分查找确定最大可完成任务数
 * 3. 使用双端队列维护可用任务集合
 * 4. 逆向处理工人以优化药丸使用决策
 */
var maxTaskAssign = function (tasks, workers, pills, strength) {
    // 初始化二分查找边界 [0, min(workers.length, tasks.length)]
    const n = tasks.length, m = workers.length;
    let l = 0, r = Math.min(m, n);
    
    // 预处理：任务升序排列，工人降序排列
    tasks.sort((a, b) => a - b);
    workers.sort((a, b) => b - a);

    // 双端队列缓存可用任务（滑动窗口优化）
    const taskQueue = Array(r);

    /**
     * 检查是否能够完成k个任务的分配
     * @param {number} k - 待验证的任务数量
     * @returns {boolean} 是否可完成分配
     */
    const check = (k) => {
        let idx = 0;          // 当前任务指针
        let head = 0, tail = 0; // 双端队列头尾指针
        let pillsCnt = pills;  // 剩余药丸数量

        // 逆向检查每个工人的任务分配能力
        for (let i = k - 1; i >= 0; i--) {
            const workerStrength = workers[i];
            
            // 扩展任务队列：将当前工人可能完成的任务加入队列
            while (idx < k && tasks[idx] <= workerStrength + strength) {
                taskQueue[tail++] = tasks[idx++];
            }

            // 队列为空表示没有可用任务
            if (head === tail) return false;

            // 直接分配队列首任务（无需用药）
            if (workerStrength >= taskQueue[head]) {
                head++;
                continue;
            }

            // 药丸不足时分配失败
            if (pillsCnt === 0) return false;

            // 使用药丸分配队列末任务（贪心策略）
            tail--;
            pillsCnt--;
        }
        return true;
    };

    // 二分查找寻找最大可完成任务数
    while (l <= r) {
        const mid = Math.floor((r - l) / 2) + l;
        if (check(mid)) {
            l = mid + 1; // 尝试扩大任务数量
        } else {
            r = mid - 1; // 缩小任务数量
        }
    }
    return r; // 返回最大可行解
};

```