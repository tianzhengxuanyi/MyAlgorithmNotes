### 4.4 单调队列

#### [239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/description/)

给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。

返回 滑动窗口中的最大值 。

**题解：**

遍历数组，使用双端队列维护当前窗口的最大值，队列中存储的是数组的下标。

- 初始化双端队列：队列为空
- 遍历数组：
  - 当队尾元素小于等于当前元素时，弹出队尾元素，直到队尾元素大于当前元素（因为当前元素值更大，且下标更靠后，所以队尾元素可以被弹出）
  - 将当前元素的下标加入队尾
  - 当队头元素的下标小于等于当前下标减去窗口大小时，弹出队头元素
  - 当当前下标大于等于窗口大小时，将队头元素加入结果数组
- 返回结果数组

```js
/**
 * 使用单调队列求滑动窗口最大值
 * @param {number[]} nums - 输入数组
 * @param {number} k - 滑动窗口大小
 * @returns {number[]} 每个窗口的最大值数组
 * @timecomplexity O(n) 每个元素最多入队出队一次
 * @spacecomplexity O(k) 双端队列存储空间
 * @algorithm
 * 1. 维护单调递减队列存储元素索引
 * 2. 窗口右移时移除超出窗口范围的队首元素
 * 3. 新元素入队前移除所有较小值的索引
 */
var maxSlidingWindow = function (nums, k) {
    const n = nums.length;
    const ans = Array(n - k + 1).fill(-Infinity);
    const q = new Deque(); // 双端队列存储索引

    for (let i = 0; i < n; i++) {
        // 维护单调递减性：移除所有小于当前值的元素索引
        while (!q.isEmpty() && nums[i] >= nums[q.back()]) {
            q.popBack();
        }
        
        q.pushBack(i); // 将当前索引加入队列

        // 前k-1个元素不形成完整窗口
        if (i < k - 1) continue;

        // 移除超出窗口左边界（i-k）的队首元素
        if (i >= k && q.front() === i - k) {
            q.popFront();
        }

        // 当前窗口最大值是队首元素对应的值
        ans[i - k + 1] = nums[q.front()];
    }
    return ans;
};

```

#### [1438. 绝对差不超过限制的最长连续子数组](https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/description/)
 
给你一个整数数组 nums ，和一个表示限制的整数 limit，请你返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于 limit。

**题解：**

子数组中最大值和最小值的差不超过 limit，不定长滑动窗口，用两个单调队列分别维护窗口类的最大值和最小值，如果最大值-最小值超过limit，窗口左侧移出。

```js
/**
 * 寻找最长连续子数组的长度，要求子数组中任意两元素的绝对差不超过 limit
 * @param {number[]} nums - 输入的整数数组
 * @param {number} limit - 允许的最大绝对差限制
 * @return {number} 满足条件的最长子数组长度
 * @timecomplexity O(n) 每个元素最多入队和出队一次，n为数组长度
 * @spacecomplexity O(n) 双端队列最多存储n个元素索引
 * @algorithm 滑动窗口+双端单调队列：
 *            1. 使用两个单调队列分别维护窗口内的最大值和最小值
 *            2. 右指针遍历数组扩展窗口，左指针在窗口不满足条件时收缩
 *            3. 通过队列特性快速获取当前窗口的最大/最小值，实现O(1)时间复杂度的极值查询
 */
var longestSubarray = function(nums, limit) {
    // mxQ: 单调递减队列，存储元素索引，队首始终为当前窗口最大值的索引
    // mnQ: 单调递增队列，存储元素索引，队首始终为当前窗口最小值的索引
    const mxQ = new Deque(), mnQ = new Deque();
    let ans = 1; // 初始化最长子数组长度为1（至少存在长度为1的子数组）
    let l = 0; // 滑动窗口左边界

    // 遍历数组，i为滑动窗口右边界
    for (let i = 0; i < nums.length; i++) {
        // 维护单调递减队列（最大值队列）：
        // 移除队尾所有小于等于当前元素的索引，因为它们不可能成为未来窗口的最大值
        // 当前元素值更大且位置更靠右，未来窗口若包含它们则一定包含当前元素，故可安全移除
        while (!mxQ.isEmpty() && nums[mxQ.back()] <= nums[i]) {
            mxQ.popBack();
        }
        mxQ.pushBack(i); // 将当前元素索引加入最大值队列

        // 维护单调递增队列（最小值队列）：
        // 移除队尾所有大于等于当前元素的索引，因为它们不可能成为未来窗口的最小值
        // 当前元素值更小且位置更靠右，未来窗口若包含它们则一定包含当前元素，故可安全移除
        while (!mnQ.isEmpty() && nums[mnQ.back()] >= nums[i]) {
            mnQ.popBack();
        }
        mnQ.pushBack(i); // 将当前元素索引加入最小值队列

        // 当窗口内最大最小值差超过limit时，移动左边界收缩窗口
        while (nums[mxQ.front()] - nums[mnQ.front()] > limit) {
            // 若左边界是当前最大值的索引，将其移出最大值队列
            if (mxQ.front() === l) {
                mxQ.popFront();
            }
            // 若左边界是当前最小值的索引，将其移出最小值队列
            if (mnQ.front() === l) {
                mnQ.popFront();
            }
            l++; // 左边界右移，缩小窗口范围
        }

        // 更新最长子数组长度：当前窗口长度为i-l+1，与历史最大值比较取较大者
        ans = Math.max(ans, i - l + 1);
    }
    return ans;
};

```