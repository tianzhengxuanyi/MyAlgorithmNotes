### 2025-10-19

#### [1625. 执行操作后字典序最小的字符串](https://leetcode.cn/problems/lexicographically-smallest-string-after-applying-operations/description/)

给你一个字符串 `s` 以及两个整数 `a` 和 `b` 。其中，字符串 `s` 的长度为偶数，且仅由数字 `0` 到 `9` 组成。

你可以在 `s` 上按任意顺序多次执行下面两个操作之一：

* 累加：将  `a` 加到 `s` 中所有下标为奇数的元素上（**下标从 0 开始**）。数字一旦超过 `9` 就会变成 `0`，如此循环往复。例如，`s = "3456"` 且 `a = 5`，则执行此操作后 `s` 变成 `"3951"`。
* 轮转：将 `s` 向右轮转 `b` 位。例如，`s = "3456"` 且 `b = 1`，则执行此操作后 `s` 变成 `"6345"`。

请你返回在 `s` 上执行上述操作任意次后可以得到的 **字典序最小** 的字符串。

如果两个字符串长度相同，那么字符串 `a` 字典序比字符串 `b` 小可以这样定义：在 `a` 和 `b` 出现不同的第一个位置上，字符串 `a` 中的字符出现在字母表中的时间早于 `b` 中的对应字符。例如，`"0158”` 字典序比 `"0190"` 小，因为不同的第一个位置是在第三个字符，显然 `'5'` 出现在 `'9'` 之前。

**示例 1：**

```
输入：s = "5525", a = 9, b = 2
输出："2050"
解释：执行操作如下：
初态："5525"
轮转："2555"
累加："2454"
累加："2353"
轮转："5323"
累加："5222"
累加："5121"
轮转："2151"
累加："2050"​​​​​
无法获得字典序小于 "2050" 的字符串。
```

**示例 2：**

```
输入：s = "74", a = 5, b = 1
输出："24"
解释：执行操作如下：
初态："74"
轮转："47"
累加："42"
轮转："24"​​​​​
无法获得字典序小于 "24" 的字符串。
```

**示例 3：**

```
输入：s = "0011", a = 4, b = 2
输出："0011"
解释：无法获得字典序小于 "0011" 的字符串。
```

**提示：**

* `2 <= s.length <= 100`
* `s.length` 是偶数
* `s` 仅由数字 `0` 到 `9` 组成
* `1 <= a <= 9`
* `1 <= b <= s.length - 1`

**枚举轮转次数和累加次数**

```js
/**
 * 寻找通过旋转和累加操作后字典序最小的字符串
 * @file leetcode_submissions_2025-10-19.md
 * @author 
 * @date 2025-10-19
 * @version 1.0
 */

/**
 * 通过旋转和特定位置数字累加操作找到字典序最小的字符串
 * @param {string} s - 原始数字字符串
 * @param {number} a - 每次累加操作增加的数值
 * @param {number} b - 每次旋转操作移动的字符数
 * @return {string} 经过所有可能操作后字典序最小的字符串
 * @note 该函数通过枚举所有可能的旋转位置和累加次数，找出字典序最小的结果
 */
var findLexSmallestString = function (s, a, b) {
    const n = s.length; // 字符串长度
    const vis = new Array(n).fill(false); // 记录已访问过的旋转位置，避免重复计算
    // 当b为偶数时，旋转偶数次后偶数位置不会回到原位，因此偶数位置只能累加0次；当b为奇数时，偶数位置可以累加0-9次
    let kLimit = b % 2 === 0 ? 0 : 9;
    let ans = s; // 初始化结果为原始字符串
    s += s; // 复制字符串以简化旋转操作
    
    // 枚举所有可能的旋转位置
    for (let i = 0; !vis[i]; i = (i + b) % n) {
        vis[i] = true; // 标记当前旋转位置已访问
        
        // 枚举奇数下标的累加次数（0-9次）
        for (let j = 0; j < 10; j++) {
            // 枚举偶数下标的累加次数（根据b的奇偶性决定范围）
            for (let k = 0; k <= kLimit; k++) {
                let t = [...s.slice(i, i + n)]; // 获取当前旋转位置的子字符串并转换为数组
                
                // 对奇数下标位置的数字进行累加操作
                for (let p = 1; p < n; p += 2) {
                    t[p] = (+t[p] + j * a) % 10; // 累加后对10取模确保是个位数
                }

                // 对偶数下标位置的数字进行累加操作
                for (let p = 0; p < n; p += 2) {
                    t[p] = (+t[p] + k * a) % 10; // 累加后对10取模确保是个位数
                }
                
                let res = t.join(""); // 将数组转换回字符串
                if (res < ans) { // 更新字典序最小的结果
                    ans = res;
                }
            }
        }
    }

    return ans; // 返回找到的字典序最小字符串
};

```