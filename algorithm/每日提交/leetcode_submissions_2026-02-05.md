### 2026-02-05

#### [4. 寻找两个正序数组的中位数](https://leetcode.cn/problems/median-of-two-sorted-arrays/description/)

给定两个大小分别为 `m` 和 `n` 的正序（从小到大）数组 `nums1` 和 `nums2`。请你找出并返回这两个正序数组的 **中位数** 。

算法的时间复杂度应该为 `O(log (m+n))` 。

**示例 1：**

```
输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2
```

**示例 2：**

```
输入：nums1 = [1,2], nums2 = [3,4]
输出：2.50000
解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5
```

**提示：**

* `nums1.length == m`
* `nums2.length == n`
* `0 <= m <= 1000`
* `0 <= n <= 1000`
* `1 <= m + n <= 2000`
* `-106 <= nums1[i], nums2[i] <= 106`

#### [287. 寻找重复数](https://leetcode.cn/problems/find-the-duplicate-number/description/)

给定一个包含 `n + 1` 个整数的数组 `nums` ，其数字都在 `[1, n]` 范围内（包括 `1` 和 `n`），可知至少存在一个重复的整数。

假设 `nums` 只有 **一个重复的整数** ，返回 **这个重复的数** 。

你设计的解决方案必须 **不修改** 数组 `nums` 且只用常量级 `O(1)` 的额外空间。

**示例 1：**

```
输入：nums = [1,3,4,2,2]
输出：2
```

**示例 2：**

```
输入：nums = [3,1,3,4,2]
输出：3
```

**示例 3 :**

```
输入：nums = [3,3,3,3,3]
输出：3
```

**提示：**

* `1 <= n <= 105`
* `nums.length == n + 1`
* `1 <= nums[i] <= n`
* `nums` 中 **只有一个整数** 出现 **两次或多次** ，其余整数均只出现 **一次**

**进阶：**

* 如何证明 `nums` 中至少存在一个重复的数字?
* 你可以设计一个线性级时间复杂度 `O(n)` 的解决方案吗？

#### [3379. 转换数组](https://leetcode.cn/problems/transformed-array/description/)

给你一个整数数组 `nums`，它表示一个循环数组。请你遵循以下规则创建一个大小 **相同**的新数组 `result` ：

对于每个下标 `i`（其中 `0 <= i < nums.length`），独立执行以下操作：

* 如果 `nums[i] > 0`：从下标 `i` 开始，向 **右**移动 `nums[i]` 步，在循环数组中落脚的下标对应的值赋给 `result[i]`。
* 如果 `nums[i] < 0`：从下标 `i` 开始，向 **左**移动 `abs(nums[i])` 步，在循环数组中落脚的下标对应的值赋给 `result[i]`。
* 如果 `nums[i] == 0`：将 `nums[i]` 的值赋给 `result[i]`。

返回新数组 `result`。

**注意：**由于 `nums` 是循环数组，向右移动超过最后一个元素时将回到开头，向左移动超过第一个元素时将回到末尾。

**示例 1：**

**输入：** nums = [3,-2,1,1]

**输出：** [1,1,1,3]

**解释：**

* 对于 `nums[0]` 等于 3，向右移动 3 步到 `nums[3]`，因此 `result[0]` 为 1。
* 对于 `nums[1]` 等于 -2，向左移动 2 步到 `nums[3]`，因此 `result[1]` 为 1。
* 对于 `nums[2]` 等于 1，向右移动 1 步到 `nums[3]`，因此 `result[2]` 为 1。
* 对于 `nums[3]` 等于 1，向右移动 1 步到 `nums[0]`，因此 `result[3]` 为 3。

**示例 2：**

**输入：** nums = [-1,4,-1]

**输出：** [-1,-1,4]

**解释：**

* 对于 `nums[0]` 等于 -1，向左移动 1 步到 `nums[2]`，因此 `result[0]` 为 -1。
* 对于 `nums[1]` 等于 4，向右移动 4 步到 `nums[2]`，因此 `result[1]` 为 -1。
* 对于 `nums[2]` 等于 -1，向左移动 1 步到 `nums[1]`，因此 `result[2]` 为 4。

**提示：**

* `1 <= nums.length <= 100`
* `-100 <= nums[i] <= 100`

