### 树状数组(动态前缀和)

```js
/**
 * 树状数组（Fenwick Tree / Binary Indexed Tree）类实现
 * 支持单点更新和区间查询操作
 */
class Fenwick {
  /**
   * 初始化树状数组
   * @param {number} n - 数组大小
   */
  constructor(n) {
    this.tree = Array(n + 1).fill(0); // 树状数组，索引0不使用
  }

  /**
   * 更新指定位置的值
   * @param {number} index - 要更新的位置（0-base）
   * @param {number} val - 要增加的值
   */
  update(index, val) {
    // 转换为1-base索引，并更新所有覆盖该位置的区间
    // i += i & -i 用于找到所有包含当前位置的上级区间
    for (let i = index + 1; i < this.tree.length; i += i & -i) {
      this.tree[i] += val;
    }
  }

  /**
   * 计算前缀和（从索引1到i的元素和）
   * @param {number} i - 前缀和的右边界（1-base）
   * @return {number} - 计算得到的前缀和
   */
  prefixSum(i) {
    let sum = 0;
    // i &= i - 1 用于移除二进制表示中最低位的1，找到所有包含在当前区间中的子区间
    for (; i > 0; i &= i - 1) {
      sum += this.tree[i];
    }
    return sum;
  }

  /**
   * 计算区间和
   * @param {number} l - 区间左边界（0-base）
   * @param {number} r - 区间右边界（0-base）
   * @return {number} - 区间[l, r]的元素和
   */
  sumRange(l, r) {
    // 区间和 = 右边界前缀和 - 左边界前一个位置的前缀和
    return this.prefixSum(r + 1) - this.prefixSum(l);
  }
}
```

#### [307. 区域和检索 - 数组可修改](https://leetcode.cn/problems/range-sum-query-mutable/description/)

给你一个数组 `nums` ，请你完成两类查询。

1. 其中一类查询要求 **更新** 数组  `nums`  下标对应的值
2. 另一类查询要求返回数组  `nums`  中索引  `left`  和索引  `right`  之间（ **包含**）的 nums 元素的 **和** ，其中  `left <= right`

实现 `NumArray` 类：

- `NumArray(int[] nums)` 用整数数组 `nums` 初始化对象
- `void update(int index, int val)` 将 `nums[index]` 的值 **更新** 为 `val`
- `int sumRange(int left, int right)` 返回数组  `nums`  中索引  `left`  和索引  `right`  之间（ **包含**）的 nums 元素的 **和** （即，`nums[left] + nums[left + 1], ..., nums[right]`）

**示例 1：**

```
输入：
["NumArray", "sumRange", "update", "sumRange"]
[[[1, 3, 5]], [0, 2], [1, 2], [0, 2]]
输出：
[null, 9, null, 8]

解释：
NumArray numArray = new NumArray([1, 3, 5]);
numArray.sumRange(0, 2); // 返回 1 + 3 + 5 = 9
numArray.update(1, 2);   // nums = [1,2,5]
numArray.sumRange(0, 2); // 返回 1 + 2 + 5 = 8
```

**提示：**

- `1 <= nums.length <= 3 * 104`
- `-100 <= nums[i] <= 100`
- `0 <= index < nums.length`
- `-100 <= val <= 100`
- `0 <= left <= right < nums.length`
- 调用 `update` 和 `sumRange` 方法次数不大于  `3 * 104`

##### 树状数组

```js
/**
 * 树状数组（Binary Indexed Tree / Fenwick Tree）类实现
 * 树状数组是一种支持单点更新和区间查询的数据结构，特别适用于处理前缀和操作
 */

/**
 * 初始化树状数组
 * @param {number[]} nums - 初始数组数据
 * @description 构造函数通过遍历初始数组，调用update方法构建树状数组
 * 时间复杂度：O(n log n)，空间复杂度：O(n)
 */
var NumArray = function (nums) {
  const n = nums.length;
  this.nums = Array(n).fill(0); // 存储原始数组值，用于计算更新时的差值
  // 0-base转换为1-base：树状数组通常使用1索引以简化计算
  this.tree = Array(n + 1).fill(0); // 树状数组，大小为n+1（索引0不使用）
  for (let i = 0; i < n; i++) {
    this.update(i, nums[i]); // 逐个初始化元素，构建树状数组
  }
};

/**
 * 更新指定索引的值
 * @param {number} index - 要更新的元素索引（0-base）
 * @param {number} val - 新的元素值
 * @return {void}
 * @description 计算值的变化量，然后更新树状数组中所有包含该索引的区间
 * 时间复杂度：O(log n)
 */
NumArray.prototype.update = function (index, val) {
  const delta = val - this.nums[index]; // 计算新旧值的差值
  this.nums[index] = val; // 更新原始数组中的值
  // 0-base转换为1-base：将用户传入的0索引转换为树状数组使用的1索引
  for (let i = index + 1; i < this.tree.length; i += i & -i) {
    // i & -i 计算最低位的1所代表的值
    this.tree[i] += delta; // 更新所有包含该位置的区间和
  }
};

/**
 * 计算区间和
 * @param {number} left - 区间左边界（0-base，包含）
 * @param {number} right - 区间右边界（0-base，包含）
 * @return {number} - 区间[left, right]的元素和
 * @description 利用前缀和的性质：区间和 = 右边界前缀和 - 左边界前一个位置的前缀和
 * 时间复杂度：O(log n)
 */
NumArray.prototype.sumRange = function (left, right) {
  // 0-base转换为1-base：计算前缀和时需要将索引加1
  return this.prefixSum(right + 1) - this.prefixSum(left); // 区间和 = sum[0..right] - sum[0..left-1]
};

/**
 * 计算前缀和（树状数组核心操作）
 * @param {number} i - 前缀和的右边界（1-base）
 * @return {number} - 从索引1到i的元素和
 * @description 利用树状数组的性质，累加所有包含在区间[1,i]中的区间和
 * 时间复杂度：O(log n)
 */
NumArray.prototype.prefixSum = function (i) {
  let sum = 0; // 用于存储累加结果
  // i &= i - 1 操作会移除i的二进制表示中最低位的1
  // 例如：1100 (12) & 1011 (11) = 1000 (8)
  for (; i > 0; i &= i - 1) {
    sum += this.tree[i]; // 累加当前区间的值
  }
  return sum; // 返回计算得到的前缀和
};

/**
 * Your NumArray object will be instantiated and called as such:
 * var obj = new NumArray(nums)
 * obj.update(index,val)
 * var param_2 = obj.sumRange(left,right)
 */
```
