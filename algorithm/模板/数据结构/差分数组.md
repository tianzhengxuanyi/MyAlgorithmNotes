### 差分数组

#### [2848. 与车相交的点](https://leetcode.cn/problems/points-that-intersect-with-cars/description/)

给你一个下标从 0 开始的二维整数数组 nums 表示汽车停放在数轴上的坐标。对于任意下标 i，nums[i] = [starti, endi] ，其中 starti 是第 i 辆车的起点，endi 是第 i 辆车的终点。

返回数轴上被车 任意部分 覆盖的整数点的数目。

##### 差分数组
```js
/**
 * @param {number[][]} nums
 * @return {number}
 */
var numberOfPoints = function(nums) {
    const MX = Math.max(...nums.map(a => a[1]));
    const arr = Array(MX + 2).fill(0);
    for (let [s, e] of nums) {
        arr[s] += 1;
        arr[e+1] -= 1;
    }
    let ans = 0, sum =  0;
    for (let d of arr) {
        sum += d;
        if (sum > 0) ans++;
    }
    return ans;
};
```

### 二维差分

#### [2536. 子矩阵元素加 1](https://leetcode.cn/problems/increment-submatrices-by-one/description/)
 
给你一个正整数 n ，表示最初有一个 n x n 、下标从 0 开始的整数矩阵 mat ，矩阵中填满了 0 。

另给你一个二维整数数组 query 。针对每个查询 query[i] = [row1i, col1i, row2i, col2i] ，请你执行下述操作：

- 找出 左上角 为 (row1i, col1i) 且 右下角 为 (row2i, col2i) 的子矩阵，将子矩阵中的 每个元素 加 1 。也就是给所有满足 row1i <= x <= row2i 和 col1i <= y <= col2i 的 mat[x][y] 加 1 。

返回执行完所有操作后得到的矩阵 mat 。


```js
/**
 * 对n x n的初始零矩阵执行一系列子矩阵加1操作，并返回最终矩阵
 * @param {number} n - 矩阵的大小（n x n）
 * @param {number[][]} queries - 二维查询数组，每个查询为[row1, col1, row2, col2]，表示子矩阵范围
 * @return {number[][]} 执行所有查询后得到的矩阵
 */
var rangeAddQueries = function (n, queries) {
    // 创建(n+1)x(n+1)的差分数组，多开一行一列避免边界判断
    const diffs = Array.from({ length: n + 1 }, () => Array(n + 1).fill(0));
    
    // 处理每个查询，通过差分数组标记子矩阵加1的范围
    for (let [r1, c1, r2, c2] of queries) {
        // 左上角加1（子矩阵起始位置）
        diffs[r1][c1] += 1;
        // 右下角行+1处减1（子矩阵结束行的下一行）
        diffs[r2 + 1][c1] -= 1;
        // 右下角列+1处减1（子矩阵结束列的下一列）
        diffs[r1][c2 + 1] -= 1;
        // 右下角行+1列+1处加1（抵消双重减1的影响）
        diffs[r2 + 1][c2 + 1] += 1;
    }
    
    // 创建结果矩阵，用于存储前缀和计算后的最终值
    const prefix = Array.from({ length: n }, () => Array(n).fill(0));
    
    // 计算二维前缀和，将差分数组转换为实际矩阵值
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
            // 前缀和公式：当前值 = 上 + 左 - 左上（去重） + 差分数组当前值
            prefix[i][j] = (prefix[i - 1]?.[j] ?? 0) + (prefix[i][j - 1] ?? 0) - (prefix[i-1]?.[j-1] ?? 0) + diffs[i][j];
        }
    }
    
    return prefix;
};

```