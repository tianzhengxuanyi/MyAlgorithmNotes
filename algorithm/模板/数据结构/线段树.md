### 线段树

```js
class SegmentTree {
    /** 线段树构造函数 */
    constructor(arr) {
        let n = arr.length;
        this.arr = arr; // 原始数组
        // 初始化线段树数组（大小为2的幂次）
        this.max = Array(2 << (32 - Math.clz32(n)));
        this.build(1, 0, n - 1); // 构建线段树
    }

    /** 构建线段树 */
    build(o, l, r) {
        if (l == r) { // 叶子节点
            this.max[o] = this.arr[l];
            return;
        }
        let m = Math.floor((l + r) / 2);
        this.build(2 * o, l, m);    // 递归构建左子树
        this.build(2 * o + 1, m + 1, r); // 递归构建右子树
        this.max[o] = Math.max(this.max[2 * o], this.max[2 * o + 1]); // 更新区间最大值
    }

    /** 查找第一个 >=x 的篮子（返回1表示找到，-1表示未找到） */
    find(o, l, r, x) {
        if (this.max[o] < x) { // 当前区间最大值不足
            return -1;
        }
        if (l === r) { // 到达叶子节点
            // 找到符合条件的子节点
            this.max[o] = -1; // 标记该篮子已被使用
            this.update(o)   // 更新父节点最大值
            return 1;
        }
        let m = Math.floor((l + r) / 2);
        let res = this.find(2 * o, l, m, x); // 优先查找左子树
        if (res < 0) { // 左子树未找到则查右子树
            res = this.find(2 * o + 1, m + 1, r, x);
        }
        return res;
    }

    /** 更新父节点最大值（自底向上） */
    update(o) {
        if (o === 0) return; // 递归终止条件
        let p = Math.floor(o / 2); // 父节点索引
        this.max[p] = Math.max(this.max[2 * p], this.max[2 * p  + 1]);
        this.update(p) // 递归更新上层节点
    }
}

```

- [3479. 水果成篮 III](https://leetcode.cn/problems/fruits-into-baskets-iii/description/)