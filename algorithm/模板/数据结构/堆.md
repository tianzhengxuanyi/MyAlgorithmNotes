### 堆

**堆**
```js
class Heap {
  heap: any[];
  cmp: (a: any, b: any) => any;
  constructor(arr?: number[], cmp = (a: any, b: any) => a - b) {
    this.heap = [];
    this.cmp = cmp;
    if (arr) {
      arr.forEach((item) => {
        this.insert(item);
      });
    }
  }
  insert(data: any) {
    this.heap.push(data);
    let current = this.getSize() - 1;
    let parentIndex = (current - 1) >> 1;
    while (
      parentIndex >= 0 &&
      this.cmp(this.heap[current], this.heap[parentIndex]) > 0
    ) {
      this.swap(current, parentIndex);
      current = parentIndex;
      parentIndex = (current - 1) >> 1;
    }
  }
  heapify(index: number) {
    let size = this.getSize() - 1;
    let current = index;
    let left = 2 * current + 1;
    while (left <= size) {
      let maxIndex =
        left + 1 <= size && this.heap[left + 1] > this.heap[left]
          ? left + 1
          : left;
      if (this.cmp(this.heap[maxIndex], this.heap[current]) > 0) {
        this.swap(maxIndex, current);
        current = maxIndex;
        left = 2 * current + 1;
      } else {
        break;
      }
    }
  }
  pop() {
    let size = this.getSize() - 1;
    this.swap(0, size);
    let ret = this.heap.pop();
    this.heapify(0);
    return ret;
  }
  getSize() {
    return this.heap.length;
  }
  swap(i: number, j: number) {
    const temp = this.heap[i];
    this.heap[i] = this.heap[j];
    this.heap[j] = temp;
  }
}
```

**原地堆化**
```js
/**
 * 将数组转换为最大堆
 * @param {number[]} h - 待堆化数组
 * @description 
 * 从最后一个非叶子节点开始反向遍历
 * 时间复杂度：O(n)
 */
const heapfiy = (h) => {
    for (let i = Math.floor(h.length / 2); i >= 0; i--) {
        sink(h, i)
    }
}

/**
 * 元素下沉操作
 * @param {number[]} h - 堆数组
 * @param {number} i - 当前节点索引
 * @description 
 * 1. 比较左右子节点选择较大者
 * 2. 时间复杂度：O(log n)
 */
const sink = (h, i) => {
    let size = h.length;
    while (2 * i + 1 < size) {
        let j = 2 * i + 1;
        // 选择较大子节点
        if (j + 1 < size && h[j + 1] > h[j]) {
            j++;
        }
        // 堆性质满足时终止
        if (h[j] <= h[i]) {
            break;
        }
        // 交换节点值
        [h[i], h[j]] = [h[j], h[i]];
        i = j;
    }
}

```
