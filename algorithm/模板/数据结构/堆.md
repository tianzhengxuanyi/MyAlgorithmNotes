### 堆

**堆**
```js
class Heap {
  heap: any[];
  cmp: (a: any, b: any) => any;
  constructor(arr?: number[], cmp = (a: any, b: any) => a - b) {
    this.heap = [];
    this.cmp = cmp;
    if (arr) {
      arr.forEach((item) => {
        this.insert(item);
      });
    }
  }
  insert(data: any) {
    this.heap.push(data);
    let current = this.getSize() - 1;
    let parentIndex = (current - 1) >> 1;
    while (
      parentIndex >= 0 &&
      this.cmp(this.heap[current], this.heap[parentIndex]) > 0
    ) {
      this.swap(current, parentIndex);
      current = parentIndex;
      parentIndex = (current - 1) >> 1;
    }
  }
  heapify(index: number) {
    let size = this.getSize() - 1;
    let current = index;
    let left = 2 * current + 1;
    while (left <= size) {
      let maxIndex =
        left + 1 <= size && this.heap[left + 1] > this.heap[left]
          ? left + 1
          : left;
      if (this.cmp(this.heap[maxIndex], this.heap[current]) > 0) {
        this.swap(maxIndex, current);
        current = maxIndex;
        left = 2 * current + 1;
      } else {
        break;
      }
    }
  }
  pop() {
    let size = this.getSize() - 1;
    this.swap(0, size);
    let ret = this.heap.pop();
    this.heapify(0);
    return ret;
  }
  getSize() {
    return this.heap.length;
  }
  swap(i: number, j: number) {
    const temp = this.heap[i];
    this.heap[i] = this.heap[j];
    this.heap[j] = temp;
  }
}
```

**原地堆化**
```js
/**
 * 将数组转换为最大堆
 * @param {number[]} h - 待堆化数组
 * @description 
 * 从最后一个非叶子节点开始反向遍历
 * 时间复杂度：O(n)
 */
const heapfiy = (h) => {
    for (let i = Math.floor(h.length / 2); i >= 0; i--) {
        sink(h, i)
    }
}

/**
 * 元素下沉操作
 * @param {number[]} h - 堆数组
 * @param {number} i - 当前节点索引
 * @description 
 * 1. 比较左右子节点选择较大者
 * 2. 时间复杂度：O(log n)
 */
const sink = (h, i) => {
    let size = h.length;
    while (2 * i + 1 < size) {
        let j = 2 * i + 1;
        // 选择较大子节点
        if (j + 1 < size && h[j + 1] > h[j]) {
            j++;
        }
        // 堆性质满足时终止
        if (h[j] <= h[i]) {
            break;
        }
        // 交换节点值
        [h[i], h[j]] = [h[j], h[i]];
        i = j;
    }
}

```


**可删除元素堆**

```js
/**
 * 通用堆实现类（支持快速删除任意元素）
 * @class
 * @template T
 * @param {(a: T, b: T) => number} [comp] - 比较函数，默认小根堆
 * @property {T[]} heap - 堆存储数组
 * @property {Map<T, number>} idxMap - 元素索引映射
 * 
 * @example
 * // 创建大根堆
 * const maxHeap = new _Heap((a, b) => b - a);
 */
class _Heap {
    /**
     * @constructor
     * @param {Function} [comp=(a, b) => a - b] - 自定义比较函数
     */
    constructor(comp = (a, b) => a - b) {
        this.heap = [];
        this.idxMap = new Map();
        this.comp = comp;
    }

    /**
     * 获取堆顶元素
     * @returns {T|number} 堆顶元素，空堆返回-1
     * @complexity O(1)
     */
    front() {
        return this.heap[0] ?? -1;
    }

    /**
     * 获取堆大小
     * @returns {number}
     */
    size() {
        return this.heap.length;
    }

    /**
     * 插入元素
     * @param {T} val - 待插入值
     * @returns {void}
     * @complexity O(log n)
     */
    enqueue(val) {
        this.heap.push(val);
        this.idxMap.set(val, this.heap.length - 1);
        this.siftUp(this.heap.length - 1);
    }

    /**
     * 弹出堆顶元素
     * @returns {T|number} 被移除的堆顶元素，空堆返回-1
     * @complexity O(log n)
     */
    dequeue() {
        if (this.heap.length == 0) return -1;
        let front = this.heap[0];
        this.swap(0, this.heap.length - 1);
        this.idxMap.delete(front);
        this.heap.pop();
        this.sink(0);
        return front;
    }

    /**
     * 上浮调整（内部方法）
     * @protected
     * @param {number} index - 需要上浮的节点索引
     * @complexity O(log n)
     */
    siftUp(index) {
        let parent = Math.floor((index - 1) / 2);
        while (parent >= 0 && this.comp(this.heap[index], this.heap[parent]) > 0) {
            this.swap(index, parent);
            index = parent, parent = Math.floor((index - 1) / 2);
        }
    }

    /**
     * 下沉调整（内部方法）
     * @protected
     * @param {number} index - 需要下沉的节点索引
     * @complexity O(log n)
     */
    sink(index) {
        let n = this.heap.length;
        while (2 * index + 1 < n) {
            let child = 2 * index + 1;
            if (child + 1 < n && this.comp(this.heap[child + 1], this.heap[child]) > 0) {
                child++;
            }
            if (this.comp(this.heap[index], this.heap[child]) >= 0) break;
            this.swap(index, child);
            index = child;
        }
    }

    /**
     * 交换元素并更新索引映射
     * @private
     * @param {number} i - 索引1
     * @param {number} j - 索引2
     */
    swap(i, j) {
        this.idxMap.set(this.heap[i], j), this.idxMap.set(this.heap[j], i);
        [this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]];
    }

    /**
     * 删除指定元素
     * @param {T} val - 需要删除的值
     * @returns {void}
     * @throws {Error} 当元素不存在时静默返回
     * @complexity O(log n)
     * @note 使用索引映射实现快速删除，实际复杂度包含哈希表操作
     */
    remove(val) {
        if (!this.idxMap.has(val)) return;
        let index = this.idxMap.get(val);
        let last = this.heap[this.heap.length - 1];
        this.swap(index, this.heap.length - 1);
        this.idxMap.delete(val);
        this.heap.pop();
        if (this.comp(last, val) > 0) {
            this.siftUp(index)
        } else {
            this.sink(index);
        }
    }
}

```