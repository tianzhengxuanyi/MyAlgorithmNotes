# BitCount(二进制中1的个数)

## 迭代

**时间复杂度：O(log n)**

```javascript
function bitCount(n) {
  let count = 0; // 计数器，用于统计1的个数
  while (n) { // 当n不为0时继续循环
    if (n & 1) { // 检查最低位是否为1
      count++;   // 如果最低位是1，计数器加1
    }
    n >>= 1;    // 将n右移1位，相当于除以2，处理下一位
  }
  return count; // 返回1的总个数
}
```

## 掩码位运算（分治法）

**时间复杂度：O(1)**

采用分治策略，将32位整数分成多个小组，并行计算每个小组中1的个数，然后逐级合并结果。

```javascript
function bitCount(n) {
  // 第一步：每2位为一组，统计每组中1的个数
  // 0x55555555 = 01010101 01010101 01010101 01010101
  n = (n & 0x55555555) + ((n >> 1) & 0x55555555);
  
  // 第二步：每4位为一组，将相邻的2位组的结果相加
  // 0x33333333 = 00110011 00110011 00110011 00110011
  n = (n & 0x33333333) + ((n >> 2) & 0x33333333);
  
  // 第三步：每8位为一组，将相邻的4位组的结果相加
  // 0x0F0F0F0F = 00001111 00001111 00001111 00001111
  n = (n & 0x0F0F0F0F) + ((n >> 4) & 0x0F0F0F0F);
  
  // 第四步：每16位为一组，将相邻的8位组的结果相加
  n = n + (n >> 8);
  
  // 第五步：每32位为一组，将相邻的16位组的结果相加
  n = n + (n >> 16);
  
  // 返回结果，只保留低6位（因为最多32位，最多32个1）
  return n & 0x3f; // 0x3f = 00111111 (二进制)
}
```