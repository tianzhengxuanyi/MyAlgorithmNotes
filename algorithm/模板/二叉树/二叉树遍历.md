### 1 递归遍历

![](../image/day5-4.jpg)

```js
// 递归遍历二叉树
function f(head) {
  //1
  if (head == null) {
    return;
  }
  //1 第一次到达节点
  f(head.left);
  //2 第二次返回节点
  f(head.right);
  //3 第三次返回节点
}
```

#### 前序遍历（递归）

在第一次到达节点时打印或操作

```js
var preorderTraversal = function (root) {
  let arr = [];
  const dfs = (node) => {
    if (!node) return;
    arr.push(node.val); // 第一次到达节点时加入
    dfs(node.left);
    dfs(node.right);
  };
  dfs(root);
  return arr;
};
```

#### 中序遍历（递归）

在第二次返回节点时打印或操作

```js
var inorderTraversal = function (root) {
  let arr = [];
  const dfs = (node) => {
    if (!node) return;
    dfs(node.left);
    arr.push(node.val); // 第一次返回节点时加入
    dfs(node.right);
  };
  dfs(root);
  return arr;
};
```

#### 后序遍历（递归）

在第三次返回节点时打印或操作

```js
var postorderTraversal = function (root) {
  let arr = [];
  const dfs = (node) => {
    if (!node) return;
    dfs(node.left);
    dfs(node.right);
    arr.push(node.val); // 第二次返回节点时加入
  };
  dfs(root);
  return arr;
};
```

### 2 使用栈辅助遍历（非递归）

#### 前序遍历（非递归）

![](../image/day5-5.jpeg)

```js
var preorderTraversal = function (root) {
  if (root === null) return [];
  // 不使用递归遍历
  // 使用栈
  let stack = [];
  let arr = [];
  let curr = null;
  stack.push(root);
  while (stack.length !== 0) {
    curr = stack.pop();
    arr.push(curr.val);
    if (curr.right) {
      stack.push(curr.right);
    }
    if (curr.left) {
      stack.push(curr.left);
    }
  }
  return arr;
};
```

#### 中序遍历（非递归）

**note：中序（左头右）**

![](../image/day5-6.jpeg)

所有的树都可以被左边界分解掉

![](../image/day5-8.jpg)

```js
var inorderTraversal = function (root) {
  if (root === null) return [];
  // 非递归，用栈
  let stack = [];
  let arr = [];
  let curr = root;
  while (stack.length !== 0 || curr !== null) {
    if (curr !== null) {
      stack.push(curr);
      curr = curr.left;
    } else {
      curr = stack.pop();
      arr.push(curr.val);
      curr = curr.right;
    }
  }

  return arr;
};
```

#### 后序遍历（非递归）

![](../image/day5-7.jpeg)

```js
var postorderTraversal = function (root) {
  // 非递归
  if (root === null) {
    return [];
  }
  let arr = [];
  let stack = [];
  let collect = []; // 收集栈
  let curr = null;
  stack.push(root);
  while (stack.length !== 0) {
    curr = stack.pop();
    collect.push(curr); // 将弹出节点压入收集栈
    if (curr.left) {
      // 先添加左节点
      stack.push(curr.left);
    }
    if (curr.right) {
      stack.push(curr.right);
    }
  }
  while (collect.length !== 0) {
    arr.push(collect.pop().val);
  }
  return arr;
};
```

### 3 Mirror 遍历

一种遍历二叉树的方式 时间复杂度 O(N) 空间复杂度 O(1)

Morris 遍历的实质: 通过来回标记遍历整棵树

二叉树题目的最优解：如果要用第三次信息的强整合要用递归套路，如果不需要第三次信息的强整合 morris 遍历是最优解。

#### Morris 遍历细节

假设来到当前节点 cur，开始时 cur 来到头节点位置

1. 如果 cur 没有左孩子，cur 向右移动(cur = cur.right)
2. 如果 cur 有左孩子，找到左子树上最右的节点 mostRight：
   - 如果 mostRight 的右指针指向空，让其指向 cur，然后 cur 向左移动(cur = cur.left)
   - 如果 mostRight 的右指针指向 cur，让其指向 null，然后 cur 向右移动(cur = cur.right)
3. cur 为空时遍历停止

无左树，只有一次到达自己

有左树，会经过自己两次，根据左树的最右节点指向判断第几次达到自己

```js
function morris(head) {
  if (head === null) {
    return;
  }
  let cur = head;
  let mostRight = null;

  while (cur !== null) {
    mostRight = cur.left;
    if (mostRight !== null) {
      // cur有左孩子

      // 找到左孩子的最右节点
      while (mostRight.right !== null && mostRight.right !== cur) {
        mostRight = mostRight.right;
      }

      if (mostRight.right === null) {
        // 第一次经过cur
        mostRight.right = cur;
        cur = cur.left;
      } else {
        // 第二次经过cur
        mostRight.right = null;
        cur = cur.right;
      }
    } else {
      // cur没有左孩子
      cur = cur.right;
    }
  }
}
```

#### 前序遍历

- 只到达自己一次直接打印；
- 能够到达自己两次，在第一次打印；

```js
// 前序
function morrisPre(head) {
  if (head === null) {
    return;
  }
  let cur = head;
  let mostRight = null;

  while (cur !== null) {
    mostRight = cur.left;
    if (mostRight !== null) {
      // cur有左孩子

      // 找到左孩子的最右节点
      while (mostRight.right !== null && mostRight.right !== cur) {
        mostRight = mostRight.right;
      }

      if (mostRight.right === null) {
        // 第一次经过cur
        console.log(cur.value);
        mostRight.right = cur;
        cur = cur.left;
      } else {
        // 第二次经过cur
        mostRight.right = null;
        cur = cur.right;
      }
    } else {
      // cur没有左孩子
      console.log(cur.value);
      cur = cur.right;
    }
  }
}
```

#### 中序遍历

- 只到达自己一次直接打印；
- 能够到达自己两次，在第二次打印；

```js
// 中序
function morrisIn(head) {
  if (head === null) {
    return;
  }
  let cur = head;
  let mostRight = null;

  while (cur !== null) {
    mostRight = cur.left;
    if (mostRight !== null) {
      // cur有左孩子

      // 找到左孩子的最右节点
      while (mostRight.right !== null && mostRight.right !== cur) {
        mostRight = mostRight.right;
      }

      if (mostRight.right === null) {
        // 第一次经过cur
        mostRight.right = cur;
        cur = cur.left;
      } else {
        // 第二次经过cur
        console.log(cur.value);
        mostRight.right = null;
        cur = cur.right;
      }
    } else {
      // cur没有左孩子
      console.log(cur.value);
      cur = cur.right;
    }
  }
}
```

#### 后序遍历

- 能够到达两次的节点，在第二次到达时逆序打印其左子树的右边界（将以 cur.left 为头的右边界看作成链表反转打印，打印完成在逆序回去）；
- 遍历完成后，打印整个树的右边界；

```js
// 后序
function reverseNode(head) {
  if (head === null) {
    return null;
  }
  let prev = null;
  let cur = head;
  let right = null;
  while (cur !== null) {
    right = cur.right;
    cur.right = prev;
    prev = cur;
    cur = right;
  }
  return prev;
}
function printEdge(head) {
  let cur = reverseNode(head);
  while (cur !== null) {
    console.log(cur.value);
    cur = cur.right;
  }
  reverseNode(head);
}
function morrisPos(head) {
  if (head === null) {
    return;
  }
  let cur = head;
  let mostRight = null;

  while (cur !== null) {
    mostRight = cur.left;
    if (mostRight !== null) {
      // cur有左孩子

      // 找到左孩子的最右节点
      while (mostRight.right !== null && mostRight.right !== cur) {
        mostRight = mostRight.right;
      }

      if (mostRight.right === null) {
        // 第一次经过cur
        mostRight.right = cur;
        cur = cur.left;
      } else {
        // 第二次经过cur
        mostRight.right = null;
        printEdge(cur.left);
        cur = cur.right;
      }
    } else {
      // cur没有左孩子
      cur = cur.right;
    }
  }
  printEdge(head);
}
```

### 4 宽度优先遍历（求一棵二叉树的宽度）

![](../image/day5-9.png)

利用队列，弹出队头节点，将左节点放入再放右节点。直到队列为空。

```js
var levelOrder = function (root) {
  if (root === null) return [];
  let queue = [];
  let curr = null;
  let arr = [];
  queue.push(root);

  while (queue.length !== 0) {
    curr = queue.shift();
    if (curr.left) {
      queue.push(curr.left);
    }
    if (curr.right) {
      queue.push(curr.right);
    }
    arr.push(curr.val);
  }
  return arr;
};
```

#### 二叉树最大宽度

**空节点不计入宽度时：**

准备一个`levelMap`记录点在第几层，设置三个变量，当前在哪一层`curLevel`，当前层发现几个节点`curLevelNodes`，所有层中哪一层发现的节点最多的 max

```js
function w(node) {
  if (head == null) {
    return;
  }
  const queue = [];
  queue.push(head);
  const levelMap = new Map(); //记录每个节点对应的层数
  levelMap.set(head, 1); //放入第一个节点
  let curLevel = 1; //当前节点所在的层数
  let curLevelNodes = 0; //当前层发现几个节点数
  let max = -Infinity; //哪一层发现的最多的节点数
  while (queue.length !== 0) {
    let cur = queue.shift();
    let curNodeLevel = levelMap.get(cur); //节点的层数
    if (curNodeLevel == curLevel) {
      //节点是否是当前统计的层
      curLevelNodes++;
    } else {
      max = Math.max(max, curLevelNodes);
      curLevel++;
      curLevelNodes = 1;
    }
    //先放左再放右边，记录每个点所在的层数
    if (cur.left != null) {
      levelMap.set(cur.left, curNodeLevel + 1);
      queue.push(cur.left);
    }
    if (cur.right != null) {
      levelMap.set(cur.right, curNodeLevel + 1);
      queue.push(cur.right);
    }
  }
}
```

**空节点计入宽度：**

![](../image/day5-10.png)

**思路：**

- 宽度优先遍历二叉树
- 记录当前层、当前层节点下标
- 每层节点宽度为每层最后一个节点下标减去第一个节点下标加一
- 返回各层宽度最大的值

```js
var widthOfBinaryTree = function (root) {
  // 宽度优先遍历
  // 记录当前层和当前层的节点数
  // 记录当前层最后一个节点（上一层最后一个节点的右节点）
  if (root === null) return 0;
  let curr = null;
  let queue = [];
  let arr = [[]];
  root.val = 1;
  queue.push(root);

  // 判断是否是当前层
  // 根据hashmap中的currNodeLevel和currLevel对比
  let hashMap = new Map();
  hashMap.set(root, 1);
  let currLevel = 1;
  let currNodeLevel = 1;
  // 取模防止下标溢出
  let mod = 10000000007;
  // 返回的最大值
  let max = -Infinity;
  while (queue.length !== 0) {
    curr = queue.shift();
    currNodeLevel = hashMap.get(curr);
    console.log(curr.val);
    if (currNodeLevel !== currLevel) {
      currLevel += 1;
      arr[currLevel - 1] = [];
    }
    arr[currLevel - 1].push(curr.val);
    if (curr.left) {
      // 下标
      curr.left.val = (2 * curr.val - 1) % mod;
      hashMap.set(curr.left, currLevel + 1);
      queue.push(curr.left);
    }
    if (curr.right) {
      curr.right.val = (2 * curr.val) % mod;
      hashMap.set(curr.right, currLevel + 1);
      queue.push(curr.right);
    }
  }
  for (let i = 0; i < arr.length; i++) {
    max =
      max > arr[i][arr[i].length - 1] - arr[i][0] + 1
        ? max
        : arr[i][arr[i].length - 1] - arr[i][0] + 1;
  }
  return max;
};
```

**递归——深度优先遍历**

- 使用递归深度优先遍历
- 每次递归时记录当前层数、每层的节点及其下标
- 每层节点宽度为每层最后一个节点下标减去第一个节点下标加一
- 返回各层宽度最大的值

```js
var widthOfBinaryTree = function (root) {
  // 深度优先遍历
  let arr = [];
  let mod = 10000000007;
  function getDeepNode(root, deep, val) {
    if (root === null) return null;
    if (!arr[deep]) {
      arr[deep] = [];
    }
    arr[deep].push(val);
    getDeepNode(root.left, deep + 1, (2 * val - 1) % mod);
    getDeepNode(root.right, deep + 1, (2 * val) % mod);
  }
  getDeepNode(root, 0, 1);
  let max = 1;
  for (let i = 0; i < arr.length; i++) {
    max =
      max > arr[i][arr[i].length - 1] - arr[i][0] + 1
        ? max
        : arr[i][arr[i].length - 1] - arr[i][0] + 1;
  }
  return max;
};
```
