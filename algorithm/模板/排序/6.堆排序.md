### 6、堆排序

**时间复杂度：** `O(N*logN)`

**空间复杂度：** `O(1)`

**稳定性：** 不稳定

**算法步骤：**

-   将数组利用 heapInsert 或者 heapfiy 变成大根堆，此时数组中最大值在堆顶，堆 size 为数组长度
-   将数组第一项和最后一项交换，堆 size 减一，并对堆从第一项进行 heapfiy；
-   循环执行直到堆 size 为 0

```js
function heapSort(arr) {
    if (arr === null || arr.length < 2) {
        return;
    }
    for (let i = 0; i < arr.length; i++) {
        heapInsert(arr, i);
    }
    let heapSize = arr.length;
    swap(arr, 0, --heapSize);

    while (heapSize > 0) {
        heapfiy(arr, 0, heapSize);
        swap(arr, 0, --heapSize);
    }
}

function heapInsert(arr, i) {
    while (arr[i] > arr[(i - 1) >> 1]) {
        swap(arr, i, (i - 1) >> 1);
        i = (i - 1) >> 1;
    }
}

function heapfiy(arr, i, heapSize) {
    let left = 2 * i + 1;

    while (left < heapSize) {
        let maxIndex =
            left + 1 < heapSize && arr[left + 1] > arr[left] ? left + 1 : left;
        if (arr[i] > arr[maxIndex]) {
            break;
        }
        swap(arr, i, maxIndex);
        i = maxIndex;
        left = 2 * i + 1;
    }
}
```

