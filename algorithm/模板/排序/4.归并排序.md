### 4、归并排序

**时间复杂度：** `O(N*logN)`

**空间复杂度：** `O(N)`

**稳定性：** 稳定

**算法步骤(递归)：**

-   申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；
-   递归序列左侧部分使其有序；
-   递归序列右侧部分使其有序；
-   利用额外空间将左侧和右侧合并，并使合并后的序列有序；
-   将合并序列复制到原序列。

```js
function mergeSort(arr) {
    if (arr === null || arr.length < 2) {
        return;
    }
    dfs(arr, 0, arr.length - 1);
}
function dfs(arr, l, r) {
    if (l === r) {
        return;
    }
    let mid = ((r - l) >> 1) + l;
    dfs(arr, l, mid);
    dfs(arr, mid + 1, r);
    merge(arr, l, mid, r);
}
function merge(arr, l, mid, r) {
    let help = new Array(r - l + 1);
    let p1 = l;
    let p2 = mid + 1;
    let i = 0;
    while (p1 <= mid && p2 <= r) {
        help[i++] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++];
    }
    while (p1 <= mid) {
        help[i++] = arr[p1++];
    }
    while (p2 <= r) {
        help[i++] = arr[p2++];
    }
    for (i = 0; i < help.length; i++) {
        arr[l + i] = help[i];
    }
}
```

