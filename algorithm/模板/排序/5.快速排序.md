### 5、快速排序

**时间复杂度：** `O(N*logN)`

**空间复杂度：** `O(logN)`

**稳定性：** 不稳定

**算法步骤：**

-   随机选取数列中的一个元素与最后一个元素交换，此时最后一个元素为"基准"(pivot);
-   设立双指针分别指向下标-1(left)和数列末尾(right)，代表小于基准的分区和大于基准的分区；
-   遍历数列，如果当前值小于基准，则与 left 指针下一位交换位置，left 指针+1；
-   如果当前值等于基准，继续遍历；
-   如果当前值大于基准，则与 right 指针前一位交换位置，right 指针-1，交换后的当前位置再与基准进行比较；
-   当前遍历位置与 right 指针相遇，终止遍历，返回当前的 left 和 right 指针；
-   根据返回的 left 和 right 指针，将小于基准的分区和大于基准的分区按照上述步骤递归排序；

```js
function quickSort(arr) {
    if (arr === null || arr.length < 2) {
        return;
    }
    function process(arr, l, r) {
        if (l < r) {
            swap(arr, Math.floor((r - l + 1) * Math.random() + l), r);
            const p = partition(arr, l, r);
            process(arr, l, p[0] - 1);
            process(arr, p[1] + 1, r);
        }
    }
    function partition(arr, l, r) { 
        let left = l - 1;
        let right = r;
        while (l < right) {
            if (arr[l] < arr[r]) {
                swap(arr, ++left, l++);
            } else if (arr[l] > arr[r]) {
                swap(arr, --right, l);
            } else {
                l++;
            }
        }
        swap(arr, right, r);
        return [left + 1, right];
    }
    process(arr, 0, arr.length - 1);
}
```