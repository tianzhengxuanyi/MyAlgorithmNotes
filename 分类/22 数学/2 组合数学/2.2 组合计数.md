### 2.2 组合计数

#### [3405. 统计恰好有 K 个相等相邻元素的数组数目](https://leetcode.cn/problems/count-the-number-of-arrays-with-k-matching-adjacent-elements/description/)
 
给你三个整数 n ，m ，k 。长度为 n 的 好数组 arr 定义如下：

- arr 中每个元素都在 闭 区间 [1, m] 中。
- 恰好 有 k 个下标 i （其中 1 <= i < n）满足 arr[i - 1] == arr[i] 。
- 请你返回可以构造出的 好数组 数目。

由于答案可能会很大，请你将它对 109 + 7 取余 后返回。


```js
/**
 * @param {number} n
 * @param {number} m
 * @param {number} k
 * @return {number}
 */
var countGoodArrays = function(n, m, k) {
    // C(n - 1, k) * m * (m - 1) ^ (n - 1 - k)
    // 问题转换为从n-1个相邻数对中选取k个相邻数相等的数对 == 从n-1个相邻数对中选取n - 1 - k个相邻数不等的数对
    // 第一个**数**有m种可能
    // 后续n - 1 - k个相邻数不等的数对，每个(i-1, i)中的i都有m - 1种可能
    // k个相邻数相等的数对不需要计算
        // 假设i-1, i, i+1 ... j，其中（i-1, i）为不等相邻数对，（i, i+1）为相等相邻数对
        // 当（i-1, i）中i确定后，（i, i+1）中i+1就被确定
    let ans = (fact[n-1] * invF[k]) % MOD;
    ans = (ans * invF[n - k - 1]) % MOD; // 计算C(n-1, k) = fact[n-1]/(fact[k]*fact[n-1-k])
    ans = (ans * BigInt(m)) % MOD; // 乘以第一个元素的选择数
    ans = (ans * qpow(m - 1, n - 1 - k)) % MOD; // 乘以不相等的相邻对的选择数
    return Number(ans);
};

const MX = 100001;
const MOD = BigInt(1e9 + 7);

// 快速幂函数，用于计算x^n mod MOD
const qpow = (x, n) => {
    x = BigInt(x), n = BigInt(n);
    let res = 1n;

    while (n > 0n) {
        if (n & 1n) {
            res = (res * x) % MOD;
        }
        x = (x * x) % MOD;
        n = n >> 1n;
    }

    return res;
}

// 预计算阶乘数组fact和阶乘的逆元数组invF
// C(n, k) =  n! / k! * (n - k - 1)! = fact[n] * invF[k] * invF[n - k];
// invF[n] = invF[n+1] * (n + 1) => 1 / n! = (1 / (n+1)!) * (n+1)
// (a / b) % mod = a * (b ^ (mod - 2)) % mod;

const fact = Array(MX);
fact[0] = 1n;

for (let i = 1; i < MX; i++) {
    fact[i] = (fact[i - 1] * BigInt(i)) % MOD // 计算i! = (i-1)! * i
}

const invF = Array(MX);
// 费马小定理计算最大阶乘的逆元: invF[MX-1] = (MX-1)!^(MOD-2) mod MOD
invF[MX - 1] = qpow(fact[MX - 1], MOD - 2n) % MOD;

// 递推计算所有阶乘的逆元: invF[i] = invF[i+1] * (i+1) mod MOD
for (let i = MX - 2; i >= 0; i--) {
    invF[i] = (invF[i+1] * BigInt(i+1)) % MOD;
}
```