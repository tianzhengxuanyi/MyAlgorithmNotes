### LogTrick


#### [2411. 按位或最大的最小子数组长度](https://leetcode.cn/problems/smallest-subarrays-with-maximum-bitwise-or/description)
 
给你一个长度为 n 下标从 0 开始的数组 nums ，数组中所有数字均为非负整数。对于 0 到 n - 1 之间的每一个下标 i ，你需要找出 nums 中一个 最小 非空子数组，它的起始位置为 i （包含这个位置），同时有 最大 的 按位或运算值 。

换言之，令 Bij 表示子数组 nums[i...j] 的按位或运算的结果，你需要找到一个起始位置为 i 的最小子数组，这个子数组的按位或运算的结果等于 max(Bik) ，其中 i <= k <= n - 1 。
一个数组的按位或运算值是这个数组里所有数字按位或运算的结果。

请你返回一个大小为 n 的整数数组 answer，其中 answer[i]是开始位置为 i ，按位或运算结果最大，且 最短 子数组的长度。

子数组 是数组里一段连续非空元素组成的序列。


```js
/**
 * 计算数组中每个起始位置的最小子数组长度，使得该子数组的按位或结果为最大可能值
 * @param {number[]} nums - 输入的非负整数数组
 * @return {number[]} - 结果数组，其中answer[i]表示起始位置为i的满足条件的最小子数组长度
 */
var smallestSubarrays = function(nums) {
    const n = nums.length;                  // 数组长度
    const ans = Array(n).fill(1);           // 结果数组，初始化为1（单个元素是最小可能子数组）
    
    // 外层循环：遍历每个元素作为子数组的结束位置
    for (let i = 0; i < n; i++) {
        // 内层循环：从i-1开始向前遍历，处理所有可能的起始位置j
        // 采用倒序遍历是因为按位或运算具有单调性（结果只增不减）
        for (let j = i - 1; j >= 0; j--) {
            // 若当前j位置的OR值已包含nums[i]的所有位（即OR结果不变），则无需继续向前计算
            // 因为继续向前的j' < j，其OR值只会更大或相等，不会需要更长的子数组
            if ((nums[j] | nums[i]) === nums[j]) break;
            
            // 更新j位置的OR值，纳入nums[i]的位信息
            nums[j] |= nums[i];
            // 更新j位置的最小子数组长度：从j到i共(i-j+1)个元素
            ans[j] = i - j + 1;
        }
    }

    return ans;
};

```