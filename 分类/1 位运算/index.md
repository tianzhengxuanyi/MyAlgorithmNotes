## [二进制](https://zhuanlan.zhihu.com/p/298441930)

## [分享｜从集合论到位运算，常见位运算技巧分类总结！](https://leetcode.cn/circle/discuss/CaOJ45/)

- 判断 x 中是否有相邻的 1: `x & (x >> 1)`
- 判断 x 的二进制位都为 1: `x & (x + 1)`
- 将 x 的最低位的 0 变为 1: `x |= (x + 1)`
- 移除 x 最低位的 1: `x & (x - 1)`
- 求 x 最低位的 1: `x & (-x)`

  > 假设 n 的二进制表示为 (a10⋯0)<sub>2</sub>，其中 a 表示若干个高位，1 表示最低位的那个 1，0⋯0 表示后面的若干个 0，那么 −n 的二进制表示为：
  >
  > (aˉ01⋯1)<sub>2</sub> +(1)<sub>2</sub> =(aˉ10⋯0)<sub>2</sub>
  >
  > 其中 aˉ 表示将 a 每一位取反。我们将 (a10⋯0)<sub>2</sub>​ 与 (aˉ10⋯0)<sub>2</sub>进行按位与运算，高位全部变为 0，最低位的 1 以及之后的所有 0 不变，
  > 这样我们就获取了 n 二进制表示的最低位的 1。

- 求 x 最高位的 1: `1 << (31 - __builtin_clz(x))`
- 判断一个数是否是2的幂: `x & (x - 1)`

**异或性质**
记 ⊕ 为异或运算，异或运算满足以下性质：

- x⊕x=0；
- x⊕y=y⊕x（交换律）；
- (x⊕y)⊕z=x⊕(y⊕z)（结合律）；
- x⊕y⊕y=x（自反性）；
- ∀i∈Z，有 4i⊕(4i+1)⊕(4i+2)⊕(4i+3)=0。
- (a&b)^(a&c) == a&(b^c)

![位运算异或1](../../image/位运算异或1.png)

## 位运算

| 符号 | 描述 | 运算规则                                                                                                                       |
| :--: | ---- | ------------------------------------------------------------------------------------------------------------------------------ |
|  &   | 与   | 两个位都为 1 时，结果才为 1                                                                                                    |
|  \|  | 或   | 两个位都为 0 时，结果才为 0                                                                                                    |
|  ^   | 异或 | 两个位相同为 0，相异为 1                                                                                                       |
|  ~   | 取反 | 0 变 1，1 变 0                                                                                                                 |
|  <<  | 左移 | 各二进位全部左移若干位，高位丢弃，低位补 0                                                                                     |
|  >>  | 右移 | 各二进位全部右移若干位，对无符号数，高位补 0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补 0（逻辑右移） |

### 1.按位与运算符（&）

**定义：** 参加运算的两个数据，按二进制位进行"与"运算。

运算规则：

```
0&0=0  0&1=0  1&0=0  1&1=1
```

总结：两位同时为 1，结果才为 1，否则结果为 0。

例如：`3&5` 即 `0000 0011 & 0000 0101 = 0000 0001`，因此 `3&5` 的值得 1。

注意：负数按补码形式参加按位与运算。

**与运算的用途：**

1）清零

如果想将一个单元清零，即使其全部二进制位为 0，只要与一个各位都为零的数值相与，结果为零。

2）取一个数的指定位

比如取数 X=1010 1110 的低 4 位，只需要另找一个数 Y，令 Y 的低 4 位为 1，其余位为 0，即 Y=0000 1111，然后将 X 与 Y 进行按位与运算（X&Y=0000 1110）即可得到 X 的指定位。

3）判断奇偶

只要根据最未位是 0 还是 1 来决定，为 0 就是偶数，为 1 就是奇数。因此可以用`if ((a & 1) == 0)`代替`if (a % 2 == 0)`来判断 a 是不是偶数。

### 2.按位或运算符（|）

**定义：** 参加运算的两个对象，按二进制位进行"或"运算。

运算规则：

```
0|0=0  0|1=1  1|0=1  1|1=1
```

总结：参加运算的两个对象只要有一个为 1，其值为 1。

例如：`3|5`即 `0000 0011 | 0000 0101 = 0000 0111`，因此，`3|5`的值得 7。

注意：负数按补码形式参加按位或运算。

**或运算的用途：**

1）常用来对一个数据的某些位设置为 1

比如将数 X=1010 1110 的低 4 位设置为 1，只需要另找一个数 Y，令 Y 的低 4 位为 1，其余位为 0，即 Y=0000 1111，然后将 X 与 Y 进行按位或运算（X|Y=1010 1111）即可得到。

### 3.异或运算符（^）

**定义：** 参加运算的两个数据，按二进制位进行"异或"运算。

运算规则：

```
0^0=0  0^1=1  1^0=1  1^1=0
```

总结：参加运算的两个对象，如果两个相应位相同为 0，相异为 1。

**异或的几条性质:**

- 1、交换律
- 2、结合律 (a^b)^c == a^(b^c)
- 3、对于任何数 x，都有 x^x=0，x^0=x
- 4、自反性: a^b^b=a^0=a;

**异或运算的用途：**

1）翻转指定位

比如将数 X=1010 1110 的低 4 位进行翻转，只需要另找一个数 Y，令 Y 的低 4 位为 1，其余位为 0，即 Y=0000 1111，然后将 X 与 Y 进行异或运算（X^Y=1010 0001）即可得到。

2）与 0 相异或值不变

例如：1010 1110 ^ 0000 0000 = 1010 1110

3）交换两个数

实例

```js
function Swap(a, b) {
  if (a != b) {
    a ^= b;
    b ^= a;
    a ^= b;
  }
}
```

### 4.取反运算符 (~)

**定义：** 参加运算的一个数据，按二进制进行"取反"运算。

运算规则：

```
~1=0
~0=1
```

总结：对一个二进制数按位取反，即将 0 变 1，1 变 0。

**异或运算的用途：**

1）使一个数的最低位为零

使 a 的最低位为 0，可以表示为：a & ~1。~1 的值为 1111 1111 1111 1110，再按"与"运算，最低位一定为 0。因为" ~"运算符的优先级比算术运算符、关系运算符、逻辑运算符和其他运算符都高。

### 5.左移运算符（<<）

**定义：** 将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补 0）。

设 a=1010 1110，a = a<< 2 将 a 的二进制位左移 2 位、右补 0，即得 a=1011 1000。

若左移时舍弃的高位不包含 1，则每左移一位，相当于该数乘以 2。

### 6.右移运算符（>>）

**定义：** 将一个数的各二进制位全部右移若干位，正数左补 0，负数左补 1，右边丢弃。

例如：a=a>>2 将 a 的二进制位右移 2 位，左补 0 或者 左补 1 得看被移数是正还是负。

操作数每右移一位，相当于该数除以 2。

### 7.复合赋值运算符

位运算符与赋值运算符结合，组成新的复合赋值运算符，它们是：

```
&=        例：a&=b    相当于     a=a&b

|=        例：a|=b    相当于     a=a|b

>>=      例：a>>=b   相当于     a=a>>b

<<=      例：a<<=b     相当于      a=a<<b

^=        例：a^=b    相当于   a=a^b
```

运算规则：和前面讲的复合赋值运算符的运算规则相似。

不同长度的数据进行位运算：如果两个不同长度的数据进行位运算时，系统会将二者按右端对齐，然后进行位运算。

以"与运算"为例说明如下：我们知道在 C 语言中 long 型占 4 个字节，int 型占 2 个字节，如果一个 long 型数据与一个 int 型数据进行"与运算"，右端对齐后，左边不足的位依下面三种情况补足，

- 1）如果整型数据为正数，左边补 16 个 0。
- 2）如果整型数据为负数，左边补 16 个 1。
- 3）如果整形数据为无符号数，左边也补 16 个 0。

如：long a=123；int b=1；计算 a& b。

如：long a=123；int b=-1；计算 a& b。

如：long a=123；unsigned intb=1；计算 a & b。

## [logTrick](https://leetcode.cn/problems/smallest-subarrays-with-maximum-bitwise-or/solutions/1830911/by-endlesscheng-zai1/)

### [模板](https://leetcode.cn/problems/smallest-subarrays-with-maximum-bitwise-or/solutions/1830911/by-endlesscheng-zai1/)

该模板可以做到

- 求出所有子数组的按位或的结果，以及值等于该结果的子数组的个数。
- 求按位或结果等于任意给定数字的子数组的最短长度/最长长度。
末尾列出了一些题目，均可以用该模板秒杀。

思考：对于起始位置为 i 的子数组的按位或，至多有多少种不同的结果？

根据或运算的性质，我们可以从 x=nums[i] 开始，不断往右扩展子数组，按位或的结果要么使 x 不变，要么让 x 的某些比特位的值由 0 变 1。最坏情况下从 x=0 出发，每次改变一个比特位，最终得到 2^29 −1<10 ^9 ，因此至多有 30 种不同的结果。这意味着我们可以递推计算所有按位或的结果。

另一个结论是，相同的按位或对应的子数组右端点会形成一个连续的区间，从而保证下面去重逻辑的正确性（这一性质还可以用来统计按位或结果及其对应的子数组的个数）。

据此，我们可以倒着遍历 nums，在遍历的同时，用一个数组 ors 维护以 i 为左端点的子数组的按位或的结果，及其对应的子数组右端点的最小值。继续遍历到 nums[i−1] 时，我们可以把 nums[i−1] 和 ors 中的每个值按位或，合并值相同的结果。

这样在遍历时，ors 中值最大的元素对应的子数组右端点的最小值，就是要求的最短子数组的右端点。

注：下面代码用到了原地去重的技巧，如果你对此并不熟悉，可以先做做  26. 删除有序数组中的重复项。

```js
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var smallestSubarrays = function (nums) {
  const n = nums.length;
  const ans = Array(n).fill(1);
  const ors = []; // 子数组所有可能的或值不超过30个，保存或值和或值的最小下标
  for (let i = n - 1; i >= 0; i--) {
    // 枚举左端点
    ors.push([0, i]);
    let k = 0;
    for (let or of ors) {
      // 计算当前左端点所有可能的或值
      or[0] |= nums[i];
      if (ors[k][0] == or[0]) {
        // 合并相同的或值
        ors[k][1] = or[1]; // 取更小的下标
      } else {
        k += 1;
        ors[k] = or;
      }
    }
    ors.length = k + 1;
    ans[i] = ors[0][1] - i + 1; // ors[i]的或值从大到小
  }
  return ans;
};
```

### [3171. 找到按位或最接近 K 的子数组](https://leetcode.cn/problems/find-subarray-with-bitwise-or-closest-to-k/description/)

给你一个数组 nums 和一个整数 k 。你需要找到 nums 的一个 子数组 ，满足子数组中所有元素按位或运算 OR 的值与 k 的 绝对差 尽可能 小 。换言之，你需要选择一个子数组 nums[l..r] 满足 |k - (nums[l] OR nums[l + 1] ... OR nums[r])| 最小。

请你返回 最小 的绝对差值。

子数组 是数组中连续的 非空 元素序列。

**思路：**

> 1. 双重遍历，将当前 nums[i]与依次与前面元素 nums[j]或运算，并将结果更新到 nums[j](更新后：`nums[j] = aj | aj+1 | ... | ai`)中，这样遍历结束可以得到所有子数组的或运算结果
> 2. 在遍历过程中计算与 k 的绝对差，得到最小的绝对差
> 3. 注意：双重遍历的时间复杂度为 O(n^2)，会超时
> 4. 优化：
>    1. 当 nums[i]与 nums[j]或运算的结果等于 nums[j]时，此时 nums[i]在于 j 前面的子数组的或运算结果相同，因此可以直接在 j 处 break；例如：`nums[i] | nums[j] = ai | nums[j] = nums[j]`，此时`nums[i] | nums[j-1] = ai | (aj-1 | aj | ... | ai-1) = ai | aj-1 | nums[j] = aj-1 | nums[j] = nums[j-1]`
>    2. 当 nums[i] 小于 10^9 时，nums[i]最多有 29 位 1，所以最多 29 论循环，因此可以将时间复杂度优化到 O(nlogU)，U 为 nums[i]的最大值

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var minimumDifference = function (nums, k) {
  const n = nums.length;
  let ans = Infinity;
  for (let i = 0; i < n; i++) {
    ans = Math.min(ans, Math.abs(k - nums[i]));
    for (let j = i - 1; j >= 0; j--) {
      if ((nums[j] | nums[i]) === nums[j]) break;
      nums[j] |= nums[i];
      ans = Math.min(ans, Math.abs(k - nums[j]));
    }
  }
  return ans;
};
```

### [2411. 按位或最大的最小子数组长度](https://leetcode.cn/problems/smallest-subarrays-with-maximum-bitwise-or/description/)

给你一个长度为 n 下标从 0 开始的数组 nums ，数组中所有数字均为非负整数。对于 0 到 n - 1 之间的每一个下标 i ，你需要找出 nums 中一个 最小 非空子数组，它的起始位置为 i （包含这个位置），同时有 最大 的 按位或运算值 。

换言之，令 Bij 表示子数组 nums[i...j] 的按位或运算的结果，你需要找到一个起始位置为 i 的最小子数组，这个子数组的按位或运算的结果等于 max(Bik) ，其中 i <= k <= n - 1 。
一个数组的按位或运算值是这个数组里所有数字按位或运算的结果。

请你返回一个大小为 n 的整数数组 answer，其中 answer[i]是开始位置为 i ，按位或运算结果最大，且 最短 子数组的长度。

子数组 是数组里一段连续非空元素组成的序列

```js
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var smallestSubarrays = function (nums) {
  const n = nums.length;
  const ans = Array(n).fill(1);
  const ors = []; // 子数组所有可能的或值不超过30个，保存或值和或值的最小下标
  for (let i = n - 1; i >= 0; i--) {
    // 枚举左端点
    ors.push([0, i]);
    let k = 0;
    for (let or of ors) {
      // 计算当前左端点所有可能的或值
      or[0] |= nums[i];
      if (ors[k][0] == or[0]) {
        // 合并相同的或值
        ors[k][1] = or[1]; // 取更小的下标
      } else {
        k += 1;
        ors[k] = or;
      }
    }
    ors.length = k + 1;
    ans[i] = ors[0][1] - i + 1; // ors[i]的或值从大到小
  }
  return ans;
};
```

## 题目

### 题目一

数组中一种数出现了奇数次，其他的出现了偶数次，找出出现奇数次的这个数（时间复杂度 O(N) 空间复杂度 O(1)）

**思路：** 出现偶数次的数自己和自己异或后为 0，异或满足结合律和交换律，所有元素异或即可的到结果

```js
function process(arr) {
  let res = 0;
  for (let i of arr) {
    res ^= i;
  }
  return res;
}
```

### 题目二

数组中两种数出现了奇数次，其他的出现了偶数次，找出出现奇数次的这个数（时间复杂度 O(N) 空间复杂度：O(1)）

**思路：** 设 a 和 b 是出现奇数次的两个数，a 不等于 b，即 a 和 b 必有一位数不一样，所有元素异或之后的结果就是 res = a^b 不为 0，当 res 有一位为 1 时，则说明这一位 a 和 b 不相等，则可将原数组分为两类，该位为 1 和为 0 的，将其中一类的全部元素进行异或，可得出其中一个奇数次的数记作 res'，再将其与 res 进行异或，得出另一个数。

补充：提取出一个数最右边的 1 的位置

`int rightOne = res & (~res +1 );`

举例：

      res：    1 0 1 0 1 1 1 1 0 0
      ~res：   0 1 0 1 0 0 0 0 1 1
      ~res+1： 0 1 0 1 0 0 0 1 0 0
      res & （~res+1）= 0 0 0 0 0 0 1 0 0

结果：

```js
function getOdd2(arr) {
  let res = 0;
  for (let i of arr) {
    res ^= i;
  }
  let rightOne = res & (~res + 1); // 提出最右侧的1
  let ans = 0;
  for (let i of arr) {
    if ((rightOne & i) === 0) {
      ans ^= i;
    }
  }
  return [ans, res ^ ans];
}
```

### 题目三

给定两个有符号 32 位整数 a 和 b，返回 a 和 b 中较大的。
【要求】
不用做任何比较判断。

### 题目四

判断一个 32 位正数是不是 2 的幂、4 的幂

### [3211. 生成不含相邻零的二进制字符串](https://leetcode.cn/problems/generate-binary-strings-without-adjacent-zeros/description/)

给你一个正整数 n。

如果一个二进制字符串 x 的所有长度为 2 的子字符串中包含 至少 一个 "1"，则称 x 是一个 有效 字符串。

返回所有长度为 n 的 有效 字符串，可以以任意顺序排列。

```js
/**
 * @param {number} n
 * @return {string[]}
 */
var validStrings = function (n) {
  const res = [];
  let mask = (1 << n) - 1;
  for (let i = 0; i < 1 << n; i++) {
    if ((i & (i >> 1)) === 0) {
      res.push((i ^ mask).toString(2).padStart(n, "0"));
    }
  }
  return res;
};
```
