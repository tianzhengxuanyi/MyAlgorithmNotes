### 11.6 矩阵快速幂优化 DP

**递归需严格满足递归式**，如斐波那契数列`F(n) = F(n-1) + F(n-2)`，必须在递归的每一层中都满足递归式，不存在其他条件分支返回结果`F(n)`

#### 斐波那契数列（leetcode 剑指offer10）

**思路1（递归）：**

时间复杂度O(n)

```js
function fib(n) {
    if (n < 2) {
        return n;
    }

    let a= 0, b = 0, dp = 1;
    for (let i = 2; i <= n; i++) {
        a = b;
        b = dp;
        dp = a + b;
    }

    return dp;
}
```

**思路2（简化）：**

时间复杂度O(logn)

递归严格满足递归式时，递归式满足如下规律：

递归式：`F(n) = F(n-1) + F(n-2)`

$|F(3), F(2)| = |F(2), F(1)| * \left[\begin{matrix}
    a & b \\
    c & d 
\end{matrix} \right]$

$|F(4), F(3)| = |F(3), F(2)| * \left[\begin{matrix}
    a & b \\
    c & d 
\end{matrix} \right]$

$|F(5), F(4)| = |F(4), F(3)| * \left[\begin{matrix}
    a & b \\
    c & d 
\end{matrix} \right]$

$........$

$|F(n), F(n-1)| = |F(n-1), F(n-2)| * \left[\begin{matrix}
    a & b \\
    c & d 
\end{matrix} \right]$

因此可以归纳得出：

$|F(n), F(n-1)| = |F(2), F(1)| * \left[\begin{matrix}
    a & b \\
    c & d 
\end{matrix} \right]^{n-2}$

在斐波那契数列中a = 1 b = 1 c = 1 d = 0;

所以$|F(n), F(n-1)| = |1, 1| * \left[\begin{matrix}
    1 & 1 \\
    1 & 0 
\end{matrix} \right]^{n-2}$

只要求解出矩阵matrix的n-2次方就可以得出`F(n)`;

**快速求解矩阵n次方（时间复杂度O(logn)）**

假设n的二进制为1000101，初始res为单位矩阵，t = matrix；

循环n的二级制位次，每次循环t = t * t，如果n的当前位上为1则res *= t；

如上述列子n = 69，二进制位1000101，每次循环时t分别为$m$、$m^2$、$m^4$、$m^8$、$m^{16}$、$m^{32}$、$m^{64}$，n在第1、3、7位时位1，则$res=m*m^4*m^{64}=m^{69}$;

```ts
type matrix = number[][];
function muliMatrix(m1: matrix, m2: matrix): matrix {
    if (m1[0].length !== m2.length) {
        throw new Error("长度不匹配");
    }

    const m = m1.length;
    const p = m2.length;
    const n = m2[0].length;

    const mat = new Array(m).fill(0).map(arr => new Array(n).fill(0));
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            for (let k = 0; k < p; k++) {
                mat[i][j] += m1[i][k] * m2[k][j];
            }
        }
    }

    return mat;
}
function matrixPower(mat: matrix, n: number): matrix {
    const m = mat.length;
    let res = new Array(m).fill(0).map((arr, index) =>{
        let temp =  new Array(m).fill(0)
        temp[index] = 1;
        return temp;
    });

    while (n > 0) {
        if (n & 1) {
            res = muliMatrix(res, mat);
        }
        mat = muliMatrix(mat, mat);
        n = n  >> 1;
    }

    return res;
}
function fib(n: number): number {
    if (n < 2) {
        return n
    }

    const mat = [[1,1],[1,0]];
    const matPower = matrixPower(mat, n -2);
    const resultMat = muliMatrix([[1,1]],matPower);
    return resultMat[0][0];
}
```

#### 推广到一般情况

递归式：$F(n) = a*F(n-1) + b*F(n-4) ... + c*F(n-m)$

可以转换成（只需要注意n减去最多的数m）：

$|F(n), F(n-1), F(n-2), F(n-3), F(n-4), ... ,F(n-m)| = |F(m), F(m-1),...F(1)|*matrix^{n-m}$，其中matrix为m*m的矩阵

**题目：**

农场中有一头母牛，每年会生下一头小母牛，小母牛三年后才能生孩子，问第n年农场有多少头母牛？（假设母牛不会死）

递归式： $F(n) = F(n-1) + F(n-3)$

**题目：**

农场中有一只母兔子，每年会生两只小母兔，小母兔需要两年才会成熟生孩子，每只兔子五年后就会死掉，问n年之后有多少只兔子？

递归式：$F(n) = F(n-1) + 2*F(n-2) - F(n-5)$

#### 1137. 第 N 个泰波那契数
 
泰波那契序列 Tn 定义如下： 

T0 = 0, T1 = 1, T2 = 1, 且在 n >= 0 的条件下 Tn+3 = Tn + Tn+1 + Tn+2

给你整数 n，请返回第 n 个泰波那契数 Tn 的值。

**动态规划：递推**

```js
/**
 * @param {number} n
 * @return {number}
 */
var tribonacci = function (n) {
    // 基础情况处理
    if (n == 0) return 0;       // T(0) = 0
    if (n < 3) return 1;        // T(1)=1, T(2)=1
    
    // 初始化前三个泰波那契数
    let p = 0,   // 相当于T(n-3)
        p1 = 1,  // 相当于T(n-2) 
        p2 = 1,   // 相当于T(n-1)
        p3 = 0;   // 将要计算的T(n)
    
    // 从T(3)开始迭代计算到T(n)
    for (let i = 3; i <= n; i++) {
        p3 = p2 + p1 + p;  // 泰波那契递推公式: T(n) = T(n-1)+T(n-2)+T(n-3)
        
        // 滚动更新变量，为下一次迭代准备
        p = p1,   // 原来的T(n-2)变成新的T(n-3)
        p1 = p2,  // 原来的T(n-1)变成新的T(n-2)
        p2 = p3;  // 新计算的T(n)变成新的T(n-1)
    }

    return p3;  // 返回第n个泰波那契数
};

```

**矩阵快速幂**

```js
/**
 * @param {number} n
 * @return {number}
 */
var tribonacci = function (n) {
    if (n == 0) return 0;       // T(0) = 0
    if (n < 3) return 1;        // T(1)=1, T(2)=1
    
    // 初始向量 [T2, T1, T0] = [1, 1, 0]
    const base = [[1, 1, 0]];
    // 转移矩阵 [[1,1,0],[1,0,1],[1,0,0]]
    const mat = [[1, 1, 0], [1, 0, 1], [1, 0, 0]];
    // 计算 base * mat^n
    const res = multiple(base, pow(mat, n))
    // 结果矩阵中的res[0][2]即为Tn的值
    return res[0][2];
};

/**
 * 矩阵乘法
 * @param {number[][]} mat1 矩阵1
 * @param {number[][]} mat2 矩阵2 
 * @returns {number[][]} 矩阵乘积
 */
const multiple = (mat1, mat2) => {
    const a = mat1.length, b = mat1[0].length, c = mat2.length, d = mat2[0].length;
    if (b !== c) return;  // 检查矩阵维度是否匹配

    // 初始化结果矩阵
    const res = Array.from({ length: a }, () => Array(d).fill(0));

    // 三重循环计算矩阵乘法
    for (let i = 0; i < a; i++) {
        for (let j = 0; j < d; j++) {
            for (let k = 0; k < b; k++) {
                res[i][j] += mat1[i][k] * mat2[k][j];
            }
        }
    }

    return res;
}

/**
 * 矩阵快速幂
 * @param {number[][]} mat 基础矩阵
 * @param {number} n 幂次
 * @returns {number[][]} 矩阵的n次幂
 */
const pow = (mat, n) => {
    let p = mat,  // 当前幂次的矩阵
        // 初始化单位矩阵
        res = Array.from({ length: mat.length }, () => Array(mat[0].length).fill(0));
    
    // 构造单位矩阵
    for (let i = 0; i < mat.length; i++) {
        res[i][i] = 1;
    }
    
    // 快速幂算法
    while (n) {
        if (n & 1) {  // 当前位为1时累乘到结果
            res = multiple(res, p);
        }
        n = n >> 1;    // 右移一位
        p = multiple(p, p);  // 矩阵平方
    }

    return res;
}

```

#### [1220. 统计元音字母序列的数目](https://leetcode.cn/problems/count-vowels-permutation/description/)
 
给你一个整数 n，请你帮忙统计一下我们可以按下述规则形成多少个长度为 n 的字符串：

字符串中的每个字符都应当是小写元音字母（'a', 'e', 'i', 'o', 'u'）
- 每个元音 'a' 后面都只能跟着 'e'
- 每个元音 'e' 后面只能跟着 'a' 或者是 'i'
- 每个元音 'i' 后面 不能 再跟着另一个 'i'
- 每个元音 'o' 后面只能跟着 'i' 或者是 'u'
- 每个元音 'u' 后面只能跟着 'a'
由于答案可能会很大，所以请你返回 模 10^9 + 7 之后的结果。

```js
/**
 * 计算长度为n的元音字母序列数量
 * @param {number} n - 字符串长度
 * @return {number} - 有效的元音序列数量
 */
var countVowelPermutation = function (n) {
    // 初始化DP数组，f[i][j]表示长度为i+1以第j个元音结尾的序列数
    // 元音顺序: a(0), e(1), i(2), o(3), u(4)
    const f = Array.from({ length: n }, () => Array(5).fill(0));
    
    // 基础情况：长度为1的字符串，每个元音各有一种可能
    f[0].fill(1);
    
    // 动态规划填充数组
    for (let i = 1; i < n; i++) {
        // 'a'只能跟在'e','i','u'后面
        f[i][0] = (f[i - 1][2] + f[i - 1][1] + f[i - 1][4]) % MOD;
        // 'e'只能跟在'a','i'后面
        f[i][1] = (f[i - 1][2] + f[i - 1][0]) % MOD;
        // 'i'只能跟在'e','o'后面
        f[i][2] = (f[i - 1][1] + f[i - 1][3]) % MOD;
        // 'o'只能跟在'i'后面
        f[i][3] = (f[i - 1][2]) % MOD;
        // 'u'只能跟在'i','o'后面
        f[i][4] = (f[i - 1][2] + f[i - 1][3]) % MOD;
    }

    // 返回所有长度为n以不同元音结尾的序列数之和
    return (f[n - 1][0] + f[n - 1][1] + f[n - 1][2] + f[n - 1][3] + f[n - 1][4]) % MOD;
};

// 模数，防止整数溢出
const MOD = 1e9 + 7;

// f[n][a] = f[n-1][e] + f[n-1][i] + f[n-1][u];
// f[n][e] = f[n-1][a] + f[n-1][i]
// f[n][i] = f[n-1][o] + f[n-1][e]
// f[n][o] = f[n-1][i]
// f[n][u] = f[n-1][i] + f[n-1][o]
```


```js
/**
 * 计算长度为n的元音字母序列数量（矩阵快速幂优化版）
 * @param {number} n - 字符串长度
 * @return {number} - 有效的元音序列数量
 */
var countVowelPermutation = function (n) {
    // 使用矩阵快速幂计算：SUM * (MAT^(n-1)) * BASE
    return Number(multiple(SUM, multiple(pow(MAT, n - 1), BASE))[0])
};

// 状态转移矩阵（根据题目规则构建）
// 行表示当前字符，列表示下一个字符
// 顺序: a(0), e(1), i(2), o(3), u(4)
const MAT = [
    [0n, 1n, 1n, 0n, 1n],  // a后面可以跟e,i,u
    [1n, 0n, 1n, 0n, 0n],  // e后面可以跟a,i
    [0n, 1n, 0n, 1n, 0n],  // i后面可以跟e,o
    [0n, 0n, 1n, 0n, 0n],  // o后面可以跟i
    [0n, 0n, 1n, 1n, 0n]   // u后面可以跟i,o
];

// 初始状态向量（长度为1时每个元音各有一种可能）
const BASE = [[1n], [1n], [1n], [1n], [1n]];

// 求和向量（用于将最终结果相加）
const SUM = [[1n, 1n, 1n, 1n, 1n]];

// 模数，防止整数溢出
const MOD = BigInt(1e9 + 7);

/**
 * 矩阵乘法
 * @param {bigint[][]} mat1 - 矩阵1
 * @param {bigint[][]} mat2 - 矩阵2
 * @return {bigint[][]} - 矩阵乘积
 */
const multiple = (mat1, mat2) => {
    const m = mat1.length, n = mat2[0].length;
    const res = Array.from({ length: m }, () => Array(n).fill(0n));
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            for (let k = 0; k < mat2.length; k++) {
                res[i][j] = (res[i][j] + (mat1[i][k] * mat2[k][j]) % MOD) % MOD;
            }
        }
    }
    return res;
}

/**
 * 矩阵快速幂
 * @param {bigint[][]} mat - 基础矩阵
 * @param {number} n - 幂次
 * @return {bigint[][]} - 矩阵的n次幂
 */
const pow = (mat, n) => {
    let m = mat.length;
    // 初始化单位矩阵
    let res = Array.from({ length: m }, () => Array(m).fill(0n));
    for (let i = 0; i < m; i++) {
        res[i][i] = 1n;
    }

    // 快速幂算法
    while (n) {
        if (n & 1) {
            res = multiple(res, mat);
        }
        mat = multiple(mat, mat);
        n = n >> 1;
    }

    return res;
}

// f[n][a] = f[n-1][e] + f[n-1][i] + f[n-1][u];
// f[n][e] = f[n-1][a] + f[n-1][i]
// f[n][i] = f[n-1][o] + f[n-1][e]
// f[n][o] = f[n-1][i]
// f[n][u] = f[n-1][i] + f[n-1][o]
```

#### [552. 学生出勤记录 II](https://leetcode.cn/problems/student-attendance-record-ii/description/)

可以用字符串表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：
- 'A'：Absent，缺勤
- 'L'：Late，迟到
- 'P'：Present，到场

如果学生能够 同时 满足下面两个条件，则可以获得出勤奖励：
- 按 总出勤 计，学生缺勤（'A'）严格 少于两天。
- 学生 不会 存在 连续 3 天或 连续 3 天以上的迟到（'L'）记录。

给你一个整数 n ，表示出勤记录的长度（次数）。请你返回记录长度为 n 时，可能获得出勤奖励的记录情况 数量 。答案可能很大，所以返回对 109 + 7 取余 的结果。

**动态规划：** 

- 状态定义： dfs(i, CA, CL) 表示 第 i 天时， 0 - i 天的A的数量为CA，第i天（包含第i天）向前连续L的数量为CL时， 可能获得出勤奖励的记录情况 数量。CA in [0, 1], CL in [0, 1, 2]
- 状态转移：
  - dfs(i, 0, 0) = dfs(i - 1, 0, 0) + dfs(i - 1, 0, 1) + dfs(i - 1, 0, 2)
  - dfs(i, 0, 1) = dfs(i - 1, 0, 0)
  - dfs(i, 0, 2) = dfs(i - 1, 0, 1)
  - dfs(i, 1, 0) = dfs(i - 1, 0, 0) + dfs(i - 1, 0, 1) + dfs(i - 1, 0, 2) + dfs(i - 1, 1, 0) + dfs(i - 1, 1,  1) + dfs(i - 1, 1, 2)
  - dfs(i, 1, 1) = dfs(i - 1, 1, 0)
  - dfs(i, 1, 2) = dfs(i - 1, 1, 1)

```js
/**
 * 检查出勤记录的有效组合数（矩阵快速幂优化版）
 * @param {number} n - 出勤记录的天数
 * @return {number} - 有效的出勤记录组合数
 */
var checkRecord = function (n) {
    // 计算状态转移矩阵的(n-1)次方，然后乘以初始状态向量
    const f = multiple(pow(factory, n - 1), f0);
    let ans = 0n;
    // 将所有可能的状态相加得到最终结果
    for (let i = 0; i < 6; i++) {
        ans = (ans + f[i][0]) % MOD;
    }

    return Number(ans);
};

// 模数，防止整数溢出
const MOD = BigInt(1e9 + 7);

// 状态转移矩阵（6x6矩阵，对应6种状态）
// 状态顺序: 
// 0: 无A，最后0个L
// 1: 无A，最后1个L
// 2: 无A，最后2个L
// 3: 有A，最后0个L
// 4: 有A，最后1个L
// 5: 有A，最后2个L
const factory = [
    [1n, 1n, 1n, 0n, 0n, 0n],  // 状态0的转移
    [1n, 0n, 0n, 0n, 0n, 0n],  // 状态1的转移
    [0n, 1n, 0n, 0n, 0n, 0n],  // 状态2的转移
    [1n, 1n, 1n, 1n, 1n, 1n],  // 状态3的转移
    [0n, 0n, 0n, 1n, 0n, 0n],  // 状态4的转移
    [0n, 0n, 0n, 0n, 1n, 0n]   // 状态5的转移
];

// 初始状态向量（第1天的情况）
const f0 = [
    [1n],  // 第1天P
    [1n],  // 第1天L
    [0n],  // 第1天不可能有连续2个L
    [1n],  // 第1天A
    [0n],  // 第1天不可能有A且1个L
    [0n]   // 第1天不可能有A且2个L
];

/**
 * 矩阵乘法
 * @param {bigint[][]} mat1 - 矩阵1
 * @param {bigint[][]} mat2 - 矩阵2
 * @return {bigint[][]} - 矩阵乘积
 */
const multiple = (mat1, mat2) => {
    const m = mat1.length, n = mat2[0].length;
    const res = Array.from({ length: m }, () => Array(n).fill(0n));

    // 三重循环计算矩阵乘法
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            for (let k = 0; k < mat2.length; k++) {
                res[i][j] = (res[i][j] + (mat1[i][k] * mat2[k][j]) % MOD) % MOD;
            }
        }
    }

    return res;
}

/**
 * 矩阵快速幂
 * @param {bigint[][]} mat - 基础矩阵
 * @param {number} n - 幂次
 * @return {bigint[][]} - 矩阵的n次幂
 */
const pow = (mat, n) => {
    const m = mat.length;
    // 初始化单位矩阵
    let res = Array.from({ length: m }, () => Array(m).fill(0n));
    for (let i = 0; i < m; i++) {
        res[i][i] = 1n;
    }

    // 快速幂算法
    while (n) {
        if (n & 1) {
            res = multiple(res, mat);
        }
        n = n >> 1;
        mat = multiple(mat, mat);
    }

    return res;
}

// f[i][CA][CL] 表示0 - 第i 天时A出现的次数为CA，i- 1、i- 2天L连续的天数为CL时可能获得的出勤奖励数量
// f[i][0][0] = f[i - 1][0][0] + f[i - 1][0][1] + f[i - 1][0][2]
// f[i][0][1] = f[i - 1][0][0]
// f[i][0][2] = f[i - 1][0][1]

// f[i][1][0] = (f[i - 1][0][0] + f[i - 1][0][1] + f[i - 1][0][2]) // 第i天选A
//             + (f[i-1][1][0] + f[i-1][1][1] + f[i-1][1][2])  // 第i天选P
// f[i][1][1] = f[i - 1][1][0] // 第i天选L
// f[i][1][2] = f[i - 1][1][1] // 第i天选L

```