### 11.1 前缀和优化DP

#### [2327. 知道秘密的人数](https://leetcode.cn/problems/number-of-people-aware-of-a-secret/description/)
 
在第 1 天，有一个人发现了一个秘密。

给你一个整数 delay ，表示每个人会在发现秘密后的 delay 天之后，每天 给一个新的人 分享 秘密。同时给你一个整数 forget ，表示每个人在发现秘密 forget 天之后会 忘记 这个秘密。一个人 不能 在忘记秘密那一天及之后的日子里分享秘密。

给你一个整数 n ，请你返回在第 n 天结束时，知道秘密的人数。由于答案可能会很大，请你将结果对 109 + 7 取余 后返回。

**动态规划：**

状态定义：dfs(i) 表示第i天知道秘密的新增人数

```js
/**
 * @param {number} n
 * @param {number} delay
 * @param {number} forget
 * @return {number}
 */
var peopleAwareOfSecret = function(n, delay, forget) {
    // 初始化记忆化数组，memo[i]表示第i天新增知道秘密的人数
    const memo = Array(n + 1).fill(-1);
    memo[0] = 0;  // 第0天没有人知道秘密
    
    // 定义DFS函数，计算第i天新增知道秘密的人数
    const dfs = (i) => {
        if (i == 1) return memo[i] = 1;  // 第1天有1人知道秘密
        if (memo[i] >= 0) return memo[i];  // 如果已经计算过，直接返回
        
        let res = 0;
        
        // 计算第i天新增人数：从i-delay天到i-forget+1天之间知道秘密的人会在第i天传播
        for (let j = Math.max(0, i - delay); j >= Math.max(i - forget + 1, 0); j--) {
            res = (res + dfs(j)) % MOD;  // 累加有效传播人数
        }
        
        return memo[i] = res;  // 记忆化并返回结果
    }

    let ans = 0;
    // 计算第n天结束时知道秘密的总人数：统计最后forget天内新增的人数
    for (let i = n; i >= Math.max(n - forget + 1, 1); i--) {
        ans = (ans + dfs(i)) % MOD;
    }

    return ans;
};

// 定义模数常量
const MOD = 1e9 + 7;

```


**递推：**

```js
/**
 * @param {number} n
 * @param {number} delay
 * @param {number} forget
 * @return {number}
 */
var peopleAwareOfSecret = function (n, delay, forget) {
    // 初始化DP数组，f[i]表示第i天新增知道秘密的人数
    const f = Array(n + 1).fill(0);
    f[1] = 1;  // 第1天有1人知道秘密
    
    // 动态规划递推计算每天新增人数
    for (let i = 1; i <= n; i++) {
        // 计算第i天新增人数：从i-delay天到i-forget+1天之间知道秘密的人会在第i天传播
        for (let j = Math.max(0, i - delay); j >= Math.max(i - forget + 1, 0); j--) {
            f[i] = (f[i] + f[j]) % MOD;  // 累加有效传播人数
        }
    }
    
    // 计算第n天结束时知道秘密的总人数
    let ans = 0;
    // 统计最后forget天内新增的人数（因为超过forget天的人会忘记）
    for (let i = n; i >= Math.max(n - forget + 1, 1); i--) {
        ans = (ans + f[i]) % MOD;
    }
    
    return ans;
};

// 定义模数常量，用于大数取余
const MOD = 1e9 + 7;

```


**前缀和优化：**

```js
/**
 * @param {number} n
 * @param {number} delay
 * @param {number} forget
 * @return {number}
 */
var peopleAwareOfSecret = function (n, delay, forget) {
    // f数组表示前缀和数组，f[i]表示第1天到第i天新增知道秘密的人数总和
    const f = Array(n + 1).fill(0);
    f[1] = 1;  // 第1天初始有1人知道秘密
    
    // 使用前缀和优化计算每天新增人数
    for (let i = 2; i <= n; i++) {
        // 计算f[i] = 
        // (能传播秘密的人数区间[i-delay, i-forget]的总人数(第i天新增的人数) + 前一天的前缀和) % MOD
        // 使用MOD防止负数出现
        f[i] = ((f[Math.max(0, i - delay)] - f[Math.max(i - forget, 0)] + MOD) % MOD + f[i - 1]) % MOD;
    }
    
    // 最终结果 = 最后forget天内新增的人数总和（因为超过forget天的人会忘记）
    return (f[n] - f[Math.max(n - forget , 0)] + MOD) % MOD;
};

// 定义模数常量，用于大数取余
const MOD = 1e9 + 7;

```

**刷表法：**

```js
/**
 * @param {number} n 总天数
 * @param {number} delay 传播延迟天数
 * @param {number} forget 遗忘天数
 * @return {number} 第n天结束时知道秘密的人数
 */
var peopleAwareOfSecret = function(n, delay, forget) {
    // f数组记录每天新增知道秘密的人数
    const f = Array(n + 1).fill(0);
    // 第1天初始有1人知道秘密
    f[1] = 1;
    
    // 刷表法：遍历每一天i，更新i能影响的天数j
    for (let i = 1;  i < n; i++) {
        // j的范围是i+delay到i+forget-1（因为forget天后会忘记）
        for (let j = i + delay; j < Math.min(i + forget, n + 1); j++) {
            // 第j天新增人数 += 第i天知道秘密的人数
            f[j] = (f[i] + f[j]) % MOD;
        }
    }

    // 计算最终结果：最后forget天内新增的人数总和
    let ans = 0;
    for (let i = n - forget + 1; i <= n; i++) {
        ans = (ans + f[i]) % MOD;
    }
    return ans;
};
// 模数常量，用于大数取余
const MOD = 1e9 + 7;

```


#### [1871. 跳跃游戏 VII](https://leetcode.cn/problems/jump-game-vii/description/)

给你一个下标从 0 开始的二进制字符串 s 和两个整数 minJump 和 maxJump 。一开始，你在下标 0 处，且该位置的值一定为 '0' 。当同时满足如下条件时，你可以从下标 i 移动到下标 j 处：

- i + minJump <= j <= min(i + maxJump, s.length - 1) 且
- s[j] == '0'.

如果你可以到达 s 的下标 s.length - 1 处，请你返回 true ，否则返回 false 。

**dfs + 记忆化：超时**

状态定义： dfs(i) 表示从i位置能否到达终点

状态转移方程： dfs(i) = dfs(i + minJump) || dfs(i + minJump + 1) || ... || dfs(i + maxJump)

```js
/**
 * @param {string} s
 * @param {number} minJump
 * @param {number} maxJump
 * @return {boolean}
 */
var canReach = function(s, minJump, maxJump) {
    const n = s.length;
    // 检查终点是否为'0'，不是则直接返回false
    if (s[n - 1] != 0) return false;
    
    // 记忆化数组，memo[i]表示从位置i能否到达终点
    const memo = Array(n);
    
    // DFS函数定义：判断从位置i能否到达终点
    const dfs = (i) => {
        // 基本情况：已经到达终点
        if (i == n - 1) return memo[i] = true;
        // 如果已经计算过，直接返回结果
        if (memo[i] !== undefined) return memo[i];
        
        // 尝试所有可能的跳跃距离
        for (let j = i + minJump; j <= Math.min(n - 1, i + maxJump); j++) {
            // 只有当目标位置是'0'且从该位置能到达终点时，才返回true
            if (s[j] == 0 && dfs(j)) {
                return memo[i] = true;
            }
        }
        
        // 所有可能跳跃都无法到达终点，返回false
        return memo[i] = false;
    }

    // 从起点0开始DFS
    return dfs(0)
};

```

**递推 + 前缀和优化：**

```js
/**
 * @param {string} s
 * @param {number} minJump
 * @param {number} maxJump
 * @return {boolean}
 */
var canReach = function(s, minJump, maxJump) {
    const n = s.length;
    // 检查终点是否为'0'，不是则直接返回false
    if (s[n - 1] != 0) return false;
    
    // cnt数组是前缀和数组，cnt[i]表示从位置i到末尾有多少个可达位置
    const cnt = Array(n + 1).fill(0);
    // 初始化终点位置为可达
    cnt[n - 1] = 1;

    // 从后向前动态规划计算每个位置的可达性
    for (let i = n - 2; i >= 0; i--) {
        // 如果当前位置是'0'，且在跳跃范围内有可达位置
        if (i <= n - 1 - minJump && s[i] == 0 && 
            cnt[i + minJump] - cnt[Math.min(i + maxJump, n - 1) + 1] > 0) {
            // 当前位置可达，前缀和+1
            cnt[i] = cnt[i + 1] + 1;
        } else {
            // 当前位置不可达，继承下一个位置的前缀和
            cnt[i] = cnt[i+1];
        }
    }
    
    // 检查起点0是否在跳跃范围内有可达位置
    return cnt[minJump] - cnt[Math.min(maxJump, n - 1) + 1] > 0;
};

```