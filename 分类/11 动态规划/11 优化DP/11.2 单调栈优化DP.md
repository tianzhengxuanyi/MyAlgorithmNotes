### 单调栈优化DP

#### [1335. 工作计划的最低难度](https://leetcode.cn/problems/minimum-difficulty-of-a-job-schedule/description/)

你需要制定一份 d 天的工作计划表。工作之间存在依赖，要想执行第 i 项工作，你必须完成全部 j 项工作（ 0 <= j < i）。

你每天 至少 需要完成一项任务。工作计划的总难度是这 d 天每一天的难度之和，而一天的工作难度是当天应该完成工作的最大难度。

给你一个整数数组 jobDifficulty 和一个整数 d，分别代表工作难度和需要计划的天数。第 i 项工作的难度是 jobDifficulty[i]。

返回整个工作计划的 最小难度 。如果无法制定工作计划，则返回 -1 。

**动态规划：**


```js
/**
 * @param {number[]} jobDifficulty
 * @param {number} d
 * @return {number}
 */
var minDifficulty = function (jobDifficulty, d) {
    const n = jobDifficulty.length;
    // 如果工作数量小于天数，无法分配（每天至少一个工作）
    if (n < d) return -1;
    // 初始化DP数组：f[i][j]表示前j个工作分成i+1天的最小难度
    const f = Array.from({ length: d }, () => Array(n).fill(Infinity));

    // 初始化第一天的情况：前i个工作的最大难度
    for (let i = 0, mx = 0; i < n; i++) {
        mx = Math.max(mx, jobDifficulty[i]);
        f[0][i] = mx;
    }

    // 从第2天开始计算
    for (let i = 1; i < d; i++) {
        // 第i天至少需要i+1个工作（因为前i天每天至少一个工作）
        for (let j = i; j < n; j++) {
            let res = Infinity, difficutly = jobDifficulty[j];
            // 尝试将第k到j个工作分配到第i天
            for (let k = j; k >= i; k--) {
                // 计算当前天的最大难度
                difficutly = Math.max(difficutly, jobDifficulty[k]);
                // 总难度 = 当前天的难度 + 前i-1天处理k-1个工作的最小难度
                res = Math.min(res, difficutly + f[i - 1][k - 1]);
            }
            f[i][j] = res;
        }
    }
    // 返回结果，如果仍然是Infinity则返回-1
    return f[d-1][n-1] > Infinity ? -1 : f[d-1][n-1];
};

```

**动态规划+单调栈优化：**

```js
/**
 * @param {number[]} jobDifficulty
 * @param {number} d
 * @return {number}
 */
var minDifficulty = function (jobDifficulty, d) {
    const n = jobDifficulty.length;
    if (n < d) return -1;
    const f = Array.from({ length: 2 }, () => Array(n).fill(Infinity));

    for (let i = 0, mx = 0; i < n; i++) {
        mx = Math.max(mx, jobDifficulty[i]);
        f[0][i] = mx;
    }

    for (let i = 1; i < d; i++) {
        const stack = [];
        for (let j = i; j < n; j++) {
            let m = f[(i - 1) % 2][j - 1];
            while (stack.length && jobDifficulty[stack[stack.length - 1][0]] < jobDifficulty[j]) {
                m = Math.min(m, stack.pop()[1]);
            }

            if (!stack.length) {
                f[i % 2][j] = m + jobDifficulty[j];
            } else {
                f[i % 2][j] = Math.min(m + jobDifficulty[j], f[i % 2][stack[stack.length - 1][0]]);
            }

            stack.push([j, m]);
        }
    }
    return f[(d - 1) % 2][n - 1] > Infinity ? -1 : f[(d - 1) % 2][n - 1];
};
```