#### 1137. 第 N 个泰波那契数
 
泰波那契序列 Tn 定义如下： 

T0 = 0, T1 = 1, T2 = 1, 且在 n >= 0 的条件下 Tn+3 = Tn + Tn+1 + Tn+2

给你整数 n，请返回第 n 个泰波那契数 Tn 的值。

**动态规划：递推**

```js
/**
 * @param {number} n
 * @return {number}
 */
var tribonacci = function (n) {
    // 基础情况处理
    if (n == 0) return 0;       // T(0) = 0
    if (n < 3) return 1;        // T(1)=1, T(2)=1
    
    // 初始化前三个泰波那契数
    let p = 0,   // 相当于T(n-3)
        p1 = 1,  // 相当于T(n-2) 
        p2 = 1,   // 相当于T(n-1)
        p3 = 0;   // 将要计算的T(n)
    
    // 从T(3)开始迭代计算到T(n)
    for (let i = 3; i <= n; i++) {
        p3 = p2 + p1 + p;  // 泰波那契递推公式: T(n) = T(n-1)+T(n-2)+T(n-3)
        
        // 滚动更新变量，为下一次迭代准备
        p = p1,   // 原来的T(n-2)变成新的T(n-3)
        p1 = p2,  // 原来的T(n-1)变成新的T(n-2)
        p2 = p3;  // 新计算的T(n)变成新的T(n-1)
    }

    return p3;  // 返回第n个泰波那契数
};

```

**矩阵快速幂**

```js
/**
 * @param {number} n
 * @return {number}
 */
var tribonacci = function (n) {
    if (n == 0) return 0;       // T(0) = 0
    if (n < 3) return 1;        // T(1)=1, T(2)=1
    
    // 初始向量 [T2, T1, T0] = [1, 1, 0]
    const base = [[1, 1, 0]];
    // 转移矩阵 [[1,1,0],[1,0,1],[1,0,0]]
    const mat = [[1, 1, 0], [1, 0, 1], [1, 0, 0]];
    // 计算 base * mat^n
    const res = multiple(base, pow(mat, n))
    // 结果矩阵中的res[0][2]即为Tn的值
    return res[0][2];
};

/**
 * 矩阵乘法
 * @param {number[][]} mat1 矩阵1
 * @param {number[][]} mat2 矩阵2 
 * @returns {number[][]} 矩阵乘积
 */
const multiple = (mat1, mat2) => {
    const a = mat1.length, b = mat1[0].length, c = mat2.length, d = mat2[0].length;
    if (b !== c) return;  // 检查矩阵维度是否匹配

    // 初始化结果矩阵
    const res = Array.from({ length: a }, () => Array(d).fill(0));

    // 三重循环计算矩阵乘法
    for (let i = 0; i < a; i++) {
        for (let j = 0; j < d; j++) {
            for (let k = 0; k < b; k++) {
                res[i][j] += mat1[i][k] * mat2[k][j];
            }
        }
    }

    return res;
}

/**
 * 矩阵快速幂
 * @param {number[][]} mat 基础矩阵
 * @param {number} n 幂次
 * @returns {number[][]} 矩阵的n次幂
 */
const pow = (mat, n) => {
    let p = mat,  // 当前幂次的矩阵
        // 初始化单位矩阵
        res = Array.from({ length: mat.length }, () => Array(mat[0].length).fill(0));
    
    // 构造单位矩阵
    for (let i = 0; i < mat.length; i++) {
        res[i][i] = 1;
    }
    
    // 快速幂算法
    while (n) {
        if (n & 1) {  // 当前位为1时累乘到结果
            res = multiple(res, p);
        }
        n = n >> 1;    // 右移一位
        p = multiple(p, p);  // 矩阵平方
    }

    return res;
}

```