### 7.2 不相交区间

- 将所有区间按照右端点分组。
- 枚举右端点(end)，计算以当前右端点为结尾的区间的最大价值(dp[i])。
   - 对于每个右端点，枚举所有以它为结尾的区间([start_i, end])。
   - dp[i]可以从dp[start_i - 1]转移而来，加上当前区间的价值。


#### [2830. 销售利润最大化](https://leetcode.cn/problems/maximize-the-profit-as-the-salesman/description/)

给你一个整数 n 表示数轴上的房屋数量，编号从 0 到 n - 1 。

另给你一个二维整数数组 offers ，其中 offers[i] = [starti, endi, goldi] 表示第 i 个买家想要以 goldi 枚金币的价格购买从 starti 到 endi 的所有房屋。

作为一名销售，你需要有策略地选择并销售房屋使自己的收入最大化。

返回你可以赚取的金币的最大数目。

注意 同一所房屋不能卖给不同的买家，并且允许保留一些房屋不进行出售。

```js
/**
 * 动态规划解决房屋销售利润最大化问题
 * @param {number} n 房屋总数（0 到 n-1）
 * @param {number[][]} offers 买家报价数组 [start, end, gold]
 * @return {number} 最大利润
 */
var maximizeTheProfit = function (n, offers) {
  // 按结束位置分组存储报价（gorup应为group，可能是拼写错误）
  const gorup = new Map();
  for (let [start, end, offer] of offers) {
    let g = gorup.get(end) ?? [];
    g.push([start, offer]);  // 存储起始位置和对应报价
    gorup.set(end, g);
  }

  // 初始化DP数组，dp[i]表示前i个房屋的最大利润
  const dp = Array(n).fill(0);
  
  // 初始化第一个房屋的报价
  for (let [_, offer] of gorup.get(0) ?? []) {
    dp[0] = Math.max(dp[0], offer); // 取最大的报价
  }

  // 动态规划主循环
  for (let i = 1; i < n; i++) {
    dp[i] = dp[i - 1]; // 默认不选当前房屋
    
    // 检查所有以i为结束位置的报价
    let g = gorup.get(i) ?? [];
    for (let [start, offer] of g) {
      // 状态转移方程：选择当前报价 + 之前区间最大利润
      dp[i] = Math.max(dp[i], offer + (dp[start - 1] ?? 0));
    }
  }

  return dp[n - 1]; // 返回最终结果
};
```
