### 7.1 一维 DP

发生在前缀/后缀之间的转移，例如从 f[i−1] 转移到 f[i]，或者从 f[j] 转移到 f[i]。

#### [2140. 解决智力问题](https://leetcode.cn/problems/solving-questions-with-brainpower/description/)

给你一个下标从 0 开始的二维整数数组 questions ，其中 questions[i] = [pointsi, brainpoweri] 。

这个数组表示一场考试里的一系列题目，你需要 按顺序 （也就是从问题 0 开始依次解决），针对每个问题选择 解决 或者 跳过 操作。解决问题 i 将让你 获得 pointsi 的分数，但是你将 无法 解决接下来的 brainpoweri 个问题（即只能跳过接下来的 brainpoweri 个问题）。如果你跳过问题 i ，你可以对下一个问题决定使用哪种操作。

比方说，给你 questions = [[3, 2], [4, 3], [4, 4], [2, 5]] ：
如果问题 0 被解决了， 那么你可以获得 3 分，但你不能解决问题 1 和 2 。
如果你跳过问题 0 ，且解决问题 1 ，你将获得 4 分但是不能解决问题 2 和 3 。
请你返回这场考试里你能获得的 最高 分数。

```js
/**
 * @param {number[][]} questions
 * @return {number}
 */
var mostPoints = function (questions) {
  // 获取问题的总数
  const n = questions.length;
  // 初始化动态规划数组，用于存储从每个问题开始能获得的最大分数
  const dp = Array(n).fill(0);
  // 最后一个问题的最大分数就是它本身的分数
  dp[n - 1] = questions[n - 1][0];
  // 从倒数第二个问题开始向前遍历
  for (let i = n - 2; i >= 0; i--) {
    // 对于每个问题，有两种选择：
    // 1. 回答当前问题，获得其分数，并跳过指定数量的问题
    // 2. 跳过当前问题，直接考虑下一个问题
    // 取两者中的最大值作为当前问题的最大分数
    dp[i] = Math.max(
      questions[i][0] + (dp[i + 1 + questions[i][1]] ?? 0),
      dp[i + 1]
    );
  }

  // 返回从第一个问题开始能获得的最大分数
  return dp[0];
};
```
