### 子数组 DP

转移方程：

- 以 i 为结尾的子数组的和：dp[i] = Math.max(nums[i], dp[i - 1] + nums[i])。

- 以 i 为结尾的子数组的积：dp[i] = Math.max(nums[i], dp[i - 1] * nums[i])。

#### [3524. 求出数组的 X 值 I 刷表法](https://leetcode.cn/problems/find-x-value-of-array-i/description/)

给你一个由 正 整数组成的数组 nums，以及一个 正 整数 k。

你可以对 nums 执行 一次 操作，该操作中可以移除任意 不重叠 的前缀和后缀，使得 nums 仍然 非空 。

你需要找出 nums 的 x 值，即在执行操作后，剩余元素的 乘积 除以 k 后的 余数 为 x 的操作数量。

返回一个大小为 k 的数组 result，其中 result[x] 表示对于 0 <= x <= k - 1，nums 的 x 值。

数组的 前缀 指从数组起始位置开始到数组中任意位置的一段连续子数组。

数组的 后缀 是指从数组中任意位置开始到数组末尾的一段连续子数组。

子数组 是数组中一段连续的元素序列。

注意，在操作中选择的前缀和后缀可以是 空的 。

**刷表法：**

在刷表法的状态转移过程中，会进行形如 y \* nums[i] % k 的乘法和取模运算。

因为 k 较小， y 的取值范围有限（ 0 到 k - 1 ），所以乘法运算的次数是可控的。

1. 与查表法对比

- 查表法：依据已知的状态转移来源算目标状态值。比如在动态规划里，已知 dp[i] = dp[i - 1] + dp[i - 2]，计算 dp[i]的值时，就去查 dp[i - 1]和 dp[i - 2]这两个来源状态的值，然后按方程计算，这是从目标状态找来源状态计算。

- 刷表法：从已知的状态出发，去更新它能影响到的其他状态。不是先确定目标状态再找来源，而是从当前状态主动去更新其他状态。

2. 本题刷表法示例：定义 f[i + 1][x]表示右端点为 i 的、元素积模 k 等于 x 的子数组个数，v = nums[i]。

- 已知以 i - 1 为右端点的子数组模 k 余数为 y（y 的取值范围是从 0 到 k - 1），对应子数组个数是 f[i][y]。

- 新加入 v 后，新子数组（以 i 为右端点）模 k 结果为 y _ v % k，就把 f[i][y]的数量累加到 f[i + 1]y _ v % k]上。

- 举个例子，若 k = 5，f[3][2] = 10，v = 3，2 \* 3 % 5 = 1，就把 f[3][2]的 10 累加到 f[4][1]上，这是从 f[3][2]这个已知状态主动去更新 f[4][1]状态，而不是先确定要算 f[4][1]，再去找怎么得到它。

3. 刷表法优势：在本题中，如果用查表法，也就是先确定目标状态 f[i + 1][x]，然后倒推哪些 y 能使 y _ v % k = x，这比较困难，因为可能有多个 y 满足条件，计算起来复杂。而刷表法从已知的 y 出发，直接计算 y _ v % k 就能容易更新对应的状态，让状态转移的计算过程更简便。

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
var resultArray = function (nums, k) {
  const n = nums.length;
  const ans = Array(k).fill(0); // 最终结果：每个余数的出现次数
  const dp = Array.from({ length: n }, () => Array(k).fill(0)); // 刷表法DP数组

  // 刷表法核心逻辑：遍历每个元素，将当前状态"刷"到下一个位置
  for (let i = 0; i < n; i++) {
    let mod = nums[i] % k;

    for (let x = 0; x < k; x++) {
      // 1. 单独当前元素的情况（长度为1的子数组）
      dp[i][x] += mod == x; // 初始化当前状态

      // 2. 刷表法核心转移：将当前状态传递到下一个元素
      if (i + 1 < n) {
        // 转移方程：dp[i+1][(x * num) % k] += dp[i][x]
        // 含义：将当前余数x与下个元素相乘后的新余数状态进行累加
        const newMod = (x * nums[i + 1]) % k;
        dp[i + 1][newMod] += dp[i][x]; // 状态转移
      }

      // 累加所有以nums[i]结尾的子数组的余数情况
      ans[x] += dp[i][x];
    }
  }

  return ans;
};
```
