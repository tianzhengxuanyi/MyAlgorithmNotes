### 合法子序列DP

计算合法子序列的最长长度、个数、元素和等。

一般定义 f[x] 表示以元素 x 结尾的合法子序列的最长长度/个数/元素和，从子序列的倒数第二个数转移过来。

注意这里的 x 不是下标，是元素值。如果 x 不是整数，或者值域范围很大，可以用哈希表代替数组。

#### [2501. 数组中最长的方波](https://leetcode.cn/problems/longest-square-streak-in-an-array/description/)
 
给你一个整数数组 nums 。如果 nums 的子序列满足下述条件，则认为该子序列是一个 **方波** ：

子序列的长度至少为 **2** ，并且
将子序列从小到大排序 **之后** ，除第一个元素外，每个元素都是前一个元素的 **平方** 。
返回 **nums** 中 **最长方波** 的长度，如果不存在 **方波** 则返回 -1 。

子序列 也是一个数组，可以由另一个数组删除一些或不删除元素且不改变剩余元素的顺序得到。


**排序+DP**： 枚举每个元素作为结尾的最长方波长度，从Math.sqrt(x)转移过来。
```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var longestSquareStreak = function (nums) {
    nums.sort((a, b) => a - b);
    const map = new Map();
    let ans = -1;
    for (let num of nums) {
        map.set(num, (map.get(Math.sqrt(num)) ?? 0) + 1);
        ans = Math.max(map.get(num), ans);
    }
    return ans < 2 ? -1 : ans;
};
```

**记忆化搜索**： 枚举每个元素作为开头的最长方波长度，从x^2转移过来。
```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var longestSquareStreak = function (nums) {
    // 使用 Set 实现 O(1) 时间复杂度的存在性检查
    const set = new Set(nums);
    // 记忆化存储，记录已计算过的数字的最长序列长度
    const map = new Map();

    // 递归定义：计算以 x 为起点的平方波最大长度
    const dfs = (x) => {
        // 已经计算过直接返回缓存值
        if (map.has(x)) return map.get(x);  
        // 不存在该数字时序列中断
        if (!set.has(x)) return 0;         

        // 递归查找 x^2 的后续序列长度
        let r = 1 + dfs(x * x);
        map.set(x, r);  // 缓存计算结果
        return r;
    }

    let ans = -1;
    // 遍历所有数字计算最大序列长度
    for (let num of nums) {
        ans = Math.max(ans, dfs(num));
    }

    // 根据题意返回结果（至少需要 2 个元素）
    return ans < 2 ? -1 : ans;  
};
```

#### [1218. 最长定差子序列(哈希DP)](https://leetcode.cn/problems/longest-arithmetic-subsequence-of-given-difference/description/)

给你一个整数数组 arr 和一个整数 difference，请你找出并返回 arr 中最长等差子序列的长度，该子序列中相邻元素之间的差等于 difference 。

子序列 是指在不改变其余元素顺序的情况下，通过删除一些元素或不删除任何元素而从 arr 派生出来的序列。



**动态规划(哈希DP)**: 枚举每个元素作为结尾的最长定差子序列长度，从x-difference转移过来。
```js
/**
 * @param {number[]} arr
 * @param {number} difference
 * @return {number}
 */
var longestSubsequence = function (arr, difference) {
    // 动态规划哈希表：存储以数字n结尾的最长定差子序列长度
    const dp = new Map();
    let ans = 0; // 记录全局最大值
    
    // 遍历数组中的每个数字
    for (let n of arr) {
        // 当前数字的前驱值应为 n - difference
        // 获取前驱值的序列长度（若无则取0），当前数字序列长度+1
        dp.set(n, (dp.get(n - difference) ?? 0) + 1);
        
        // 更新全局最大长度
        ans = Math.max(ans, dp.get(n));
    }
    
    return ans;
};
```

#### [1027. 最长等差数列](https://leetcode.cn/problems/longest-arithmetic-subsequence/)

给你一个整数数组 nums，返回 nums 中最长等差子序列的长度。

回想一下，nums 的子序列是一个列表 nums[i1], nums[i2], ..., nums[ik] ，且 0 <= i1 < i2 < ... < ik <= nums.length - 1。并且如果 seq[i+1] - seq[i]( 0 <= i < seq.length - 1) 的值都相同，那么序列 seq 是等差的。

**动态规划**：枚举所有可能的公差d(-mx~mx), 转换为求[1218. 最长定差子序列](https://leetcode.cn/problems/longest-arithmetic-subsequence-of-given-difference/description/)。

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var longestArithSeqLength = function(nums) {
    const mx = Math.max(...nums); // 获取数组最大值用于确定公差范围
    let ans = 0;
    
    // 遍历所有可能的公差d（从负最大值到正最大值）
    for (let d = -mx; d <= mx; d++) {
        // dp数组记录以每个数字结尾的等差序列长度
        let dp = Array(mx + 1); 
        
        // 遍历数组元素构建DP
        for (let x of nums) {
            // 当前元素的前驱值 = x - d，如果存在则累加长度
            dp[x] = (dp[x - d] ?? 0) + 1; 
            // 更新全局最大值
            ans = Math.max(ans, dp[x]); 
        }
    }

    return ans; // 返回找到的最长序列长度
};
```

#### [2826. 将三个组排序](https://leetcode.cn/problems/sorting-three-groups/description/)
 
给你一个整数数组 nums 。nums 的每个元素是 1，2 或 3。在每次操作中，你可以删除 nums 中的一个元素。返回使 nums 成为 非递减 顺序所需操作数的 最小值。

**合法子序列DP**: 枚举每个元素作为结尾的合法子序列长度，从y(y <= x)转移过来。

dp[x - 1] 表示以元素 x 结尾的合法子序列的最长子序列长度。

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var minimumOperations = function (nums) {
    const dp = [0, 0, 0];
    for (let num of nums) {
        if (num === 1) {
            dp[0] += 1;
        } else if (num == 2){
            dp[1] = Math.max(dp[0], dp[1]) + 1;
        } else {
            dp[2] = Math.max(dp[0], dp[1], dp[2]) + 1;
        }
    }

    return nums.length - Math.max(...dp);
};
```

**最长递增子序列**：

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var minimumOperations = function (nums) {
    let ng = 0;
    for (let x of nums) {
        let i = lowerBound(nums, x + 1, 0, ng - 1); // 查找大于x的数的最小索引
        if (i >= ng) {
            nums[ng++] = x;
        } else {
            nums[i] = x;
        }
    }

    return nums.length - ng;
};

const lowerBound = (nums, target, left, right) => {
    let l = left, r = right;

    while (l <= r) {
        let mid = Math.floor((r - l) / 2) + l;
        if (nums[mid] < target) {
            l = mid + 1;
        } else {
            r = mid - 1;
        }
    }

    return l;
}
```