### 合法子序列DP

计算合法子序列的最长长度、个数、元素和等。

一般定义 f[x] 表示以元素 x 结尾的合法子序列的最长长度/个数/元素和，从子序列的倒数第二个数转移过来。

注意这里的 x 不是下标，是元素值。如果 x 不是整数，或者值域范围很大，可以用哈希表代替数组。

#### [2501. 数组中最长的方波](https://leetcode.cn/problems/longest-square-streak-in-an-array/description/)
 
给你一个整数数组 nums 。如果 nums 的子序列满足下述条件，则认为该子序列是一个 **方波** ：

子序列的长度至少为 **2** ，并且
将子序列从小到大排序 **之后** ，除第一个元素外，每个元素都是前一个元素的 **平方** 。
返回 **nums** 中 **最长方波** 的长度，如果不存在 **方波** 则返回 -1 。

子序列 也是一个数组，可以由另一个数组删除一些或不删除元素且不改变剩余元素的顺序得到。


**排序+DP**： 枚举每个元素作为结尾的最长方波长度，从Math.sqrt(x)转移过来。
```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var longestSquareStreak = function (nums) {
    nums.sort((a, b) => a - b);
    const map = new Map();
    let ans = -1;
    for (let num of nums) {
        map.set(num, (map.get(Math.sqrt(num)) ?? 0) + 1);
        ans = Math.max(map.get(num), ans);
    }
    return ans < 2 ? -1 : ans;
};
```

**记忆化搜索**： 枚举每个元素作为开头的最长方波长度，从x^2转移过来。
```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var longestSquareStreak = function (nums) {
    // 使用 Set 实现 O(1) 时间复杂度的存在性检查
    const set = new Set(nums);
    // 记忆化存储，记录已计算过的数字的最长序列长度
    const map = new Map();

    // 递归定义：计算以 x 为起点的平方波最大长度
    const dfs = (x) => {
        // 已经计算过直接返回缓存值
        if (map.has(x)) return map.get(x);  
        // 不存在该数字时序列中断
        if (!set.has(x)) return 0;         

        // 递归查找 x^2 的后续序列长度
        let r = 1 + dfs(x * x);
        map.set(x, r);  // 缓存计算结果
        return r;
    }

    let ans = -1;
    // 遍历所有数字计算最大序列长度
    for (let num of nums) {
        ans = Math.max(ans, dfs(num));
    }

    // 根据题意返回结果（至少需要 2 个元素）
    return ans < 2 ? -1 : ans;  
};
```

#### [1218. 最长定差子序列(哈希DP)](https://leetcode.cn/problems/longest-arithmetic-subsequence-of-given-difference/description/)

给你一个整数数组 arr 和一个整数 difference，请你找出并返回 arr 中最长等差子序列的长度，该子序列中相邻元素之间的差等于 difference 。

子序列 是指在不改变其余元素顺序的情况下，通过删除一些元素或不删除任何元素而从 arr 派生出来的序列。



**动态规划(哈希DP)**: 枚举每个元素作为结尾的最长定差子序列长度，从x-difference转移过来。
```js
/**
 * @param {number[]} arr
 * @param {number} difference
 * @return {number}
 */
var longestSubsequence = function (arr, difference) {
    // 动态规划哈希表：存储以数字n结尾的最长定差子序列长度
    const dp = new Map();
    let ans = 0; // 记录全局最大值
    
    // 遍历数组中的每个数字
    for (let n of arr) {
        // 当前数字的前驱值应为 n - difference
        // 获取前驱值的序列长度（若无则取0），当前数字序列长度+1
        dp.set(n, (dp.get(n - difference) ?? 0) + 1);
        
        // 更新全局最大长度
        ans = Math.max(ans, dp.get(n));
    }
    
    return ans;
};
```

#### [1027. 最长等差数列](https://leetcode.cn/problems/longest-arithmetic-subsequence/)

给你一个整数数组 nums，返回 nums 中最长等差子序列的长度。

回想一下，nums 的子序列是一个列表 nums[i1], nums[i2], ..., nums[ik] ，且 0 <= i1 < i2 < ... < ik <= nums.length - 1。并且如果 seq[i+1] - seq[i]( 0 <= i < seq.length - 1) 的值都相同，那么序列 seq 是等差的。

**动态规划**：枚举所有可能的公差d(-mx~mx), 转换为求[1218. 最长定差子序列](https://leetcode.cn/problems/longest-arithmetic-subsequence-of-given-difference/description/)。

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var longestArithSeqLength = function(nums) {
    const mx = Math.max(...nums); // 获取数组最大值用于确定公差范围
    let ans = 0;
    
    // 遍历所有可能的公差d（从负最大值到正最大值）
    for (let d = -mx; d <= mx; d++) {
        // dp数组记录以每个数字结尾的等差序列长度
        let dp = Array(mx + 1); 
        
        // 遍历数组元素构建DP
        for (let x of nums) {
            // 当前元素的前驱值 = x - d，如果存在则累加长度
            dp[x] = (dp[x - d] ?? 0) + 1; 
            // 更新全局最大值
            ans = Math.max(ans, dp[x]); 
        }
    }

    return ans; // 返回找到的最长序列长度
};
```

#### [2826. 将三个组排序](https://leetcode.cn/problems/sorting-three-groups/description/)
 
给你一个整数数组 nums 。nums 的每个元素是 1，2 或 3。在每次操作中，你可以删除 nums 中的一个元素。返回使 nums 成为 非递减 顺序所需操作数的 最小值。

**合法子序列DP**: 枚举每个元素作为结尾的合法子序列长度，从y(y <= x)转移过来。

dp[x - 1] 表示以元素 x 结尾的合法子序列的最长子序列长度。

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var minimumOperations = function (nums) {
    const dp = [0, 0, 0];
    for (let num of nums) {
        if (num === 1) {
            dp[0] += 1;
        } else if (num == 2){
            dp[1] = Math.max(dp[0], dp[1]) + 1;
        } else {
            dp[2] = Math.max(dp[0], dp[1], dp[2]) + 1;
        }
    }

    return nums.length - Math.max(...dp);
};
```

**最长递增子序列**：

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var minimumOperations = function (nums) {
    let ng = 0;
    for (let x of nums) {
        let i = lowerBound(nums, x + 1, 0, ng - 1); // 查找大于x的数的最小索引
        if (i >= ng) {
            nums[ng++] = x;
        } else {
            nums[i] = x;
        }
    }

    return nums.length - ng;
};

const lowerBound = (nums, target, left, right) => {
    let l = left, r = right;

    while (l <= r) {
        let mid = Math.floor((r - l) / 2) + l;
        if (nums[mid] < target) {
            l = mid + 1;
        } else {
            r = mid - 1;
        }
    }

    return l;
}
```

#### [2370. 最长理想子序列](https://leetcode.cn/problems/longest-ideal-subsequence/description/)

给你一个由小写字母组成的字符串 s ，和一个整数 k 。如果满足下述条件，则可以将字符串 t 视作是 理想字符串 ：

t 是字符串 s 的一个子序列。
t 中每两个 相邻 字母在字母表中位次的绝对差值小于或等于 k 。
返回 最长 理想字符串的长度。

字符串的子序列同样是一个字符串，并且子序列还满足：可以经由其他字符串删除某些字符（也可以不删除）但不改变剩余字符的顺序得到。

注意：字母表顺序不会循环。例如，'a' 和 'z' 在字母表中位次的绝对差值是 25 ，而不是 1 。

**动态规划：** 枚举元素x作为结尾的最长理想子序列长度，从元素y状态转移(x.charCodeAt() - k <= y.charCodeAt() <= x.charCodeAt() + k)。

```js
/**
 * @param {string} s
 * @param {number} k
 * @return {number}
 */
var longestIdealString = function (s, k) {
    const dp = Array(26).fill(0);
    let ans = 0;
    for (let char of s) {
        let chr = char.charCodeAt() - 97;
        let res = 0;
        for (let j = Math.max(chr - k, 0); j <= Math.min(chr + k, 25); j++) {
            res = Math.max(res, (dp[j] ?? 0) + 1);
        }
        dp[chr] = res;
        ans = Math.max(ans, dp[chr]);
    }
    return ans;
};
```

#### [873. 最长的斐波那契子序列的长度](https://leetcode.cn/problems/length-of-longest-fibonacci-subsequence/description/)
 
如果序列 X_1, X_2, ..., X_n 满足下列条件，就说它是 斐波那契式 的：

- n >= 3
- 对于所有 i + 2 <= n，都有 X_i + X_{i+1} = X_{i+2}

给定一个严格递增的正整数数组形成序列 arr ，找到 arr 中最长的斐波那契式的子序列的长度。如果一个不存在，返回  0 。

（回想一下，子序列是从原序列 arr 中派生出来的，它从 arr 中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如， [3, 5, 8] 是 [3, 4, 5, 6, 7, 8] 的一个子序列）

**动态规划：** dp[i][j] 表示以 arr[i] 和 arr[j] 结尾的最长斐波那契式子序列的长度，dp[i][j] = dp[k][i] + 1 (arr[k] + arr[i] = arr[j])。

```js
/**
 * @param {number[]} arr
 * @return {number}
 */
var lenLongestFibSubseq = function (arr) {
    const n = arr.length;
    // 使用嵌套Map记录状态：dp.get(a).get(b) 表示以 b,a 结尾的斐波那契序列长度
    const dp = new Map(); 
    let ans = 0;
    
    // 遍历所有可能的序列最后一个元素（斐波那契序列至少需要三个元素）
    for (let i = 1; i < n; i++) {
        // 当前数字对应的状态表，记录所有可能的前驱数字
        let map = dp.get(arr[i]) ?? new Map();
        
        // 逆向遍历前驱数字，寻找满足 a + b = arr[i] 的组合
        for (let j = i - 1; j >= 0 && arr[i] - arr[j] > 0; j--) {
            // 计算以arr[j] arr[i]结尾的前一个斐波那契数
            let prev = arr[i] - arr[j];
            // 获取以 arr[j] 结尾，前驱为 prev 的序列长度（默认长度为1，表示新序列）
            let prevLen = dp.get(arr[j])?.get(prev) ?? 1;
            
            // 更新当前序列长度：prevLen + 1 表示将 arr[i] 加入序列
            map.set(arr[j], prevLen + 1);
            ans = Math.max(ans, prevLen + 1);
        }
        
        dp.set(arr[i], map);
    }

    // 斐波那契序列至少需要3个元素（长度为3表示包含起始三元组）
    return ans < 3 ? 0 : ans;
};
```

#### [3202. 找出有效子序列的最大长度 II](https://leetcode.cn/problems/find-the-maximum-length-of-valid-subsequence-ii/description/)

给你一个整数数组 nums 和一个 正 整数 k 。
nums 的一个 子序列 sub 的长度为 x ，如果其满足以下条件，则称其为 有效子序列 ：

(sub[0] + sub[1]) % k == (sub[1] + sub[2]) % k == ... == (sub[x - 2] + sub[x - 1]) % k
返回 nums 的 最长有效子序列 的长度。

**动态规划：** 

- 枚举(sub[x - 2] + sub[x - 1]) % k 可能的余数 i
- sub[x - 1] % k = m => sub[x - 2] % k = (i - m + k) % k
- dp[m] 表示在有效子序列的余数为i是， 以 余数为m 的数结尾的最长子序列长度，dp[m] = dp[(i - m + k) % k] + 1

```js
var maximumLength = function(nums, k) {
    let ans = 0;
    // 遍历所有可能的余数偏移量 (0 到 k-1)
    for (let i = 0; i < k; i++) {
        // dp数组记录当前余数位置的最长子序列长度
        let dp = Array(k).fill(0);

        // 遍历数组元素
        for (let x of nums) {
            let m = x % k; // 计算当前元素的余数
            // 核心状态转移方程：寻找满足条件的上一个余数位置
            // (i - m + k) % k 保证非负，计算前一个有效位置
            dp[m] = dp[(i - m + k) % k] + 1;
            ans = Math.max(ans, dp[m]); // 更新全局最大值
        }
    }

    return ans; // 返回所有可能情况中的最大长度
};
```

#### [1048. 最长字符串链](https://leetcode.cn/problems/longest-string-chain/submissions/633038454/)
 
给出一个单词数组 words ，其中每个单词都由小写英文字母组成。

如果我们可以 不改变其他字符的顺序 ，在 wordA 的任何地方添加 恰好一个 字母使其变成 wordB ，那么我们认为 wordA 是 wordB 的 前身 。

例如，"abc" 是 "abac" 的 前身 ，而 "cba" 不是 "bcad" 的 前身
词链是单词 [word_1, word_2, ..., word_k] 组成的序列，k >= 1，其中 word1 是 word2 的前身，word2 是 word3 的前身，依此类推。一个单词通常是 k == 1 的 单词链 。

从给定单词列表 words 中选择单词组成词链，返回 词链的 最长可能长度 。

**记忆化搜索**： 枚举元素x作为结尾的最长字符串链长度，从y(y.length = x.length - 1)转移过来(删除一个字符)。

```js
/**
 * @param {string[]} words
 * @return {number}
 */
var longestStrChain = function(words) {
    const set = new Set(words);
    const dp = new Map();
    const dfs = (word) => {
        if (!set.has(word)) return 0;
        if (dp.has(word)) return dp.get(word);
        let res = 0;
        for (let i = 0; i < word.length; i++) {
            let next = word.slice(0, i) + word.slice(i+1);
            res = Math.max(res, dfs(next));
        }
        dp.set(word, res + 1);
        return res + 1;
    }
    let ans = 0;
    for (let word of words) {
        ans = Math.max(ans, dfs(word));
    }
    return ans;
};
```