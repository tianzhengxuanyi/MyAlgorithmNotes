
### 7.6 多维DP

#### [2222. 选择建筑的方案数](https://leetcode.cn/problems/number-of-ways-to-select-buildings/description/)

给你一个下标从 0 开始的二进制字符串 s ，它表示一条街沿途的建筑类型，其中：

s[i] = '0' 表示第 i 栋建筑是一栋办公楼，
s[i] = '1' 表示第 i 栋建筑是一间餐厅。
作为市政厅的官员，你需要随机 选择 3 栋建筑。然而，为了确保多样性，选出来的 3 栋建筑 相邻 的两栋不能是同一类型。

比方说，给你 s = "001101" ，我们不能选择第 1 ，3 和 5 栋建筑，因为得到的子序列是 "011" ，有相邻两栋建筑是同一类型，所以 不合 题意。
请你返回可以选择 3 栋建筑的 有效方案数 。

**动态规划：记忆化缓存  超时**
```js
/**
 * @param {string} s
 * @return {number}
 */
var numberOfWays = function (s) {
    const n = s.length;
    // 三维DP数组：dp[i][k][type]
    // i: 当前处理到的字符索引
    // k: 剩余需要选择的建筑数量 (3->2->1->0)
    // type: 最后一个选择的建筑类型 (0或1)
    const dp = Array.from({ length: n }, () => 
        Array.from({ length: 4 }, () => [-1, -1])); // 初始化记忆化缓存

    // 深度优先搜索（带记忆化）
    const dfs = (i, k, type) => {
        // 递归终止条件：已选够3个建筑
        if (k === 0) return 1;
        // 边界条件：索引越界
        if (i < 0) return 0;
        // 检查缓存
        if (dp[i][k][type] >= 0) return dp[i][k][type];
        
        // 不选当前建筑的情况
        let res = dfs(i - 1, k, type);
        // 如果当前建筑符合要求的类型（需要与前一个类型交替）
        if (s[i] == type) {  // 注意这里应该是严格等于字符类型比较
            // 选择当前建筑，并切换下一个需要的类型（1 ^ type取反）
            res += dfs(i - 1, k - 1, 1 ^ type);
        }

        return dp[i][k][type] = res; // 记录缓存
    }

    // 最终结果：以0结尾的方案数 + 以1结尾的方案数
    return dfs(n - 1, 3, 1) + dfs(n - 1, 3, 0);
};
```

**动态规划：空间优化**
```js
/**
 * @param {string} s
 * @return {number}
 */
var numberOfWays = function (s) {
    const n = s.length;
    // 空间优化后的DP数组：dp[k][type]
    // k: 当前已选择的建筑数量 (1-3)
    // type: 最后一个选择的建筑类型 (0或1)
    const dp = Array.from({ length: 4 }, () => [0, 0]); // 初始化状态矩阵
    
    let prev; // 保存上一层状态
    for (let i = 1; i <= n; i++) {
        // 初始化第一层状态（选择1个建筑）
        prev = [1, 1];  // 基准情况：每个独立字符都可作为起点
        
        for (let k = 1; k <= 3; k++) {
            // 核心状态转移：当前字符类型为type时，累加上一层的相反类型数量
            // 1 ^ (s[i-1]-0) 实现类型翻转（0->1，1->0）
            dp[k][s[i - 1] - 0] += prev[1 ^ (s[i - 1] - 0)];
            
            // 保存当前层状态用于下一轮迭代
            prev = [...dp[k]]; // 解构赋值实现数组拷贝
        }
    }

    // 返回选择3个建筑的两种类型方案之和
    return dp[3][0] + dp[3][1];
};

```

**统计'010'和'101'的方案数：**
```js
var numberOfWays = function (s) {
    const n = s.length;
    // 统计字符串中总共有多少个0和1
    let total0 = 0, total1 = 0;
    for (let i = 0; i < n; i++) {
        if (s[i] == 0) {
            total0 += 1;
        } else {
            total1 += 1;
        }
    }

    let ans = 0;
    // 倒序遍历时，统计已遍历部分0和1的数量
    let cnt0 = 0, cnt1 = 0;
    for (let i = n - 1; i >= 0; i--) {
        if (s[i] == 0) {
            // 当遇到0时，组合模式为1-0-1：
            // cnt1是右侧已统计的1数量，(total1 - cnt1)是左侧剩余的1数量
            ans += cnt1 * (total1 - cnt1);
            cnt0 += 1;
        } else {
            // 当遇到1时，组合模式为0-1-0：
            // cnt0是右侧已统计的0数量，(total0 - cnt0)是左侧剩余的0数量
            ans += cnt0 * (total0 - cnt0);
            cnt1 += 1;
        }
    }

    return ans;
};

```

#### [2400. 恰好移动 k 步到达某一位置的方法数目](https://leetcode.cn/problems/number-of-ways-to-reach-a-position-after-exactly-k-steps/description/)
 
给你两个 正 整数 startPos 和 endPos 。最初，你站在 无限 数轴上位置 startPos 处。在一步移动中，你可以向左或者向右移动一个位置。

给你一个正整数 k ，返回从 startPos 出发、恰好 移动 k 步并到达 endPos 的 不同 方法数目。由于答案可能会很大，返回对 109 + 7 取余 的结果。

如果所执行移动的顺序不完全相同，则认为两种方法不同。

注意：数轴包含负整数。

**动态规划：记忆化缓存**
```js
var numberOfWays = function (startPos, endPos, k) {
    // 记忆化缓存：dp[r].get(i) 表示剩余r步时，在位置i的方案数
    const dp = Array.from({ length: k + 1 }, () => new Map());
    
    // 深度优先搜索函数
    const dfs = (r, i) => {
        if (dp[r].has(i)) return dp[r].get(i); // 已缓存的结果直接返回
        
        // 剪枝：剩余步数不足以到达目标位置
        if (Math.abs(endPos - i) > r) {
            dp[r].set(i, 0);
            return 0;
        }
        
        // 递归终止条件：步数用尽
        if (r == 0) {
            dp[r].set(i, i === endPos ? 1 : 0);
            return dp[r].get(i);
        }
        
        // 状态转移：向左或向右移动一步，结果取模
        dp[r].set(i, (dfs(r - 1, i + 1) + dfs(r - 1, i - 1)) % mod);
        return dp[r].get(i);
    }

    return dfs(k, startPos); // 从初始状态开始搜索
};

const mod = 1e9 + 7; // 题目要求的取模基数
```

**组合数学**

```js
/**
 * @param {number} startPos
 * @param {number} endPos
 * @param {number} k
 * @return {number}
 */
var numberOfWays = function (startPos, endPos, k) {
    // 计算起点到终点的绝对距离
    let step = Math.abs(startPos - endPos);
    // 剩余步数 = 总步数 - 必须步数
    let rest = k - step;
    
    // 剪枝条件：总步数不足 或 剩余步数为奇数时无法返回
    if (step > k || rest % 2) return 0;

    // 组合数学解法：C(k, m) 其中m = (必须步数 + 剩余步数/2)
    const C = Array.from({ length: k + 1 }, () => Array(k + 1).fill(0));

    // 构建组合数表（帕斯卡三角形）
    for (let i = 0; i <= k; i++) {
        C[i][0] = 1; // 任何数选0个的方案都是1
        for (let j = 1; j <= i; j++) {
            // 组合数递推公式，结果取模
            C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod;
        }
    }
    // 返回组合数结果：需要step步向目标方向，rest/2步来回抵消
    return C[k][step + rest / 2];
};

const mod = 1e9 + 7; // 题目要求的模数
```

#### [1262. 可被三整除的最大和](https://leetcode.cn/problems/greatest-sum-divisible-by-three/description/)
 
给你一个整数数组 nums，请你找出并返回能被三整除的元素 最大和。

**动态规划：空间优化**

dp[i][j] 表示前 i 个元素中，模 3 余 j 的最大和。

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSumDivThree = function (nums) {
    let ans = 0;
    // 空间优化后的滚动数组：dp[当前索引%2][余数]
    // 初始化时将非初始状态设为 -Infinity (表示不可达)
    let dp = Array.from({ length: 2 }, () => Array(3).fill(-Infinity))
    // 初始状态：第一个元素的余数位置存储该元素值
    dp[0][nums[0] % 3] = nums[0];
    
    for (let i = 1; i < nums.length; i++) {
        let m = nums[i] % 3; // 当前元素模3的余数
        // 倒序遍历余数状态，避免覆盖未使用的状态
        for (let j = 2; j >= 0; j--) {
            // 状态转移：取不选当前元素 vs 选当前元素的最大值
            // (3 + j - m) % 3 是数学等价写法，避免负数取模
            dp[i % 2][j] = Math.max(
                dp[(i + 1) % 2][j], // 不选当前元素，继承上一状态
                dp[(i + 1) % 2][(3 + j - m) % 3] + nums[i] // 选当前元素
            );
            // 处理当前元素单独构成子集的情况（当余数匹配时）
            if (m === j) {
                dp[i % 2][j] = Math.max(dp[i % 2][j], nums[i]);
            }
        }
        // 更新最大值（仅关注能被3整除的情况）
        ans = Math.max(ans, dp[i % 2][0]);
    }
    return ans;
};

```

#### [3332. 旅客可以得到的最多点数 1828](https://leetcode.cn/problems/maximum-points-tourist-can-earn/)

给你两个整数 n 和 k ，和两个二维整数数组 stayScore 和 travelScore 。

一位旅客正在一个有 n 座城市的国家旅游，每座城市都 直接 与其他所有城市相连。这位游客会旅游 恰好 k 天（下标从 0 开始），且旅客可以选择 任意 城市作为起点。

每一天，这位旅客都有两个选择：

- 留在当前城市：如果旅客在第 i 天停留在前一天所在的城市 curr ，旅客会获得 stayScore[i][curr] 点数。
- 前往另外一座城市：如果旅客从城市 curr 前往城市 dest ，旅客会获得 travelScore[curr][dest] 点数。

请你返回这位旅客可以获得的 最多 点数。

**动态规划：记忆化搜索**
```js
var maxScore = function(n, k, stayScore, travelScore) {
    // 记忆化缓存数组：dp[i][j] 表示在第i天位于j城市时的最大累计得分
    const dp = Array.from({length: k + 1}, () => Array(n).fill(-1));
    
    // 深度优先搜索函数
    const dfs = (i, j) => {
        if (i == k) return dp[i][j] = 0; // 递归终止条件：天数用尽
        if (dp[i][j] >= 0) return dp[i][j]; // 已计算过的状态直接返回
        
        // 选择1：留在当前城市
        let res = dfs(i + 1, j) + stayScore[i][j];
        
        // 选择2：移动到其他城市
        for (let next = 0; next < n; next++) {
            if (next === j) continue; // 不能停留在当前城市
            // 递归计算移动后的得分，取最大值
            res = Math.max(res, dfs(i+1, next) + travelScore[j][next]);
        }

        return dp[i][j] = res; // 记录并返回当前状态的最大值
    }

    // 遍历所有可能的起始城市，寻找最大得分
    let ans = 0;
    for (let j = 0; j < n; j++) {
        ans = Math.max(ans, dfs(0, j));
    }

    return ans;
};

```

**动态规划：空间优化**

```js
/**
 * @param {number} n
 * @param {number} k
 * @param {number[][]} stayScore
 * @param {number[][]} travelScore
 * @return {number}
 */
var maxScore = function (n, k, stayScore, travelScore) {
    // 使用滚动数组优化空间复杂度：dp[当前天数%2][城市编号]
    const dp = Array.from({ length: 2 }, () => Array(n).fill(0));
    
    // 倒序处理每一天（从最后一天往前计算）
    for (let i = k - 1; i >= 0; i--) {
        // 遍历所有城市
        for (let j = 0; j < n; j++) {
            // 选择1：停留在当前城市（继承前一天同一城市的状态）
            dp[i % 2][j] = dp[(i + 1) % 2][j] + stayScore[i][j];
            
            // 选择2：移动到其他城市（遍历所有可能的目标城市）
            for (let next = 0; next < n; next++) {
                if (next === j) continue; // 跳过当前城市
                // 比较移动后的得分，取最大值（继承前一天目标城市的状态）
                dp[i % 2][j] = Math.max(
                    dp[i % 2][j],
                    dp[(i + 1) % 2][next] + travelScore[j][next]
                );
            }
        }
    }

    // 返回第0天所有城市中的最大得分
    return Math.max(...dp[0]);
};
```


#### [3176. 求出最长好子序列 I 1849](https://leetcode.cn/problems/find-the-maximum-length-of-a-good-subsequence-i/description/)

给你一个整数数组 nums 和一个 非负 整数 k 。如果一个整数序列 seq 满足在下标范围 [0, seq.length - 2] 中 最多只有 k 个下标 i 满足 seq[i] != seq[i + 1] ，那么我们称这个整数序列为 好 序列。

请你返回 nums 中 好 子序列 的最长长度。

#### [1269. 停在原地的方案数 1854]()
#### [3250. 单调数组对的数目 I 1898]()

作者：灵茶山艾府
链接：https://leetcode.cn/discuss/post/3581838/fen-xiang-gun-ti-dan-dong-tai-gui-hua-ru-007o/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。