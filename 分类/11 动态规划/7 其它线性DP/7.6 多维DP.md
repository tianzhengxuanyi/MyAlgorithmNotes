
### 7.6 多维DP

#### [2222. 选择建筑的方案数](https://leetcode.cn/problems/number-of-ways-to-select-buildings/description/)

给你一个下标从 0 开始的二进制字符串 s ，它表示一条街沿途的建筑类型，其中：

s[i] = '0' 表示第 i 栋建筑是一栋办公楼，
s[i] = '1' 表示第 i 栋建筑是一间餐厅。
作为市政厅的官员，你需要随机 选择 3 栋建筑。然而，为了确保多样性，选出来的 3 栋建筑 相邻 的两栋不能是同一类型。

比方说，给你 s = "001101" ，我们不能选择第 1 ，3 和 5 栋建筑，因为得到的子序列是 "011" ，有相邻两栋建筑是同一类型，所以 不合 题意。
请你返回可以选择 3 栋建筑的 有效方案数 。

**动态规划：记忆化缓存  超时**
```js
/**
 * @param {string} s
 * @return {number}
 */
var numberOfWays = function (s) {
    const n = s.length;
    // 三维DP数组：dp[i][k][type]
    // i: 当前处理到的字符索引
    // k: 剩余需要选择的建筑数量 (3->2->1->0)
    // type: 最后一个选择的建筑类型 (0或1)
    const dp = Array.from({ length: n }, () => 
        Array.from({ length: 4 }, () => [-1, -1])); // 初始化记忆化缓存

    // 深度优先搜索（带记忆化）
    const dfs = (i, k, type) => {
        // 递归终止条件：已选够3个建筑
        if (k === 0) return 1;
        // 边界条件：索引越界
        if (i < 0) return 0;
        // 检查缓存
        if (dp[i][k][type] >= 0) return dp[i][k][type];
        
        // 不选当前建筑的情况
        let res = dfs(i - 1, k, type);
        // 如果当前建筑符合要求的类型（需要与前一个类型交替）
        if (s[i] == type) {  // 注意这里应该是严格等于字符类型比较
            // 选择当前建筑，并切换下一个需要的类型（1 ^ type取反）
            res += dfs(i - 1, k - 1, 1 ^ type);
        }

        return dp[i][k][type] = res; // 记录缓存
    }

    // 最终结果：以0结尾的方案数 + 以1结尾的方案数
    return dfs(n - 1, 3, 1) + dfs(n - 1, 3, 0);
};
```

**动态规划：空间优化**
```js
/**
 * @param {string} s
 * @return {number}
 */
var numberOfWays = function (s) {
    const n = s.length;
    // 空间优化后的DP数组：dp[k][type]
    // k: 当前已选择的建筑数量 (1-3)
    // type: 最后一个选择的建筑类型 (0或1)
    const dp = Array.from({ length: 4 }, () => [0, 0]); // 初始化状态矩阵
    
    let prev; // 保存上一层状态
    for (let i = 1; i <= n; i++) {
        // 初始化第一层状态（选择1个建筑）
        prev = [1, 1];  // 基准情况：每个独立字符都可作为起点
        
        for (let k = 1; k <= 3; k++) {
            // 核心状态转移：当前字符类型为type时，累加上一层的相反类型数量
            // 1 ^ (s[i-1]-0) 实现类型翻转（0->1，1->0）
            dp[k][s[i - 1] - 0] += prev[1 ^ (s[i - 1] - 0)];
            
            // 保存当前层状态用于下一轮迭代
            prev = [...dp[k]]; // 解构赋值实现数组拷贝
        }
    }

    // 返回选择3个建筑的两种类型方案之和
    return dp[3][0] + dp[3][1];
};

```

**统计'010'和'101'的方案数：**
```js
var numberOfWays = function (s) {
    const n = s.length;
    // 统计字符串中总共有多少个0和1
    let total0 = 0, total1 = 0;
    for (let i = 0; i < n; i++) {
        if (s[i] == 0) {
            total0 += 1;
        } else {
            total1 += 1;
        }
    }

    let ans = 0;
    // 倒序遍历时，统计已遍历部分0和1的数量
    let cnt0 = 0, cnt1 = 0;
    for (let i = n - 1; i >= 0; i--) {
        if (s[i] == 0) {
            // 当遇到0时，组合模式为1-0-1：
            // cnt1是右侧已统计的1数量，(total1 - cnt1)是左侧剩余的1数量
            ans += cnt1 * (total1 - cnt1);
            cnt0 += 1;
        } else {
            // 当遇到1时，组合模式为0-1-0：
            // cnt0是右侧已统计的0数量，(total0 - cnt0)是左侧剩余的0数量
            ans += cnt0 * (total0 - cnt0);
            cnt1 += 1;
        }
    }

    return ans;
};

```

#### [2400. 恰好移动 k 步到达某一位置的方法数目](https://leetcode.cn/problems/number-of-ways-to-reach-a-position-after-exactly-k-steps/description/)
 
给你两个 正 整数 startPos 和 endPos 。最初，你站在 无限 数轴上位置 startPos 处。在一步移动中，你可以向左或者向右移动一个位置。

给你一个正整数 k ，返回从 startPos 出发、恰好 移动 k 步并到达 endPos 的 不同 方法数目。由于答案可能会很大，返回对 109 + 7 取余 的结果。

如果所执行移动的顺序不完全相同，则认为两种方法不同。

注意：数轴包含负整数。

**动态规划：记忆化缓存**
```js
var numberOfWays = function (startPos, endPos, k) {
    // 记忆化缓存：dp[r].get(i) 表示剩余r步时，在位置i的方案数
    const dp = Array.from({ length: k + 1 }, () => new Map());
    
    // 深度优先搜索函数
    const dfs = (r, i) => {
        if (dp[r].has(i)) return dp[r].get(i); // 已缓存的结果直接返回
        
        // 剪枝：剩余步数不足以到达目标位置
        if (Math.abs(endPos - i) > r) {
            dp[r].set(i, 0);
            return 0;
        }
        
        // 递归终止条件：步数用尽
        if (r == 0) {
            dp[r].set(i, i === endPos ? 1 : 0);
            return dp[r].get(i);
        }
        
        // 状态转移：向左或向右移动一步，结果取模
        dp[r].set(i, (dfs(r - 1, i + 1) + dfs(r - 1, i - 1)) % mod);
        return dp[r].get(i);
    }

    return dfs(k, startPos); // 从初始状态开始搜索
};

const mod = 1e9 + 7; // 题目要求的取模基数
```

**组合数学**

```js
/**
 * @param {number} startPos
 * @param {number} endPos
 * @param {number} k
 * @return {number}
 */
var numberOfWays = function (startPos, endPos, k) {
    // 计算起点到终点的绝对距离
    let step = Math.abs(startPos - endPos);
    // 剩余步数 = 总步数 - 必须步数
    let rest = k - step;
    
    // 剪枝条件：总步数不足 或 剩余步数为奇数时无法返回
    if (step > k || rest % 2) return 0;

    // 组合数学解法：C(k, m) 其中m = (必须步数 + 剩余步数/2)
    const C = Array.from({ length: k + 1 }, () => Array(k + 1).fill(0));

    // 构建组合数表（帕斯卡三角形）
    for (let i = 0; i <= k; i++) {
        C[i][0] = 1; // 任何数选0个的方案都是1
        for (let j = 1; j <= i; j++) {
            // 组合数递推公式，结果取模
            C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod;
        }
    }
    // 返回组合数结果：需要step步向目标方向，rest/2步来回抵消
    return C[k][step + rest / 2];
};

const mod = 1e9 + 7; // 题目要求的模数
```

#### [1262. 可被三整除的最大和](https://leetcode.cn/problems/greatest-sum-divisible-by-three/description/)
 
给你一个整数数组 nums，请你找出并返回能被三整除的元素 最大和。

**动态规划：空间优化**

dp[i][j] 表示前 i 个元素中，模 3 余 j 的最大和。

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSumDivThree = function (nums) {
    let ans = 0;
    // 空间优化后的滚动数组：dp[当前索引%2][余数]
    // 初始化时将非初始状态设为 -Infinity (表示不可达)
    let dp = Array.from({ length: 2 }, () => Array(3).fill(-Infinity))
    // 初始状态：第一个元素的余数位置存储该元素值
    dp[0][nums[0] % 3] = nums[0];
    
    for (let i = 1; i < nums.length; i++) {
        let m = nums[i] % 3; // 当前元素模3的余数
        // 倒序遍历余数状态，避免覆盖未使用的状态
        for (let j = 2; j >= 0; j--) {
            // 状态转移：取不选当前元素 vs 选当前元素的最大值
            // (3 + j - m) % 3 是数学等价写法，避免负数取模
            dp[i % 2][j] = Math.max(
                dp[(i + 1) % 2][j], // 不选当前元素，继承上一状态
                dp[(i + 1) % 2][(3 + j - m) % 3] + nums[i] // 选当前元素
            );
            // 处理当前元素单独构成子集的情况（当余数匹配时）
            if (m === j) {
                dp[i % 2][j] = Math.max(dp[i % 2][j], nums[i]);
            }
        }
        // 更新最大值（仅关注能被3整除的情况）
        ans = Math.max(ans, dp[i % 2][0]);
    }
    return ans;
};

```

#### [3332. 旅客可以得到的最多点数 1828](https://leetcode.cn/problems/maximum-points-tourist-can-earn/)

给你两个整数 n 和 k ，和两个二维整数数组 stayScore 和 travelScore 。

一位旅客正在一个有 n 座城市的国家旅游，每座城市都 直接 与其他所有城市相连。这位游客会旅游 恰好 k 天（下标从 0 开始），且旅客可以选择 任意 城市作为起点。

每一天，这位旅客都有两个选择：

- 留在当前城市：如果旅客在第 i 天停留在前一天所在的城市 curr ，旅客会获得 stayScore[i][curr] 点数。
- 前往另外一座城市：如果旅客从城市 curr 前往城市 dest ，旅客会获得 travelScore[curr][dest] 点数。

请你返回这位旅客可以获得的 最多 点数。

**动态规划：记忆化搜索**
```js
var maxScore = function(n, k, stayScore, travelScore) {
    // 记忆化缓存数组：dp[i][j] 表示在第i天位于j城市时的最大累计得分
    const dp = Array.from({length: k + 1}, () => Array(n).fill(-1));
    
    // 深度优先搜索函数
    const dfs = (i, j) => {
        if (i == k) return dp[i][j] = 0; // 递归终止条件：天数用尽
        if (dp[i][j] >= 0) return dp[i][j]; // 已计算过的状态直接返回
        
        // 选择1：留在当前城市
        let res = dfs(i + 1, j) + stayScore[i][j];
        
        // 选择2：移动到其他城市
        for (let next = 0; next < n; next++) {
            if (next === j) continue; // 不能停留在当前城市
            // 递归计算移动后的得分，取最大值
            res = Math.max(res, dfs(i+1, next) + travelScore[j][next]);
        }

        return dp[i][j] = res; // 记录并返回当前状态的最大值
    }

    // 遍历所有可能的起始城市，寻找最大得分
    let ans = 0;
    for (let j = 0; j < n; j++) {
        ans = Math.max(ans, dfs(0, j));
    }

    return ans;
};

```

**动态规划：空间优化**

```js
/**
 * @param {number} n
 * @param {number} k
 * @param {number[][]} stayScore
 * @param {number[][]} travelScore
 * @return {number}
 */
var maxScore = function (n, k, stayScore, travelScore) {
    // 使用滚动数组优化空间复杂度：dp[当前天数%2][城市编号]
    const dp = Array.from({ length: 2 }, () => Array(n).fill(0));
    
    // 倒序处理每一天（从最后一天往前计算）
    for (let i = k - 1; i >= 0; i--) {
        // 遍历所有城市
        for (let j = 0; j < n; j++) {
            // 选择1：停留在当前城市（继承前一天同一城市的状态）
            dp[i % 2][j] = dp[(i + 1) % 2][j] + stayScore[i][j];
            
            // 选择2：移动到其他城市（遍历所有可能的目标城市）
            for (let next = 0; next < n; next++) {
                if (next === j) continue; // 跳过当前城市
                // 比较移动后的得分，取最大值（继承前一天目标城市的状态）
                dp[i % 2][j] = Math.max(
                    dp[i % 2][j],
                    dp[(i + 1) % 2][next] + travelScore[j][next]
                );
            }
        }
    }

    // 返回第0天所有城市中的最大得分
    return Math.max(...dp[0]);
};
```


#### [3176. 求出最长好子序列 I 1849](https://leetcode.cn/problems/find-the-maximum-length-of-a-good-subsequence-i/description/)

给你一个整数数组 nums 和一个 非负 整数 k 。如果一个整数序列 seq 满足在下标范围 [0, seq.length - 2] 中 最多只有 k 个下标 i 满足 seq[i] != seq[i + 1] ，那么我们称这个整数序列为 好 序列。

请你返回 nums 中 好 子序列 的最长长度。

**动态规划：记忆化缓存**

dfs(i, j) 表示以 nums[i] 为结尾的最长好子序列长度，其中至多有 j 个相邻元素不相同。

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var maximumLength = function (nums, k) {
    const n = nums.length;
    const dp = Array.from({ length: n }, () => Array(k + 1)) // DP缓存：dp[i][j]表示以nums[i]结尾，最多j次不同的最长子序列长度
    
    // 递归函数定义：计算以nums[i]结尾，剩余j次不同机会时的最大长度
    const dfs = (i, j) => {
        if (j < 0) return -Infinity;    // 无效状态：超过允许的不同次数
        if (i === 0) return dp[i][j] = 1; // 递归基：单个元素长度为1
        if (dp[i][j] !== undefined) return dp[i][j]; // 记忆化返回
        
        let res = 1; // 至少可以取当前元素自己（长度1）
        // 遍历所有可能的前驱元素
        for (let next = i - 1; next >= 0; next--) { 
            if (nums[i] === nums[next]) {
                // 元素相同：继承前驱的剩余次数
                res = Math.max(res, dfs(next, j) + 1);
            } else {
                // 元素不同：消耗一次机会，取前驱的j-1状态
                res = Math.max(res, dfs(next, j - 1) + 1);
            }
        }

        return dp[i][j] = res; // 记录并返回最优解
    }

    let ans = 0;
    // 遍历所有可能的结尾元素，取最大值
    for (let i = n - 1; i >= 0; i--) {
        ans = Math.max(ans, dfs(i, k));
    }

    return ans;
};

```

**动态规划：时间优化**

时间复杂度优化：

- 使用prevMx 记录前一层(j-1)的最大值数组，O(1)的时间计算dfs(next, j - 1) when nums[i] !== nums[next]
- 使用mxMap 记录相同数值的最大长度，O(1)的时间计算dfs(next, j) when nums[i] === nums[next]

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var maximumLength = function (nums, k) {
    const n = nums.length;
    // dp[j][i] 表示允许j次不同，以nums[i]结尾的最长好子序列长度
    const dp = Array.from({ length: k + 1 }, () => Array(n).fill(1));
    // prevMx 记录前一层(j-1)的最大值数组
    let prevMx = Array(n).fill(-Infinity);
    
    for (let j = 0; j <= k; j++) { // 遍历所有可能的差异次数
        // mxMap 记录相同数值的最大长度，currMax 当前全局最大值，temp 临时存储当前层最大值
        let mxMap = new Map(), currMax = -Infinity, temp = Array(n).fill(-Infinity);
        
        for (let i = 0; i < n; i++) { // 正序处理每个元素
            temp[i] = currMax; // 保存当前位置之前的全局最大值
            
            // 状态转移：取三种情况最大值
            // 1. 维持当前长度 2. 继承前层不同次数状态 3. 使用相同数值的缓存
            dp[j][i] = Math.max(
                dp[j][i], // 基础长度1
                prevMx[i] + 1, // 从前层不同次数状态转移
                (mxMap.get(nums[i]) ?? 0) + 1 // 相同数值的缓存转移
            );
            
            currMax = Math.max(currMax, dp[j][i]); // 更新全局最大值
            // 更新当前数值的最大长度缓存
            mxMap.set(nums[i], Math.max(dp[j][i], mxMap.get(nums[i]) ?? 0));
        }
        prevMx = temp; // 保存当前层结果供下一层使用
    }

    return Math.max(...dp[k]); // 返回允许k次差异时的全局最大值
};

```

**动态规划：空间优化**

状态转移中没有使用之前的结果可以省略dp数组

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var maximumLength = function (nums, k) {
    const n = nums.length;
    // 前一层最大长度数组，初始为负无穷表示不可达
    let prevMx = Array(n).fill(-Infinity), ans = -Infinity;
    
    // 遍历所有允许的差异次数 (0~k)
    for (let j = 0; j <= k; j++) {
        // mxMap: 存储相同数值的最大长度，currMax: 当前全局最大值，temp: 临时存储当前层最大值
        let mxMap = new Map(), currMax = -Infinity, temp = Array(n).fill(-Infinity);
        
        // 正序处理每个元素，维护前缀最大值
        for (let i = 0; i < n; i++) {
            temp[i] = currMax; // 记录当前位置之前的全局最大值
            
            // 状态转移：三种情况取最大值
            // 1.当前元素单独构成序列 2.继承前层不同次数状态 3.使用相同数值缓存
            let curr = Math.max(
                1, 
                prevMx[i] + 1, 
                (mxMap.get(nums[i]) ?? 0) + 1
            );
            
            currMax = Math.max(currMax, curr); // 更新全局最大值
            mxMap.set(nums[i], Math.max(curr, mxMap.get(nums[i]) ?? 0)); // 更新数值缓存
            ans = Math.max(ans, curr); // 维护全局答案
        }
        prevMx = temp; // 保存当前层结果供下一层使用
    }
    return ans;
};

```

#### [1269. 停在原地的方案数 1854](https://leetcode.cn/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/description/)

有一个长度为 arrLen 的数组，开始有一个指针在索引 0 处。

每一步操作中，你可以将指针向左或向右移动 1 步，或者停在原地（指针不能被移动到数组范围外）。

给你两个整数 steps 和 arrLen ，请你计算并返回：在恰好执行 steps 次操作以后，指针仍然指向索引 0 处的方案数。

由于答案可能会很大，请返回方案数 模 10^9 + 7 后的结果。

**动态规划: 滚动数组**

```js
/**
 * @param {number} steps
 * @param {number} arrLen
 * @return {number}
 */
var numWays = function (steps, arrLen) {
    if (arrLen == 1) return 1; // 特殊情况处理：数组长度为1时只有原地停留一种方案
    const dp = Array.from({ length: 2 }, () => Array(arrLen).fill(0)); // 滚动数组优化，只需保留两步状态
    dp[0][0] = 1; // 初始状态：0步时位置0的方案数为1
    
    // 遍历每一步操作
    for (let i = 1; i <= steps; i++) {
        // 处理边界位置0（只能从位置0停留或从位置1左移过来）
        dp[i % 2][0] = (dp[(i - 1) % 2][1] + dp[(i - 1) % 2][0]) % mod;
        
        // 处理边界最后位置（只能从末尾位置停留或从倒数第二位置右移过来）
        dp[i % 2][arrLen - 1] = (dp[(i - 1) % 2][arrLen - 2] + dp[(i - 1) % 2][arrLen - 1]) % mod;
        
        // 处理中间位置（可停留/左移/右移）
        for (let j = 1; j < Math.min(arrLen - 1, i + 1); j++) { // 优化：j不可能超过当前步数+1
            dp[i % 2][j] = (
                dp[(i - 1) % 2][j] +     // 原地停留
                dp[(i - 1) % 2][j - 1] + // 从左侧移动过来 
                dp[(i - 1) % 2][j + 1]   // 从右侧移动过来
            ) % mod;
        }
    }
    return dp[steps % 2][0]; // 返回最终停留在位置0的方案数
};

const mod = 1e9 + 7; // 题目要求的模数

```

**动态规划：一个数组**

用prev记录dp[i-1][j-1]，使用一维数组优化空间复杂度

```js
/**
 * @param {number} steps
 * @param {number} arrLen
 * @return {number}
 */
var numWays = function (steps, arrLen) {
    if (arrLen == 1) return 1; // 数组长度为1时只能原地停留
    const dp = Array(arrLen).fill(0); // 一维数组空间优化
    dp[0] = 1; // 初始状态：0步时位置0的方案数为1
    let prev;   // 用于保存前一个位置的旧值
    
    // 遍历每一步操作
    for (let i = 1; i <= steps; i++) {
        prev = dp[0]; // 保存位置0的旧值
        // 优化遍历范围：当前位置j不可能超过当前步数i+1
        for (let j = 0; j <= Math.min(arrLen - 1, i + 1); j++) {
            let curr = dp[j]; // 保存当前位置的旧值
            
            // 状态转移分三种情况：
            if (j === 0) { 
                // 边界位置0：只能从原地停留或右侧移动过来
                dp[0] = (dp[1] + dp[0]) % mod;
            } else if (j === arrLen - 1) {
                // 边界末尾位置：只能从原地停留或左侧移动过来
                dp[arrLen - 1] = (prev + dp[arrLen - 1]) % mod;
            } else {
                // 中间位置：左移来 + 停留 + 右移来
                dp[j] = (dp[j] + prev + dp[j + 1]) % mod;
            }

            prev = curr; // 更新prev为当前处理前的旧值
        }
    }
    return dp[0]; // 返回最终停留在起始位置的方案数
};

const mod = 1e9 + 7; // 题目要求的模数

```

#### [3250. 单调数组对的数目 I 1898](https://leetcode.cn/problems/find-the-count-of-monotonic-pairs-i/description/)

给你一个长度为 n 的 正 整数数组 nums 。

如果两个 非负 整数数组 (arr1, arr2) 满足以下条件，我们称它们是 单调 数组对：

- 两个数组的长度都是 n 。
- arr1 是单调 非递减 的，换句话说 arr1[0] <= arr1[1] <= ... <= arr1[n - 1] 。
- arr2 是单调 非递增 的，换句话说 arr2[0] >= arr2[1] >= ... >= arr2[n - 1] 。
- 对于所有的 0 <= i <= n - 1 都有 arr1[i] + arr2[i] == nums[i] 。
请你返回所有 单调 数组对的数目。

由于答案可能很大，请你将它对 109 + 7 取余 后返回。

**动态规划**

dp[i][j] 表示以 nums[i] 为结尾，arr1 中最大值为 j 的单调数组对的数量。枚举dp[i-1][m]的所有可能方案数：

- m <= j
- m <= nums[i-1]
- nums[i-1] - m >= nums[i] - j => m <=  nums[i-1] - nums[i] + j

综上m的取值范围为：[0, min(nums[i-1] - nums[i] + j, nums[i-1], j)]

```js
/**
 * 计算满足特定条件的数对个数（动态规划解法）
 * @param {number[]} nums 输入数组，元素表示位置约束条件
 * @return {number} 返回符合条件的数对个数，模 1e9+7
 */
var countOfPairs = function (nums) {
    const n = nums.length, last = nums[n - 1]; // 数组长度和最后一个元素值
    // 以 nums[i] 为结尾，arr1 中最大值为 j 的单调数组对的数量
    const dp = Array.from({ length: n }, () => Array(last + 1).fill(-1)); // 记忆化数组，存储子问题结果

    // 递归记忆化搜索函数
    const dfs = (i, j) => {
        if (i == 0) return 1; // 基准情况：处理到第一个元素时只有一种组合方式
        if (dp[i][j] >= 0) return dp[i][j] // 已计算过的子问题直接返回
        
        let v = nums[i]; // 当前元素的约束值
        let res = 0;
        // 遍历可能的前一个元素的状态值 k
        for (let k = 0; k <= Math.min(j, nums[i - 1], nums[i - 1] - v + j); k++) {
            res = (res + dfs(i - 1, k)) % mod; // 累加前一个状态的所有可能情况
        }
        return dp[i][j] = res; // 存储并返回当前子问题的结果
    }

    let ans = 0;
    // 遍历所有可能的最终状态值
    for (let j = 0; j <= last; j++) {
        ans = (ans + dfs(n - 1, j))  % mod; // 累加所有终态情况的结果
    }
    return ans;
};

const mod = 1e9 + 7; // 模数常量，用于防止整数溢出
```