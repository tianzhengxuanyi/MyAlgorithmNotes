
### 7.6 多维DP

#### [2222. 选择建筑的方案数](https://leetcode.cn/problems/number-of-ways-to-select-buildings/description/)

给你一个下标从 0 开始的二进制字符串 s ，它表示一条街沿途的建筑类型，其中：

s[i] = '0' 表示第 i 栋建筑是一栋办公楼，
s[i] = '1' 表示第 i 栋建筑是一间餐厅。
作为市政厅的官员，你需要随机 选择 3 栋建筑。然而，为了确保多样性，选出来的 3 栋建筑 相邻 的两栋不能是同一类型。

比方说，给你 s = "001101" ，我们不能选择第 1 ，3 和 5 栋建筑，因为得到的子序列是 "011" ，有相邻两栋建筑是同一类型，所以 不合 题意。
请你返回可以选择 3 栋建筑的 有效方案数 。

**动态规划：记忆化缓存  超时**
```js
/**
 * @param {string} s
 * @return {number}
 */
var numberOfWays = function (s) {
    const n = s.length;
    // 三维DP数组：dp[i][k][type]
    // i: 当前处理到的字符索引
    // k: 剩余需要选择的建筑数量 (3->2->1->0)
    // type: 最后一个选择的建筑类型 (0或1)
    const dp = Array.from({ length: n }, () => 
        Array.from({ length: 4 }, () => [-1, -1])); // 初始化记忆化缓存

    // 深度优先搜索（带记忆化）
    const dfs = (i, k, type) => {
        // 递归终止条件：已选够3个建筑
        if (k === 0) return 1;
        // 边界条件：索引越界
        if (i < 0) return 0;
        // 检查缓存
        if (dp[i][k][type] >= 0) return dp[i][k][type];
        
        // 不选当前建筑的情况
        let res = dfs(i - 1, k, type);
        // 如果当前建筑符合要求的类型（需要与前一个类型交替）
        if (s[i] == type) {  // 注意这里应该是严格等于字符类型比较
            // 选择当前建筑，并切换下一个需要的类型（1 ^ type取反）
            res += dfs(i - 1, k - 1, 1 ^ type);
        }

        return dp[i][k][type] = res; // 记录缓存
    }

    // 最终结果：以0结尾的方案数 + 以1结尾的方案数
    return dfs(n - 1, 3, 1) + dfs(n - 1, 3, 0);
};
```

**动态规划：空间优化**
```js
/**
 * @param {string} s
 * @return {number}
 */
var numberOfWays = function (s) {
    const n = s.length;
    // 空间优化后的DP数组：dp[k][type]
    // k: 当前已选择的建筑数量 (1-3)
    // type: 最后一个选择的建筑类型 (0或1)
    const dp = Array.from({ length: 4 }, () => [0, 0]); // 初始化状态矩阵
    
    let prev; // 保存上一层状态
    for (let i = 1; i <= n; i++) {
        // 初始化第一层状态（选择1个建筑）
        prev = [1, 1];  // 基准情况：每个独立字符都可作为起点
        
        for (let k = 1; k <= 3; k++) {
            // 核心状态转移：当前字符类型为type时，累加上一层的相反类型数量
            // 1 ^ (s[i-1]-0) 实现类型翻转（0->1，1->0）
            dp[k][s[i - 1] - 0] += prev[1 ^ (s[i - 1] - 0)];
            
            // 保存当前层状态用于下一轮迭代
            prev = [...dp[k]]; // 解构赋值实现数组拷贝
        }
    }

    // 返回选择3个建筑的两种类型方案之和
    return dp[3][0] + dp[3][1];
};

```

**统计'010'和'101'的方案数：**
```js
var numberOfWays = function (s) {
    const n = s.length;
    // 统计字符串中总共有多少个0和1
    let total0 = 0, total1 = 0;
    for (let i = 0; i < n; i++) {
        if (s[i] == 0) {
            total0 += 1;
        } else {
            total1 += 1;
        }
    }

    let ans = 0;
    // 倒序遍历时，统计已遍历部分0和1的数量
    let cnt0 = 0, cnt1 = 0;
    for (let i = n - 1; i >= 0; i--) {
        if (s[i] == 0) {
            // 当遇到0时，组合模式为1-0-1：
            // cnt1是右侧已统计的1数量，(total1 - cnt1)是左侧剩余的1数量
            ans += cnt1 * (total1 - cnt1);
            cnt0 += 1;
        } else {
            // 当遇到1时，组合模式为0-1-0：
            // cnt0是右侧已统计的0数量，(total0 - cnt0)是左侧剩余的0数量
            ans += cnt0 * (total0 - cnt0);
            cnt1 += 1;
        }
    }

    return ans;
};

```

#### [2400. 恰好移动 k 步到达某一位置的方法数目](https://leetcode.cn/problems/number-of-ways-to-reach-a-position-after-exactly-k-steps/description/)
 
给你两个 正 整数 startPos 和 endPos 。最初，你站在 无限 数轴上位置 startPos 处。在一步移动中，你可以向左或者向右移动一个位置。

给你一个正整数 k ，返回从 startPos 出发、恰好 移动 k 步并到达 endPos 的 不同 方法数目。由于答案可能会很大，返回对 109 + 7 取余 的结果。

如果所执行移动的顺序不完全相同，则认为两种方法不同。

注意：数轴包含负整数。

**动态规划：记忆化缓存**
```js
var numberOfWays = function (startPos, endPos, k) {
    // 记忆化缓存：dp[r].get(i) 表示剩余r步时，在位置i的方案数
    const dp = Array.from({ length: k + 1 }, () => new Map());
    
    // 深度优先搜索函数
    const dfs = (r, i) => {
        if (dp[r].has(i)) return dp[r].get(i); // 已缓存的结果直接返回
        
        // 剪枝：剩余步数不足以到达目标位置
        if (Math.abs(endPos - i) > r) {
            dp[r].set(i, 0);
            return 0;
        }
        
        // 递归终止条件：步数用尽
        if (r == 0) {
            dp[r].set(i, i === endPos ? 1 : 0);
            return dp[r].get(i);
        }
        
        // 状态转移：向左或向右移动一步，结果取模
        dp[r].set(i, (dfs(r - 1, i + 1) + dfs(r - 1, i - 1)) % mod);
        return dp[r].get(i);
    }

    return dfs(k, startPos); // 从初始状态开始搜索
};

const mod = 1e9 + 7; // 题目要求的取模基数
```

**组合数学**

```js
/**
 * @param {number} startPos
 * @param {number} endPos
 * @param {number} k
 * @return {number}
 */
var numberOfWays = function (startPos, endPos, k) {
    // 计算起点到终点的绝对距离
    let step = Math.abs(startPos - endPos);
    // 剩余步数 = 总步数 - 必须步数
    let rest = k - step;
    
    // 剪枝条件：总步数不足 或 剩余步数为奇数时无法返回
    if (step > k || rest % 2) return 0;

    // 组合数学解法：C(k, m) 其中m = (必须步数 + 剩余步数/2)
    const C = Array.from({ length: k + 1 }, () => Array(k + 1).fill(0));

    // 构建组合数表（帕斯卡三角形）
    for (let i = 0; i <= k; i++) {
        C[i][0] = 1; // 任何数选0个的方案都是1
        for (let j = 1; j <= i; j++) {
            // 组合数递推公式，结果取模
            C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod;
        }
    }
    // 返回组合数结果：需要step步向目标方向，rest/2步来回抵消
    return C[k][step + rest / 2];
};

const mod = 1e9 + 7; // 题目要求的模数
```