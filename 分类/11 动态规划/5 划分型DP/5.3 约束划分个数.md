### 约束划分个数

将数组分成（恰好/至多）k 个连续子数组，计算与这些子数组有关的最优值。

一般定义 f[i][j] 表示将长为 j 的前缀 a[:j] 分成 i 个连续子数组所得到的最优解
- 定义成f[j][i]也可以，即交换分组数和下标的参数位置，但是f[i][j]更方便空间压缩为f[j]
- f[i][j] 也可表示为从就开始的后缀a[j:]分成连续i个连续子数组所得的最优解

前缀时状态转移： 枚举最后一个子数组的左端点 L，从 f[i−1][L] 转移到 f[i][j]，并考虑 a[L:j] 对最优解的影响。

后缀时状态转移： 枚举第一个子数组的右端点 R，从 f[i−1][R+1] 转移到 f[i][j]，并考虑 a[j:R] 对最优解的影响。


#### [813. 最大平均值和的分组](https://leetcode.cn/problems/largest-sum-of-averages/description/)

给定数组 nums 和一个整数 k 。我们将给定的数组 nums 分成 最多 k 个非空子数组，且数组内部是连续的 。 分数 由每个子数组内的平均值的总和构成。

注意我们必须使用 nums 数组中的每一个数进行分组，并且分数不一定需要是整数。

返回我们所能得到的最大 分数 是多少。答案误差在 10-6 内被视为是正确的。

**记忆化缓存**

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var largestSumOfAverages = function (nums, k) {
    const n = nums.length;
    // dp[i][r] 表示从第i个元素开始，分成r+1组的最大平均和
    const dp = Array.from({ length: n }, () => Array(k).fill(-1));
    
    // 递归函数：i-当前起始位置，r-剩余分组次数
    const f = (i, r) => {
        if (i >= n) return 0;
        // 当不能再分组时，返回剩余元素的平均值
        if (r === 0) {
            let sum = 0;
            for (let j = i; j < n; j++) {
                sum += nums[j];
            }
            return dp[i][r] = sum / (n - i);
        }
        // 已经计算过的情况直接返回
        if (dp[i][r] >= 0) return dp[i][r];
        
        let res = -Infinity, sum = 0;
        // 遍历所有可能的分割点
        for (let j = i; j < n; j++) {
            sum += nums[j];
            // 当前分割点的平均值 + 后续子问题的解
            res = Math.max(res, (sum / (j - i + 1)) + f(j + 1, r - 1));
        }

        return dp[i][r] = res;
    }

    // 从第0个元素开始，使用k-1次分组机会
    return f(0, k - 1);
};
```

**递推**

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var largestSumOfAverages = function (nums, k) {
    const n = nums.length;
    // dp数组复用空间：dp[j]表示从位置j开始分割的最大平均和
    const dp = Array(n + 1).fill(0);
    
    // 初始化k=1的情况（所有元素分一组）
    let sum = 0;
    for (let j = n - 1; j >= 0; j--) {
        sum += nums[j];
        dp[j] = sum / (n - j); // 计算j到末尾的平均值
    }
    
    // 动态规划处理k>1的情况
    for (let i = 1; i < k; i++) { // i表示当前剩余分割次数
        for (let j = 0; j < n; j++) { // 遍历所有起始位置
            let res = -Infinity, sum = 0;
            // 尝试所有可能的分割点t
            for (let t = j; t < n; t++) {
                sum += nums[t];
                // 当前分割区间的平均值 + 后续区间的最大和（复用前一轮计算结果）
                res = Math.max(res, sum / (t - j + 1) + dp[t + 1]);
            }
            dp[j] = res; // 更新当前分割次数下的最大值
        }
    }

    return dp[0]; // 返回从0位置开始分割的最大值
};
```