### 1.3 最大子数组和（最大子段和）

有两种做法：

1. 定义状态 f[i] 表示以 a[i] 结尾的最大子数组和，不和 i 左边拼起来就是 f[i]=a[i]，和 i 左边拼起来就是 f[i]=f[i−1]+a[i]，取最大值就得到了状态转移方程 f[i]=max(f[i−1],0)+a[i]，答案为 max(f)。这个做法也叫做 Kadane 算法。
2. 用 前缀和，转化成 121. 买卖股票的最佳时机。

#### [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/description/)

给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

```js
/**
 * 使用Kadane算法计算数组中的最大子数组和
 * @param {number[]} nums 输入数组
 * @return {number} 最大子数组和
 */
var maxSubArray = function (nums) {
  // p: 当前子数组和
  // p1: 前一个位置的子数组和
  // ans: 全局最大子数组和
  let p = 0,
    p1 = nums[0],
    ans = nums[0];

  for (let i = 1; i < nums.length; i++) {
    // 计算当前子数组和：要么从当前元素重新开始，要么延续前一个子数组
    p = Math.max(nums[i], nums[i] + p1);
    // 更新全局最大值
    ans = Math.max(ans, p);
    // 保存当前子数组和供下一次迭代使用
    p1 = p;
  }

  return ans;
};
```

#### [1191. K 次串联后最大子数组之和](https://leetcode.cn/problems/k-concatenation-maximum-sum/description/)

给定一个整数数组 arr 和一个整数 k ，通过重复 k 次来修改数组。

例如，如果 arr = [1, 2] ， k = 3 ，那么修改后的数组将是 [1, 2, 1, 2, 1, 2] 。

返回修改后的数组中的最大的子数组之和。注意，子数组长度可以是 0，在这种情况下它的总和也是 0。

由于 结果可能会很大，需要返回的 109 + 7 的 模 。

```js
/**
 * 计算k次连接数组的最大子数组和
 * @param {number[]} arr 输入数组
 * @param {number} k 连接次数
 * @return {number} 最大子数组和对mod取模的结果
 */
var kConcatenationMaxSum = function (arr, k) {
  const n = arr.length;
  let sum = arr[0]; // 数组元素总和
  // ans: 全局最大子数组和
  // p: 当前子数组和
  // p1: 前一个位置的子数组和
  let ans = (p = p1 = Math.max(0, arr[0]));

  // 遍历数组，当k=1时只遍历一次，否则遍历两次
  for (let i = 1; i < (k === 1 ? 1 : 2) * n; i++) {
    // 更新当前子数组和：要么从当前元素重新开始，要么延续前一个子数组
    p1 = p = Math.max(Math.max(p1, 0) + arr[i % n], 0);
    // 更新全局最大值
    ans = Math.max(ans, p);
    // 计算数组元素总和（只需要计算一次）
    if (i < n) sum += arr[i];
  }
  // 结果由三部分组成：
  // 1. 单次或两次连接的最大子数组和(ans)
  // 2. 如果k>2，中间可以插入(k-2)个完整数组的和(sum)
  // 如果sum > 0, 一次连接的最大子数组和跨越两个数组的证明：
  // 假设没有连接的最大子数组和为max1，最大子数组之前的数组和为pre1，最大子数组之后的数组和为post1。
  // max1 + pre1 + post1 = sum > 0
  // 一次连接后的最大子数组和大于或等于max1 + pre1 + post1 + max1 >= max1
  return (ans + Math.max(k - 2, 0) * Math.max(sum, 0)) % mod;
};

const mod = 1e9 + 7; // 模数
```
