### 2.2 进阶

#### 3363. 最多可收集的水果数目
 
有一个游戏，游戏由 n x n 个房间网格状排布组成。

给你一个大小为 n x n 的二维整数数组 fruits ，其中 fruits[i][j] 表示房间 (i, j) 中的水果数目。有三个小朋友 一开始 分别从角落房间 (0, 0) ，(0, n - 1) 和 (n - 1, 0) 出发。

每一位小朋友都会 **恰好** 移动 n - 1 次，并到达房间 (n - 1, n - 1) ：

- 从 (0, 0) 出发的小朋友每次移动从房间 (i, j) 出发，可以到达 (i + 1, j + 1) ，(i + 1, j) 和 (i, j + 1) 房间之一（如果存在）。
- 从 (0, n - 1) 出发的小朋友每次移动从房间 (i, j) 出发，可以到达房间 (i + 1, j - 1) ，(i + 1, j) 和 (i + 1, j + 1) 房间之一（如果存在）。
- 从 (n - 1, 0) 出发的小朋友每次移动从房间 (i, j) 出发，可以到达房间 (i - 1, j + 1) ，(i, j + 1) 和 (i + 1, j + 1) 房间之一（如果存在）。

当一个小朋友到达一个房间时，会把这个房间里所有的水果都收集起来。如果有两个或者更多小朋友进入同一个房间，只有一个小朋友能收集这个房间的水果。当小朋友离开一个房间时，这个房间里不会再有水果。

请你返回三个小朋友总共 最多 可以收集多少个水果。

**题解：**

- 从 (0, 0) 出发的小朋友要 **恰好** 移动 n - 1 次，并到达房间 (n - 1, n - 1)，**只能获取对角线上的水果**。
- 从 (0, n - 1) 出发的小朋友要 **恰好** 移动 n - 1 次，并到达房间 (n - 1, n - 1)，**只能获取对角线上的水果**。
- 从 (n - 1, 0) 出发的小朋友要 **恰好** 移动 n - 1 次，并到达房间 (n - 1, n - 1)，**只能获取对角线下的水果**。

求解时可以将下方的数据转置，用同一个dfs计算第二和第三个小朋友的结果。

```js
/**
 * 计算从网格中收集水果的最大数量
 * 采用动态规划方法，分两次遍历网格以收集最大可能的水果
 * @param {number[][]} fruits - 二维网格，每个单元格包含水果数量
 * @return {number} - 收集到的最大水果数量
 */
var maxCollectedFruits = function (fruits) {
    const n = fruits.length;  // 获取网格大小（假设为n x n的方阵）
    let ans = 0;  // 初始化结果变量

    // 第一步：收集主对角线上的水果并将其清零
    // 因为题目要求不能重复收集同一单元格的水果
    for (let i = 0; i < n; i++) {
        ans += fruits[i][i];  // 累加对角线上的水果
        fruits[i][i] = 0;     // 将已收集的位置置零
    }

    // 定义移动方向：向下左、向下、向下右
    // 这些方向用于动态规划中的状态转移
    const d = [[1, -1], [1, 0], [1, 1]];

    /**
     * 动态规划辅助函数：计算从(0, n-1)到终点能收集的最大水果
     * 采用自底向上的计算方式
     * @param {number[][]} fruits - 当前水果网格
     * @return {number} - 从起点到终点的最大水果数量
     */
    const f = (fruits) => {
        // 从倒数第二行开始向上计算（自底向上）
        for (let i = n - 2; i >= 0; i--) {
            // 只处理上三角区域（j >= i）
            for (let j = i; j < n; j++) {
                let t = 0;  // 临时变量，存储当前单元格能收集的最大水果
                // 尝试所有可能的移动方向
                for (let [x, y] of d) {
                    let dx = i + x, dy = j + y;  // 计算新位置
                    // 检查新位置是否有效：在网格范围内且保持上三角区域
                    if (dx >= n || dx < 0 || dy >= n || dy < 0 || dx > dy) continue;
                    // 更新当前单元格的最大水果数量
                    t = Math.max(fruits[dx][dy] + fruits[i][j], t);
                }
                fruits[i][j] = t;  // 存储计算结果
            }
        }
        return fruits[0][n - 1];  // 返回从起点(0, n-1)出发的最大收集量
    }

    // 第一次调用f函数，计算从(0, n-1)到终点的最大水果数并累加到结果
    ans += f(fruits);

    // 重置网格：将对角线重置为0，并将上三角复制到下三角（使网格对称）
    for (let i = 0; i < n; i++) {
        fruits[i][i] = 0;
        for (let j = 0; j < i; j++) {
            fruits[j][i] = fruits[i][j];
        }
    }

    // 第二次调用f函数，计算对称路径的最大水果数并累加到结果
    ans += f(fruits);

    return ans;  // 返回总的最大水果收集量
};

```
