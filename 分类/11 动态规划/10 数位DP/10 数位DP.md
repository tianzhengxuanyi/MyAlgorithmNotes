### 数位DP

#### 模版一

将 n 转换成字符串 s，定义 dfs(i,mask,isLimit,isNum) 表示构造第 i 位及其之后数位的合法方案数，其余参数的含义为：

- mask 表示前面选过的数字集合，换句话说，第 i 位要选的数字不能在 mask 中。
- isLimit 表示当前是否受到了 n 的约束（注意要构造的数字不能超过 n）。若为真，则第 i 位填入的数字至多为 s[i]，否则可以是 9。如果在受到约束的情况下填了 s[i]，那么后续填入的数字仍会受到 n 的约束。例如 n=123，如果 i=0 填的是 1 的话，i=1 的这一位至多填 2。如果 i=0 填的是 1，i=1 填的是 2，那么 i=2 的这一位至多填 3。
- isNum 表示 i 前面的数位是否填了数字。若为假，则当前位可以跳过（不填数字），或者要填入的数字至少为 1；若为真，则要填入的数字可以从 0 开始。例如 n=123，在 i=0 时跳过的话，相当于后面要构造的是一个 99 以内的数字了，如果 i=1 不跳过，那么相当于构造一个 10 到 99 的两位数，如果 i=1 跳过，相当于构造的是一个 9 以内的数字。
- 为什么要定义 isNum？因为 010 和 10 都是 10，如果认为第一个 0 和第三个 0 都是我们填入的数字，这就不符合题目要求了，但 10 显然是符合题目要求的。

- 只记忆化 (i,mask) 这两个状态？

    是可以的。比如 n=234，第一位填 2，第二位填 3，后面无论怎么递归，都不会再次递归到第一位填 2，第二位填 3 的情况，所以不需要记录。（注：想象我们在写一个三重循环，枚举每一位填什么数字。第一位填 2，第二位填 3 已经是快要结束循环的情况了，不可能再次枚举到。）又比如，第一位不填，第二位也不填，后面无论怎么递归也不会再次递归到这种情况，所以也不需要记录。

    根据这个例子，我们可以只记录不受到 isLimit 或 isNum 约束时的状态 (i,mask)。比如 n=234，第一位（最高位）填的 1，那么继续递归，后面就可以随便填，所以状态 (1,2) 就表示前面填了一个 1（对应的 mask=2），从第二位往后随便填的方案数。

    相当于我们记忆化的是 (i,mask,false,true)。

```js
var countSpecialNumbers = function(n) {
    const s = n.toString();
    const m = s.length;
    const memo = Array.from({ length: m }, () => Array(1 << 10).fill(-1)); // -1 表示没有计算过

    function dfs(i, mask, isLimit, isNum) {
        if (i === m) {
            return isNum ? 1 : 0; // is_num 为 true 表示得到了一个合法数字
        }
        if (!isLimit && isNum && memo[i][mask] !== -1) {
            return memo[i][mask]; // 之前计算过
        }
        let res = 0;
        if (!isNum) { // 可以跳过当前数位
            res += dfs(i + 1, mask, false, false);
        }
        // 如果前面填的数字都和 n 的一样，那么这一位至多填数字 s[i]（否则就超过 n 啦）
        const up = isLimit ? +s[i] : 9;
        // 枚举要填入的数字 d
        // 如果前面没有填数字，则必须从 1 开始（因为不能有前导零）
        for (let d = isNum ? 0 : 1; d <= up; d++) {
            if ((mask >> d & 1) === 0) { // d 不在 mask 中，说明之前没有填过 d
                res += dfs(i + 1, mask | (1 << d), isLimit && d === up, true);
            }
        }
        if (!isLimit && isNum) {
            memo[i][mask] = res; // 记忆化
        }
        return res;
    }
    return dfs(0, 0, true, false);
};
```

#### 模版二

```js
/**
 * @param {number} start
 * @param {number} finish
 * @param {number} limit
 * @param {string} s
 * @return {number}
 */
var numberOfPowerfulInt = function (start, finish, limit, s) {
    // 将数字转为字符串并统一长度
    const finishStr = String(finish),
        len = finishStr.length;
    let startStr = String(start);
    // 补前导零使start和finish长度一致
    startStr = "0".repeat(len - startStr.length) + startStr;
    // 计算非后缀部分的长度
    let d = len - s.length;

    // 记忆化数组，记录不受限制时的计算结果
    const memo = Array(len).fill(-1);
    
    // 深度优先搜索函数
    const dfs = (i, isLoLimit, isHiLimit) => {
        // 递归终止条件：处理完所有位数
        if (i === len) return 1;
        // 检查是否可以使用记忆化结果（不受上下限限制的情况）
        if (!isHiLimit && !isLoLimit && memo[i] >= 0) return memo[i];
        
        // 确定当前位数字的上下界
        const hi = isHiLimit ? finishStr[i] : limit;  // 上限
        const lo = isLoLimit ? startStr[i] : 0;       // 下限

        let res = 0;
        // 处理非后缀部分
        if (i < d) {
            // 枚举所有可能的数字（在上下界范围内）
            for (let j = lo; j <= Math.min(hi, limit); j++) {
                res += dfs(i + 1, isLoLimit && j == lo, isHiLimit && j == hi);
            }
        } 
        // 处理后缀部分
        else {
            // 枚举数字，但必须匹配后缀s的对应位
            for (let j = lo; j <= Math.min(hi, limit); j++) {
                if (j != s[i - d]) continue;  // 不匹配则跳过
                res += dfs(i + 1, isLoLimit && j == lo, isHiLimit && j == hi);
            }
        }

        // 记忆化不受限制时的结果
        if (!isHiLimit && !isLoLimit) {
            memo[i] = res;
        }

        return res;
    };

    // 从第0位开始递归，初始状态：受上下限限制
    return dfs(0, true, true);
};

```

#### 模版二 isNum参数

- isNum为false时，如果要跳过当前位，需判断当前位的下限是不是前导零
  - 如果不是前导零，跳过则会让数小于下限


```js
var count = function (num1, num2, min_sum, max_sum) {
    // 统一数字长度，不足的前面补零
    const len = num2.length;
    num1 = "0".repeat(len - num1.length) + num1;

    // 记忆化数组：i表示当前处理到第几位，sum表示当前数字和
    const memo = Array.from({ length: len }, () => Array(401).fill(-1));
    
    // 深度优先搜索函数
    const dfs = (i, sum, isLoLimit, isHiLimit, isNum) => {
        // 剪枝：如果当前和已经超过max_sum，直接返回0
        if (sum > max_sum) return 0;
        // 递归终止条件：处理完所有位数后检查数字和是否在范围内
        if (i == len) return min_sum <= sum && sum <= max_sum ? 1 : 0;
        // 记忆化检查：不受限制且已开始填数字的情况
        if (!isLoLimit && !isHiLimit && isNum && memo[i][sum] >= 0) return memo[i][sum];
        
        let res = 0;
        // 处理前导零情况：可以跳过当前位
        if (!isNum && num1[i] == 0) {
            // ☆ 只有当前导零且当前位是0时才允许跳过
            // 保持isNum=false表示仍未开始填数字
            // isLoLimit=true确保后续位不低于num1对应位
            // isHiLimit=false解除上限约束
            res = (res + dfs(i + 1, sum, true, false, false)) % MOD;
        }

        // 确定当前位可填数字的上下界
        let hi = isHiLimit ? num2[i] : 9;  // 受上限约束时取num2对应位，否则9
        let lo = isLoLimit ? num1[i] : 0;  // 受下限约束时取num1对应位，否则0

        // 枚举当前位可填的数字
        for (let j = Math.max(lo, isNum ? 0 : 1); j <= hi; j++) {
            // 递归处理下一位：更新数字和，根据是否达到边界更新限制状态
            res = (res + dfs(i + 1, sum + j, isLoLimit && j == num1[i], isHiLimit && j == num2[i], true)) % MOD;
        }
        
        // 记忆化存储：不受限制且已开始填数字的情况
        if (!isLoLimit && !isHiLimit && isNum) {
            memo[i][sum] = res;
        }

        return res;
    }

    // 从第0位开始递归，初始状态：受上下限限制，尚未开始填数字
    return dfs(0, 0, true, true, false);
};

// 模数常量
const MOD = 1e9 + 7;

```



#### [2376. 统计特殊整数](https://leetcode.cn/problems/count-special-integers/description/)
 
如果一个正整数每一个数位都是 互不相同 的，我们称它是 特殊整数 。

给你一个 正 整数 n ，请你返回区间 [1, n] 之间特殊整数的数目。


```js
/**
 * @param {number} n
 * @return {number}
 */
var countSpecialNumbers = function (n) {
    // 将数字转为字符串便于逐位处理，并获取数字长度
    const s = String(n), len = s.length;
    // 初始化记忆化数组：i表示当前处理到第几位，mask用二进制位记录已使用的数字
    const memo = Array.from({ length: len }, () => Array(1 << 10).fill(-1));
    
    // 深度优先搜索函数
    const dfs = (i, mask, isLimit, isNum) => {
        // 递归终止条件：处理完所有位数
        if (i === len) return isNum;
        // 检查是否可以使用记忆化结果（不受限制且已开始填数字的情况）
        if (!isLimit && isNum && memo[i][mask] >= 0) return memo[i][mask];
        
        let res = 0;

        // 情况1：跳过当前位（前提是前面还没填过数字）
        if (!isNum) {
            res += dfs(i + 1, mask, false, false);
        }
        
        // 确定当前位可填数字的上下界
        let up = isLimit ? s[i] - 0 : 9;  // 受限制时最大值为s[i]，否则为9

        // 枚举当前位可填的数字
        // 已开始填数字可从0开始，否则从1开始（避免前导零）
        for (let j = isNum ? 0 : 1; j <= up; j++) {
            // 如果数字j已经被使用过，跳过
            if (mask & (1 << j)) continue;
            // 递归处理下一位：更新mask，根据是否达到上限更新isLimit
            res += dfs(i + 1, mask | (1 << j), isLimit && j == up, true);
        }
        
        // 记忆化存储（不受限制且已开始填数字的情况）
        if (!isLimit && isNum) {
            memo[i][mask] = res;
        }
        return res;
    }

    // 从第0位开始递归，初始状态：mask为空，受数字n限制，尚未开始填数字
    return dfs(0, 0, true, false);
};

```


#### [2999. 统计强大整数的数目](https://leetcode.cn/problems/count-the-number-of-powerful-integers/description/)
 
给你三个整数 start ，finish 和 limit 。同时给你一个下标从 0 开始的字符串 s ，表示一个 正 整数。

如果一个 正 整数 x 末尾部分是 s （换句话说，s 是 x 的 后缀），且 x 中的每个数位至多是 limit ，那么我们称 x 是 强大的 。

请你返回区间 [start..finish] 内强大整数的 总数目 。

如果一个字符串 x 是 y 中某个下标开始（包括 0 ），到下标为 y.length - 1 结束的子字符串，那么我们称 x 是 y 的一个后缀。比方说，25 是 5125 的一个后缀，但不是 512 的后缀。

**模版一**

```js
/**
 * @param {number} start
 * @param {number} finish
 * @param {number} limit
 * @param {string} s
 * @return {number}
 */
var numberOfPowerfulInt = function (start, finish, limit, s) {
    // 使用前缀和思想计算区间内的数量：[start,finish] = [0,finish] - [0,start-1]
    return f(finish, limit, s) - f(start - 1, limit, s)
};

const f = (num, limit, s) => {
    const str = String(num), len = str.length;  // 将数字转为字符串便于逐位处理
    const d = len - s.length;  // 计算数字长度与后缀长度的差值
    if (d < 0) return 0;  // 如果数字比后缀还短，直接返回0

    // 记忆化数组：记录不受限制时的计算结果
    const memo = Array(len).fill(-1);
    
    // 深度优先搜索函数
    const dfs = (i, isLimit) => {
        // 递归终止条件：处理完所有位数
        if (i == len) return 1;
        // 检查是否可以使用记忆化结果（不受限制的情况）
        if (!isLimit && memo[i] >= 0) return memo[i];
        
        let res = 0;
        // 确定当前位可填数字的上界：受限制时为原数字对应位，否则为limit
        const hi = isLimit ? +str[i] : limit;
        
        // 当前位在前d位（非后缀部分）
        if (i < d) {
            // 枚举所有可能的数字（0到hi和limit中的较小值）
            for (let j = 0; j <= Math.min(hi, limit); j++) {
                res += dfs(i + 1, isLimit && j == hi);
            }
        } 
        // 当前位在后缀部分
        else {
            // 枚举数字，但必须匹配后缀s的对应位
            for (let j = 0; j <= Math.min(hi, limit); j++) {
                if (j != s[i - d]) continue;  // 不匹配则跳过
                res += dfs(i + 1, isLimit && j == hi);
            }
        }

        // 记忆化不受限制时的结果
        if (!isLimit) {
            memo[i] = res;
        }

        return res;
    }

    // 从第0位开始递归，初始状态：受数字num的限制
    return dfs(0, true);
}

```

**模版二**

```js
/**
 * @param {number} start
 * @param {number} finish
 * @param {number} limit
 * @param {string} s
 * @return {number}
 */
var numberOfPowerfulInt = function (start, finish, limit, s) {
    // 将数字转为字符串并统一长度
    const finishStr = String(finish),
        len = finishStr.length;
    let startStr = String(start);
    // 补前导零使start和finish长度一致
    startStr = "0".repeat(len - startStr.length) + startStr;
    // 计算非后缀部分的长度
    let d = len - s.length;

    // 记忆化数组，记录不受限制时的计算结果
    const memo = Array(len).fill(-1);
    
    // 深度优先搜索函数
    const dfs = (i, isLoLimit, isHiLimit) => {
        // 递归终止条件：处理完所有位数
        if (i === len) return 1;
        // 检查是否可以使用记忆化结果（不受上下限限制的情况）
        if (!isHiLimit && !isLoLimit && memo[i] >= 0) return memo[i];
        
        // 确定当前位数字的上下界
        const hi = isHiLimit ? finishStr[i] : limit;  // 上限
        const lo = isLoLimit ? startStr[i] : 0;       // 下限

        let res = 0;
        // 处理非后缀部分
        if (i < d) {
            // 枚举所有可能的数字（在上下界范围内）
            for (let j = lo; j <= Math.min(hi, limit); j++) {
                res += dfs(i + 1, isLoLimit && j == lo, isHiLimit && j == hi);
            }
        } 
        // 处理后缀部分
        else {
            // 枚举数字，但必须匹配后缀s的对应位
            for (let j = lo; j <= Math.min(hi, limit); j++) {
                if (j != s[i - d]) continue;  // 不匹配则跳过
                res += dfs(i + 1, isLoLimit && j == lo, isHiLimit && j == hi);
            }
        }

        // 记忆化不受限制时的结果
        if (!isHiLimit && !isLoLimit) {
            memo[i] = res;
        }

        return res;
    };

    // 从第0位开始递归，初始状态：受上下限限制
    return dfs(0, true, true);
};

```


#### [2719. 统计整数数目](https://leetcode.cn/problems/count-of-integers/description/)

给你两个数字字符串 num1 和 num2 ，以及两个整数 max_sum 和 min_sum 。如果一个整数 x 满足以下条件，我们称它是一个好整数：

- num1 <= x <= num2
- min_sum <= digit_sum(x) <= max_sum.
请你返回好整数的数目。答案可能很大，请返回答案对 109 + 7 取余后的结果。

注意，digit_sum(x) 表示 x 各位数字之和。

```js
/**
 * @param {string} num1
 * @param {string} num2
 * @param {number} min_sum
 * @param {number} max_sum
 * @return {number}
 */
var count = function (num1, num2, min_sum, max_sum) {
    // 统一数字长度，不足的前面补零
    const len = num2.length;
    num1 = "0".repeat(len - num1.length) + num1;

    // 记忆化数组：i表示当前处理到第几位，sum表示当前数字和
    const memo = Array.from({ length: len }, () => Array(401).fill(-1));
    
    // 深度优先搜索函数
    const dfs = (i, sum, isLoLimit, isHiLimit, isNum) => {
        // 剪枝：如果当前和已经超过max_sum，直接返回0
        if (sum > max_sum) return 0;
        // 递归终止条件：处理完所有位数后检查数字和是否在范围内
        if (i == len) return min_sum <= sum && sum <= max_sum ? 1 : 0;
        // 记忆化检查：不受限制且已开始填数字的情况
        if (!isLoLimit && !isHiLimit && isNum && memo[i][sum] >= 0) return memo[i][sum];
        
        let res = 0;
        // 处理前导零情况：可以跳过当前位
        if (!isNum && num1[i] == 0) {
            // ☆ 只有当前导零且当前位是0时才允许跳过
            // 保持isNum=false表示仍未开始填数字
            // isLoLimit=true确保后续位不低于num1对应位
            // isHiLimit=false解除上限约束
            res = (res + dfs(i + 1, sum, true, false, false)) % MOD;
        }

        // 确定当前位可填数字的上下界
        let hi = isHiLimit ? num2[i] : 9;  // 受上限约束时取num2对应位，否则9
        let lo = isLoLimit ? num1[i] : 0;  // 受下限约束时取num1对应位，否则0

        // 枚举当前位可填的数字
        for (let j = Math.max(lo, isNum ? 0 : 1); j <= hi; j++) {
            // 递归处理下一位：更新数字和，根据是否达到边界更新限制状态
            res = (res + dfs(i + 1, sum + j, isLoLimit && j == num1[i], isHiLimit && j == num2[i], true)) % MOD;
        }
        
        // 记忆化存储：不受限制且已开始填数字的情况
        if (!isLoLimit && !isHiLimit && isNum) {
            memo[i][sum] = res;
        }

        return res;
    }

    // 从第0位开始递归，初始状态：受上下限限制，尚未开始填数字
    return dfs(0, 0, true, true, false);
};

// 模数常量
const MOD = 1e9 + 7;

```

#### [1399. 统计最大组的数目](https://leetcode.cn/problems/count-largest-group/description/)

给定一个整数 n 。

我们需要根据数字的数位和将 1 到 n 的数字分组。例如，数字 14 和 5 属于 同一 组，而数字 13 和 3 属于 不同 组。

返回最大组的数字数量，即元素数量 最多 的组。

**数位DP**

- 前导0不影响数位和的结果，所以不需要isNum参数
- dfs(i, target, isLimit) 中target表示剩余的数位和可以记忆化缓存，如果表示0-i的数位和则不可以

```js
/**
 * @param {number} n
 * @return {number}
 */
var countLargestGroup = function (n) {
    // 将数字转为字符串便于逐位处理，并获取数字长度
    const s = String(n), len = s.length;

    // 初始化记忆化数组：i表示当前处理到第几位，target表示剩余需要达到的数位和
    const memo = Array.from({length: len}, () => Array(len * 9 + 1).fill(-1));
    
    // 深度优先搜索函数
    const dfs = (i, target, isLimit) => {
        // 递归终止条件：处理完所有位数后检查是否达到目标数位和
        if (i == len) {
            return target == 0 ? 1 : 0;
        }

        // 检查是否可以使用记忆化结果（不受限制的情况）
        if (!isLimit && memo[i][target] >= 0) return memo[i][target];

        let res = 0;
        // 确定当前位可填数字的上界：受限制时取原数字对应位，否则为9
        let hi = isLimit ? s[i] : 9;

        // 枚举当前位可填的数字（不超过剩余目标数位和）
        for (let j = 0; j <= Math.min(hi, target); j++) {
            // 递归处理下一位：更新剩余目标数位和，根据是否达到上限更新isLimit
            res += dfs(i + 1, target - j, isLimit && j == hi);
        }
        
        // 记忆化不受限制时的结果
        if (!isLimit) memo[i][target] = res;
        return res;
    }

    // 统计各数位和对应的数字数量
    const cnt = new Map();
    let maxVal = -Infinity;
    // 遍历所有可能的数位和（1到最大可能数位和）
    for (let t = 1; t <= len * 9; t++) {
        // 计算数位和为t的数字数量
        let val = dfs(0, t, true);
        // 记录各数量出现的次数
        cnt.set(val, (cnt.get(val) ?? 0) + 1);
        // 更新最大组的大小
        if (val > maxVal) {
            maxVal = val;
        }
    }

    // 返回最大组的数量
    return cnt.get(maxVal);
};

```

#### [1742. 盒子中小球的最大数量](https://leetcode.cn/problems/maximum-number-of-balls-in-a-box/description/)

你在一家生产小球的玩具厂工作，有 n 个小球，编号从 lowLimit 开始，到 highLimit 结束（包括 lowLimit 和 highLimit ，即 n == highLimit - lowLimit + 1）。另有无限数量的盒子，编号从 1 到 infinity 。

你的工作是将每个小球放入盒子中，其中盒子的编号应当等于小球编号上每位数字的和。例如，编号 321 的小球应当放入编号 3 + 2 + 1 = 6 的盒子，而编号 10 的小球应当放入编号 1 + 0 = 1 的盒子。

给你两个整数 lowLimit 和 highLimit ，返回放有最多小球的盒子中的小球数量。如果有多个盒子都满足放有最多小球，只需返回其中任一盒子的小球数量。

```js

/**
 * @param {number} lowLimit 小球编号下限
 * @param {number} highLimit 小球编号上限
 * @return {number} 最多小球的盒子中的小球数量
 */
var countBalls = function(lowLimit, highLimit) {
    // 将数字转为字符串并统一长度（补前导零）
    let low = String(lowLimit), high = String(highLimit);
    const len = high.length;
    low = '0'.repeat(len - low.length) + low;
    
    // 记忆化数组：i表示当前处理到第几位，r表示剩余需要达到的数位和
    const memo = Array.from({length: len}, () => Array(9 * len + 1).fill(-1));
    
    // 深度优先搜索函数
    const dfs = (i, r, isLowLimit, isHighLimit) => {
        // 递归终止条件：处理完所有位数后检查是否达到目标数位和
        if (i === len) return r === 0 ? 1 : 0;
        // 检查是否可以使用记忆化结果（不受限制的情况）
        if (!isHighLimit && !isLowLimit && memo[i][r] >= 0) return memo[i][r];
        
        // 确定当前位可填数字的上下界
        const hi = isHighLimit ? high[i] : 9;  // 受上限约束时取high对应位，否则9
        const lo = isLowLimit ? low[i] : 0;   // 受下限约束时取low对应位，否则0
        
        let res = 0;
        // 枚举当前位可填的数字（不超过剩余目标数位和）
        for (let j = lo; j <= hi; j++) {
            if (r - j < 0) break;  // 剪枝：剩余数位和不足时提前终止
            // 递归处理下一位：更新剩余数位和，根据是否达到边界更新限制状态
            res += dfs(i + 1, r - j, isLowLimit && j == lo, isHighLimit && j == hi);
        }
        
        // 记忆化不受限制时的结果
        if (!isHighLimit && !isLowLimit) memo[i][r] = res;
        return res;
    }
    
    // 统计各数位和对应的球数量
    let ans = -Infinity;
    let totoal = 0;
    // 遍历所有可能的数位和（0到最大可能数位和）
    for (let r = 0; r <= 9 * len; r++) {
        let cnt = dfs(0, r, true, true);  // 计算数位和为r的球数量
        totoal += cnt;
        if (cnt > ans) {
            ans = cnt;  // 更新最大值
        }
    }
    return ans;  // 返回最多球的盒子中的球数量
};

```


#### [788. 旋转数字](https://leetcode.cn/problems/rotated-digits/description/)

我们称一个数 X 为好数, 如果它的每位数字逐个地被旋转 180 度后，我们仍可以得到一个有效的，且和 X 不同的数。要求每位数字都要被旋转。

如果一个数的每位数字被旋转以后仍然还是一个数字， 则这个数是有效的。0, 1, 和 8 被旋转后仍然是它们自己；2 和 5 可以互相旋转成对方（在这种情况下，它们以不同的方向旋转，换句话说，2 和 5 互为镜像）；6 和 9 同理，除了这些以外其他的数字旋转以后都不再是有效的数字。

现在我们有一个正整数 N, 计算从 1 到 N 中有多少个数 X 是好数？

```js
/**
 * 计算1到n中有多少个数是"好数"
 * 好数定义：每位数字旋转180度后仍是一个有效且不同的数字
 * @param {number} n - 正整数上限
 * @return {number} 好数的数量
 */
var rotatedDigits = function (n) {
    // 将数字转为字符串便于逐位处理，并获取数字长度
    const s = String(n), len = s.length;

    // 记忆化数组：i表示当前处理到第几位，isChange表示是否已包含可旋转变化的数字
    const memo = Array.from({length: len}, () => Array(2).fill(-1));
    
    /**
     * 深度优先搜索函数
     * @param {number} i - 当前处理的位数索引
     * @param {boolean} isChange - 是否已包含可旋转变化的数字(2,5,6,9)
     * @param {boolean} isLimit - 是否受到n的限制
     * @return {number} 当前状态下满足条件的数字数量
     */
    const dfs = (i, isChange, isLimit) => {
        // 递归终止条件：处理完所有位数后，只有包含变化数字才算好数
        if (i == len) return isChange ? 1 : 0;
        // 检查是否可以使用记忆化结果（不受限制的情况）
        if (!isLimit && memo[i][isChange] >= 0) return memo[i][isChange];
        
        // 确定当前位可填数字的上界：受限制时取原数字对应位，否则为9
        const hi = isLimit ? +s[i] : 9;
        let res = 0;
        
        // 枚举当前位可填的数字
        for (let j = 0; j <= hi; j++) {
            // 跳过旋转后无效的数字(3,4,7)
            if (rotatedIsNan.has(j)) continue;
            // 递归处理下一位：更新isChange状态，根据是否达到上限更新isLimit
            res += dfs(i+1, +(isChange || rotatedIsChange.has(j)), isLimit && j == hi)
        }
        
        // 记忆化不受限制时的结果
        if (!isLimit) memo[i][isChange] = res;
        return res;
    }

    // 从第0位开始递归，初始状态：未包含变化数字，受数字n的限制
    return dfs(0, 0, true);
};

// 旋转后无效的数字集合(3,4,7)
const rotatedIsNan = new Set([3, 4, 7]);
// 旋转后会变化的数字集合(2,5,6,9)
const rotatedIsChange = new Set([2, 5, 6, 9])

```


#### [902. 最大为 N 的数字组合](https://leetcode.cn/problems/numbers-at-most-n-given-digit-set/description/)

给定一个按 非递减顺序 排列的数字数组 digits 。你可以用任意次数 digits[i] 来写的数字。例如，如果 digits = ['1','3','5']，我们可以写数字，如 '13', '551', 和 '1351315'。

返回 可以生成的小于或等于给定整数 n 的正整数的个数 。

```js
/**
 * 计算使用给定数字集合digits可以组成的小于等于n的数字数量
 * @param {string[]} digits - 可用的数字字符集合(已排序)
 * @param {number} n - 目标上限数字
 * @return {number} 符合条件的数字数量
 */
var atMostNGivenDigitSet = function(digits, n) {
    // 将n转为字符串便于逐位处理，并获取数字长度
    const s = String(n), len = s.length;
    const dn = digits.length; // 可用数字的数量

    // 记忆化数组：记录不受限制时的计算结果
    const memo = Array(len).fill(-1);
    
    /**
     * 深度优先搜索函数
     * @param {number} i - 当前处理的位数索引
     * @param {boolean} isLimit - 是否受到n的限制
     * @param {boolean} isNum - 是否已经开始填数字
     * @return {number} 当前状态下满足条件的数字数量
     */
    const dfs = (i, isLimit, isNum) => {
        // 递归终止条件：处理完所有位数后，只有已开始填数字才算有效
        if (i === len) return isNum ? 1 : 0;
        // 检查是否可以使用记忆化结果（已开始填数字且不受限制的情况）
        if (isNum && !isLimit && memo[i] >= 0) return memo[i];
        
        let res = 0;
        // digits中可能没有0，所有需要isNum跳过
        // 情况1：跳过当前位（前提是前面还没填过数字）
        if (!isNum) {
            res += dfs(i+1, false, false);
        }
        
        // 确定当前位可填数字的上界：受限制时取原数字对应位，否则为9
        const hi = isLimit ? +s[i] : 9;

        // 枚举当前位可填的数字（从digits中选取）
        for (let j = 0; j < dn; j++) {
            // 如果当前数字超过上限则提前终止（digits已排序）
            if (digits[j] > hi) break;
            // 递归处理下一位：更新isLimit状态，标记已开始填数字
            res += dfs(i+1, isLimit && digits[j] == s[i], true);
        }
        
        // 记忆化已开始填数字且不受限制时的结果
        if (isNum && !isLimit) memo[i] = res;
        return res;
    }

    // 从第0位开始递归，初始状态：受n的限制，尚未开始填数字
    return dfs(0, true, false);
};

```

#### [600. 不含连续1的非负整数](https://leetcode.cn/problems/non-negative-integers-without-consecutive-ones/description/)

给定一个正整数 n ，请你统计在 [0, n] 范围的非负整数中，有多少个整数的二进制表示中不存在 连续的 1 。

**数位DP：**

把n转换成二进制字符串，然后套用数位DP模版。

```js
 * @param {number} n
 * @return {number}
 */
var findIntegers = function(n) {
    const s = n.toString(2), len = s.length;

    const memo = Array.from({length: len}, () => [-1, -1]);
    const dfs = (i, pre, isLimit) => {
        if (i === len) return 1;
        if (!isLimit && memo[i][pre] >= 0) return memo[i][pre]
        const hi = isLimit ? +s[i] : 1;

        let res = 0;

        for (let j = 0; j <= hi; j++) {
            if (pre && j == 1) continue;
            res += dfs(i+1, +(j == 1), isLimit && j == hi);
        }

        if (!isLimit) memo[i][pre] = res;

        return res;
    }

    return dfs(0, 0, true);
};
```