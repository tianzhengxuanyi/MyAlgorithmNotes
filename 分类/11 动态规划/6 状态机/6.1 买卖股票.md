### 买卖股票

**无限次交易**

定义状态：
- 第i天持有股票(dp[i][1])
- 第i天不持有股票(dp[i][0])

状态转移方程：
- 第i天持有股票(dp[i][1])：
    - 第i-1天持有股票(dp[i-1][1]，第i天不操作)
    - 第i-1天不持有股票，第i天买入(dp[i-1][0]-prices[i]，第i天买入)
- 第i天不持有股票(dp[i][0])：
    - 第i-1天不持有股票(dp[i-1][0]，第i天不操作)
    - 第i-1天持有股票，第i天卖出(dp[i-1][1]+prices[i]，第i天卖出)

初始状态：
- 第0天之前不持有股票，dp[-1][0] = 0
- 第0天之前持有股票，dp[-1][1] = -Infinity

**至多交易k次**

定义状态：
- 第i天持有股票，且当前至多交易j次(dp[i][j][1])
- 第i天不持有股票，且当前至多交易j次(dp[i][j][0])

状态转移方程：
- 第i天持有股票，且当前至多交易j次(dp[i][j][1])：
    - 第i-1天持有股票，第i天不操作(dp[i-1][j][1]，第i天不操作)
    - 第i-1天不持有股票，第i天买入(dp[i-1][j][0]-prices[i]，第i天买入)(买入不增加交易次数)
- 第i天不持有股票，且当前至多交易j次(dp[i][j][0])：
    - 第i-1天不持有股票，第i天不操作(dp[i-1][j][0]，第i天不操作)
    - 第i-1天持有股票，第i天卖出(dp[i-1][j-1][1]+prices[i]，第i天卖出)(卖出增加交易次数)

初始状态：
- 第0天之前不持有股票，dp[-1][j][0] = 0, j >= 0
- 第0天之前持有股票，dp[-1][j][1] = -Infinity, j >= 0
- 交易次数小于0时，dp[i][j][0] = dp[i][j][1] = -Infinity, j < 0

**有冷冻期**

定义状态：
- 第i天持有股票(dp[i][1])
- 第i天不持有股票(dp[i][0])

状态转移方程(冷冻期一天)：
- 第i天持有股票(dp[i][1])：
    - 第i-1天持有股票(dp[i-1][1]，第i天不操作)
    - 第i-2天不持有股票，第i天买入(dp[i-2][0]-prices[i]，第i天买入)
    - 第i-1天不持有股票且第i-1天不卖出的情况下(**等价于第i-2天不持有股票**)，第i天买入
- 第i天不持有股票(dp[i][0])：
    - 第i-1天不持有股票(dp[i-1][0]，第i天不操作)
    - 第i-1天持有股票，第i天卖出(dp[i-1][1]+prices[i]，第i天卖出)

初始状态：
- 第0天之前不持有股票，dp[-1][0] = 0
- 第0天之前持有股票，dp[-1][1] = -Infinity

#### [121. 买卖股票的最佳时机 (交易一次)](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/)

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

**贪心：**

```js
/**
 * 计算一次股票交易的最大利润
 * @param {number[]} prices 每日股价数组
 * @return {number} 最大利润
 */
var maxProfit = function(prices) {
    const len = prices.length;
    // 边界条件：至少需要两天的价格才能交易
    if (len < 2) return 0;

    let ans = 0;          // 记录最大利润
    let max = prices[len - 1]; // 从右往左遍历时的最高价
    
    // 逆向遍历价格数组（从倒数第二天开始）
    for (let i = len - 2; i >= 0; i--) {
        // 计算当前价格买入，后续最高价卖出的利润，并更新最大值
        ans = Math.max(ans, max - prices[i]);
        // 维护当前遇到过的最高股价
        max = Math.max(max, prices[i]);
    }

    return ans;
};
```

#### [122. 买卖股票的最佳时机 II 交易无限次](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/)

给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。

返回 你能获得的 最大 利润 。

**记忆化搜索：**

```js
/**
 * 动态规划解法 - 记忆化搜索
 * @param {number[]} prices 股票每日价格数组
 * @return {number} 最大利润
 */
var maxProfit = function (prices) {
    const n = prices.length;
    
    // 初始化DP数组，dp[i][0]表示第i天不持有股票的最大利润
    // dp[i][1]表示第i天持有股票的最大利润
    const dp = Array.from({ length: n }, () => Array(2));
    
    // 递归函数：i表示当前天数，hold表示是否持有股票（0/1）
    const f = (i, hold) => {
        // 基准情况：第0天时，若持有则为负股价，不持有则利润0
        if (i === 0) return hold == 1 ? -prices[i] : 0;
        
        // 已计算过则直接返回缓存值
        if (dp[i][hold] !== undefined) return dp[i][hold];
        
        if (hold) {
            // 当前持有：取（保持持有）或（前一天未持有+当天买入）的最大值
            return dp[i][hold] = Math.max(f(i - 1, 1), f(i - 1, 0) - prices[i]);
        }
        // 当前未持有：取（保持未持有）或（前一天持有+当天卖出）的最大值
        return dp[i][hold] = Math.max(f(i - 1, 0), f(i - 1, 1) + prices[i]);
    }

    // 最终返回最后一天不持有股票的状态
    return f(n - 1, 0);
};
```

**动态规划：**

```js
/**
 * 动态规划解法 - 记忆化搜索
 * @param {number[]} prices 股票每日价格数组
 * @return {number} 最大利润
 */
var maxProfit = function (prices) {
    const n = prices.length;
    // 初始化DP数组：dp[天数][是否持有]
    // dp[i][0]表示第i天不持有股票的最大利润
    // dp[i][1]表示第i天持有股票的最大利润
    const dp = Array.from({ length: n + 1 }, () => Array(2));
    // 初始状态：第-1天不可能持有股票
    dp[0][0] = 0; 
    dp[0][1] = -Infinity; // 用负无穷表示不可能的状态
    
    for (let i = 0; i < n; i++) {
        // 状态转移方程：
        // 当前持有 = max(保持持有，当天买入)
        dp[i + 1][1] = Math.max(dp[i][1], dp[i][0] - prices[i]);
        // 当前未持有 = max(保持未持有，当天卖出)
        dp[i + 1][0] = Math.max(dp[i][0], dp[i][1] + prices[i]);
    }
    // 返回最后一天未持有股票的状态（即全部交易完成）
    return dp[n][0];
};
```

**空间压缩优化：**

```js
var maxProfit = function (prices) {
    const n = prices.length;
    // 状态压缩后的动态规划
    let prevUnHold = 0,   // 前一天未持有股票的最大利润
        prevHold = -Infinity; // 前一天持有股票的最大利润（初始状态不可持有）
    
    let hold, unHold; // 当前持有/未持有状态
    
    for (let i = 0; i < n; i++) {
        // 状态转移方程：
        hold = Math.max(
            prevHold,           // 保持持有
            prevUnHold - prices[i] // 当日买入
        );
        unHold = Math.max(
            prevUnHold,         // 保持未持有
            prevHold + prices[i] // 当日卖出
        );
        
        // 滚动更新状态变量
        prevHold = hold;
        prevUnHold = unHold;
    }
    // 最终必须处于未持有状态才能获得最大利润
    return unHold;
};
```

#### [188. 买卖股票的最佳时机 IV 至多完成k次交易](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/)

给你一个整数数组 prices 和一个整数 k ，其中 prices[i] 是某支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。也就是说，你最多可以买 k 次，卖 k 次。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**记忆化搜索：**

```js
var maxProfit = function(k, prices) {
    const n = prices.length;
    const memo = Array(n).fill(null).map(() => Array(k + 1).fill(null).map(() => Array(2).fill(-1))); // -1 表示还没有计算过
    function dfs(i, j, hold) {
        if (j < 0) {
            return -Infinity;
        }
        if (i < 0) {
            return hold === 1 ? -Infinity : 0;
        }
        if (memo[i][j][hold] !== -1) { // 之前计算过
            return memo[i][j][hold];
        }
        if (hold === 1) {
            memo[i][j][hold] = Math.max(dfs(i - 1, j, 1), dfs(i - 1, j, 0) - prices[i]);
        } else {
            memo[i][j][hold] = Math.max(dfs(i - 1, j, 0), dfs(i - 1, j - 1, 1) + prices[i]);
        }
        return memo[i][j][hold];
    }
    return dfs(n - 1, k, 0);
};
```

**动态规划：**

```js
var maxProfit = function(k, prices) {
    const n = prices.length;
    const f = Array(n + 1).fill(null).map(() => Array(k + 2).fill(null).map(() => Array(2).fill(-Infinity)));
    for (let j = 1; j < k + 2; j++) {
        f[0][j][0] = 0;
    }
    for (let i = 0; i < n; i++) {
        for (let j = 1; j < k + 2; j++) {
            f[i + 1][j][0] = Math.max(f[i][j][0], f[i][j - 1][1] + prices[i]);
            f[i + 1][j][1] = Math.max(f[i][j][1], f[i][j][0] - prices[i]);
        }
    }
    return f[n][k + 1][0];
};
```

**空间压缩优化：**

```js
var maxProfit = function(k, prices) {
    const f = Array(k + 2).fill(null).map(() => Array(2).fill(-Infinity));
    for (let j = 1; j <= k + 1; j++) {
        f[j][0] = 0;
    }
    for (const p of prices) {
        for (let j = k + 1; j > 0; j--) {
            f[j][0] = Math.max(f[j][0], f[j - 1][1] + p);
            f[j][1] = Math.max(f[j][1], f[j][0] - p);
        }
    }
    return f[k + 1][0];
};
```

#### 「恰好」完成 k 笔交易

递归到 i<0 时，只有 j=0 才是合法的，j>0 是不合法的。

**动态规划：**

```js
var maxProfit = function(k, prices) {
    const n = prices.length;
    const f = Array(n + 1).fill(null).map(() => Array(k + 2).fill(null).map(() => Array(2).fill(-Infinity)));
    // for (let j = 1; j < k + 2; j++) {
    //     f[0][j][0] = 0;
    // }
    f[0][1][0] = 0; // 改动
    for (let i = 0; i < n; i++) {
        for (let j = 1; j < k + 2; j++) {
            f[i + 1][j][0] = Math.max(f[i][j][0], f[i][j - 1][1] + prices[i]);
            f[i + 1][j][1] = Math.max(f[i][j][1], f[i][j][0] - prices[i]);
        }
    }
    return f[n][k + 1][0];
};
```

#### 「至少」完成 k 笔交易

递归到「至少 0 次」时，它等价于「交易次数没有限制」，那么这个状态的计算方式和 122. 买卖股票的最佳时机 II 是一样的。

**动态规划：**

```js
var maxProfit = function(k, prices) {
    const n = prices.length;
    const f = Array(n + 1).fill(null).map(() => Array(k + 2).fill(null).map(() => Array(2).fill(-Infinity)));
    f[0][0][0] = 0;
    for (let i = 0; i < n; i++) {
        f[i + 1][0][1] = Math.max(f[i][0][1], f[i][0][0] - prices[i]); // 无限次数交易
        f[i + 1][0][0] = Math.max(f[i][0][0], f[i][0][1] + prices[i]); // 无限次数交易
        for (let j = 1; j < k + 2; j++) {
            f[i + 1][j][0] = Math.max(f[i][j][0], f[i][j - 1][1] + prices[i]);
            f[i + 1][j][1] = Math.max(f[i][j][1], f[i][j][0] - prices[i]);
        }
    }
    return f[n][k + 1][0];
};
```

#### [309. 买卖股票的最佳时机含冷冻期](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/)

给定一个整数数组prices，其中第  prices[i] 表示第 i 天的股票价格 。​

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**记忆化搜索：**

```js
/**
 * 计算最大利润
 * @param {number[]} prices 股票每日价格数组
 * @return {number} 最大利润
```js
/**
 * @param {number[]} prices 股票每日价格数组
 * @return {number} 能获取的最大利润
 */
var maxProfit = function (prices) {
    // dp[i][1] = Math.max(dp[i-1][1], dp[i-2][0] - prices[i])
    // dp[i][0] 表示未没有持股 且没有卖出的时候 直接从dp[i-2][0]转移，所以不需要考虑
    // dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i])
    const n = prices.length;
    // 初始化二维DP数组，[i][0]表示第i天未持有，[i][1]表示持有
    const dp = Array.from({ length: n }, () => Array(2));

    // 递归记忆化函数
    const f = (i, hold) => {
        // 基准情况处理
        if (i === 0) return hold == 0 ? 0 : - prices[i]; // 第0天初始化
        if (i < 0) return hold == 0 ? 0 : -Infinity;     // 无效索引处理
        if (dp[i][hold] !== undefined) return dp[i][hold]; // 已计算过的直接返回

        if (hold) {
            // 持有状态：取「保持持有」或「两天前未持有->今日买入」的较大值
            return dp[i][hold] = Math.max(f(i - 1, 1), f(i - 2, 0) - prices[i]);
        } else {
            // 未持有状态：取「保持未持有」或「昨日持有->今日卖出」的较大值
            return dp[i][hold] = Math.max(f(i - 1, 0), f(i - 1, 1) + prices[i]);
        }
    }

    return f(n - 1, 0); // 最终返回最后一天未持有的最大利润
};
```

**空间优化：**

```js
/**
 * @param {number[]} prices 股票每日价格数组
 * @return {number} 能获取的最大利润
 */
var maxProfit = function (prices) {
    let p00 = 0, p01 = -Infinity, p10 = 0, p11 = -Infinity, p20 = 0, p21 = - prices[0];

    for (let price of prices) {
        p21 = Math.max(p11, p00 - price);
        p20 = Math.max(p10, p11 + price);
        p00 = p10, p01 = p11, p10 = p20, p11 = p21;
    }

    return p20;
};
```

#### [714. 买卖股票的最佳时机含手续费](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/)

给定一个整数数组 prices，其中 prices[i]表示第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。

你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。

返回获得利润的最大值。

注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。

 

```js
/**
 * 计算带手续费的股票买卖最大利润（动态规划+记忆化搜索）
 * @param {number[]} prices - 每日股价数组
 * @param {number} fee - 交易手续费
 * @return {number} 最大利润
 */
var maxProfit = function (prices, fee) {
    const n = prices.length;
    // 初始化DP数组，dp[i][0]表示第i天不持有股票的最大收益
    // dp[i][1]表示第i天持有股票的最大收益
    const dp = Array.from({ length: n }, () => Array(2));
    
    // 递归函数定义
    const f = (i, hold) => {
        // 基准情况：i < 0时的边界处理
        if (i < 0) return hold == 0 ? 0 : -Infinity; // 初始状态必须不持有股票
        
        // 检查缓存
        if (dp[i][hold] !== undefined) return dp[i][hold];
        
        if (hold) {
            // 当前持有股票的状态转移：
            // 1. 保持持有（不操作）
            // 2. 当天买入（需要扣除买入价格）
            return (dp[i][hold] = Math.max(
                f(i - 1, 1),
                f(i - 1, 0) - prices[i]
            ));
        }
        // 当前不持有股票的状态转移：
        // 1. 保持不持有（不操作）
        // 2. 当天卖出（获得收益并扣除手续费）
        return (dp[i][hold] = Math.max(
            f(i - 1, 0),
            f(i - 1, 1) + prices[i] - fee
        ));
    };

    // 最终返回最后一天不持有股票的最大收益
    return f(n - 1, 0);
};
```