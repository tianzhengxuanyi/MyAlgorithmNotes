### 多重背包

有 N 种物品和一个容量为 C 的背包，每种物品「数量有限」。

第 i 件物品的体积是 v[i] ，价值是 w[i]，数量为 s[i]。

问选择哪些物品，每件物品选择多少件，可使得总价值最大(等于target)。

**转移方程：**
$f[i][j] = \max(f[i-1][j-k*v[i]] + k*w[i])$ 其中 $0 \leq k \leq s[i]$。


#### [2585. 获得分数的方法数](https://leetcode.cn/problems/number-of-ways-to-earn-points/description/)

考试中有 n 种类型的题目。给你一个整数 target 和一个下标从 0 开始的二维整数数组 types ，其中 types[i] = [counti, marksi] 表示第 i 种类型的题目有 counti 道，每道题目对应 marksi 分。

返回你在考试中恰好得到 target 分的方法数。由于答案可能很大，结果需要对 109 +7 取余。

注意，同类型题目无法区分。

比如说，如果有 3 道同类型题目，那么解答第 1 和第 2 道题目与解答第 1 和第 3 道题目或者第 2 和第 3 道题目是相同的。

**转移方程：**
$f[i][j] = \sum_{k=0}^{count_i}(f[i-1][j-k*marks_i])$ ,其中 $j-k*marks_i \geq 0$。

```js
/**
 * @param {number} target
 * @param {number[][]} types
 * @return {number}
 */
var waysToReachTarget = function (target, types) {
    const n = types.length;
    const dp = Array.from({ length: n }, () => Array(target + 1).fill(0));
    for (let i = 0; i < n; i++) {
        const [cnt, mark] = types[i];
        for (let r = 0; r <= target; r++) {
            if (i === 0) {
                dp[i][r] =  r % mark === 0 && (r / mark) <= cnt ? 1 : 0;
                continue;
            }
            let res = 0;
            for (let k = 0; k <= Math.min(cnt, r / mark); k++) {
                res = (res + dp[i - 1][r - k * mark]) % mod;
            }
            dp[i][r] = res;
        }
    }

    return dp[n-1][target];
};


const mod = 1e9 + 7;
```

**空间优化：**
```js
/**
 * @param {number} target
 * @param {number[][]} types
 * @return {number}
 */
var waysToReachTarget = function (target, types) {
    const n = types.length;
    const dp = Array.from({length: target + 1}, (_, r) => r % types[0][1] === 0 && (r / types[0][1]) <= types[0][0] ? 1 : 0);
    for (let i = 1; i < n; i++) {
        const [cnt, mark] = types[i];
        for (let r = target; r >= 0 ; r--) {
            let res = 0;
            for (let k = 0; k <= Math.min(cnt, r / mark); k++) {
                res = (res + dp[r - k * mark]) % mod;
            }
            dp[r] = res;
        }
    }

    return dp[target];
};


const mod = 1e9 + 7;
```
