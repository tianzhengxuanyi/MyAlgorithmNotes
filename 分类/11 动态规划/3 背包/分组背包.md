### 分组背包

给定 N 个物品组，和容量为 C 的背包。

第 i 个物品组共有 S[i] 件物品，其中第 i 组的第 j 件物品的成本为 v[i][j]，价值为 w[i][j]。

每组有若干个物品，同一组内的物品**最多只能选一个**(恰好选一个)。

求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。

**转移方程（最多只能选一个）：**
$f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i][k]] + w[i][k]) (0 <= k <= s[i])$

**转移方程（恰好选一个）：**
$f[i][j] = max(f[i - 1][j - v[i][k]] + w[i][k]) (0 <= k <= s[i])$

#### [1155. 掷骰子等于目标和的方法数](https://leetcode.cn/problems/number-of-dice-rolls-with-target-sum/description/)

这里有 n 个一样的骰子，每个骰子上都有 k 个面，分别标号为 1 到 k 。

给定三个整数 n、k 和 target，请返回投掷骰子的所有可能得到的结果（共有 kn 种方式），使得骰子面朝上的数字总和等于 target。

由于答案可能很大，你需要对 109 + 7 取模。

**转移方程（方案数）：**
$f[i][r] = \sum_{j=1}^{k}(f[i - 1][r - j])$

```js
/**
 * @param {number} n
 * @param {number} k
 * @param {number} target
 * @return {number}
 */
var numRollsToTarget = function (n, k, target) {
  const dp = Array.from({ length: n }, () => Array(target + 1).fill(-1));
  const f = (i, r) => {
    if (r < 0) {
      return 0;
    }
    if (i === 0) {
      return r > k || r == 0 ? 0 : 1;
    }
    if (dp[i][r] >= 0) return dp[i][r];
    let res = 0;
    for (let j = 1; j <= k; j++) {
      res = (res + f(i - 1, r - j)) % mod;
    }

    return (dp[i][r] = res);
  };

  return f(n - 1, target) % mod;
};

const mod = 1e9 + 7;
```

**空间优化：**

```js
/**
 * @param {number} n
 * @param {number} k
 * @param {number} target
 * @return {number}
 */
var numRollsToTarget = function (n, k, target) {
  const dp = Array.from({ length: target + 1 }, (_, r) =>
    r > k || r == 0 ? 0 : 1
  );

  for (let i = 1; i < n; i++) {
    for (let r = target; r >= 0; r--) {
      let res = 0;
      for (let j = 1; j <= Math.min(r, k); j++) {
        res = (res + dp[r - j]) % mod;
      }
      dp[r] = res;
    }
  }

  return dp[target];
};

const mod = 1e9 + 7;
```
