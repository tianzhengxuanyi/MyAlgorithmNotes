### 最长回文子序列

#### [516. 最长回文子序列](https://leetcode.cn/problems/longest-palindromic-subsequence/description/)

给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。

子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。

**动态规划：**

dp[i][j]表示s[i...j]的最长回文子序列的长度。

状态转移：
- 当s[i] === s[j]时，dp[i][j] = dp[i+1][j-1] + 2。

- 当s[i] !== s[j]时，dp[i][j] = max(dp[i+1][j], dp[i][j-1], dp[i+1][j-1])。

初始化：
- 当i === j时，dp[i][j] = 1。
- 当i > j时，dp[i][j] = 0。

```js
/**
 * @param {string} s
 * @return {number}
 */
var longestPalindromeSubseq = function (s) {
    const n = s.length;
    // 创建二维 DP 数组，dp[i][j] 表示 s[i..j] 的最长回文子序列长度
    const dp = Array.from({ length: n }, () => Array(n).fill(0));

    // 倒序遍历保证子问题先被计算（i从末尾开始）
    for (let i = n - 1; i >= 0; i--) {
        dp[i][i] = 1; // 单个字符的回文长度为1
        // 枚举区间右端点 j
        for (let j = i + 1; j < n; j++) {
            // 情况1：首尾字符相等
            if (s[i] == s[j]) {
                dp[i][j] = Math.max(dp[i][j], dp[i + 1][j - 1] + 2);
            }
            // 情况2：首尾字符不等，取三种子问题的最大值
            dp[i][j] = Math.max(
                dp[i][j],            // 当前可能已经计算过的值
                dp[i + 1][j],        // 舍弃左端点
                dp[i][j - 1],        // 舍弃右端点
                dp[i + 1][j - 1]     // 同时舍弃两端（其实可以省略，因为前两种已包含）
            );
        }
    }
    // 返回整个字符串的最长回文子序列长度
    return dp[0][n - 1];
};
```


#### [730. 统计不同回文子序列](https://leetcode.cn/problems/count-different-palindromic-subsequences/description/)

给你一个字符串 s ，返回 s 中不同的非空回文子序列个数 。由于答案可能很大，请返回对 109 + 7 取余 的结果。

字符串的子序列可以经由字符串删除 0 个或多个字符获得。

如果一个序列与它反转后的序列一致，那么它是回文序列。

如果存在某个 i , 满足 ai != bi ，则两个序列 a1, a2, ... 和 b1, b2, ... 不同。

- s[i] 仅包含 'a', 'b', 'c' 或 'd' 

**动态规划：**

dp[i][j][k]表示s[i...j]中以字符k为开头和结尾的不同回文子序列个数。

状态转移：
- 当s[i] === s[j] === k时，dp[i][j][k] = dp[i+1][j-1]['a'...'d'] + 2。
- 当s[i] === k && s[j] !== k时， dp[i][j][k] = dp[i][j-1][k]
- 当s[i]!== k && s[j] === k时， dp[i][j][k] = dp[i+1][j][k]
- 当s[i]!== k && s[j]!== k时， dp[i][j][k] = dp[i+1][j-1][k]。

初始化：
- 当i === j时，dp[i][j][s[i]] = 1。

```js
/**
 * @param {string} s
 * @return {number}
 */
var countPalindromicSubsequences = function (s) {
    const n = s.length;
    // 初始化三维DP数组：dp[i][j][k] 表示s[i..j]区间中以字符k('a'-'d')为边界的不同回文子序列数
    const dp = Array.from({ length: n }, () =>
        Array.from({ length: n }, () => Array(4).fill(0))
    );

    // 倒序遍历起始点i（保证子问题先计算）
    for (let i = n - 1; i >= 0; i--) {
        const codeI = s[i].charCodeAt() - 97; // 当前起始字符编码（0-3）
        
        // 初始化长度为1的区间（单字符）
        for (let k = 0; k < 4; k++) {
            dp[i][i][k] = codeI == k ? 1 : 0; // 只有匹配字符时才有1个回文
        }
        
        // 枚举区间结束点j
        for (let j = i + 1; j < n; j++) {
            const codeJ = s[j].charCodeAt() - 97; // 当前结束字符编码
            
            for (let k = 0; k < 4; k++) { // 遍历四种可能的边界字符
                // 情况1：两端字符相同且等于当前边界字符k
                if (codeI == codeJ && codeI == k) {
                    // 累加中间所有可能的回文组合（四种边界情况）
                    for (let m = 0; m < 4; m++) {
                        dp[i][j][k] = (dp[i][j][k] + dp[i + 1][j - 1][m]) % mod;
                    }
                    // 新增两个单字符回文（s[i]和s[j]自身）以及它们的组合
                    dp[i][j][k] = (dp[i][j][k] + 2) % mod;
                }
                // 情况2：左边界匹配但右边界不匹配
                else if (codeI == k && codeJ !== k) {
                    dp[i][j][k] = dp[i][j - 1][k]; // 继承左边界固定时的结果
                }
                // 情况3：右边界匹配但左边界不匹配
                else if (codeJ == k && codeI !== k) {
                    dp[i][j][k] = dp[i + 1][j][k]; // 继承右边界固定时的结果
                }
                // 情况4：两端都不匹配当前边界字符
                else {
                    dp[i][j][k] = dp[i + 1][j - 1][k]; // 直接继承内部区间结果
                }
            }
        }
    }

    // 汇总四种边界字符的总回文数
    let ans = 0;
    for (let k = 0; k < 4; k++) {
        ans = (ans + dp[0][n - 1][k]) % mod;
    }

    return ans;
};

// 模数常量（10^9 + 7）
const mod = 1e9 + 7;

```


#### [1312. 让字符串成为回文串的最少插入次数](https://leetcode.cn/problems/minimum-insertion-steps-to-make-a-string-palindrome/description/)

给你一个字符串 s ，每一次操作你都可以在字符串的任意位置插入任意字符。

请你返回让 s 成为回文串的 最少操作次数 。

「回文串」是正读和反读都相同的字符串。

**动态规划：**

dp[i][j]表示s[i...j]的最少插入次数。

状态转移：
- 当s[i] === s[j]时，dp[i][j] = dp[i+1][j-1]。
- 当s[i]!== s[j]时，dp[i][j] = min(dp[i+1][j], dp[i][j-1]) + 1。

```js
/**
 * @param {string} s
 * @return {number}
 */
var minInsertions = function (s) {
    const n = s.length;
    // 初始化记忆化数组，dp[i][j] 表示让 s[i..j] 成为回文的最小插入次数
    const dp = Array.from({ length: n }, () => Array(n).fill(-1))
    
    const dfs = (i, j) => {
        // 基础情况：单个字符本身就是回文
        if (i === j) return dp[i][j] = 0;
        // 处理两个相邻字符的情况
        if (i + 1 == j) {
            return dp[i][j] = s[i] == s[j] ? 0 : 1; // 不同则需插入1次
        }
        if (dp[i][j] >= 0) return dp[i][j]; // 已计算过的子问题直接返回
        
        // 首尾字符相同的情况
        if (s[i] == s[j]) {
            return dp[i][j] = dfs(i + 1, j - 1); // 无需插入，取中间子串结果
        } else {
            // 三种插入策略取最小值（实际第三种情况可被前两种覆盖，但保留不影响结果）
            return dp[i][j] = Math.min(
                dfs(i, j - 1) + 1,  // 在右边插入s[i]使匹配，处理剩余区间
                dfs(i + 1, j) + 1  // 在左边插入s[j]使匹配，处理剩余区间
            );
        }
    };

    // 计算整个字符串的最小插入次数
    return dfs(0, n - 1);
};

```