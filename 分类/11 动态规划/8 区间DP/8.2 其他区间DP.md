### 8.2 其他区间DP

#### [5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/description/)

给你一个字符串 s，找到 s 中最长的 回文 子串。


**动态规划：**

dp[i][j]表示s[i...j]是否为回文子串。

状态转移：

- 当s[i] === s[j]时，dp[i][j] = dp[i+1][j-1] || i+ 1 > j -1。 // 单个字符或两个字符的情况。
- 当s[i]!== s[j]时，dp[i][j] = false。

初始化：

- 当i === j时，dp[i][j] = true。
- 当i > j时，dp[i][j] = false。

每次迭代更新最长回文子串的起始和结束位置。

```js
/**
 * @param {string} s
 * @return {string}
 */
var longestPalindrome = function (s) {
    const n = s.length;
    // DP数组：isPalindrome[i][j]表示s[i..j]是否为回文
    const isPalindrome = Array.from({ length: n }, () => Array(n).fill(false));
    // 记录最长回文的长度和起止索引
    let maxLen = 1, maxI = 0, maxJ = 0;
    
    // 初始化：单个字符都是回文
    for (let i = 0; i < n; i++) {
        isPalindrome[i][i] = true;
    }
    
    // 倒序计算区间[i,j]的回文状态
    for (let i = n - 2; i >= 0; i--) {
        for (let j = i + 1; j < n; j++) {
            // 状态转移：两端相等且内部子串是回文（或子串长度<=2）
            isPalindrome[i][j] = s[i] === s[j] && 
                (isPalindrome[i + 1][j - 1] || i + 1 > j - 1);
            
            // 更新最长回文记录
            if (isPalindrome[i][j] && j - i + 1 > maxLen) {
                maxLen = j - i + 1;
                maxI = i;
                maxJ = j;
            }
        }
    }

    // 根据记录的索引截取最长回文子串
    return s.slice(maxI, maxJ + 1);
};

```

#### [647. 回文子串](https://leetcode.cn/problems/palindromic-substrings/)

给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。

回文字符串 是正着读和倒过来读一样的字符串。

子字符串 是字符串中的由连续字符组成的一个序列。

**动态规划（同5. 最长回文子串思路一致）**

dp[i][j]表示s[i...j]是否为回文子串。

状态转移：

- 当s[i] === s[j]时，dp[i][j] = dp[i+1][j-1] || i+ 1 > j -1。 // 单个字符或两个字符的情况。
- 当s[i]!== s[j]时，dp[i][j] = false。

最终统计dp[i][j]为true的个数。

```js
/**
 * @param {string} s
 * @return {number}
 */
var countSubstrings = function (s) {
    const n = s.length;
    let ans = n; // 初始值为单字符回文数（每个字符都是回文）
    // DP数组：isP[i][j]表示s[i..j]是否为回文
    const isP = Array.from({ length: n }, () => Array(n).fill(false));

    // 初始化：长度为1的子串都是回文
    for (let i = 0; i < n; i++) {
        isP[i][i] = true;
    }

    // 倒序计算所有可能区间
    for (let i = n - 2; i >= 0; i--) {
        for (let j = i + 1; j < n; j++) {
            // 状态转移：首尾相同且内部子串回文（或长度<=2）
            isP[i][j] = s[i] === s[j] && (isP[i + 1][j - 1] || i + 1 > j - 1);
            
            // 发现回文时累计结果
            if (isP[i][j]) {
                ans++;
            }
        }
    }

    return ans; // 返回所有回文子串总数
};

```