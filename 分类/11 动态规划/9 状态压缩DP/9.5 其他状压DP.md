### 其他状压 DP

#### [1411. 给 N x 3 网格图涂色的方案数](https://leetcode.cn/problems/number-of-ways-to-paint-n-3-grid/description/)

你有一个 n x 3 的网格图 grid ，你需要用 红，黄，绿 三种颜色之一给每一个格子上色，且确保相邻格子颜色不同（也就是有相同水平边或者垂直边的格子颜色不同）。

给你网格图的行数 n 。

请你返回给 grid 涂色的方案数。由于答案可能会非常大，请你返回答案对 10^9 + 7 取余的结果。

**动态规划： 状态压缩**

定义： dfs(i, s) 表示当前第 i 行，且第 i 行的状态为 s 时的方案数。其中 s 为一个 9 位 的二进制数，每三位为一组，表示当前列选择的颜色。
如：'100 010 001' 表示第 1 列(100)选择了 红色 颜色，第 2 列(010)选择了 黄色 颜色，第 3 列选择了 绿色 颜色。

状态转移方程： dfs(i, s) = sum(dfs(i - 1, s')) 其中 s' 为第 i - 1 列的所有状态，且 s' 和 s 不冲突。

每一行单独考虑有 12 中状态，枚举这 12 种状态 s',如果 s & s' 为 0 ，则说明 s 和 s' 没有冲突，此时可以转移。

```js
/**
 * 计算n×3网格的涂色方案数
 * @param {number} n - 网格行数
 * @return {number} - 涂色方案数模1e9+7的结果
 */
var numOfWays = function (n) {
  // 记忆化数组，memo[i][s]表示第i行状态为s时的方案数
  const memo = Array.from({ length: n }, () => ({}));

  /**
   * 递归计算方案数
   * @param {number} i - 当前行索引
   * @param {number} s - 当前行状态(9位二进制数，每3位表示一列颜色)
   * @return {number} - 方案数
   */
  const dfs = (i, s) => {
    if (i == 0) return 1; // 第0行只有一种方案（基础情况）
    if (memo[i][s]) return memo[i][s]; // 已计算过则直接返回

    let res = 0;
    // 遍历所有可能的前一行状态
    for (let p of prob) {
      if (s & p) {
        // 检查当前行和前一行的颜色是否冲突
        continue;
      }
      res = (res + dfs(i - 1, p)) % mod; // 累加不冲突的方案数
    }

    return (memo[i][s] = res); // 记忆化并返回结果
  };

  let ans = 0;
  // 遍历所有可能的最后一行状态
  for (let p of prob) {
    ans = (ans + dfs(n - 1, p)) % mod;
  }

  return ans;
};

const mod = 1e9 + 7; // 模数
const prob = []; // 存储所有有效的单行状态

/**
 * 生成所有有效的单行涂色状态
 * @param {number} i - 当前列索引(0-2)
 * @param {number} path - 当前状态路径
 * @param {number} prev - 前一个选择的颜色
 */
const getProb = (i, path, prev) => {
  if (i == 3) {
    // 已处理完3列
    prob.push(path);
    return;
  }

  // 尝试所有可能的颜色选择
  for (let c = 0; c < 3; c++) {
    if (i == 0 || c !== prev) {
      // 第一列或颜色不同于前一列
      path |= 1 << (c * 3 + i); // 设置当前列颜色
      getProb(i + 1, path, c); // 递归处理下一列
      path ^= 1 << (c * 3 + i); // 回溯，撤销颜色选择
    }
  }
};

// 初始化所有有效单行状态
getProb(0, 0, -1);
```

**空间优化 + 递推**

```js
/**
 * 计算n×3网格的涂色方案数（空间优化版）
 * @param {number} n - 网格行数
 * @return {number} - 涂色方案数模1e9+7的结果
 */
var numOfWays = function (n) {
  // 使用滚动数组优化空间，dp[0]和dp[1]交替表示当前行和前一行
  const dp = Array.from({ length: 2 }, () => Array(12).fill(0));
  // 初始化第一行，所有12种状态都有1种方案
  dp[0].fill(1);

  // 动态规划处理每一行
  for (let i = 1; i < n; i++) {
    for (let j = 0; j < 12; j++) {
      dp[i % 2][j] = 0; // 重置当前行状态
      // 遍历所有可能的前一行状态
      for (let k = 0; k < 12; k++) {
        // 检查当前行状态j和前一行状态k是否冲突（是否有相邻同色）
        if (prob[j] & prob[k]) continue;
        // 累加不冲突的方案数
        dp[i % 2][j] = (dp[i % 2][j] + dp[(i - 1) % 2][k]) % mod;
      }
    }
  }

  let ans = 0;
  // 累加最后一行所有状态的方案数
  for (let j = 0; j < 12; j++) {
    ans = (ans + dp[(n - 1) % 2][j]) % mod;
  }

  return ans;
};

const mod = 1e9 + 7; // 模数，用于防止整数溢出
const prob = []; // 存储所有有效的单行状态（共12种）

/**
 * 生成所有有效的单行涂色状态
 * @param {number} i - 当前列索引(0-2)
 * @param {number} path - 当前状态路径
 * @param {number} prev - 前一个选择的颜色
 */
const getProb = (i, path, prev) => {
  if (i == 3) {
    // 已处理完3列
    prob.push(path);
    return;
  }

  // 尝试所有可能的颜色选择
  for (let c = 0; c < 3; c++) {
    if (i == 0 || c !== prev) {
      // 第一列或颜色不同于前一列
      path |= 1 << (c * 3 + i); // 设置当前列颜色
      getProb(i + 1, path, c); // 递归处理下一列
      path ^= 1 << (c * 3 + i); // 回溯，撤销颜色选择
    }
  }
};

// 初始化所有有效单行状态
getProb(0, 0, -1);
```

**另一种定义：**

单行的颜色可以分为两类 ABC（三个位置颜色都不同）和 ABA（三个位置颜色有两个相同）:

- 当 i 为 ABC，i-1 为 ABC 的个数为 2：
  - 假设 i 的颜色为 abc, i-1 的三个位置的颜色分别可能为(b\c)(a\c)(a\b)
  - 假设 i-1 第一个位置选 b，所有可能的组合为 baa、bab、bca、bcb。只有一种 bca 满足条件
  - 假设 i-1 第一个位置选 c，所有可能的组合为 caa、cab、cca、ccb。只有一种 cab 满足条件
- 当 i 为 ABC，i-1 为 ABA 的个数为 2（bab、bcb）
- 当 i 为 ABA，i-1 为 ABC 的个数为 2
- 当 i 为 ABA，i-1 为 ABA 的个数为 3

**状态转移方程：**

- f_i_ABC = 2 _ f_i-1_ABC + 2 _ f_i-1_ABA
- f_i_ABA = 2 _ f_i-1_ABC + 3 _ f_i-1_ABA

```js
/**
 * 计算n×3网格的涂色方案数（基于状态分类优化版）
 * @param {number} n - 网格行数
 * @return {number} - 涂色方案数模1e9+7的结果
 */
var numOfWays = function (n) {
  // 初始化：f0表示ABC类型（三列颜色各不相同）的方案数
  // f1表示ABA类型（首尾同色）的方案数
  let f0 = 6, // 第一行ABC类型有6种方案（3!排列）
    f1 = 6; // 第一行ABA类型有6种方案（3颜色×2中间颜色）
  let new_f0, new_f1; // 临时变量存储下一状态

  // 动态规划处理每一行
  for (let i = 1; i < n; i++) {
    // ABC类型的新行可以由：
    // 1. 前一行ABC类型转移而来，有2种方式
    // 2. 前一行ABA类型转移而来，有2种方式
    new_f0 = (((2 * f0) % mod) + ((2 * f1) % mod)) % mod;

    // ABA类型的新行可以由：
    // 1. 前一行ABC类型转移而来，有2种方式
    // 2. 前一行ABA类型转移而来，有3种方式
    new_f1 = (((2 * f0) % mod) + ((3 * f1) % mod)) % mod;

    // 更新状态
    (f0 = new_f0), (f1 = new_f1);
  }

  // 总方案数为两种类型方案数之和
  return (f0 + f1) % mod;
};

// 模数，用于防止整数溢出
const mod = 1e9 + 7;
```
