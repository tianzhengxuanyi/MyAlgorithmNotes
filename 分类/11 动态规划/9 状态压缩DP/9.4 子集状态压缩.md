### 9.4 子集状压 DP

一般定义 f[S] 表示未选（或者已选）的集合为 S 时，和题目有关的最优值。通过枚举 S（或者 S 的补集 ∁ U S）的子集来转移。

时间复杂度（通常来说）是 O(3 ^ n)

值得注意的是，枚举子集的子集还可以用「选或不选」来做，对于存在无效状态的情况，可以做到更优的时间复杂度。具体见 1349 题解 最后的写法。 


#### [2305. 公平分发饼干](https://leetcode.cn/problems/fair-distribution-of-cookies/description/)
 
给你一个整数数组 cookies ，其中 cookies[i] 表示在第 i 个零食包中的饼干数量。另给你一个整数 k 表示等待分发零食包的孩子数量，所有 零食包都需要分发。在同一个零食包中的所有饼干都必须分发给同一个孩子，不能分开。

分发的 不公平程度 定义为单个孩子在分发过程中能够获得饼干的最大总数。

返回所有分发的最小不公平程度。

**动态规划： 子集状压**

```js
/**
 * @param {number[]} cookies
 * @param {number} k
 * @return {number}
 */
var distributeCookies = function (cookies, k) {
    const n = cookies.length;
    // 预处理所有子集的饼干总和
    const sum = Array(1 << n).fill(0);
    for (let i = 0; i < n; i++) {
        // 动态规划预处理子集和：通过添加第i个元素生成新子集
        for (let j = 0, bit = 1 << i; j < bit; j++) {
            sum[bit | j] = sum[j] + cookies[i];
        }
    }

    // 记忆化数组：memo[i][s] 表示前i个孩子分配s集合时的最小最大和
    const memo = Array.from({ length: k }, () => Array(1 << n).fill(-1));
    
    // DFS + 记忆化搜索
    const dfs = (i, s) => {
        if (s == 0) return 0;    // 所有饼干已分配完毕
        if (i < 0) return Infinity; // 无效状态
        if (memo[i][s] >= 0) return memo[i][s];
        
        let res = Infinity;
        let sub = s; // 当前孩子要分配的饼干子集
        
        // 枚举所有可能的子集分配方案
        while (sub !== 0) {
            // 当前子集给第i个孩子，剩余子集递归处理
            res = Math.min(res, Math.max(
                dfs(i - 1, (s ^ sub)), // 剩余子集分配给前i-1个孩子
                sum[sub]               // 当前孩子获得的饼干数
            ));
            // 位运算技巧：获取下一个子集
            sub = (sub - 1) & s;
        }
        return memo[i][s] = res;
    };

    // 初始状态：k-1号孩子分配全部饼干（二进制全1表示）
    return dfs(k - 1, (1 << n) - 1);
};

```

#### [1986. 完成任务的最少工作时间段](https://leetcode.cn/problems/minimum-number-of-work-sessions-to-finish-the-tasks/description/)
 
你被安排了 n 个任务。任务需要花费的时间用长度为 n 的整数数组 tasks 表示，第 i 个任务需要花费 tasks[i] 小时完成。一个 工作时间段 中，你可以 至多 连续工作 sessionTime 个小时，然后休息一会儿。

你需要按照如下条件完成给定任务：

如果你在某一个时间段开始一个任务，你需要在 同一个 时间段完成它。
完成一个任务后，你可以 立马 开始一个新的任务。
你可以按 任意顺序 完成任务。
给你 tasks 和 sessionTime ，请你按照上述要求，返回完成所有任务所需要的 最少 数目的 工作时间段 。

测试数据保证 sessionTime 大于等于 tasks[i] 中的 最大值 。

```js

/**
 * @param {number[]} tasks
 * @param {number} sessionTime
 * @return {number}
 */
/**
 * @param {number[]} cookies 饼干数组，每个元素表示一个零食包中的饼干数量
 * @param {number} k 孩子数量
 * @return {number} 返回所有分发方案中的最小不公平程度
 */
var distributeCookies = function (cookies, k) {
    const n = cookies.length;
    // 预处理所有子集的饼干总和
    // sum数组：sum[mask]表示当选择mask代表的子集时，饼干的总数量
    const sum = Array(1 << n).fill(0);
    for (let i = 0; i < n; i++) {
        // 动态规划预处理子集和：通过添加第i个元素生成新子集
        for (let j = 0, bit = 1 << i; j < bit; j++) {
            sum[bit | j] = sum[j] + cookies[i];
        }
    }

    // 记忆化数组：memo[i][s] 表示前i个孩子分配s集合时的最小最大和
    const memo = Array.from({ length: k }, () => Array(1 << n).fill(-1));
    
    // DFS + 记忆化搜索
    // i: 当前处理的孩子索引(0-based)
    // s: 二进制掩码，表示还未分配的饼干集合
    const dfs = (i, s) => {
        if (s == 0) return 0;    // 所有饼干已分配完毕
        if (i < 0) return Infinity; // 无效状态(没有孩子可分)
        if (memo[i][s] >= 0) return memo[i][s]; // 已计算过，直接返回
        
        let res = Infinity;
        let sub = s; // 当前孩子要分配的饼干子集
        
        // 枚举所有可能的子集分配方案
        // 使用位运算技巧高效枚举子集
        while (sub !== 0) {
            // 当前子集给第i个孩子，剩余子集递归处理
            res = Math.min(res, Math.max(
                dfs(i - 1, (s ^ sub)), // 剩余子集分配给前i-1个孩子
                sum[sub]               // 当前孩子获得的饼干数
            ));
            // 位运算技巧：获取下一个子集
            // (sub-1) & s 可以得到比sub小的下一个有效子集
            sub = (sub - 1) & s;
        }
        return memo[i][s] = res; // 记忆化存储结果
    };

    // 初始状态：k-1号孩子分配全部饼干（二进制全1表示）
    return dfs(k - 1, (1 << n) - 1);
};

```