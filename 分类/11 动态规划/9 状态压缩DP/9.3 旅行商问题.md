### 9.3 旅行商问题

给定一个字符串数组 words，找到以 words 中每个字符串作为子字符串的最短字符串。如果有多个有效最短字符串满足题目条件，返回其中 任意一个 即可。

我们可以假设 words 中没有字符串是 words 中另一个字符串的子字符串。

#### [943. 最短超级串](https://leetcode.cn/problems/find-the-shortest-superstring/description/)
 
给定一个字符串数组 words，找到以 words 中每个字符串作为子字符串的最短字符串。如果有多个有效最短字符串满足题目条件，返回其中 任意一个 即可。

我们可以假设 words 中没有字符串是 words 中另一个字符串的子字符串。

**动态规划：**

```js
/**
 * 找到包含所有单词的最短超级字符串
 * @param {string[]} words - 输入的单词数组
 * @return {string} 最短的超级字符串
 */
var shortestSuperstring = function (words) {
    const n = words.length;
    // ws[i][j] 表示words[i]的后缀与words[j]的前缀的最大重叠长度
    const ws = Array.from({ length: n }, () => Array(n).fill(0));

    // 预处理计算所有单词对之间的最大重叠长度
    for (let i = 0; i < n; i++) {
        let lenI = words[i].length;
        for (let j = 0; j < n; j++) {
            if (i == j) continue; // 跳过自身比较
            // 从最大可能重叠长度开始检查
            for (let l = Math.min(lenI, words[j].length); l >= 0; l--) {
                if (words[i].slice(lenI - l) === words[j].slice(0, l)) {
                    ws[i][j] = l; // 记录最大重叠长度
                    break;
                }
            }
        }
    }

    // p[s][i] 记录在状态s下，以i结尾时的前驱节点
    const p = Array.from({ length: (1 << n) }, () => Array(n).fill(-1));
    // f[s][i] 记录在状态s下，以i结尾时的最大重叠长度
    const f = Array.from({ length: (1 << n) }, () => Array(n).fill(-Infinity));
    
    // 初始化：每个单词单独存在时的状态
    for (let i = 0; i < n; i++) {
        f[1 << i][i] = 0;
    }
    
    // 动态规划处理所有状态
    for (let s = 1; s < (1 << n); s++) {
        for (let i = 0; i < n; i++) {
            // 如果状态s不包含i，或者s只包含i，则跳过
            if (!(s & (1 << i)) || s == (1 << i)) continue;

            // 尝试从所有可能的前驱状态转移
            for (let j = 0; j < n; j++) {
                if (!(s & (1 << j)) || j == i) continue;
                let t = f[s ^ (1 << i)][j] + ws[j][i];
                if (t >= f[s][i]) {
                    f[s][i] = t;
                    p[s][i] = j; // 记录前驱节点
                }
            }
        }
    }

    // 回溯找出最优解
    let ans = "", last, status = (1 << n) - 1, max = -Infinity;
    // 找到最终状态下的最优结尾单词
    for (let i = 0; i < n; i++) {
        if (f[status][i] > max) {
            max = f[status][i];
            last = i;
        }
    }

    // 从最后节点开始回溯构建超级字符串
    ans = words[last];
    while (status) {
        let prev = p[status][last];
        if (prev == -1) break; // 没有前驱节点时停止
        // 将前驱单词的非重叠部分拼接到结果前面
        ans = words[prev].slice(0, words[prev].length - ws[prev][last]) + ans;
        status ^= (1 << last); // 移除当前节点
        last = prev; // 移动到前驱节点
    }

    return ans;
};

```