### 9.1 排列型 相邻无关

暴力做法是枚举所有排列，对每个排列计算和题目有关的值，时间复杂度（通常来说）是 O(n!)。可以解决 n≤10 的问题。

状压 DP 可以把时间复杂度（通常来说）优化至 O(n⋅2^n)。可以解决 n≤20 的问题。

一般有两种定义方式：

- 定义 f[S] 表示已经排列好的元素（下标）集合为 S 时，和题目有关的最优值。通过枚举当前位置要填的元素（下标）来转移。
- 定义 f[S] 表示可以选的元素（下标）集合为 S 时，和题目有关的最优值。通过枚举当前位置要填的元素（下标）来转移。

#### [526. 优美的排列](https://leetcode.cn/problems/beautiful-arrangement/description/)

假设有从 1 到 n 的 n 个整数。用这些整数构造一个数组 perm（下标从 1 开始），只要满足下述条件 之一 ，该数组就是一个 优美的排列 ：

- perm[i] 能够被 i 整除
- i 能够被 perm[i] 整除

给你一个整数 n ，返回可以构造的 优美排列 的 数量 。

**动态规划：状态压缩**

定义 dfs(s)表示已经选好的元素集合位 s 时，最终的优美排列数量。

状态转移：

- 枚举 s 中没有选的元素 x，满足 x 是 i 的倍数或 i 是 x 的倍数。

入口：dfs(0)，表示初始时没有选任何元素。

出口：当 s 包含 n 个元素时（统计 s 中位 1 的个数），返回 1。

```js
/**
 * 计算优美排列的数量
 * @param {number} n - 数字范围 [1, n]
 * @return {number} 优美排列的数量
 */
var countArrangement = function (n) {
  // 记忆化数组，memo[s]表示已选数字集合为s时的排列数
  const memo = Array(1 << n).fill(-1);

  // DFS函数，s是已选数字的位图表示
  const dfs = (s) => {
    // 终止条件：所有数字都已选中（所有位都为1）
    if (s === (1 << n) - 1) return (memo[s] = 1);
    // 记忆化：如果已计算过则直接返回
    if (memo[s] >= 0) return memo[s];

    let res = 0;
    // j表示当前要填的位置（第几个数字）
    const j = bitCount_32(s) + 1;

    // 枚举所有数字
    for (let i = 1; i <= n; i++) {
      // 跳过已选的数字
      if (s & (1 << (i - 1))) continue;
      // 检查优美排列条件
      if (i % j == 0 || j % i == 0) {
        // 递归计算选中i后的排列数
        res += dfs(s | (1 << (i - 1)));
      }
    }

    return (memo[s] = res);
  };

  return dfs(0); // 从空集合开始
};

/**
 * 计算32位整数中1的个数（汉明重量）
 * @param {number} n - 要计算的数字
 * @return {number} 1的个数
 */
function bitCount_32(n) {
  let cnt = 0;
  while (n) {
    cnt++;
    n &= n - 1; // 清除最低位的1
  }
  return cnt;
}
```

```js
/**
 * 计算优美排列的数量（迭代版）
 * @param {number} n - 数字范围 [1, n]
 * @return {number} 优美排列的数量
 */
var countArrangement = function (n) {
  // DP数组，f[s]表示已选数字集合为s时的排列数
  const f = Array(1 << n).fill(0);
  // 初始状态：空集合的排列数为1
  f[0] = 1;

  // 枚举所有可能的数字集合状态
  for (let s = 1; s < 1 << n; s++) {
    // j表示当前集合的大小（即已选数字的个数）
    const j = bitCount_32(s);

    // 枚举所有可能的数字
    for (let i = 1; i <= n; i++) {
      // 检查数字i是否在当前集合中，且满足优美排列条件
      if ((s >> (i - 1)) & 1 && (i % j == 0 || j % i == 0)) {
        // 状态转移：从去掉i的状态累加
        f[s] += f[s ^ (1 << (i - 1))];
      }
    }
  }

  // 返回所有数字都被选中的状态的结果
  return f[(1 << n) - 1];
};

/**
 * 计算32位整数中1的个数（汉明重量）
 * @param {number} n - 要计算的数字
 * @return {number} 1的个数
 */
function bitCount_32(n) {
  let cnt = 0;
  while (n) {
    cnt++;
    n &= n - 1; // 清除最低位的1
  }
  return cnt;
}
```

#### [3376. 破解锁的最少时间 I](https://leetcode.cn/problems/minimum-time-to-break-locks-i/description/)

Bob 被困在了一个地窖里，他需要破解 n 个锁才能逃出地窖，每一个锁都需要一定的 能量 才能打开。每一个锁需要的能量存放在一个数组 strength 里，其中 strength[i] 表示打开第 i 个锁需要的能量。

Bob 有一把剑，它具备以下的特征：

一开始剑的能量为 0 。
剑的能量增加因子 X 一开始的值为 1 。
每分钟，剑的能量都会增加当前的 X 值。
打开第 i 把锁，剑的能量需要到达 至少 strength[i] 。
打开一把锁以后，剑的能量会变回 0 ，X 的值会增加一个给定的值 K 。
你的任务是打开所有 n 把锁并逃出地窖，请你求出需要的 最少 分钟数。

请你返回 Bob 打开所有 n 把锁需要的 最少 时间。
