### 前后缀分解

#### [238. 除自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/description/)
 
给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。

题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内。

请 不要使用除法，且在 O(n) 时间复杂度内完成此题。

```js
/**
 * 前后缀分解算法：计算数组中每个元素除自身外所有元素的乘积
 * 算法思路：
 * 1. 构建前缀乘积数组prefix，prefix[i]表示nums[0..i-1]的乘积
 * 2. 构建后缀乘积（通过变量迭代计算），表示nums[i+1..n-1]的乘积
 * 3. 将前缀乘积与后缀乘积相乘，得到结果
 * 时间复杂度：O(n)，空间复杂度：O(1)（不考虑输出数组）
 * @param {number[]} nums - 输入数组
 * @return {number[]} - 每个元素除自身外所有元素的乘积组成的数组
 */
var productExceptSelf = function(nums) {
    // 获取数组长度
    const n = nums.length;
    // 初始化前缀乘积数组，默认值为1
    const prefix = Array(n).fill(1);
    // 计算前缀乘积：prefix[i] = nums[0] * nums[1] * ... * nums[i-1]
    for (let i = 1; i < n; i++) {
        // 当前前缀乘积 = 前一个前缀乘积 * 前一个元素值
        prefix[i] = prefix[i - 1] * nums[i - 1];
    }
    // 初始化后缀乘积变量，初始值为1
    let suffix = 1;
    // 从后向前计算后缀乘积并与前缀乘积结合
    for (let i = n - 2; i >= 0; i--) {
        // 更新后缀乘积：当前后缀乘积 = 原后缀乘积 * 后一个元素值
        suffix = suffix * nums[i+1];
        // 当前结果 = 前缀乘积 * 后缀乘积
        prefix[i] = prefix[i] * suffix;
    }
    // 返回计算结果（复用prefix数组存储最终结果）
    return prefix;
};

```

#### [724. 寻找数组的中心下标](https://leetcode.cn/problems/find-pivot-index/description/)
 
给你一个整数数组 nums ，请计算数组的 中心下标 。

数组 中心下标 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。

如果中心下标位于数组最左端，那么左侧数之和视为 0 ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。

如果数组有多个中心下标，应该返回 最靠近左边 的那一个。如果数组不存在中心下标，返回 -1 。

**前后缀分解：**

```js
/**
 * 寻找数组的中心索引
 * @param {number[]} nums 输入数组
 * @return {number} 返回中心索引，不存在则返回-1
 */
var pivotIndex = function(nums) {
    const n = nums.length;  // 获取数组长度
    const suffix = Array(n).fill(0);  // 创建后缀和数组，初始化为0
    
    // 计算后缀和数组：从右向左遍历，suffix[i]表示i右侧所有元素的和
    for (let i = n - 2; i>= 0; i--) {
        suffix[i] = suffix[i+1] + nums[i+1];  // 当前后缀和 = 后一个后缀和 + 后一个元素值
    }
    
    // 检查第一个元素是否是中心索引（左侧和为0）
    if (suffix[0] === 0) return 0;
    
    let prefix = 0;  // 初始化前缀和
    
    // 从左向右遍历，检查每个位置是否是中心索引
    for (let i = 1; i < n; i++) {
        prefix = prefix + nums[i - 1];  // 更新前缀和 = 前一个前缀和 + 前一个元素值
        if (prefix === suffix[i]) return i;  // 如果前缀和等于后缀和，返回当前索引
    }
    
    // 检查最后一个元素是否是中心索引（右侧和为0）
    if (prefix[n - 1] === 0) return n - 1;
    
    return -1;  // 没有找到中心索引，返回-1
};

```

**优化：**

计算nums的总和，然后从左到右遍历，计算前缀和，后缀和为总和减去前缀和减去当前元素。

```js
/**
 * 寻找数组的中心索引（优化版）
 * @param {number[]} nums 输入数组
 * @return {number} 返回中心索引，不存在则返回-1
 */
var pivotIndex = function(nums) {
    const n = nums.length;  // 获取数组长度
    let sum = 0;  // 初始化总和变量
    
    // 计算数组所有元素的总和
    for (let i = 0; i < n; i++) {
        sum += nums[i];  // 累加每个元素到总和
    }
    
    // 检查第一个元素是否是中心索引（右侧和=总和-第一个元素=0）
    if (sum - nums[0] == 0) return 0;
    
    let prefix = 0;  // 初始化前缀和
    
    // 从左向右遍历，检查每个位置是否是中心索引
    for (let i = 1; i < n; i++) {
        prefix = prefix + nums[i - 1];  // 更新前缀和 = 前一个前缀和 + 前一个元素值
        // 如果前缀和等于后缀和（总和-前缀和-当前元素），返回当前索引
        if (prefix == (sum - prefix - nums[i])) return i;
    }
    
    return -1;  // 没有找到中心索引，返回-1
};

```