### 树的直径

#### [543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/description/)
 
给你一棵二叉树的根节点，返回该树的 直径 。

二叉树的 直径 是指树中任意两个节点之间最长路径的 长度 。这条路径可能经过也可能不经过根节点 root 。

两节点之间路径的 长度 由它们之间边数表示。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * 计算二叉树的直径（最长路径的边数）
 * @param {TreeNode} root 二叉树的根节点
 * @return {number} 树的直径（边数）
 */
var diameterOfBinaryTree = function (root) {
    return dfs(root)[1] - 1; // 返回直径（需要将节点数减1转换为边数）
};

/**
 * 深度优先搜索辅助函数
 * @param {TreeNode} node 当前节点
 * @return {number[]} 返回一个数组：
 *   [0]: 当前节点的最大深度（从当前节点到叶子节点的最长路径节点数）
 *   [1]: 当前子树中的最大直径（节点数）
 */
const dfs = (node) => {
    if (!node) return [0, 0]; // 空节点深度为0，直径为0

    const left = dfs(node.left), right = dfs(node.right); // 递归获取左右子树信息
    
    // 返回：
    // [0] 当前节点深度 = 左右子树最大深度 + 1（当前节点）
    // [1] 当前子树直径 = max(左子树直径, 右子树直径, 经过当前节点的路径长度)
    return [Math.max(left[0], right[0]) + 1, Math.max(left[1], right[1], left[0] + right[0] + 1)];
}

```

- 链：从子树中的叶子节点到当前节点的路径。把最长链的长度，作为 dfs 的返回值。根据这一定义，空节点的链长是 −1，叶子节点的链长是 0。
- 直径：等价于由两条（或者一条）链拼成的路径。我们枚举每个 node，假设直径在这里「拐弯」，也就是计算由左右两条从下面的叶子节点到 node 的链的节点值之和，去更新答案的最大值。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * 计算二叉树的直径（最长路径的边数）
 * @param {TreeNode} root 二叉树的根节点
 * @return {number} 树的直径（边数）
 */
var diameterOfBinaryTree = function (root) {
    // 初始化一个变量 ans 用于存储二叉树的最大直径
    let ans = 0;
    /**
     * 深度优先搜索辅助函数，计算以当前节点为根的子树中最长链的长度
     * @param {TreeNode} node 当前节点
     * @return {number} 从当前节点到其叶子节点的最长链的长度
     */
    const dfs = (node) => {
        // 若当前节点为空，规定其链长为 -1
        if (!node) return -1;

        // left 和 right 表示 当前节点到左子树和 右子树 最长链的长度
        // 递归计算左子树的最长链长度，叶子节点链的长度为 0，当前节点到左子节点增加一条边，所以加 1
        let left = dfs(node.left) + 1; 
        // 递归计算右子树的最长链长度，叶子节点链的长度为 0，当前节点到右子节点增加一条边，所以加 1
        let right = dfs(node.right) + 1; 
        // 更新最大直径，直径为经过当前节点的左右链长度之和
        ans = Math.max(ans, left + right);

        // 返回从当前节点出发的最长链长度
        return Math.max(left, right);
    }
    // 从根节点开始进行深度优先搜索
    dfs(root);

    // 返回计算得到的最大直径
    return ans;
};


```

#### [687. 最长同值路径](https://leetcode.cn/problems/longest-univalue-path/description/)

给定一个二叉树的 root ，返回 最长的路径的长度 ，这个路径中的 每个节点具有相同值 。 这条路径可以经过也可以不经过根节点。

两个节点之间的路径长度 由它们之间的边数表示。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * 计算二叉树中最长同值路径的长度
 * @param {TreeNode} root 二叉树的根节点
 * @return {number} 最长同值路径的长度（边数）
 */
var longestUnivaluePath = function(root) {
    // 初始化一个变量 ans 用于存储最长同值路径的长度
    let ans = 0;

    /**
     * 深度优先搜索辅助函数，计算以当前节点为起点的最长同值链的长度
     * @param {TreeNode} node 当前节点
     * @return {number} 从当前节点出发的最长同值链的长度
     */
    const dfs = (node) => {
        // 若当前节点为空，规定其同值链长度为 -1
        if (!node) return -1;

        // 递归计算左子树的最长同值链长度，当前节点到左子节点增加一条边，所以加 1
        let left = dfs(node.left) + 1;
        // 递归计算右子树的最长同值链长度，当前节点到右子节点增加一条边，所以加 1
        let right = dfs(node.right) + 1;

        // 若当前节点的值与左子节点的值不同，则将左子树的同值链长度置为 0
        left = node.val === node.left?.val ? left : 0;
        // 若当前节点的值与右子节点的值不同，则将右子树的同值链长度置为 0
        right = node.val === node.right?.val ? right : 0;

        // 更新最长同值路径的长度，即经过当前节点的左右同值链长度之和
        ans = Math.max(ans, left + right);

        // 返回从当前节点出发的最长同值链长度
        return Math.max(left, right);
    }

    // 从根节点开始进行深度优先搜索
    dfs(root);

    // 返回计算得到的最长同值路径的长度
    return ans;
};

```

#### [124. 二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/description/)

二叉树中的 路径 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。

路径和 是路径中各节点值的总和。

给你一个二叉树的根节点 root ，返回其 最大路径和 。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * 计算二叉树中的最大路径和
 * @param {TreeNode} root 二叉树的根节点
 * @return {number} 二叉树中的最大路径和
 */
var maxPathSum = function (root) {
    // 初始化最大路径和为负无穷，确保任何路径和都能更新该值
    let ans = -Infinity;
    /**
     * 深度优先搜索辅助函数，计算以当前节点为起点的最大路径和
     * @param {TreeNode} node 当前节点
     * @return {number} 从当前节点出发的最大路径和，若为负数则返回 0
     */
    const dfs = (node) => {
        // 若当前节点为空，路径和为 0
        if (!node) return 0;

        // 递归计算左子树的最大路径和
        let left = dfs(node.left);
        // 递归计算右子树的最大路径和
        let right = dfs(node.right);

        // 更新最大路径和，考虑经过当前节点的左右子树路径和
        ans = Math.max(ans, left + right + node.val);

        // 返回从当前节点出发的最大路径和，若结果为负数则返回 0，因为负数路径和不会使整体路径和增大
        return Math.max(Math.max(left, right) + node.val, 0);
    }

    // 从根节点开始进行深度优先搜索
    dfs(root);

    // 返回计算得到的最大路径和
    return ans;
};

```

#### [2385. 感染二叉树需要的总时间](https://leetcode.cn/problems/amount-of-time-for-binary-tree-to-be-infected/description/)

给你一棵二叉树的根节点 root ，二叉树中节点的值 互不相同 。另给你一个整数 start 。在第 0 分钟，感染 将会从值为 start 的节点开始爆发。

每分钟，如果节点满足以下全部条件，就会被感染：

- 节点此前还没有感染。
- 节点与一个已感染节点相邻。

返回感染整棵树需要的分钟数。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} start
 * @return {number}
 */
var amountOfTime = function (root, start) {
    // 存储最大感染时间（分钟数）
    let ans = 0;

    /**
     * 深度优先搜索辅助函数
     * @param {TreeNode} node 当前节点
     * @return {number[]} 返回一个数组：
     *   [0]: 当前节点到最远叶子节点的距离（链长）
     *   [1]: 是否在当前子树中找到了感染起始点
     */
    const dfs = (node) => {
        // 空节点返回[0, false]
        if (!node) return [0, false];

        // 递归获取左右子树信息
        let [lLen, lFound] = dfs(node.left);
        let [rLen, rFound] = dfs(node.right);

        // 情况1：当前节点是感染起始点
        if (node.val === start) {
            // 最大感染时间是左右子树中最长的链
            ans = Math.max(lLen, rLen);
            // 返回[1, true]表示找到起始点且链长为1（当前节点）
            return [1, true];
        }
        
        // 情况2：左右子树都未找到感染起始点
        if (!lFound && !rFound) {
            // 更新最大感染时间为当前最长链+1（当前节点）
            ans = Math.max(ans, Math.max(lLen, rLen) + 1);
            // 返回当前最长链+1，标记未找到起始点
            return [Math.max(lLen, rLen) + 1, false];
        } 
        // 情况3：至少一个子树中找到感染起始点
        else {
            // 更新最大感染时间为左右链长度之和（感染从一侧传播到另一侧）
            ans = Math.max(ans, lLen + rLen);
            // 返回感染路径上的链长（找到起始点的子树链长+1）
            return [lFound ? lLen + 1 : rLen + 1, true]
        }
    }

    // 从根节点开始搜索
    dfs(root);

    // 返回最大感染时间
    return ans;
};

```