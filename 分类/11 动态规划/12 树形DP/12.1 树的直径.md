### 树的直径

#### [543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/description/)
 
给你一棵二叉树的根节点，返回该树的 直径 。

二叉树的 直径 是指树中任意两个节点之间最长路径的 长度 。这条路径可能经过也可能不经过根节点 root 。

两节点之间路径的 长度 由它们之间边数表示。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * 计算二叉树的直径（最长路径的边数）
 * @param {TreeNode} root 二叉树的根节点
 * @return {number} 树的直径（边数）
 */
var diameterOfBinaryTree = function (root) {
    return dfs(root)[1] - 1; // 返回直径（需要将节点数减1转换为边数）
};

/**
 * 深度优先搜索辅助函数
 * @param {TreeNode} node 当前节点
 * @return {number[]} 返回一个数组：
 *   [0]: 当前节点的最大深度（从当前节点到叶子节点的最长路径节点数）
 *   [1]: 当前子树中的最大直径（节点数）
 */
const dfs = (node) => {
    if (!node) return [0, 0]; // 空节点深度为0，直径为0

    const left = dfs(node.left), right = dfs(node.right); // 递归获取左右子树信息
    
    // 返回：
    // [0] 当前节点深度 = 左右子树最大深度 + 1（当前节点）
    // [1] 当前子树直径 = max(左子树直径, 右子树直径, 经过当前节点的路径长度)
    return [Math.max(left[0], right[0]) + 1, Math.max(left[1], right[1], left[0] + right[0] + 1)];
}

```

- 链：从子树中的叶子节点到当前节点的路径。把最长链的长度，作为 dfs 的返回值。根据这一定义，空节点的链长是 −1，叶子节点的链长是 0。
- 直径：等价于由两条（或者一条）链拼成的路径。我们枚举每个 node，假设直径在这里「拐弯」，也就是计算由左右两条从下面的叶子节点到 node 的链的节点值之和，去更新答案的最大值。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * 计算二叉树的直径（最长路径的边数）
 * @param {TreeNode} root 二叉树的根节点
 * @return {number} 树的直径（边数）
 */
var diameterOfBinaryTree = function (root) {
    // 初始化一个变量 ans 用于存储二叉树的最大直径
    let ans = 0;
    /**
     * 深度优先搜索辅助函数，计算以当前节点为根的子树中最长链的长度
     * @param {TreeNode} node 当前节点
     * @return {number} 从当前节点到其叶子节点的最长链的长度
     */
    const dfs = (node) => {
        // 若当前节点为空，规定其链长为 -1
        if (!node) return -1;

        // left 和 right 表示 当前节点到左子树和 右子树 最长链的长度
        // 递归计算左子树的最长链长度，叶子节点链的长度为 0，当前节点到左子节点增加一条边，所以加 1
        let left = dfs(node.left) + 1; 
        // 递归计算右子树的最长链长度，叶子节点链的长度为 0，当前节点到右子节点增加一条边，所以加 1
        let right = dfs(node.right) + 1; 
        // 更新最大直径，直径为经过当前节点的左右链长度之和
        ans = Math.max(ans, left + right);

        // 返回从当前节点出发的最长链长度
        return Math.max(left, right);
    }
    // 从根节点开始进行深度优先搜索
    dfs(root);

    // 返回计算得到的最大直径
    return ans;
};


```