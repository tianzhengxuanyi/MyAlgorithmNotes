### 12.5 其他树形 DP

#### 2925. 在树上执行操作以后得到的最大分数

有一棵 n 个节点的无向树，节点编号为 0 到 n - 1 ，根节点编号为 0 。给你一个长度为 n - 1 的二维整数数组 edges 表示这棵树，其中 edges[i] = [ai, bi] 表示树中节点 ai 和 bi 有一条边。

同时给你一个长度为 n 下标从 0 开始的整数数组 values ，其中 values[i] 表示第 i 个节点的值。

一开始你的分数为 0 ，每次操作中，你将执行：

- 选择节点 i 。
- 将 values[i] 加入你的分数。
- 将 values[i] 变为 0 。
  如果从根节点出发，到任意叶子节点经过的路径上的节点值之和都不等于 0 ，那么我们称这棵树是 健康的 。

你可以对这棵树执行任意次操作，但要求执行完所有操作以后树是 健康的 ，请你返回你可以获得的 最大分数 。

```js
/**
 * 计算在保证树健康的前提下能获得的最大分数
 * @param {number[][]} edges - 树的边集合，表示节点连接关系
 * @param {number[]} values - 每个节点的初始值
 * @return {number} 最大可能分数
 */
var maximumScoreAfterOperations = function (edges, values) {
  // 构建树的邻接表表示
  const n = edges.length + 1; // 节点总数
  const graph = Array.from({ length: n }, () => []);
  for (let [x, y] of edges) {
    graph[x].push(y), graph[y].push(x); // 无向图双向连接
  }

  /**
   * 深度优先搜索计算子树的最大分数
   * @param {number} i - 当前节点
   * @param {number} fa - 父节点(防止回溯)
   * @return {[number, number]} - 返回两个值：
   *   [0]: 不保证健康情况下子树的总和(全选)
   *   [1]: 保证健康情况下能获得的最大分数
   */
  const dfs = (i, fa) => {
    let isLeaf = true; // 标记是否为叶子节点
    let sumFull = 0,
      sumHealth = 0; // sumFull:全选总和, sumHealth:健康状态最大分数

    // 遍历所有相邻节点(子节点)
    for (let next of graph[i]) {
      if (next === fa) continue; // 跳过父节点
      let [full, health] = dfs(next, i); // 递归处理子节点
      isLeaf = false;
      sumFull += full; // 累加子节点的全选总和
      sumHealth += health; // 累加子节点的健康状态分数
    }

    // 叶子节点处理：必须不选(保证健康)，所以分数为0
    if (isLeaf) return [values[i], 0];

    // 非叶子节点返回：
    // [0]: 当前节点值 + 所有子节点全选总和
    // [1]: max(选当前节点 + 子节点健康分数, 不选当前节点 + 子节点全选总和)
    return [sumFull + values[i], Math.max(values[i] + sumHealth, sumFull)];
  };

  // 从根节点(0)开始DFS，返回健康状态下的最大分数
  return dfs(0, -1)[1];
};
```
