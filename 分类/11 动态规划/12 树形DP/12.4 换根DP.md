### 换根DP

#### [834. 树中距离之和](https://leetcode.cn/problems/sum-of-distances-in-tree/description/)

给定一个无向、连通的树。树中有 n 个标记为 0...n-1 的节点以及 n-1 条边 。

给定整数 n 和数组 edges ， edges[i] = [ai, bi]表示树中的节点 ai 和 bi 之间有一条边。

返回长度为 n 的数组 answer ，其中 answer[i] 是树中第 i 个节点与所有其他节点之间的距离之和。

```js
/**
 * @param {number} n - 树中节点的数量
 * @param {number[][]} edges - 表示树中边的二维数组，每个元素 [ai, bi] 代表节点 ai 和 bi 之间有一条边
 * @return {number[]} - 长度为 n 的数组，其中第 i 个元素表示第 i 个节点与所有其他节点之间的距离之和
 */
var sumOfDistancesInTree = function(n, edges) {
    // 构建图的邻接表，graph[i] 存储与节点 i 相邻的所有节点
    const graph = Array.from({length: n}, () => []);

    // 遍历边数组，将每条边的两个端点相互添加到对方的邻接表中
    for (let [x, y] of edges) {
        graph[x].push(y), graph[y].push(x);
    }

    // 初始化结果数组，ans[i] 表示第 i 个节点与所有其他节点之间的距离之和
    const ans = Array(n).fill(0);
    // 初始化子树大小数组，sizes[i] 表示以节点 i 为根的子树的节点数量
    const sizes = Array(n).fill(1);

    /**
     * 深度优先搜索函数，用于计算以节点 0 为根时，节点 0 到所有其他节点的距离之和
     * 同时计算以每个节点为根的子树的节点数量
     * @param {number} i - 当前正在访问的节点
     * @param {number} fa - 当前节点的父节点
     * @param {number} depth - 当前节点距离根节点 0 的深度
     * @return {number} - 以当前节点为根的子树的节点数量
     */
    const dfs = (i, fa, depth) => {
        // 累加节点 0 到当前节点的距离到 ans[0] 中
        ans[0] += depth;

        // 遍历当前节点的所有相邻节点
        for (let next of graph[i]) {
            // 如果相邻节点是父节点，则跳过
            if (next === fa) continue;
            // 递归调用 dfs 计算子树的节点数量，并累加到当前节点的子树大小中
            sizes[i] += dfs(next, i, depth + 1);
        }

        return sizes[i];
    }

    // 从节点 0 开始进行深度优先搜索
    dfs(0, -1, 0);

    /**
     * 换根函数，用于从节点 0 开始，依次将根节点切换到其子节点，计算每个节点到所有其他节点的距离之和
     * @param {number} i - 当前作为根节点的节点
     * @param {number} fa - 当前根节点的父节点
     */
    const reroot = (i, fa) => {
        // 根据换根公式计算当前节点到所有其他节点的距离之和
        ans[i] = ans[fa] + n - 2 * sizes[i];

        // 遍历当前节点的所有相邻节点
        for (let next of graph[i]) {
            // 如果相邻节点是父节点，则跳过
            if (next === fa) continue;
            // 递归调用 reroot 函数，将根节点切换到相邻节点
            reroot(next, i);
        }
    }

    // 从节点 0 的所有相邻节点开始进行换根操作
    for (let i of graph[0]) {
        reroot(i, 0);
    }

    // 返回结果数组
    return ans;
};

```