### 换根DP

#### [834. 树中距离之和](https://leetcode.cn/problems/sum-of-distances-in-tree/description/)

给定一个无向、连通的树。树中有 n 个标记为 0...n-1 的节点以及 n-1 条边 。

给定整数 n 和数组 edges ， edges[i] = [ai, bi]表示树中的节点 ai 和 bi 之间有一条边。

返回长度为 n 的数组 answer ，其中 answer[i] 是树中第 i 个节点与所有其他节点之间的距离之和。

```js
/**
 * @param {number} n - 树中节点的数量
 * @param {number[][]} edges - 表示树中边的二维数组，每个元素 [ai, bi] 代表节点 ai 和 bi 之间有一条边
 * @return {number[]} - 长度为 n 的数组，其中第 i 个元素表示第 i 个节点与所有其他节点之间的距离之和
 */
var sumOfDistancesInTree = function(n, edges) {
    // 构建图的邻接表，graph[i] 存储与节点 i 相邻的所有节点
    const graph = Array.from({length: n}, () => []);

    // 遍历边数组，将每条边的两个端点相互添加到对方的邻接表中
    for (let [x, y] of edges) {
        graph[x].push(y), graph[y].push(x);
    }

    // 初始化结果数组，ans[i] 表示第 i 个节点与所有其他节点之间的距离之和
    const ans = Array(n).fill(0);
    // 初始化子树大小数组，sizes[i] 表示以节点 i 为根的子树的节点数量
    const sizes = Array(n).fill(1);

    /**
     * 深度优先搜索函数，用于计算以节点 0 为根时，节点 0 到所有其他节点的距离之和
     * 同时计算以每个节点为根的子树的节点数量
     * @param {number} i - 当前正在访问的节点
     * @param {number} fa - 当前节点的父节点
     * @param {number} depth - 当前节点距离根节点 0 的深度
     * @return {number} - 以当前节点为根的子树的节点数量
     */
    const dfs = (i, fa, depth) => {
        // 累加节点 0 到当前节点的距离到 ans[0] 中
        ans[0] += depth;

        // 遍历当前节点的所有相邻节点
        for (let next of graph[i]) {
            // 如果相邻节点是父节点，则跳过
            if (next === fa) continue;
            // 递归调用 dfs 计算子树的节点数量，并累加到当前节点的子树大小中
            sizes[i] += dfs(next, i, depth + 1);
        }

        return sizes[i];
    }

    // 从节点 0 开始进行深度优先搜索
    dfs(0, -1, 0);

    /**
     * 换根函数，用于从节点 0 开始，依次将根节点切换到其子节点，计算每个节点到所有其他节点的距离之和
     * @param {number} i - 当前作为根节点的节点
     * @param {number} fa - 当前根节点的父节点
     */
    const reroot = (i, fa) => {
        // 根据换根公式计算当前节点到所有其他节点的距离之和
        ans[i] = ans[fa] + n - 2 * sizes[i];

        // 遍历当前节点的所有相邻节点
        for (let next of graph[i]) {
            // 如果相邻节点是父节点，则跳过
            if (next === fa) continue;
            // 递归调用 reroot 函数，将根节点切换到相邻节点
            reroot(next, i);
        }
    }

    // 从节点 0 的所有相邻节点开始进行换根操作
    for (let i of graph[0]) {
        reroot(i, 0);
    }

    // 返回结果数组
    return ans;
};

```

#### [2581. 统计可能的树根数目](https://leetcode.cn/problems/count-number-of-possible-root-nodes/description/)

Alice 有一棵 n 个节点的树，节点编号为 0 到 n - 1 。树用一个长度为 n - 1 的二维整数数组 edges 表示，其中 edges[i] = [ai, bi] ，表示树中节点 ai 和 bi 之间有一条边。

Alice 想要 Bob 找到这棵树的根。她允许 Bob 对这棵树进行若干次 猜测 。每一次猜测，Bob 做如下事情：

- 选择两个 不相等 的整数 u 和 v ，且树中必须存在边 [u, v] 。
- Bob 猜测树中 u 是 v 的 父节点 。

Bob 的猜测用二维整数数组 guesses 表示，其中 guesses[j] = [uj, vj] 表示 Bob 猜 uj 是 vj 的父节点。

Alice 非常懒，她不想逐个回答 Bob 的猜测，只告诉 Bob 这些猜测里面 至少 有 k 个猜测的结果为 true 。

给你二维整数数组 edges ，Bob 的所有猜测和整数 k ，请你返回可能成为树根的 节点数目 。如果没有这样的树，则返回 0。

```js
/**
 * 计算可能成为树根的节点数目，要求至少有 k 个猜测结果为 true
 * @param {number[][]} edges - 表示树中边的二维数组，每个元素 [ai, bi] 代表节点 ai 和 bi 之间有一条边
 * @param {number[][]} guesses - Bob 的猜测数组，每个元素 [uj, vj] 表示 Bob 猜 uj 是 vj 的父节点
 * @param {number} k - 要求至少为 true 的猜测数量
 * @return {number} - 可能成为树根的节点数目
 */
var rootCount = function (edges, guesses, k) {
    // 计算树的节点数量，边的数量加 1 即为节点数量
    const n = edges.length + 1;
    // 构建图的邻接表，graph[i] 存储与节点 i 相邻的所有节点
    const graph = Array.from({ length: n }, () => []);

    // 遍历边数组，将每条边的两个端点相互添加到对方的邻接表中
    for (let [x, y] of edges) {
        graph[x].push(y), graph[y].push(x);
    }

    // 创建一个 Map 用于存储 Bob 的猜测，键为父节点，值为一个 Set 存储对应的子节点
    const guessesMap = new Map();
    // 遍历猜测数组，将每个猜测添加到 guessesMap 中
    for (let [u, v] of guesses) {
        // 获取以 u 为键的 Set，如果不存在则创建一个新的 Set
        const set = guessesMap.get(u) ?? new Set();
        // 将 v 添加到 Set 中
        set.add(v);
        // 更新 guessesMap 中 u 对应的 Set
        guessesMap.set(u, set);
    }

    // 记录以节点 0 为根时，猜测结果为 true 的数量
    let cnt0 = 0;
    /**
     * 深度优先搜索函数，用于计算以节点 0 为根时，猜测结果为 true 的数量
     * @param {number} i - 当前正在访问的节点
     * @param {number} fa - 当前节点的父节点
     */
    const dfs = (i, fa) => {
        // 如果当前父节点的猜测中包含当前节点，则猜测正确，cnt0 加 1
        if (guessesMap.has(fa) && guessesMap.get(fa).has(i)) {
            cnt0 += 1;
        }

        // 遍历当前节点的所有相邻节点
        for (let next of graph[i]) {
            // 如果相邻节点是父节点，则跳过
            if (next === fa) continue;
            // 递归调用 dfs 函数，继续深度优先搜索
            dfs(next, i);
        }
    }
    // 从节点 0 开始进行深度优先搜索
    dfs(0, -1);
    
    // 初始化可能成为树根的节点数目，如果以节点 0 为根时满足条件，则初始值为 1，否则为 0
    let ans = cnt0 >= k ? 1 : 0;

    /**
     * 换根函数，用于从节点 0 开始，依次将根节点切换到其子节点，计算不同根节点下猜测结果为 true 的数量
     * @param {number} i - 当前作为根节点的节点
     * @param {number} fa - 当前根节点的父节点
     * @param {number} cnt - 当前根节点下猜测结果为 true 的数量
     */
    const reRoot = (i, fa, cnt) => {
        // 如果换根前父节点的猜测中包含当前节点，换根后该猜测不再正确，cnt 减 1
        if (guessesMap.has(fa) && guessesMap.get(fa).has(i)) {
            cnt -= 1;
        }
        // 如果换根后当前节点的猜测中包含原父节点，换根后该猜测变为正确，cnt 加 1
        if (guessesMap.has(i) && guessesMap.get(i).has(fa)) {
            cnt += 1;
        }

        // 如果当前根节点下猜测结果为 true 的数量满足条件，则可能成为树根的节点数目加 1
        if (cnt >= k) ans++;

        // 遍历当前节点的所有相邻节点
        for (let next of graph[i]) {
            // 如果相邻节点是父节点，则跳过
            if (next === fa) continue;
            // 递归调用 reRoot 函数，继续换根操作
            reRoot(next, i, cnt);
        }
    }

    // 从节点 0 的所有相邻节点开始进行换根操作
    for (let i of graph[0]) {
        reRoot(i, 0, cnt0);
    }

    // 返回可能成为树根的节点数目
    return ans;
};

```