### 输出具体方案

#### [1092. 最短公共超序列](https://leetcode.cn/problems/shortest-common-supersequence/description/)

给你两个字符串 str1 和 str2，返回同时以 str1 和 str2 作为 子序列 的最短字符串。如果答案不止一个，则可以返回满足条件的 任意一个 答案。

如果从字符串 t 中删除一些字符（也可能不删除），可以得到字符串 s ，那么 s 就是 t 的一个子序列。

**题解：**

定义 dp[i][j] 为 str1 的前 i 个字符和 str2 的前 j 个字符的最短公共超序列。

状态转移：

- 如果 str1[i-1] == str2[j-1]，那么 dp[i][j] = dp[i-1][j-1] + str1[i-1]
- 如果 str1[i-1] != str2[j-1]，那么 dp[i][j] = min(dp[i-1][j] + str1[i-1], dp[i][j-1] + str2[j-1])（ 取长度较小的一个）

```js
/**
 * 计算两个字符串的最短公共超序列
 * @param {string} str1 - 第一个输入字符串
 * @param {string} str2 - 第二个输入字符串
 * @return {string} 最短公共超序列字符串
 */
var shortestCommonSupersequence = function (str1, str2) {
  // 获取两个字符串的长度
  const m = str1.length,
    n = str2.length;

  // 初始化DP数组，f[i][j]表示str1前i个字符和str2前j个字符的最短公共超序列
  const f = Array.from({ length: m + 1 }, () => Array(n + 1).fill(""));

  // 初始化边界条件：当其中一个字符串为空时，超序列就是另一个字符串本身
  let s1 = "",
    s2 = "";
  for (let j = 1; j < n + 1; j++) {
    s2 += str2[j - 1];
    f[0][j] = s2; // str1为空时，超序列就是str2的前j个字符
  }
  for (let i = 1; i < m + 1; i++) {
    s1 += str1[i - 1];
    f[i][0] = s1; // str2为空时，超序列就是str1的前i个字符

    // 填充DP表
    for (let j = 1; j < n + 1; j++) {
      // 当当前字符相等时，可以共用该字符
      if (str1[i - 1] === str2[j - 1]) {
        f[i][j] = f[i - 1][j - 1] + str1[i - 1];
      }

      // 当字符不相等时，选择两种可能中较短的一种
      let r1 = f[i - 1][j] + str1[i - 1]; // 选择来自str1的字符
      let r2 = f[i][j - 1] + str2[j - 1]; // 选择来自str2的字符

      // 更新DP值为较短的选择
      if (f[i][j].length == 0 || r1.length < f[i][j].length) {
        f[i][j] = r1;
      }
      if (r2.length < f[i][j].length) {
        f[i][j] = r2;
      }
    }
  }

  // 返回最终结果：包含整个str1和str2的最短公共超序列
  return f[m][n];
};
```

#### [368. 最大整除子集](https://leetcode.cn/problems/largest-divisible-subset/description/)

给你一个由 无重复 正整数组成的集合 nums ，请你找出并返回其中最大的整除子集 answer ，子集中每一元素对 (answer[i], answer[j]) 都应当满足：

- answer[i] % answer[j] == 0 ，或
- answer[j] % answer[i] == 0

如果存在多个有效解子集，返回其中任何一个均可。

**题解**

首先将 nums 排序

定义 dp[i]为以 nums[i]为最大整数的整除子集的大小。

状态转移：

- 如果 nums[i]可以整除 nums[j]，那么 dp[i] = max(dp[i], dp[j] + 1) (j < i)
- 否则，dp[i] = 1

记录最大的 maxI，和 from[i]，表示以 nums[i]为最大整数的整除子集的前一个整数的下标。

最后从 nums[maxI]开始，根据 from 数组，逆序恢复出整除子集。

```js
/**
 * @param {number[]} nums - 输入的整数数组
 * @return {number[]} - 最大可整除子集
 * 算法思路：使用动态规划找出数组中最大的可整除子集
 * 1. 首先对数组进行排序，确保较小的数在前面
 * 2. 使用dp数组记录以每个位置为结尾的最大可整除子集长度
 * 3. 使用from数组记录每个位置的最优前序位置，用于重构子集
 * 4. 通过双层循环比较，找出每个位置的最大可整除子集
 * 5. 最后回溯重构出最大可整除子集
 */
var largestDivisibleSubset = function (nums) {
  // 获取数组长度
  const n = nums.length;
  // 对数组进行排序，以便从小到大比较整除关系
  nums.sort((a, b) => a - b);

  // from数组用于记录每个元素的最优前序元素索引，初始化为-1表示没有前序元素
  const from = Array(n).fill(-1);
  // dp数组用于记录以每个位置为结尾的最大可整除子集长度，初始化为1表示每个元素自身是一个子集
  const dp = Array(n).fill(1);
  // max用于记录最大子集长度，maxIndex用于记录最大子集的结尾元素索引
  let max = -Infinity,
    maxIndex = -1;
  // 外层循环遍历每个元素，作为子集的结尾元素
  for (let i = 0; i < n; i++) {
    // 内层循环遍历当前元素之前的所有元素
    for (let j = 0; j < i; j++) {
      // 如果当前元素能被之前的元素整除，且包含之前元素的子集长度+1大于当前子集长度
      if (nums[i] % nums[j] === 0 && dp[j] + 1 > dp[i]) {
        // 更新当前位置的子集长度
        dp[i] = dp[j] + 1;
        // 记录当前位置的前序元素索引
        from[i] = j;
      }
    }
    // 更新最大子集长度和对应的索引
    if (dp[i] > max) {
      max = dp[i];
      maxIndex = i;
    }
  }

  // 创建结果数组，长度为最大子集长度
  const ans = Array(dp[maxIndex]);
  // 用于填充结果数组的索引，从最后一个位置开始
  let i = dp[maxIndex] - 1;
  // 回溯重构最大可整除子集
  while (maxIndex >= 0) {
    // 将当前元素添加到结果数组
    ans[i--] = nums[maxIndex];
    // 移动到前序元素
    maxIndex = from[maxIndex];
  }

  // 返回最大可整除子集
  return ans;
};
```

#### [1363. 形成三的最大倍数](https://leetcode.cn/problems/largest-multiple-of-three/description/)

给你一个整数数组 digits，你可以通过按 任意顺序 连接其中某些数字来形成 3 的倍数，请你返回所能得到的最大的 3 的倍数。

由于答案可能不在整数数据类型范围内，请以字符串形式返回答案。如果无法得到答案，请返回一个空字符串。返回的结果不应包含不必要的前导零。

**动态规划：超时**

定义 dp[m][i]为以 digits[i]为结尾的，0- i 中生成的字符串数位和 **模 3 余 m** 的最大长度。

定义 from[m][i]为以 digits[i]为结尾的，0- i 中生成的字符串数位和 **模 3 余 m** 的最大长度的前一个状态。

最终选择 dp[0][i]最大的最为回溯起点构造字符串

```js
/**
 * 整体算法思路：
 * 问题：从给定的数字数组中找出能组成的最大的3的倍数
 * 核心思想：利用动态规划找出数组中能组成3的倍数的最长子序列，然后从后往前回溯构造结果
 * 3的倍数特性：一个数是3的倍数当且仅当它的各位数字之和是3的倍数
 */

/**
 * @param {number[]} digits - 输入的数字数组
 * @return {string} - 能组成的最大的3的倍数字符串
 */
var largestMultipleOfThree = function (digits) {
  const n = digits.length; // 获取数组长度
  digits.sort((a, b) => b - a); // 将数组从大到小排序，以便优先选择大数字
  let r = n - 1,
    ans = ""; // r指向最后一个非零数字，ans存储结果字符串

  // 处理全是0的情况，直接返回"0"
  while (digits[r] == 0) {
    ans += "0"; // 拼接0
    r--; // 向前移动指针
  }
  if (r < 0) return "0"; // 如果所有数字都是0，返回"0"

  // 初始化动态规划相关数组
  // memo: 暂未使用的数组
  const memo = Array.from({ length: 3 }, () => Array(r + 1).fill(0));
  // f[m][i]: 从前i+1个数字中选出的子序列，其和模3为m时的最大长度
  const f = Array.from({ length: 3 }, () => Array(r + 1).fill(0));
  // from[m][i]: 记录状态f[m][i]是从哪个状态转移过来的，用于回溯构造结果
  const from = Array.from({ length: 3 }, () => Array(r + 1));

  let max = 0,
    maxIndex = -1; // max记录最长子序列长度，maxIndex记录对应位置

  // 动态规划主循环
  for (let i = 0; i <= r; i++) {
    // 遍历每个数字
    let d = +digits[i]; // 当前数字
    let currM = d % 3; // 当前数字模3的余数

    for (let m = 0; m < 3; m++) {
      // 遍历三种余数状态(0,1,2)
      // 初始状态：只选当前数字时，若余数等于m，则长度为1
      f[m][i] = currM === m ? 1 : 0;

      // 检查之前的数字能否组成更长的有效子序列
      for (let j = 0; j < i; j++) {
        // 遍历之前的所有位置
        // 计算需要的前序余数：(当前目标余数 - 当前数字余数 + 3) % 3
        let prevM = (m - currM + 3) % 3;

        // 如果前序状态存在且长度+1大于当前状态，则更新
        if (f[prevM][j] > 0 && f[prevM][j] + 1 > f[m][i]) {
          f[m][i] = f[prevM][j] + 1; // 更新长度
          from[m][i] = [prevM, j]; // 记录转移来源
        }
      }

      // 如果当前状态是余数0（有效解）且长度更大，则更新最大长度
      if (m === 0 && max < f[m][i]) {
        max = f[m][i];
        maxIndex = i; // 记录当前位置
      }
    }
  }

  // 如果没有找到有效解，检查是否有0可以返回
  if (max <= 0) return n - 1 > r ? "0" : "";

  // 回溯构造结果
  let p = [0, maxIndex]; // 从最大长度的0余数状态开始
  while (p) {
    // 当还有前驱状态时
    ans = digits[p[1]] + ans; // 将当前数字拼接到结果前面
    p = from[p[0]][p[1]]; // 移动到前驱状态
  }

  return ans; // 返回结果
};
```

**优化：**

定义 prevMax[m]为前 i 个数字中，f[m][i]的最大长度。

定义 prevMaxJ[m]为前 i 个数字中，f[m][i]的最大长度的前一个位置。

```js
/**
 * 整体算法思路（优化版）：
 * 问题：从给定的数字数组中找出能组成的最大的3的倍数
 * 优化点：使用 prevMax 数组记录每个余数状态的最大值，将时间复杂度从 O(n²) 降至 O(n)
 * 核心思想：动态规划 + 贪心优化，通过记录每个余数状态的最大长度及位置，避免三重循环
 */

/**
 * @param {number[]} digits - 输入的数字数组
 * @return {string} - 能组成的最大的3的倍数字符串
 */
var largestMultipleOfThree = function (digits) {
  const n = digits.length; // 获取数组长度
  digits.sort((a, b) => b - a); // 将数组从大到小排序，优先选择大数字
  let r = n - 1,
    ans = ""; // r指向最后一个非零数字，ans存储结果字符串

  // 处理全是0的情况
  while (digits[r] == 0) {
    ans += "0"; // 拼接0
    r--; // 向前移动指针
  }
  if (r < 0) return "0"; // 所有数字都是0，直接返回"0"

  // 初始化动态规划数组
  // f[m][i]: 从前i+1个数字中选出的子序列，其和模3为m时的最大长度
  const f = Array.from({ length: 3 }, () => Array(r + 1).fill(0));
  // from[m][i]: 记录状态f[m][i]的前驱状态，用于回溯构造结果
  const from = Array.from({ length: 3 }, () => Array(r + 1));

  let max = 0,
    maxIndex = -1; // max记录最长子序列长度，maxIndex记录对应位置
  // prevMax[m]: 记录当前处理到的数字中，余数为m的子序列的最大长度
  // prevMaxJ[m]: 记录prevMax[m]对应的数字索引
  let prevMax = Array(3).fill(-1),
    prevMaxJ = Array(3).fill(0);

  // 动态规划主循环（优化版）
  for (let i = 0; i <= r; i++) {
    // 遍历每个数字
    let d = +digits[i]; // 当前数字
    let currM = d % 3; // 当前数字模3的余数

    for (let m = 0; m < 3; m++) {
      // 遍历三种余数状态(0,1,2)
      // 初始状态：只选当前数字时，若余数等于m，则长度为1
      f[m][i] = currM === m ? 1 : 0;

      // 计算需要的前序余数
      let prevM = (m - currM + 3) % 3;
      let pMax = prevMax[prevM]; // 获取前序余数的最大长度

      // 如果前序状态存在且能组成更长的子序列
      if (pMax > 0 && pMax + 1 > f[m][i]) {
        f[m][i] = pMax + 1; // 更新当前状态长度
        // 记录前驱状态（前序余数和对应的索引）
        from[m][i] = [prevM, prevMaxJ[prevM]];
      }

      // 更新最大长度（只关注余数为0的有效解）
      if (m === 0 && max < f[m][i]) {
        max = f[m][i];
        maxIndex = i; // 记录当前位置
      }
    }

    // 更新prevMax数组：记录每个余数状态的最大长度和对应索引
    for (let m = 0; m < 3; m++) {
      if (f[m][i] > prevMax[m]) {
        prevMax[m] = f[m][i]; // 更新最大长度
        prevMaxJ[m] = i; // 更新对应索引
      }
    }
  }

  // 如果没有找到有效解，检查是否有0可以返回
  if (max <= 0) return n - 1 > r ? "0" : "";

  // 回溯构造结果
  let p = [0, maxIndex]; // 从最大长度的0余数状态开始
  while (p) {
    // 当还有前驱状态时
    ans = digits[p[1]] + ans; // 将当前数字拼接到结果前面
    p = from[p[0]][p[1]]; // 移动到前驱状态
  }

  return ans; // 返回结果
};
```

**枚举需要删除的数字**

计算 digits 的和 sum，

- 如果 sum 模 3 余 1，删除一个模 3 余 1 的最小数字，如果没有就删除两个模 3 余 2 的最小数字（如果没有 1 则必有 2，否则不可能模 3 余 1）
- 如果 sum 模 3 余 2，删除一个模 3 余 2 的最小数字，如果没有就删除两个模 3 余 1 的最小数字（如果没有 2 则必有 1，否则不可能模 3 余 2）
- 如果 sum 模 3 余 0，不删除数字

所以遍历求和的同时，计算模 3 余 1 的数量和模 3 余 2 的数量，并生成 digits 的 cnt 数组。根据 cnt 生成最终字符串。

```js
/**
 * 算法思路：
 * 1. 统计每个数字出现的次数以及各数字对3取余的分布
 * 2. 计算所有数字之和，根据和对3的余数确定需要移除的数字
 * 3. 移除相应的数字后，将剩余数字从大到小排列组成最大数
 * 4. 特殊处理全零情况，确保只返回一个"0"
 *
 * @param {number[]} digits - 输入的数字数组
 * @return {string} - 能组成的最大3的倍数的字符串表示
 */
var largestMultipleOfThree = function (digits) {
  // 创建计数数组，统计0-9每个数字出现的次数
  // 创建余数数组，统计对3取余为0、1、2的数字个数
  const cnt = Array(10).fill(0),
    mod = Array(3).fill(0);
  // 初始化数字总和
  let sum = 0;
  // 遍历所有数字，统计计数、余数分布和总和
  for (let d of digits) {
    sum += +d; // 将字符型数字转为数字并累加到总和
    cnt[d] += 1; // 统计当前数字出现次数
    mod[+d % 3] += 1; // 统计当前数字对3取余的分布
  }

  // 定义需要移除的余数类型和移除数量
  let removeMod, rest;
  // 根据总和对3的余数决定移除策略
  if (sum % 3 === 1) {
    // 总和余1：优先移除1个余1的数字，否则移除2个余2的数字
    if (mod[1] > 0) {
      removeMod = 1;
      rest = 1;
    } else {
      removeMod = 2;
      rest = 2;
    }
  } else if (sum % 3 === 2) {
    // 总和余2：优先移除1个余2的数字，否则移除2个余1的数字
    if (mod[2] > 0) {
      removeMod = 2;
      rest = 1;
    } else {
      removeMod = 1;
      rest = 2;
    }
  } else {
    // 总和是3的倍数，不需要移除数字
    (removeMod = 0), (rest = 0);
  }
  // 初始化结果字符串
  let ans = "";
  // 从0到9遍历数字
  for (let i = 0; i <= 9; i++) {
    // 如果当前数字的余数等于需要移除的余数且还有移除名额
    if (i % 3 === removeMod && rest > 0) {
      // 计算需要移除的数量（不超过当前数字的出现次数和剩余移除名额）
      let remove = Math.min(rest, cnt[i]);
      cnt[i] -= remove; // 减少当前数字的计数
      rest -= remove; // 减少剩余移除名额
    }

    // 将当前数字按剩余计数添加到结果字符串的前面（保证从大到小排列）
    ans = String(i).repeat(cnt[i]) + ans;
  }

  // 如果结果以0开头，说明所有数字都是0，返回"0"
  if (ans[0] == 0) return "0";

  // 返回结果，若结果为空则返回空字符串
  return ans;
};
```
