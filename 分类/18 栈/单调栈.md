## 单调栈

> ————单调栈十六字真言：及时去掉无用数据，保证栈中元素有序。————

### 下一个更大元素

**方法一：从右到左**

从右往左倒着遍历，栈中记录下一个更大元素的「候选项」。

由于左边更大元素会「挡住」右边更小的元素，所以右边更小的元素是无用信息（不会成为左边元素的下一个更大元素），这会导致栈底（右边）大，栈顶（左边）小。

- 从右往左倒着遍历
- 将当前遍历元素与栈顶对应的元素比较
  - 如果当前元素**大于等于**栈顶对应的元素，则弹出栈顶，继续这个操作，直到栈空或不满足条件
- 得出当前遍历元素的「下一个更大元素」：
  - 栈不为空，则栈顶对应的元素为「下一个更大元素」
  - 栈为空，当前元素无「下一个更大元素」
- 将当前元素的下标入栈

```js
const st = [],
  n = nums.length,
  res = Array(n).fill(-1);
for (let i = n - 1; i >= 0; i--) {
  while (st.length && nums[i] >= nums[st[st.length - 1]]) {
    st.pop();
  }
  if (st.length) {
    res[i] = nums[st[st.length - 1]];
  }
  st.push(i);
}
```

**方法二：从左到右**

栈中记录还没算出「下一个更大元素」的那些数。

只要遍历到比栈顶元素更大的数，就意味着栈顶元素找到了答案，记录答案，并弹出栈顶。

- 从左到右遍历
- 将当前遍历元素与栈顶对应的元素比较
  - 如果当前元素**大于**栈顶对应的元素，则弹出栈顶
  - 弹出的栈顶元素的「下一个更大元素」为当前遍历元素
  - 继续这个操作，直到栈空或不满足条件
- 将当前元素的下标入栈

```js
const st = [],
  n = nums.length,
  res = Array(n).fill(-1);
for (let i = 0; i < n; i++) {
  while (st.length && nums[i] > nums[st[st.length - 1]]) {
    let top = st.pop();
    res[top] = nums[i];
  }
  st.push(i);
}
```

- [739. 每日温度](https://leetcode.cn/problems/daily-temperatures/description/)
- [1475. 商品折扣后的最终价格](https://leetcode.cn/problems/final-prices-with-a-special-discount-in-a-shop/description/)
- [496. 下一个更大元素 I](https://leetcode.cn/problems/next-greater-element-i/)
- [503. 下一个更大元素 II](https://leetcode.cn/problems/next-greater-element-ii/description/)
- [1019. 链表中的下一个更大节点 1571](https://leetcode.cn/problems/next-greater-node-in-linked-list/)

### 距离最远的更大元素

1. 正序遍历数组 A，将以 A[0] 开始的递减序列的元素下标依次存入栈中。
2. 逆序遍历数组 A，若以栈顶元素为下标的元素值 A[stack.peek()] 小于等于当前遍历的元素 A[i]，即 A[stack.peek()] <= A[i]。此时就是一个满足条件的坡的宽度，并且这个宽度一定是栈顶这个坡底 i 能形成的最大宽度，将栈顶元素出栈并计算当前坡的宽度，保留最大值即可。

### [962. 最大宽度坡](https://leetcode.cn/problems/maximum-width-ramp/description/)

给定一个整数数组 A，坡是元组 (i, j)，其中  i < j 且 A[i] <= A[j]。这样的坡的宽度为 j - i。

找出 A 中的坡的最大宽度，如果不存在，返回 0 。

**解法一、 单调栈**

```js
var maxWidthRamp = function(nums) {
    let n = nums.length;
    let st = [0];
    for (let i = 1; i < n; i++) {
        if (nums[i] < nums[st[st.length - 1]]) st.push(i);
    }
    let ans = 0;
    for (let i = n - 1; i >= 0; i--) {
        while (st.length && nums[st[st.length - 1]] <= nums[i]) {
            ans = Math.max(ans, i - st.pop())
        }
    }
    return ans;
};
```

**解法二、 排序**

1. 将数组下标按对应值升序排序
2. 遍历indexs
   1. 维护已遍历index的最小值
   2. 当前遍历index与左侧最小值的差值为满足条件的距离，维护其最大值

```js
var maxWidthRamp = function(nums) {
    let n = nums.length;
    let indexs = nums.map((_, i) => i);
    indexs.sort((a, b) => nums[a] - nums[b]);
    let ans = 0, m = n;
    for (let i of indexs) {
        ans = Math.max(ans, i - m);
        m = Math.min(i, m);
    }

    return ans;
};
```
