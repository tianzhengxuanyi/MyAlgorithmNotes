## 单调栈

> ————单调栈十六字真言：及时去掉无用数据，保证栈中元素有序。————

### 下一个更大元素

**方法一：从右到左**

从右往左倒着遍历，栈中记录下一个更大元素的「候选项」。

由于左边更大元素会「挡住」右边更小的元素，所以右边更小的元素是无用信息（不会成为左边元素的下一个更大元素），这会导致栈底（右边）大，栈顶（左边）小。

- 从右往左倒着遍历
- 将当前遍历元素与栈顶对应的元素比较
  - 如果当前元素**大于等于**栈顶对应的元素，则弹出栈顶，继续这个操作，直到栈空或不满足条件
- 得出当前遍历元素的「下一个更大元素」：
  - 栈不为空，则栈顶对应的元素为「下一个更大元素」
  - 栈为空，当前元素无「下一个更大元素」
- 将当前元素的下标入栈

```js
const st = [],
  n = nums.length,
  res = Array(n).fill(-1);
for (let i = n - 1; i >= 0; i--) {
  while (st.length && nums[i] >= nums[st[st.length - 1]]) {
    st.pop();
  }
  if (st.length) {
    res[i] = nums[st[st.length - 1]];
  }
  st.push(i);
}
```

**方法二：从左到右**

栈中记录还没算出「下一个更大元素」的那些数。

只要遍历到比栈顶元素更大的数，就意味着栈顶元素找到了答案，记录答案，并弹出栈顶。

- 从左到右遍历
- 将当前遍历元素与栈顶对应的元素比较
  - 如果当前元素**大于**栈顶对应的元素，则弹出栈顶
  - 弹出的栈顶元素的「下一个更大元素」为当前遍历元素
  - 继续这个操作，直到栈空或不满足条件
- 将当前元素的下标入栈

```js
const st = [],
  n = nums.length,
  res = Array(n).fill(-1);
for (let i = 0; i < n; i++) {
  while (st.length && nums[i] > nums[st[st.length - 1]]) {
    let top = st.pop();
    res[top] = nums[i];
  }
  st.push(i);
}
```

- [739. 每日温度](https://leetcode.cn/problems/daily-temperatures/description/)
- [1475. 商品折扣后的最终价格](https://leetcode.cn/problems/final-prices-with-a-special-discount-in-a-shop/description/)
- [496. 下一个更大元素 I](https://leetcode.cn/problems/next-greater-element-i/)
- [503. 下一个更大元素 II](https://leetcode.cn/problems/next-greater-element-ii/description/)
- [1019. 链表中的下一个更大节点 1571](https://leetcode.cn/problems/next-greater-node-in-linked-list/)

### 距离最远的更大元素

1. 正序遍历数组 A，将以 A[0] 开始的递减序列的元素下标依次存入栈中。
2. 逆序遍历数组 A，若以栈顶元素为下标的元素值 A[stack.peek()] 小于等于当前遍历的元素 A[i]，即 A[stack.peek()] <= A[i]。此时就是一个满足条件的坡的宽度，并且这个宽度一定是栈顶这个坡底 i 能形成的最大宽度，将栈顶元素出栈并计算当前坡的宽度，保留最大值即可。

#### [962. 最大宽度坡](https://leetcode.cn/problems/maximum-width-ramp/description/)

给定一个整数数组 A，坡是元组 (i, j)，其中 i < j 且 A[i] <= A[j]。这样的坡的宽度为 j - i。

找出 A 中的坡的最大宽度，如果不存在，返回 0 。

**解法一、 单调栈**

```js
var maxWidthRamp = function (nums) {
  let n = nums.length;
  let st = [0];
  for (let i = 1; i < n; i++) {
    if (nums[i] < nums[st[st.length - 1]]) st.push(i);
  }
  let ans = 0;
  for (let i = n - 1; i >= 0; i--) {
    while (st.length && nums[st[st.length - 1]] <= nums[i]) {
      ans = Math.max(ans, i - st.pop());
    }
  }
  return ans;
};
```

**解法二、 排序**

1. 将数组下标按对应值升序排序
2. 遍历 indexs
   1. 维护已遍历 index 的最小值
   2. 当前遍历 index 与左侧最小值的差值为满足条件的距离，维护其最大值

```js
var maxWidthRamp = function (nums) {
  let n = nums.length;
  let indexs = nums.map((_, i) => i);
  indexs.sort((a, b) => nums[a] - nums[b]);
  let ans = 0,
    m = n;
  for (let i of indexs) {
    ans = Math.max(ans, i - m);
    m = Math.min(i, m);
  }

  return ans;
};
```

### 矩形

> 1. 枚举以 nums[i]为高度的矩形，左边界和右边界通过单调栈求出
>
> 2. 如果求二维数组的矩形，枚举每一行 row 作为基座的情况，高度为之前行的累加，转化为问题 1

#### [84. 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/description/)

给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。

```js
/**
 * @param {number[]} heights
 * @return {number}
 */
var largestRectangleArea = function (heights) {
  const n = heights.length,
    leftMin = Array(n).fill(-1),
    st = [];
  let ans = 0;
  for (let i = 0; i < n; i++) {
    // 维护一个单调递增的栈
    // 此处`<=`根据题意不同可换成`<`
    while (st.length && heights[i] <= heights[st[st.length - 1]]) {
      // 栈顶元素的右侧下一个更小元素
      const curr = st.pop(),
        left = leftMin[curr],
        right = i;
      ans = Math.max(ans, heights[curr] * (right - left - 1));
    }
    // 如果栈不为空，则栈顶元素为当前元素的左侧下一个更小元素
    // 如果栈为空，则当前元素左侧无更小元素，取leftMin的默认值-1
    if (st.length) {
      leftMin[i] = st[st.length - 1];
    }
    st.push(i);
  }
  // 如果此时栈不为空，则栈中的元素右侧无更小元素，右边界取n
  while (st.length) {
    const curr = st.pop(),
      left = leftMin[curr],
      right = n;
    ans = Math.max(ans, heights[curr] * (right - left - 1));
  }
  return ans;
};
```

#### [1793. 好子数组的最大分数](https://leetcode.cn/problems/maximum-score-of-a-good-subarray/description/)

给你一个整数数组 nums （下标从 0 开始）和一个整数 k 。

一个子数组 (i, j) 的 分数 定义为 min(nums[i], nums[i+1], ..., nums[j]) \* (j - i + 1) 。一个 好 子数组的两个端点下标需要满足 i <= k <= j 。

请你返回 好 子数组的最大可能 分数 。

> 单调栈：枚举以 nums[i]为最小值时的分数

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var maximumScore = function (nums, k) {
  const n = nums.length,
    left = Array(n).fill(-1),
    st = [];
  let ans = 0;
  for (let i = 0; i < n; i++) {
    while (st.length && nums[i] < nums[st[st.length - 1]]) {
      // 计算分数时判断k是否在左右边界中
      ans = Math.max(ans, calc(nums, k, st, left, i));
    }
    if (st.length) {
      left[i] = st[st.length - 1];
    }
    st.push(i);
  }
  while (st.length) {
    ans = Math.max(ans, calc(nums, k, st, left, n));
  }
  return ans;
};

function calc(nums, k, st, left, right) {
  let mn = st.pop(),
    l = left[mn];

  if (l < k && right > k) {
    return nums[mn] * (right - l - 1);
  }
  return 0;
}
```

> 双指针：尝试从 i=k, j=k 出发，通过不断移动指针来找到最大矩形。比较 nums[i−1]和 nums[j+1]的大小，谁大就移动谁（一样大移动哪个都可以）

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var maximumScore = function (nums, k) {
  const n = nums.length;
  let left = k,
    right = k,
    min = nums[k],
    ans = nums[k];
  for (let i = 0; i < n - 1; i++) {
    if (right >= n - 1 || (left > 0 && nums[left - 1] >= nums[right + 1])) {
      min = Math.min(min, nums[--left]);
    } else {
      min = Math.min(min, nums[++right]);
    }
    ans = Math.max(ans, (right - left + 1) * min);
  }
  return ans;
};
```

#### [85. 最大矩形](https://leetcode.cn/problems/maximal-rectangle/description/)

给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。

```js
/**
 * @param {character[][]} matrix
 * @return {number}
 */
var maximalRectangle = function (matrix) {
  const m = matrix.length,
    n = matrix[0].length,
    nums = Array(n).fill(0);
  let ans = 0;
  for (let i = 0; i < m; i++) {
    for (let j = 0; j < n; j++) {
      // 累计高度
      if (matrix[i][j] == 1) {
        nums[j] += matrix[i][j] - 0;
      } else {
        nums[j] = 0;
      }
    }
    // 计算以当前行为底座的答案
    // 转化为84. 柱状图中最大的矩形
    ans = Math.max(ans, maxRect(nums));
  }
  return ans;
};

function maxRect(nums) {
  const n = nums.length,
    st = [],
    leftMin = Array(n).fill(-1);
  let ans = 0;
  for (let i = 0; i < n; i++) {
    while (st.length && nums[i] < nums[st[st.length - 1]]) {
      let idx = st.pop(),
        left = leftMin[idx],
        right = i;
      ans = Math.max(ans, nums[idx] * (right - left - 1));
    }
    if (st.length) {
      leftMin[i] = st[st.length - 1];
    }
    st.push(i);
  }
  while (st.length) {
    let idx = st.pop(),
      left = leftMin[idx],
      right = n;
    ans = Math.max(ans, nums[idx] * (right - left - 1));
  }
  return ans;
}
```

### 贡献法

#### [907. 子数组的最小值之和](https://leetcode.cn/problems/sum-of-subarray-minimums/description/)

给定一个整数数组 arr，找到 min(b) 的总和，其中 b 的范围为 arr 的每个（连续）子数组。

由于答案可能很大，因此 返回答案模 10^9 + 7 。

[贡献法+单调栈+三种实现版本（附题单）](https://leetcode.cn/problems/sum-of-subarray-minimums/solutions/1930857/gong-xian-fa-dan-diao-zhan-san-chong-shi-gxa5/)

> 计算以nums[i]为最小值时的子数组个数
>
> 为避免重复统计，可以修改边界的定义，把右边界改为「找小于或等于 arr[i]的数的下标」

```js
/**
 * @param {number[]} arr
 * @return {number}
 */
var sumSubarrayMins = function (arr) {
  const n = arr.length, mod = 1e9 + 7, st = [], leftMin = Array(n).fill(-1);
  let ans = 0;
  for (let i = 0; i < n; i++) {
    while (st.length && arr[i] <= arr[st[st.length - 1]]) {
      let curr = st.pop(),
        left = leftMin[curr],
        right = i;
      ans = (ans + arr[curr] * (curr - left) * (right - curr)) % mod;
    }
    if (st.length) {
      leftMin[i] = st[st.length - 1];
    }
    st.push(i);
  }
  while (st.length) {
    let curr = st.pop(),
      left = leftMin[curr],
      right = n;
    ans = (ans + arr[curr] * (curr - left) * (right - curr)) % mod;
  }

  return ans;
};
```
