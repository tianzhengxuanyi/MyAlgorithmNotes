### 3.7 DFS 时间戳

可以把树上问题转化成数组问题，比如子树的操作转化成子数组的操作。通常要结合其他数据结构。

#### [2322. 从树中删除边的最小分数](https://leetcode.cn/problems/minimum-score-after-removals-on-a-tree/description/)

存在一棵无向连通树，树中有编号从 0 到 n - 1 的 n 个节点， 以及 n - 1 条边。

给你一个下标从 0 开始的整数数组 nums ，长度为 n ，其中 nums[i] 表示第 i 个节点的值。另给你一个二维整数数组 edges ，长度为 n - 1 ，其中 edges[i] = [ai, bi] 表示树中存在一条位于节点 ai 和 bi 之间的边。

删除树中两条 不同 的边以形成三个连通组件。对于一种删除边方案，定义如下步骤以计算其分数：

1. 分别获取三个组件 每个 组件中所有节点值的异或值。
2. 最大 异或值和 最小 异或值的 差值 就是这一种删除边方案的分数。
- 例如，三个组件的节点值分别是：[4,5,7]、[1,9] 和 [3,3,3] 。三个异或值分别是 4 ^ 5 ^ 7 = 6、1 ^ 9 = 8 和 3 ^ 3 ^ 3 = 3 。最大异或值是 8 ，最小异或值是 3 ，分数是 8 - 3 = 5 。

返回在给定树上执行任意删除边方案可能的 最小 分数。

```js
/**
 * 计算从树中删除两条不同的边以形成三个连通组件后的最小分数。
 * 分数定义为三个连通组件节点值异或值的最大值与最小值之差。
 * @param {number[]} nums - 长度为 n 的整数数组，nums[i] 表示第 i 个节点的值。
 * @param {number[][]} edges - 长度为 n - 1 的二维整数数组，edges[i] = [ai, bi] 表示树中节点 ai 和 bi 之间的边。
 * @return {number} - 所有删除边方案中的最小分数。
 */
var minimumScore = function (nums, edges) {
    // 获取节点数量
    const n = nums.length;
    // 初始化每个节点及其子树节点值的异或值数组，初始值为节点自身的值
    const xors = [...nums];

    // 构建图的邻接表
    const graph = Array.from({ length: n }, () => []);

    // 遍历边数组，填充邻接表
    for (let [x, y] of edges) {
        graph[x].push(y), graph[y].push(x);
    }

    // 记录节点是否被访问过
    const visited = Array(n).fill(0);
    // 记录每个节点的 DFS 时间戳，times[i][0] 为进入时间，times[i][1] 为离开时间
    const times = Array.from({ length: n }, () => [0, 0]);
    // 时间戳计数器
    let time = 0;
    /**
     * 深度优先搜索函数，计算每个节点及其子树节点值的异或值，并记录时间戳
     * @param {number} i - 当前节点的编号
     * @return {number} - 当前节点及其子树节点值的异或值
     */
    const dfs = (i) => {
        // 标记当前节点为已访问
        visited[i] = 1;
        // 记录进入当前节点的时间戳
        times[i][0] = time;
        time++;

        // 遍历当前节点的所有邻接节点
        for (let next of graph[i]) {
            // 如果邻接节点已被访问过，则跳过
            if (visited[next]) continue;
            // 更新当前节点及其子树节点值的异或值
            xors[i] ^= dfs(next);
        }

        // 记录离开当前节点的时间戳
        times[i][1] = time;

        return xors[i];
    };
    // 从根节点 0 开始进行深度优先搜索
    dfs(0);

    // 初始化最小分数为无穷大
    let ans = Infinity;
    // 枚举删除的两条边
    // 其中i和j分别为两条边各自的子节点
    for (let i = 1; i < n; i++) {
        for (let j = 1; j < i; j++) {
            // 避免重复选择相同的节点
            if (i === j) continue;
            // 获取节点 i 和节点 j 的时间戳
            const [s1, e1] = times[i],
                [s2, e2] = times[j];
            let xor1, xor2, xor3;
            // 判断节点 j 是否在节点 i 的子树中
            if (s1 < s2 && s2 < e1) {
                // 计算三个连通组件的异或值
                (xor1 = xors[j]),
                    (xor2 = xors[i] ^ xors[j]),
                    (xor3 = xors[0] ^ xors[i]);
            // 判断节点 i 是否在节点 j 的子树中
            } else if (s2 < s1 && s1 < e2) {
                xor1 = xors[i], xor2 = xors[j] ^ xors[i], xor3 = xors[0] ^ xors[j];
            // 节点 i 和节点 j 不在彼此的子树中
            } else {
                xor1 = xors[i], xor2 = xors[j], xor3 = xors[0] ^ xors[i] ^ xors[j];
            }
            // 更新最小分数
            ans = Math.min(ans, Math.max(xor1, xor2, xor3) - Math.min(xor1, xor2, xor3));
        }
    }

    return ans;
};

```