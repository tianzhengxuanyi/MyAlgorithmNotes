### 第k小问题

> 第 k 小/大问题的通用转换方法：
>
> - 第 k 小等价于：求最小的 x，满足 ≤x 的数至少有 k 个。
> - 第 k 大等价于：求最大的 x，满足 ≥x 的数至少有 k 个。

#### [668. 乘法表中第 k 小的数](https://leetcode.cn/problems/kth-smallest-number-in-multiplication-table/description/)

几乎每一个人都用 乘法表。但是你能在乘法表中快速找到第 k 小的数字吗？

乘法表是大小为 m x n 的一个整数矩阵，其中 mat[i][j] == i \* j（下标从 1 开始）。

给你三个整数 m、n 和 k，请你在大小为 m x n 的乘法表中，找出并返回第 k 小的数字。

[题解](https://leetcode.cn/problems/kth-smallest-number-in-multiplication-table/solutions/1499050/cheng-fa-biao-zhong-di-kxiao-de-shu-by-l-521a/)

> 求第几小等价于求有多少数字不超过 x。我们可以遍历乘法表的每一行，对于乘法表的第 i 行，其数字均为 i 的倍数，因此不超过 x 的数字有 min(⌊x/i⌋,n) 个，所以遍历行就可得到整个乘法表不超过 x 的数字个数

```js
/**
 * @param {number} m
 * @param {number} n
 * @param {number} k
 * @return {number}
 */
var findKthNumber = function (m, n, k) {
  let left = 1,
    right = m * n,
    min = Math.min(m, n),
    mx = Math.max(m, n); // left 左侧为小于第k小的数 right右侧为大于等于第k小的数
  while (left <= right) {
    let mid = Math.floor((right - left) / 2) + left;
    if (check(mid, min, mx, k)) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }
  return left;
};

function check(mid, m, n, k) {
  let cnt = 0;
  for (let i = 1; i <= m; i++) {
    cnt += Math.min(n, Math.floor(mid / i));
  }
  return cnt < k;
}
```

#### [878. 第 N 个神奇数字](https://leetcode.cn/problems/nth-magical-number/description/)

一个正整数如果能被 a 或 b 整除，那么它是神奇的。

给定三个整数 n , a , b ，返回第 n 个神奇的数字。因为答案可能很大，所以返回答案 对 109 + 7 取模 后的值。

> **辗转相处获取最大公约数 gcd**

```js
/**
 * @param {number} n
 * @param {number} a
 * @param {number} b
 * @return {number}
 */
var nthMagicalNumber = function (n, a, b) {
  const mod = 1e9 + 7,
    lcm = getLCM(a, b);
  let left = 1,
    right = n * Math.min(a, b) + 1; // left左侧为小于的n个数 right为大于等于第n个数的数
  while (left <= right) {
    let mid = Math.floor((right - left) / 2) + left;
    if (Math.floor(mid / a) + Math.floor(mid / b) - Math.floor(mid / lcm) < n) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }
  return left % mod;
};

function getLCM(a, b) {
  return (a * b) / getGCD(a, b);
}

// 最大公约数
function getGCD(a, b) {
  // 如果 a b 都为偶数 除 2
  let n = 0;
  while (a % 2 === 0 && b % 2 === 0) {
    n++;
    a /= 2;
    b /= 2;
  }
  // 辗转相减
  let mx = Math.max(a, b),
    mn = Math.min(a, b);
  while (mx !== mn) {
    let d = mx - mn;
    mx = Math.max(d, mn);
    mn = Math.min(d, mn);
  }

  return mx * Math.pow(2, n);
}
```

**辗转相除求最大公约数**

```js
function getGCD(a, b) {
  let mx = Math.max(a, b),
    mn = Math.min(a, b);
  if (mx % mn === 0) {
    return mn;
  } else {
    return getGCD(mx % mn, mn);
  }
}
```

```js
function getGCD(a, b) {
  while (b !== 0) {
    let t = a % b;
    a = b;
    b = t;
  }
  return a;
}
```


#### [378. 有序矩阵中第 K 小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/description/)

给你一个 n x n 矩阵 matrix ，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。
请注意，它是 排序后 的第 k 小元素，而不是第 k 个 不同 的元素。

你必须找到一个内存复杂度优于 O(n2) 的解决方案。

```js
/**
 * @param {number[][]} matrix
 * @param {number} k
 * @return {number}
 */
var kthSmallest = function (matrix, k) {
    // 获取矩阵大小和最小/最大值作为初始搜索范围
    const n = matrix.length, left = matrix[0][0], right = matrix[n - 1][n - 1];

    // 检查函数：计算矩阵中小于等于m的元素数量
    const check = (m) => {
        let cnt = 0;
        // 从每行的右上角开始检查
        for (let i = 0, j = n - 1; i < n; i++) {
            // 找到当前行第一个不大于m的元素
            while (j >= 0 && matrix[i][j] > m) {
                j--;
            }
            // 当前行有j+1个元素<=m
            cnt += j + 1;
        }
        // 返回是否小于k个元素<=m
        return cnt < k;
    }

    // 二分查找实现
    const lowerBound = (left, right) => {
        // l左侧都是小于第k小的元素，r右侧都是>=第k小的元素
        let l = left, r = right;

        while (l <= r) {
            let mid = Math.floor((r - l) / 2) + l;
            if (check(mid)) {
                // 如果<=mid的元素不足k个，说明第k小元素在右侧
                l = mid + 1;
            } else {
                // 否则在左侧
                r = mid - 1;
            }
        }
        // 最终l指向第k小的元素
        return l;
    }

    // 在[left, right]范围内进行二分查找
    return lowerBound(left, right);
};

```

#### [2040. 两个有序数组的第 K 小乘积](https://leetcode.cn/problems/kth-smallest-product-of-two-sorted-arrays/description/)

给你两个 从小到大排好序 且下标从 0 开始的整数数组 nums1 和 nums2 以及一个整数 k ，请你返回第 k （从 1 开始编号）小的 nums1[i] * nums2[j] 的乘积，其中 0 <= i < nums1.length 且 0 <= j < nums2.length 。
 
 ```js
/**
 * 查找两个有序数组乘积的第k小元素
 * @param {number[]} nums1 第一个有序数组
 * @param {number[]} nums2 第二个有序数组
 * @param {number} k 要找的第k小元素的位置
 * @return {number} 第k小的乘积值
 */
var kthSmallestProduct = function (nums1, nums2, k) {
    // 获取数组长度
    const m = nums1.length, n = nums2.length;
    
    // 计算四个极值点的乘积，用于确定二分搜索的初始范围
    const a = nums1[0] * nums2[n - 1], // nums1最小 * nums2最大
          b = nums1[0] * nums2[0],     // nums1最小 * nums2最小
          c = nums1[m - 1] * nums2[n - 1], // nums1最大 * nums2最大
          d = nums1[m - 1] * nums2[0];    // nums1最大 * nums2最小
    
    // 确定二分搜索的左右边界
    const left = Math.min(a, b, c, d),
          right = Math.max(a, b, c, d);
    
    // 找到两个数组中负数的分界点
    const bound1 = lowerBound(0, m - 1, (mid) => nums1[mid] < 0) - 1, // nums1中最后一个负数的索引
          bound2 = lowerBound(0, n - 1, (mid) => nums2[mid] < 0) - 1;  // nums2中最后一个负数的索引

    /**
     * 检查函数：计算乘积小于等于mid的元素数量
     * @param {number} mid 中间值
     * @return {boolean} 是否小于k个元素
     */
    const check = (mid) => {
        let cnt = 0;

        if (mid < 0) {
            // 处理mid为负数的情况
            // 右上区域：nums1负数 * nums2正数
            for (let i = 0, j = bound2 + 1; i <= bound1; i++) {
                while (j < n && nums1[i] * nums2[j] > mid) {
                    j++;
                }
                cnt += n - j;
            }
            // 左下区域：nums1正数 * nums2负数
            for (let i = m - 1, j = bound2; i > bound1; i--) {
                while (j >= 0 && nums1[i] * nums2[j] > mid) {
                    j--;
                }
                cnt += j + 1;
            }
        } else {
            // 处理mid为非负数的情况
            // 预先计算左上和右下区域的固定数量
            cnt += (bound1 + 1) * (n - bound2 - 1) + // 左上区域固定数量
                   (m - bound1 - 1) * (bound2 + 1);  // 右下区域固定数量
            
            // 左上区域：nums1负数 * nums2负数
            for (let i = bound1, j = 0; i >= 0; i--) {
                while (j <= bound2 && nums1[i] * nums2[j] > mid) {
                    j++;
                }
                cnt += bound2 - j + 1;
            }
            // 右下区域：nums1正数 * nums2正数
            for (let i = bound1 + 1, j = n - 1; i < m; i++) {
                while (j > bound2 && nums1[i] * nums2[j] > mid) {
                    j--;
                }
                cnt += j - bound2;
            }
        }
        return cnt < k;
    }

    // 使用二分查找找到第k小的乘积
    return lowerBound(left, right, check);
};

/**
 * 二分查找下界函数
 * @param {number} left 左边界
 * @param {number} right 右边界
 * @param {function} check 检查函数
 * @return {number} 找到的下界值
 */
const lowerBound = (left, right, check) => {
    let l = left, r = right;

    while (l <= r) {
        let mid = Math.floor((r - l) / 2) + l;

        if (check(mid)) {
            l = mid + 1;
        } else {
            r = mid - 1;
        }
    }

    return l;
}

 ```