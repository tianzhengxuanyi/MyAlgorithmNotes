### 第k小问题

> 第 k 小/大问题的通用转换方法：
>
> - 第 k 小等价于：求最小的 x，满足 ≤x 的数至少有 k 个。
> - 第 k 大等价于：求最大的 x，满足 ≥x 的数至少有 k 个。

#### [668. 乘法表中第 k 小的数](https://leetcode.cn/problems/kth-smallest-number-in-multiplication-table/description/)

几乎每一个人都用 乘法表。但是你能在乘法表中快速找到第 k 小的数字吗？

乘法表是大小为 m x n 的一个整数矩阵，其中 mat[i][j] == i \* j（下标从 1 开始）。

给你三个整数 m、n 和 k，请你在大小为 m x n 的乘法表中，找出并返回第 k 小的数字。

[题解](https://leetcode.cn/problems/kth-smallest-number-in-multiplication-table/solutions/1499050/cheng-fa-biao-zhong-di-kxiao-de-shu-by-l-521a/)

> 求第几小等价于求有多少数字不超过 x。我们可以遍历乘法表的每一行，对于乘法表的第 i 行，其数字均为 i 的倍数，因此不超过 x 的数字有 min(⌊x/i⌋,n) 个，所以遍历行就可得到整个乘法表不超过 x 的数字个数

```js
/**
 * @param {number} m
 * @param {number} n
 * @param {number} k
 * @return {number}
 */
var findKthNumber = function (m, n, k) {
  let left = 1,
    right = m * n,
    min = Math.min(m, n),
    mx = Math.max(m, n); // left 左侧为小于第k小的数 right右侧为大于等于第k小的数
  while (left <= right) {
    let mid = Math.floor((right - left) / 2) + left;
    if (check(mid, min, mx, k)) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }
  return left;
};

function check(mid, m, n, k) {
  let cnt = 0;
  for (let i = 1; i <= m; i++) {
    cnt += Math.min(n, Math.floor(mid / i));
  }
  return cnt < k;
}
```

#### [878. 第 N 个神奇数字](https://leetcode.cn/problems/nth-magical-number/description/)

一个正整数如果能被 a 或 b 整除，那么它是神奇的。

给定三个整数 n , a , b ，返回第 n 个神奇的数字。因为答案可能很大，所以返回答案 对 109 + 7 取模 后的值。

> **辗转相处获取最大公约数 gcd**

```js
/**
 * @param {number} n
 * @param {number} a
 * @param {number} b
 * @return {number}
 */
var nthMagicalNumber = function (n, a, b) {
  const mod = 1e9 + 7,
    lcm = getLCM(a, b);
  let left = 1,
    right = n * Math.min(a, b) + 1; // left左侧为小于的n个数 right为大于等于第n个数的数
  while (left <= right) {
    let mid = Math.floor((right - left) / 2) + left;
    if (Math.floor(mid / a) + Math.floor(mid / b) - Math.floor(mid / lcm) < n) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }
  return left % mod;
};

function getLCM(a, b) {
  return (a * b) / getGCD(a, b);
}

// 最大公约数
function getGCD(a, b) {
  // 如果 a b 都为偶数 除 2
  let n = 0;
  while (a % 2 === 0 && b % 2 === 0) {
    n++;
    a /= 2;
    b /= 2;
  }
  // 辗转相减
  let mx = Math.max(a, b),
    mn = Math.min(a, b);
  while (mx !== mn) {
    let d = mx - mn;
    mx = Math.max(d, mn);
    mn = Math.min(d, mn);
  }

  return mx * Math.pow(2, n);
}
```

**辗转相除求最大公约数**

```js
function getGCD(a, b) {
  let mx = Math.max(a, b),
    mn = Math.min(a, b);
  if (mx % mn === 0) {
    return mn;
  } else {
    return getGCD(mx % mn, mn);
  }
}
```

```js
function getGCD(a, b) {
  while (b !== 0) {
    let t = a % b;
    a = b;
    b = t;
  }
  return a;
}
