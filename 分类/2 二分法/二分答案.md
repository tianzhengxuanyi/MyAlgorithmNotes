## 二分答案：最小

> 满足条件的最小或者满足条件的最大

**模板：**

```js
let left = 1,
  right = n; // left和right需根据题目得出
const check = (mid) => {
  // 根据题目判断当前mid值是否能过满足条件
};
// 二分答案
while (left <= right) {
  let mid = Math.floor((right - left) / 2) + left;
  if (!check(mid)) {
    left = mid + 1;
  } else {
    right = mid - 1;
  }
}
return left;
```

### [2187. 完成旅途的最少时间](https://leetcode.cn/problems/minimum-time-to-complete-trips/description/)

给你一个数组 time ，其中 time[i] 表示第 i 辆公交车完成 一趟旅途 所需要花费的时间。

每辆公交车可以 连续 完成多趟旅途，也就是说，一辆公交车当前旅途完成后，可以 立马开始 下一趟旅途。每辆公交车 独立 运行，也就是说可以同时有多辆公交车在运行且互不影响。

给你一个整数 totalTrips ，表示所有公交车 总共 需要完成的旅途数目。请你返回完成 至少 totalTrips 趟旅途需要花费的 最少 时间。

> [题解](https://leetcode.cn/problems/minimum-time-to-complete-trips/solutions/1295955/er-fen-da-an-python-yi-xing-gao-ding-by-xwvs8/)

```js
/**
 * @param {number[]} time
 * @param {number} totalTrips
 * @return {number}
 */
var minimumTime = function (time, totalTrips) {
  const minT = Math.min(...time);
  let left = Math.floor((minT * totalTrips) / time.length) - 1,
    right = totalTrips * minT;
  while (left <= right) {
    let mid = Math.floor((right - left) / 2) + left;
    let cnt = 0;
    for (let t of time) {
      cnt += Math.floor(mid / t);
    }
    if (cnt < totalTrips) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }
  return left;
};
```

### [3048. 标记所有下标的最早秒数 I ☆](https://leetcode.cn/problems/earliest-second-to-mark-indices-i/description/)

给你两个下标从 1 开始的整数数组 nums 和 changeIndices ，数组的长度分别为 n 和 m 。

一开始，nums 中所有下标都是未标记的，你的任务是标记 nums 中 所有 下标。

从第 1 秒到第 m 秒（包括 第 m 秒），对于每一秒 s ，你可以执行以下操作 之一 ：

- 选择范围 [1, n] 中的一个下标 i ，并且将 nums[i] 减少 1 。
- 如果 nums[changeIndices[s]] 等于 0 ，标记 下标 changeIndices[s] 。
- 什么也不做。

请你返回范围 [1, m] 中的一个整数，表示最优操作下，标记 nums 中**所有**下标的**最早秒数** ，如果无法标记所有下标，返回 -1 。

> [**题解**](https://leetcode.cn/problems/earliest-second-to-mark-indices-i/solutions/2653101/er-fen-da-an-pythonjavacgo-by-endlessche-or61/)

> 题意有点抽象，形象地解释一下：
> 你有 n 门课程需要考试，第 i 门课程需要用 nums[i] 天复习。同一天只能复习一门课程。
> 在第 i 天，你可以选择参加第 changeIndices[i] 门课程的考试。考试这一天不能复习。
> 搞定所有课程的复习+考试，至少要多少天？

```js
/**
 * @param {number[]} nums
 * @param {number[]} changeIndices
 * @return {number}
 */
var earliestSecondToMarkIndices = function (nums, changeIndices) {
  const n = nums.length,
    m = changeIndices.length;
  let left = n,
    right = m;
  if (left > right) {
    return -1;
  }

  const check = (mid) => {
    // nums下标在0-mid中出现最晚的时间
    const lastT = Array(n).fill(-1);
    for (let i = 0; i < mid; i++) {
      lastT[changeIndices[i] - 1] = i;
    }
    for (let t of lastT) {
      if (t < 0) {
        // 在0-mid中有科目没有考试
        return false;
      }
    }
    let cnt = 0; // 复习的时间
    for (let i = 0; i < mid; i++) {
      let idx = changeIndices[i] - 1; // 当天可以考试的科目
      if (i === lastT[idx]) {
        // 当前是科目昨晚考试时间，考试
        if (cnt < nums[idx]) {
          // 复习时间不够
          return false;
        }
        cnt -= nums[idx]; // 扣除复习时间
      } else {
        // 当天不考试，用来复习
        cnt++;
      }
    }

    return true;
  };
  while (left <= right) {
    let mid = Math.floor((right - left) / 2) + left;
    if (!check(mid)) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }
  return left > m ? -1 : left;
};
```

### [475. 供暖器](https://leetcode.cn/problems/heaters/description/)

冬季已经来临。 你的任务是设计一个有固定加热半径的供暖器向所有房屋供暖。

在加热器的加热半径范围内的每个房屋都可以获得供暖。

现在，给出位于一条水平线上的房屋 houses 和供暖器 heaters 的位置，请你找出并返回可以覆盖所有房屋的最小加热半径。

注意：所有供暖器 heaters 都遵循你的半径标准，加热的半径也一样。

> [二分最小 + 双指针](https://leetcode.cn/problems/heaters/solutions/1166982/gong-shui-san-xie-er-fen-shuang-zhi-zhen-mys4/)
>
> **check 函数实现：**
>
> 先对 houses 和 heaters 进行排序，使用 i 指向当前处理到的 houses[i]；j 指向 可能 覆盖到 houses[i] 的最小下标 heaters[j]；x 代表当前需要 check 的半径。
>
> 当且仅当 `heaters[j]+x < houses[i]` 时，houses[i] 必然不能被 heaters[j] 所覆盖，此时让 j 自增。
>
> 找到合适的 j 之后，再检查 `heaters[j]−x<=houses[i]<=heaters[j]+x` 是否满足，即可知道 houses[i] 的覆盖情况。

```js
/**
 * @param {number[]} houses
 * @param {number[]} heaters
 * @return {number}
 */
var findRadius = function (houses, heaters) {
  houses.sort((a, b) => a - b);
  heaters.sort((a, b) => a - b);
  const len1 = houses.length,
    len2 = heaters.length;
  let left = 0,
    right = Math.max(houses[len1 - 1], heaters[len2 - 1]);
  const check = (n) => {
    for (let i = 0, j = 0; i < len1; i++) {
      while (heaters[j] + n < houses[i]) {
        j++;
      }
      if (
        j < len2 &&
        heaters[j] - n <= houses[i] &&
        heaters[j] + n >= houses[i]
      ) {
        continue;
      }
      return false;
    }
    return true;
  };
  while (left <= right) {
    let mid = Math.floor((right - left) / 2) + left;
    if (!check(mid)) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }
  return left;
};
```

> 二分
>
> 对 heaters 排序，遍历 house**二分查找**最近位置左边和右边的 heater，计算离左右 heater 的距离中的最小值 d。答案为遍历中所有 d 值的最大值。

```js
/**
 * @param {number[]} houses
 * @param {number[]} heaters
 * @return {number}
 */
var findRadius = function (houses, heaters) {
  heaters.sort((a, b) => a - b);
  let ans = 0;
  for (let house of houses) {
    let i = lowerBound(heaters, house);
    let leftD = i - 1 >= 0 ? house - heaters[i - 1] : Infinity;
    let rightD = i < heaters.length ? heaters[i] - house : Infinity;
    ans = Math.max(ans, Math.min(leftD, rightD));
  }
  return ans;
};

function lowerBound(nums, target) {
  let l = 0,
    r = nums.length - 1;
  while (l <= r) {
    let m = Math.floor((r - l) / 2) + l;
    if (nums[m] < target) {
      l = m + 1;
    } else {
      r = m - 1;
    }
  }
  return l;
}
```

## 二分答案：最大

## 二分答案：最小化最大值

> 「**最小化最大值**」就是二分答案的代名词。
> 本质是二分答案求最小。二分的 mid 表示上界

## 二分答案：最大化最小值

> 本质是二分答案求最大。二分的 mid 表示下界。

### [3281. 范围内整数的最大得分 ☆](https://leetcode.cn/problems/maximize-score-of-numbers-in-ranges/description/)

给你一个整数数组 start 和一个整数 d，代表 n 个区间 [start[i], start[i] + d]。

你需要选择 n 个整数，其中第 i 个整数必须属于第 i 个区间。所选整数的 得分 定义为所选整数两两之间的 **最小** 绝对差。

返回所选整数的**最大可能得分**

> 最大化最小值，二分最大可能得分
>
> 按左端点排序，这样只用考虑相邻区间的差值 -> 相邻区间 i、i+1 的差值必定小于区间 i、j(j > i+1)的差值
>
> 贪心的判断得分是否合法：给定 score，能否从每个区间各选一个数，使得任意两数之差的最小值至少为 score。
>
> 1. 假设区间 i 选择 x_i，如果 x_i + score > start[i+1] + d，表示区间 i、i+1 间的差值小于 score，score 过大应当减小二分的右边界 right
> 2. 贪心地想，第一个数越小，第二个数就越能在区间内，所以第一个数要选 x_0 = start[0]。
> 3. 依次选取 x_i 判断，x_i+1 = max(start[i], x_i + score)

```js
/**
 * @param {number[]} start
 * @param {number} d
 * @return {number}
 */
var maxPossibleScore = function (start, d) {
  const len = start.length;
  start.sort((a, b) => a - b);
  // left 左侧表示符合条件   right 右侧表示得分过大不符合条件
  let left = start[len - 1] - start[0],
    right = start[len - 1] + d + 1 - start[0];
  for (let i = 1; i < len; i++) {
    left = Math.min(left, start[i] - start[i - 1]);
  }
  const check = (mid) => {
    let n = start[0];
    for (let i = 1; i < len; i++) {
      if (start[i] + d < n + mid) {
        return false;
      }
      n = Math.max(n + mid, start[i]);
    }
    return true;
  };
  while (left <= right) {
    let mid = Math.floor((right - left) / 2) + left;
    if (check(mid)) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }
  return right;
};
```

## 第 k 小/大问题

> 第 k 小/大问题的通用转换方法：
>
> - 第 k 小等价于：求最小的 x，满足 ≤x 的数至少有 k 个。
> - 第 k 大等价于：求最大的 x，满足 ≥x 的数至少有 k 个。

### [668. 乘法表中第 k 小的数](https://leetcode.cn/problems/kth-smallest-number-in-multiplication-table/description/)

几乎每一个人都用 乘法表。但是你能在乘法表中快速找到第 k 小的数字吗？

乘法表是大小为 m x n 的一个整数矩阵，其中 mat[i][j] == i \* j（下标从 1 开始）。

给你三个整数 m、n 和 k，请你在大小为 m x n 的乘法表中，找出并返回第 k 小的数字。

[题解](https://leetcode.cn/problems/kth-smallest-number-in-multiplication-table/solutions/1499050/cheng-fa-biao-zhong-di-kxiao-de-shu-by-l-521a/)

> 求第几小等价于求有多少数字不超过 x。我们可以遍历乘法表的每一行，对于乘法表的第 i 行，其数字均为 i 的倍数，因此不超过 x 的数字有 min(⌊x/i⌋,n) 个，所以遍历行就可得到整个乘法表不超过 x 的数字个数

```js
/**
 * @param {number} m
 * @param {number} n
 * @param {number} k
 * @return {number}
 */
var findKthNumber = function (m, n, k) {
  let left = 1,
    right = m * n,
    min = Math.min(m, n),
    mx = Math.max(m, n); // left 左侧为小于第k小的数 right右侧为大于等于第k小的数
  while (left <= right) {
    let mid = Math.floor((right - left) / 2) + left;
    if (check(mid, min, mx, k)) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }
  return left;
};

function check(mid, m, n, k) {
  let cnt = 0;
  for (let i = 1; i <= m; i++) {
    cnt += Math.min(n, Math.floor(mid / i));
  }
  return cnt < k;
}
```

## [878. 第 N 个神奇数字](https://leetcode.cn/problems/nth-magical-number/description/)

一个正整数如果能被 a 或 b 整除，那么它是神奇的。

给定三个整数 n , a , b ，返回第 n 个神奇的数字。因为答案可能很大，所以返回答案 对 109 + 7 取模 后的值。

> **辗转相处获取最大公约数 gcd**

```js
/**
 * @param {number} n
 * @param {number} a
 * @param {number} b
 * @return {number}
 */
var nthMagicalNumber = function (n, a, b) {
  const mod = 1e9 + 7,
    lcm = getLCM(a, b);
  let left = 1,
    right = n * Math.min(a, b) + 1; // left左侧为小于的n个数 right为大于等于第n个数的数
  while (left <= right) {
    let mid = Math.floor((right - left) / 2) + left;
    if (Math.floor(mid / a) + Math.floor(mid / b) - Math.floor(mid / lcm) < n) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }
  return left % mod;
};

function getLCM(a, b) {
  return (a * b) / getGCD(a, b);
}

// 最大公约数
function getGCD(a, b) {
  // 如果 a b 都为偶数 除 2
  let n = 0;
  while (a % 2 === 0 && b % 2 === 0) {
    n++;
    a /= 2;
    b /= 2;
  }
  // 辗转相减
  let mx = Math.max(a, b),
    mn = Math.min(a, b);
  while (mx !== mn) {
    let d = mx - mn;
    mx = Math.max(d, mn);
    mn = Math.min(d, mn);
  }

  return mx * Math.pow(2, n);
}
```

**辗转相除求最大公约数**

```js
function getGCD(a, b) {
  let mx = Math.max(a, b),
    mn = Math.min(a, b);
  if (mx % mn === 0) {
    return mn;
  } else {
    return getGCD(mx % mn, mn);
  }
}
```
