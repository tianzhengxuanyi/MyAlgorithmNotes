## [分组循环](https://leetcode.cn/problems/longest-even-odd-subarray-with-threshold/solutions/2528771/jiao-ni-yi-ci-xing-ba-dai-ma-xie-dui-on-zuspx/)

> 适用场景：按照题目要求，数组会被分割成若干组，且每一组的判断/处理逻辑是一样的。

### 核心思想：

外层循环负责遍历组之前的准备工作（记录开始位置），和遍历组之后的统计工作（更新答案最大值）。内层循环负责遍历组，找出这一组最远在哪结束。这个写法的好处是，各个逻辑块分工明确，也不需要特判最后一组（易错点）。以我的经验，这个写法是所有写法中最不容易出 bug 的，推荐大家记住。

时间复杂度乍一看是 O(n^2)，但注意变量 i 只会增加，不会重置也不会减少。所以二重循环总共循环 O(n) 次，所以时间复杂度是 O(n)。

```python
n = len(nums)
i = 0
while i < n:
    start = i
    while i < n and ...:
        i += 1
    # 从 start 到 i-1 是一组
    # 下一组从 i 开始，无需 i += 1
```

### [3105. 最长的严格递增或递减子数组](https://leetcode.cn/problems/longest-strictly-increasing-or-strictly-decreasing-subarray/description/)

给你一个整数数组 nums 。

返回数组 nums 中 **严格递增**或**严格递减**的最长非空子数组的长度。

> 注意本题，第一个单调序列末尾和第二个单调序列开头，有一个元素是重叠的，所以下面代码在外层循环末尾要把 **i 减一**。

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var longestMonotonicSubarray = function (nums) {
  let ans = 1,
    len = nums.length,
    i = 0;
  while (i < len - 1) {
    if (nums[i] === nums[i + 1]) {
      i++;
      continue;
    }
    let start = i;
    i += 2;
    while (
      i < len &&
      nums[i] !== nums[i - 1] &&
      nums[i - 1] > nums[i - 2] === nums[i] > nums[i - 1]
    ) {
      i++;
    }
    ans = Math.max(ans, i - start);
    // 第一个单调序列末尾和第二个单调序列开头，有一个元素是重叠的
    i--;
  }
  return ans;
};
```

### [467. 环绕字符串中唯一的子字符串](https://leetcode.cn/problems/unique-substrings-in-wraparound-string/)

定义字符串 base 为一个 "abcdefghijklmnopqrstuvwxyz" 无限环绕的字符串，所以 base 看起来是这样的：

- "...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....".
  给你一个字符串 s ，请你统计并返回 s 中有多少 不同非空子串 也在 base 中出现。

> 本题中答案需要去重，记录**以每个字符结尾的最长子串长度**

```js
/**
 * @param {string} s
 * @return {number}
 */
var findSubstringInWraproundString = function (s) {
  let len = s.length,
    i = 0,
    // 以每个字符结尾的最长子串长度
    map = Array(26).fill(0);
  while (i < len) {
    let code = s[i + 1]?.charCodeAt() - s[i].charCodeAt();
    if (code !== 1 && code !== -25) {
      map[s[i].charCodeAt() - 97] = Math.max(map[s[i].charCodeAt() - 97], 1);
      i++;
      continue;
    }
    let start = i;
    while (i < len - 1 && (code == 1 || code == -25)) {
      map[s[i].charCodeAt() - 97] = Math.max(
        map[s[i].charCodeAt() - 97],
        i - start + 1
      );
      i++;
      code = s[i + 1]?.charCodeAt() - s[i].charCodeAt();
    }
    map[s[i].charCodeAt() - 97] = Math.max(
      map[s[i].charCodeAt() - 97],
      i - start + 1
    );
  }
  return map.reduce((a, b) => a + b, 0);
};
```

### [2948. 交换得到字典序最小的数组 ☆](https://leetcode.cn/problems/make-lexicographically-smallest-array-by-swapping-elements/description/)

给你一个下标从 0 开始的 正整数 数组 nums 和一个 正整数 limit 。

在一次操作中，你可以选择任意两个下标 i 和 j，如果 满足 |nums[i] - nums[j]| <= limit ，则交换 nums[i] 和 nums[j] 。

返回执行任意次操作后能得到的 字典序最小的数组 。

如果在数组 a 和数组 b 第一个不同的位置上，数组 a 中的对应元素比数组 b 中的对应元素的字典序更小，则认为数组 a 就比数组 b 字典序更小。例如，数组 [2,10,3] 比数组 [10,2,3] 字典序更小，下标 0 处是两个数组第一个不同的位置，且 2 < 10 。

```js
/**
 * @param {number[]} nums
 * @param {number} limit
 * @return {number[]}
 */
var lexicographicallySmallestArray = function (nums, limit) {
  let len = nums.length,
    i = 0;
  const ids = Array(len)
    .fill(0)
    .map((_, i) => i)
    .sort((a, b) => nums[a] - nums[b]);
  const ans = Array(len);
  while (i < len) {
    let start = i;
    i++;
    while (i < len && nums[ids[i]] - nums[ids[i - 1]] <= limit) {
      i++;
    }
    let subId = ids.slice(start, i).sort((a, b) => a - b);
    for (let j = 0; j < subId.length; j++) {
      ans[subId[j]] = nums[ids[start + j]];
    }
  }
  return ans;
};
// 8 2 6 4
// 8 2 4 6   6 2 4 8 4 6 ==  4 2 6 8   2 4 6 8
```

```js
/**
 * @param {number[]} nums
 * @param {number} limit
 * @return {number[]}
 */
var lexicographicallySmallestArray = function (nums, limit) {
  let len = nums.length,
    i = 0;
  const ids = Array(len)
    .fill(0)
    .map((_, i) => i)
    .sort((a, b) => nums[a] - nums[b]);
  const ans = [...nums];
  while (i < len - 1) {
    if (ans[ids[i + 1]] - nums[ids[i]] > limit) {
      i++;
      continue;
    }
    let start = i;
    while (i < len - 1 && nums[ids[i + 1]] - nums[ids[i]] <= limit) {
      i++;
    }
    let subId = ids.slice(start, i + 1).sort((a, b) => a - b);
    for (let j = start; j <= i; j++) {
      ans[subId[j - start]] = nums[ids[j]];
    }
  }
  return ans;
};
```

### [2593. 标记所有元素后数组的分数](https://leetcode.cn/problems/find-score-of-an-array-after-marking-all-elements/description/)

给你一个数组 nums ，它包含若干正整数。

一开始分数 score = 0 ，请你按照下面算法求出最后分数：

- 从数组中选择最小且没有被标记的整数。如果有相等元素，选择下标最小的一个。
- 将选中的整数加到 score 中。
- 标记 被选中元素，如果有相邻元素，则同时标记 与它相邻的两个元素 。
- 重复此过程直到数组中所有元素都被标记。

请你返回执行上述算法后最后的分数。

**解法一： 下标排序+集合**

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var findScore = function (nums) {
  const len = nums.length;
  const ids = Array(len)
    .fill(0)
    .map((_, i) => i)
    .sort((a, b) => nums[a] - nums[b]);
  const set = new Set();
  let scroe = 0;
  for (let i = 0; i < len; i++) {
    if (set.has(ids[i])) {
      continue;
    }
    scroe += nums[ids[i]];
    set.add(ids[i] - 1);
    set.add(ids[i]);
    set.add(ids[i] + 1);
  }
  return scroe;
};
```

[**解法二：循环分组**](https://leetcode.cn/problems/find-score-of-an-array-after-marking-all-elements/solutions/2790961/2593-biao-ji-suo-you-yuan-su-hou-shu-zu-mqljy/)

将数组 nums 分成严格递减子数组，对于任意两个相邻的严格递减子数组满足前一个子数组的末尾元素小于等于后一个子数组的起始元素。分成严格递减子数组之后，对于每个长度大于 1 的子数组，其末尾元素一定会被选择，理由如下。

- 该元素左边的相邻元素一定大于该元素，因此不可能在选择该元素之前选择该元素左边的相邻元素。

- 该元素右边的相邻元素一定大于等于该元素，因此因此不可能在选择该元素之前选择该元素右边的相邻元素。

选择严格递减子数组的末尾元素之后，该子数组中的所有与末尾元素的下标之差为偶数的元素都会被选择，所有与末尾元素的下标之差为奇数的元素都不会被选择。

因此只要能定位到数组 nums 的每个严格递减子数组的下标范围，即可计算数组的分数。

用 startIndex 和 endIndex 分别表示严格递增子数组的下标范围，初始时 startIndex=endIndex=0。当 endIndex 未超出数组 nums 的下标范围时，执行如下操作。

- 当 endIndex 未到达数组 nums 的末尾下标且 nums[endIndex]>nums[endIndex+1] 时，将 endIndex 向右移动，直到 endIndex 到达数组 nums 的末尾下标或 nums[endIndex]≤nums[endIndex+1]。

- 遍历下标范围 [startIndex,endIndex] 中的所有与 endIndex 之差为偶数的下标，将遍历到的下标处的元素加到数组的分数。

- 当前子数组遍历结束之后，下标 endIndex+1 处的元素不能被选择，因此将 startIndex 和 endIndex 都更新为 endIndex+2。

遍历所有严格递增子数组之后，即可得到数组的分数。

[两种做法：从 O(nlogn) 到 O(n)（Python/Java/C++/Go）](https://leetcode.cn/problems/find-score-of-an-array-after-marking-all-elements/solutions/2177231/dai-zhao-xia-biao-qu-pai-xu-pythonjavacg-umuv/)
```python
class Solution:
    def findScore(self, nums: List[int]) -> int:
        ans = 0
        i, n = 0, len(nums)
        while i < n:
            i0 = i
            while i + 1 < n and nums[i] > nums[i + 1]:  # 找到下坡的坡底
                i += 1
            for j in range(i, i0 - 1, -2):  # 从坡底 i 到坡顶 i0，每隔一个累加
                ans += nums[j]
            i += 2  # i 选了 i+1 不能选
        return ans
```
