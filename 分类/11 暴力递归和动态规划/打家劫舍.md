## 打家劫舍

### [198. 打家劫舍](https://leetcode.cn/problems/house-robber/description/)

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

> 从第i间房子开始偷，能偷到的最大金额为`dp[i]`
>
> 如果偷第i间房子，那么第i-1间房子就不能偷，所以能偷到的最大金额为`dp[i-2]+nums[i]`
>
> 如果不偷第i间房子，那么能偷到的最大金额为`dp[i-1]`
>
> 所以递推公式：`dp[i]=max(dp[i+2]+nums[i],dp[i+1])`

```js
/**
 * @param {number[]} nums
> 递推公式：`dp[i]=max(dp[i+2]+nums[i],dp[i+1])`

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var rob = function (nums) {
    let p = p1 = nums[nums.length - 1], p2 = 0;
    for (let i = nums.length - 2; i >= 0; i--) {
        p = Math.max(p1, nums[i] + p2);
        [p2, p1] = [p1, p];
    }
    return p;
};
```

### [⭐740. 删除并获得点数](https://leetcode.cn/problems/delete-and-earn/description/) `值域打家劫舍`

给你一个整数数组 nums ，你可以对它进行一些操作。

每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除 所有 等于 nums[i] - 1 和 nums[i] + 1 的元素。

开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。

> `nums=[2,2,3,3,3,4]`, 把 nums 转换成一个值域数组 a，其中 a[i] 表示 nums 中的等于 i 的元素之和。上面的例子中，a=[0,0,4,9,4]。因为 nums 中有 3 个 3，所以 a[3]=3+3+3=9。
>
>计算数组 a 的  `198. 打家劫舍`，即为答案。

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var deleteAndEarn = function (nums) {
    const max = Math.max(...nums);
    const arr = Array(max + 1).fill(0);
    for (let num of nums) {
        arr[num] += num;
    }
    return robbed(arr);
};

function robbed(arr) {
    const n = arr.length;
    let p = p1 = arr[n - 1], p2 = 0;
    for (let i = n-2; i >= 0; i--) {
        p = Math.max(p1, arr[i] + p2);
        [p1, p2] = [p, p1];
    }
    return p;
}
```