### 二分图

#### [785. 判断二分图](https://leetcode.cn/problems/is-graph-bipartite/description/)

存在一个 无向图 ，图中有 n 个节点。其中每个节点都有一个介于 0 到 n - 1 之间的唯一编号。给你一个二维数组 graph ，其中 graph[u] 是一个节点数组，由节点 u 的邻接节点组成。形式上，对于 graph[u] 中的每个 v ，都存在一条位于节点 u 和节点 v 之间的无向边。该无向图同时具有以下属性：
不存在自环（graph[u] 不包含 u）。
不存在平行边（graph[u] 不包含重复值）。
如果 v 在 graph[u] 内，那么 u 也应该在 graph[v] 内（该图是无向图）
这个图可能不是连通图，也就是说两个节点 u 和 v 之间可能不存在一条连通彼此的路径。
二分图 定义：如果能将一个图的节点集合分割成两个独立的子集 A 和 B ，并使图中的每一条边的两个节点一个来自 A 集合，一个来自 B 集合，就将这个图称为 二分图 。

如果图是二分图，返回 true ；否则，返回 false 。

**二分图染色**

```js
/**
 * 判断给定的无向图是否是二分图
 * @param {number[][]} graph 图的邻接表表示，graph[u]包含节点u的所有邻接节点
 * @return {boolean} 如果是二分图返回true，否则返回false
 */
var isBipartite = function (graph) {
    const n = graph.length; // 图中节点总数
    const color = Array(n).fill(-1); // 颜色数组，-1表示未访问，0和1表示两种颜色
    
    /**
     * 深度优先搜索函数，尝试对节点进行二分着色
     * @param {number} i 当前节点索引
     * @param {number} c 当前节点应该被染的颜色(0或1)
     * @return {boolean} 是否成功着色
     */
    const dfs = (i, c) => {
        color[i] = c; // 标记当前节点颜色
        for (let next of graph[i]) { // 遍历所有邻接节点
            // 如果邻接节点已着色且颜色与当前节点相同，说明不是二分图
            if (color[next] >= 0 && color[next] == c) {
                return false;
            } 
            // 如果邻接节点未着色，递归尝试用相反颜色着色
            else if (color[next] < 0 && !dfs(next, 1 - c)) {
                return false;
            }
        }
        return true;
    }

    // 遍历所有节点，处理可能存在的多个连通分量
    for (let i = 0; i < n; i++) {
        // 如果节点未访问过且着色失败，说明不是二分图
        if (color[i] < 0 && !dfs(i, 0)) {
            return false;
        }
    }

    return true; // 所有节点都成功着色，是二分图
};
```