### 单源最短路：Dijkstra 算法

[**基本思想**](https://blog.csdn.net/qq_41040550/article/details/107029809)：

- 一个顶点属于集合 S，当且仅当从源到该顶点的最短路径长度已知。
- 设置顶点集合 S，并不断地作贪心选择来扩充这个集合。
- 贪心策略：每次都从 V-S 中找出具有最短特殊路长的顶点 u 加入 S。

**算法思路**：

1. 初始时，S 中仅含有源点。
2. 设 u 是 G 的某一个顶点，把从源点到 u 且中间只经过 S 中顶点的路称为从源点到 u 的特殊路径，并用数组 dist 记录当前每个顶点所对应的最短特殊路径长度。
3. Dijkstra 算法每次从 V-S 中取出具有最短特殊路长度的顶点 u，将 u 添加到 S 中，同时对数组 dist 作必要的修改。
4. 一旦 S 包含了 V 中所有顶点，dist 就记录了从源到其它所有顶点之间的最短路径长度。

![dijkstra示例](../../image/dijkstra算法示例.png)

#### [743. 网络延迟时间](https://leetcode.cn/problems/network-delay-time/description/)

给你一个列表 times，表示信号经过 有向 边的传递时间。 times[i] = (ui, vi, wi)，其中 ui 是源节点，vi 是目标节点， wi 是一个信号从源节点传递到目标节点的时间。

现在，从某个节点 K 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 -1 。

[**两种 Dijkstra 写法（附题单）**](https://leetcode.cn/problems/network-delay-time/solutions/2668220/liang-chong-dijkstra-xie-fa-fu-ti-dan-py-ooe8/)

**写法一：朴素 Dijkstra** （适用于稠密图）

> 稠密图：边的数量级和 n ^ 2 相当的图。

```js
/**
 * 计算网络信号从节点k传播到所有其他节点所需的最短时间
 * @param {number[][]} times 边列表，每个元素格式为 [源节点, 目标节点, 传播时间]
 * @param {number} n 网络中的节点总数
 * @param {number} k 信号起始节点
 * @return {number} 信号传播到所有节点的最长时间，如果无法到达所有节点则返回-1
 */
var networkDelayTime = function (times, n, k) {
  // 初始化邻接矩阵，默认值为Infinity表示不可达
  const graph = Array.from({ length: n }, () => Array(n).fill(Infinity));
  // 构建图的邻接矩阵表示
  for (let [u, v, w] of times) {
    graph[u - 1][v - 1] = w; // 节点编号转为0-based索引
  }

  // dist数组记录从起点k到各节点的最短距离
  const dist = Array(n).fill(Infinity);
  // done数组标记节点是否已确定最短路径
  const done = Array(n).fill(false);
  dist[k - 1] = 0; // 起点到自身的距离为0

  while (true) {
    // 找出当前未处理节点中距离起点最近的节点x
    let x = -1;
    for (let i = 0; i < n; i++) {
      if (!done[i] && (x < 0 || dist[i] < dist[x])) {
        x = i;
      }
    }

    // 所有节点都已处理，返回最大距离
    if (x == -1) return Math.max(...dist);
    // 存在不可达节点，返回-1
    if (dist[x] === Infinity) return -1;

    done[x] = true; // 标记节点x为已处理
    // 松弛操作：更新x的邻居节点的最短距离
    for (let y = 0; y < n; y++) {
      dist[y] = Math.min(dist[y], dist[x] + graph[x][y]);
    }
  }
};
```

**写法二：堆优化 Dijkstra**（适用于稀疏图）

> 稀疏图：边的数量远小于 n ^ 2 的图。

```js
/**
 * 计算网络信号从节点k传播到所有节点所需的最短时间
 * @param {number[][]} times - 网络连接信息数组，格式为[u, v, w]表示从u到v需要w时间
 * @param {number} n - 网络中的节点总数
 * @param {number} k - 信号起始节点
 * @return {number} - 返回信号传播到所有节点的最短时间，如果无法到达所有节点则返回-1
 */
var networkDelayTime = function (times, n, k) {
  // 初始化邻接表表示的图结构
  const graph = Array.from({ length: n }, () => []);

  // 构建图的邻接表表示
  for (let [u, v, w] of times) {
    graph[u - 1].push([v - 1, w]); // 节点编号转为0-based
  }

  // 初始化距离数组，所有节点初始距离为无穷大
  const dist = Array(n).fill(Infinity);
  // 创建最小优先队列，按距离排序
  const queue = new MinPriorityQueue((p) => p[1]);
  // 将起始节点加入队列，距离设为0
  queue.enqueue([k - 1, 0]);
  dist[k - 1] = 0;

  // Dijkstra算法主循环
  while (!queue.isEmpty()) {
    let [x, dx] = queue.dequeue();
    // 如果当前距离大于已知最短距离，跳过
    if (dx > dist[x]) {
      continue;
    }

    // 遍历当前节点的所有邻居
    for (let [y, w] of graph[x]) {
      let newDis = dx + w;
      // 如果找到更短的路径，更新距离并加入队列
      if (newDis < dist[y]) {
        dist[y] = newDis;
        queue.enqueue([y, dist[y]]);
      }
    }
  }

  // 找出所有节点中的最大距离
  let ans = Math.max(...dist);

  // 如果所有节点都可达则返回最大距离，否则返回-1
  return ans < Infinity ? ans : -1;
};
```
