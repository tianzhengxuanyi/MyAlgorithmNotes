### 拓扑排序

#### [定义](https://blog.csdn.net/lisonglisonglisong/article/details/45543451)
在图论中，拓扑排序（Topological Sorting）是一个有向无环图（DAG, Directed Acyclic Graph）的所有顶点的线性序列。且该序列必须满足下面两个条件：

- 每个顶点出现且只出现一次。
- 若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面。
有向无环图（DAG）才有拓扑排序，非DAG图没有拓扑排序一说。

#### [算法思路](https://leetcode.cn/problems/course-schedule-ii/solutions/249149/ke-cheng-biao-ii-by-leetcode-solution/)

**方法一：深度优先搜索**

对于图中的任意一个节点，它在搜索的过程中有三种状态，即：

- 「未搜索」：我们还没有搜索到这个节点；

- 「搜索中」：我们搜索过这个节点，但还没有回溯到该节点，即该节点还没有入栈，还有相邻的节点没有搜索完成）；

- 「已完成」：我们搜索过并且回溯过这个节点，即该节点已经入栈，并且所有该节点的相邻节点都出现在栈的更底部的位置，满足拓扑排序的要求。

通过上述的三种状态，我们就可以给出使用深度优先搜索得到拓扑排序的算法流程，在每一轮的搜索搜索开始时，我们任取一个「未搜索」的节点开始进行深度优先搜索。

- 我们将当前搜索的节点 u 标记为「搜索中」，遍历该节点的每一个相邻节点 v：

    - 如果 v 为「未搜索」，那么我们开始搜索 v，待搜索完成回溯到 u；

    - 如果 v 为「搜索中」，那么我们就找到了图中的一个环，因此是不存在拓扑排序的；

    - 如果 v 为「已完成」，那么说明 v 已经在栈中了，而 u 还不在栈中，因此 u 无论何时入栈都不会影响到 (u,v) 之前的拓扑关系，以及不用进行任何操作。

- 当 u 的所有相邻节点都为「已完成」时，我们将 u 放入栈中，并将其标记为「已完成」。

在整个深度优先搜索的过程结束后，如果我们没有找到图中的环，那么栈中存储这所有的 n 个节点，从栈顶到栈底的顺序即为一种拓扑排序。

**方法二：广度优先搜索**

我们使用一个队列来进行广度优先搜索。开始时，所有入度为 0 的节点都被放入队列中，它们就是可以作为拓扑排序最前面的节点，并且它们之间的相对顺序是无关紧要的。

在广度优先搜索的每一步中，我们取出队首的节点 u：

- 我们将 u 放入答案中；

- 我们移除 u 的所有出边，也就是将 u 的所有相邻节点的入度减少 1。如果某个相邻节点 v 的入度变为 0，那么我们就将 v 放入队列中。

在广度优先搜索的过程结束后。如果答案中包含了这 n 个节点，那么我们就找到了一种拓扑排序，否则说明图中存在环，也就不存在拓扑排序了。

#### [210. 课程表 II](https://leetcode.cn/problems/course-schedule-ii/description/)

现在你总共有 numCourses 门课需要选，记为 0 到 numCourses - 1。给你一个数组 prerequisites ，其中 prerequisites[i] = [ai, bi] ，表示在选修课程 ai 前 必须 先选修 bi 。

例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示：[0,1] 。
返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 任意一种 就可以了。如果不可能完成所有课程，返回 一个空数组 。

**DFS**

```js
/**
 * @param {number} numCourses
 * @param {number[][]} prerequisites
 * @return {number[]}
 */
var findOrder = function (numCourses, prerequisites) {
    // 构建邻接表图结构（课程依赖关系）
    const graph = Array.from({ length: numCourses }, () => []);
    for (let [x, y] of prerequisites) {
        graph[y].push(x); // y 是 x 的先修课程
    }

    // 访问状态数组：-1未访问，0访问中（用于检测环），1已访问
    const visited = Array(numCourses).fill(-1);
    const ans = Array(numCourses);  // 存储最终课程顺序
    let index = numCourses - 1;     // 从后往前填充结果

    const dfs = (i) => {
        visited[i] = 0; // 标记为正在访问
        for (let next of graph[i]) {
            if (visited[next] === -1) {
                if (dfs(next)) {    // 递归访问未访问节点
                    return true;    // 发现环立即返回
                }
            } else if (visited[next] === 0) {
                return true; // 遇到正在访问的节点（存在环）
            }
        }
        visited[i] = 1; // 标记为已完成访问
        ans[index--] = i; // 后序遍历位置记录课程（拓扑排序）
    };

    // 遍历所有课程，处理未连接的子图
    for (let i = 0; i < numCourses; i++) {
        if (visited[i] < 0 && dfs(i)) {
            return []; // 发现环返回空数组
        }
    }

    return ans; // 返回拓扑排序结果
};
```

**BFS**

```js
/**
 * @param {number} numCourses 课程总数
 * @param {number[][]} prerequisites 先修课程列表，格式为[[课程, 前置课程],...]
 * @return {number[]} 合法的学习顺序数组
 */
var findOrder = function(numCourses, prerequisites) {
  // 初始化入度数组（记录每个课程的先修课程数量）
  const degree = Array(numCourses).fill(0);
  // 构建邻接表（记录每个课程的后续课程）
  const graph = Array.from({length: numCourses}, () => []);
  
  // 构建图结构
  for (let [x, y] of prerequisites) {
      degree[x] += 1;       // 目标课程入度+1
      graph[y].push(x);     // 源课程添加后续课程
  }

  const ans = [];           // 结果数组
  const q = [];             // 处理队列
  
  // 初始化队列，添加入度为0的课程
  for (let i = 0; i < numCourses; i++) {
      if (degree[i] === 0) {
          q.push(i);
      }
  }

  // 拓扑排序处理
  while (q.length) {
      let current = q.pop();  // 取出当前课程
      ans.push(current);
      
      // 处理所有后续课程
      for (let next of graph[current]) {
          degree[next] -= 1;  // 减少后续课程的入度
          if (degree[next] === 0) {
              q.push(next);   // 当后续课程入度为0时加入队列
          }
      }
  }
  
  // 判断是否可以完成所有课程（是否存在环）
  return ans.length === numCourses ? ans : [];
};
```