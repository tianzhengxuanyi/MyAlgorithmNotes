### 最小生成树

#### 1. Kruskal(克鲁斯卡尔，加边法)算法 适用于稀疏图

```js
/**
 * 使用Kruskal算法计算连接所有点的最小成本
 * @param {number[][]} edges - 二维数组，每个元素表示[from, to, weight]
 * @return {number} - 返回连接所有点的最小成本
 */
var Kruskal = function (edges) {
    // 按权重从小到大排序所有边
    edges.sort((a, b) => a[2] - b[2]);
    const uf = new UnionFind(n); // 初始化并查集
    let minCost = 0;
    // Kruskal算法: 按顺序选择最小的边，如果不形成环则加入
    for (let [x, y, w] of edges) {
        if (uf.union(x, y)) { // 如果成功合并(不形成环)
            minCost += w; // 累加距离
            if (uf.cc === 1) { // 如果所有点都已连通
                break;
            }
        }
    }
    return minCost;
};

/**
 * 并查集(Union-Find)数据结构实现
 */
class UnionFind {
    constructor(n) {
        this.fa = Array(n).fill(0); // 父节点数组
        for (let i = 0; i < n; i++) {
            this.fa[i] = i; // 初始化每个节点的父节点为自己
        }
        this.size = Array(n).fill(1); // 每个集合的大小
        this.cc = n; // 连通分量计数(初始为n个独立集合)
    }

    // 查找x的根节点，带路径压缩
    find(x) {
        if (this.fa[x] !== x) {
            this.fa[x] = this.find(this.fa[x]); // 路径压缩
        }
        return this.fa[x];
    }

    // 判断x和y是否在同一个集合中
    isSame(x, y) {
        return this.fa[x] = this.fa[y];
    }

    // 合并x和y所在的集合
    union(x, y) {
        let fx = this.find(x);
        let fy = this.find(y);
        if (fx === fy) { // 已经在同一集合中
            return false;
        }
        // 按秩合并: 将小树合并到大树下
        if (this.size[fx] > this.size[fy]) {
            this.size[fx] += this.size[fy];
            this.fa[fy] = fx;
        } else {
            this.size[fy] += this.size[fx];
            this.fa[fx] = fy;
        }
        this.cc -= 1; // 连通分量减少
        return true;
    }

    // 获取x所在集合的大小
    getSize(x) {
        return this.size[x];
    }
}
```

#### 2. Prim(普里姆算法，加点法) 适用于稠密图

```js
/**
 * 使用Prim算法计算连接所有点的最小成本
 * @param {number[][]} graph - 二维数组，graph[x][y]表示x到y的边权
 * @return {number} 连接所有点的最小成本
 */
var Prim = function (graph) {
    const n = graph.length;
   
    // Prim算法初始化
    const visited = Array(n).fill(0);    // 已访问节点标记数组
    let cnt = n - 1;                    // 剩余需要连接的节点数
    const pq = new MinPriorityQueue((q) => q[2]); // 按边权排序的最小优先队列
    
    // 从第一个节点开始构建生成树
    for (let i = 1; i < n; i++) {
        pq.enqueue([0, i, graph[0][i]]); // 初始时连接节点0和其他所有节点
    }
    visited[0] = 1; // 标记起始节点已访问

    let ans = 0; // 总成本累加器
    while (!pq.isEmpty()) {
        if (cnt === 0) break; // 已连接所有节点时提前退出
        
        // 取出当前最短边
        let [x, y, w] = pq.dequeue();
        
        // 跳过已访问的目标节点
        if (visited[y] > 0) {
            continue;
        }

        // 处理新加入生成树的节点
        cnt--;
        ans += w;          // 累加路径成本
        visited[y] = 1;     // 标记节点已访问
        
        // 将新节点的未访问邻接边加入队列
        for (let i = 0; i < n; i++) {
            i !== y && pq.enqueue([y, i, graph[y][i]]);
        }
    }

    return ans;
};
```