### 1.2 前缀和与哈希表

#### [930. 和相同的二元子数组](https://leetcode.cn/problems/binary-subarrays-with-sum/description/)

给你一个二元数组 nums ，和一个整数 goal ，请你统计并返回有多少个和为 goal 的 非空 子数组。

子数组 是数组的一段连续部分。

##### 前缀和

```js
/**
 * 统计和为目标值的子数组数量（LeetCode 560题解）
 * @param {number[]} nums - 二进制数组（元素为0或1）
 * @param {number} goal - 目标和
 * @return {number} 满足条件的子数组数量
 * @note
 * 1. 使用前缀和配合哈希表实现O(n)时间复杂度
 * 2. 哈希表存储前缀和出现次数
 * 3. 核心公式：currentPrefix - previousPrefix = goal
 */
var numSubarraysWithSum = function(nums, goal) {
    let prefix = 0;
    // 哈希表记录前缀和出现次数（初始存在前缀和为0的情况）
    const cnt = new Map([[0, 1]]);
    let ans = 0;

    for (let i = 0; i < nums.length; i++) {
        prefix += nums[i];  // 计算当前前缀和
        // 查找符合 previousPrefix = currentPrefix - goal 的计数
        ans += cnt.get(prefix - goal) || 0;
        // 更新当前前缀和的计数
        cnt.set(prefix, (cnt.get(prefix) || 0) + 1);
    }
    return ans;
};

```

##### 滑动窗口

```js
/**
 * 计算二进制数组中满足指定和的子数组个数（滑动窗口解法）
 * @param {number[]} nums 二进制数组（仅含0/1元素）
 * @param {number} goal 目标子数组和
 * @return {number} 满足条件的子数组数量
 * 
 * 实现原理：
 * 1. 使用双滑动窗口维护两个区间[l1,r]和[l2,r]
 * 2. sum1维护严格大于goal的窗口左边界l1
 * 3. sum2维护大于等于goal的窗口左边界l2
 * 4. 每个右端点r的有效子数组数为 l2 - l1
 * 
 * 时间复杂度：O(n) 空间复杂度：O(1)
 */
var numSubarraysWithSum = function (nums, goal) {
    let sum1 = 0, sum2 = 0; // 维护两个滑动窗口的和
    let l1 = 0, l2 = 0;    // 两个窗口的左边界
    let ans = 0;
    
    for (let r = 0; r < nums.length; r++) {
        sum1 += nums[r];   // 累加当前元素到两个窗口
        sum2 += nums[r];
        
        // 收缩sum1窗口直到sum <= goal
        while (sum1 > goal && l1 <= r) {
            sum1 -= nums[l1++];
        }
        
        // 收缩sum2窗口直到sum < goal
        while (sum2 >= goal && l2 <= r) {
            sum2 -= nums[l2++];
        }
        
        // 有效子数组数为两个左边界之差
        ans += (l2 - l1);
    }
    return ans;
};

```