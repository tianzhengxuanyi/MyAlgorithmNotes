### 1.1 前缀和基础

#### [2438. 二的幂数组中查询范围内的乘积](https://leetcode.cn/problems/range-product-queries-of-powers/description/)

给你一个正整数 n ，你需要找到一个下标从 0 开始的数组 powers ，它包含 最少 数目的 2 的幂，且它们的和为 n 。powers 数组是 非递减 顺序的。根据前面描述，构造 powers 数组的方法是唯一的。

同时给你一个下标从 0 开始的二维整数数组 queries ，其中 queries[i] = [lefti, righti] ，其中 queries[i] 表示请你求出满足 lefti <= j <= righti 的所有 powers[j] 的乘积。

请你返回一个数组 answers ，长度与 queries 的长度相同，其中 answers[i]是第 i 个查询的答案。由于查询的结果可能非常大，请你将每个 answers[i] 都对 109 + 7 取余 。

**前缀和：（前缀乘积数组）**

枚举 n 的二进制表示中的 1，将所有的 1 对应的 2 的幂次方加入到 powers 数组中，并生成powers的前缀乘积数组。

```js
/**
 * 计算二的幂数组中查询范围内的乘积
 * @param {number} n - 目标正整数，需分解为最少个数的2的幂之和
 * @param {number[][]} queries - 查询数组，每个元素为[left, right]表示查询范围
 * @return {number[]} - 每个查询的结果数组，结果对10^9+7取余
 */
var productQueries = function(n, queries) {
    // 前缀乘积数组，prefix[0] = 1（乘法单位元），prefix[i]表示powers数组前i个元素的乘积
    const prefix = [1n];
    // 当前2的幂次值，初始为2^0 = 1
    let power = 1n;
    
    // 分解n的二进制表示，提取所有含1的位对应的2的幂次
    while (n) {
        // 若当前最低位为1（表示需要包含当前power）
        if (n & 1) {
            // 更新前缀乘积：当前前缀积 = 上一个前缀积 * 当前power，取模防止溢出
            prefix.push(prefix[prefix.length - 1] * power % mod);
        }
        // 右移n，处理下一个更高位
        n = n >> 1;
        // 更新当前power为下一个2的幂次（2^k -> 2^(k+1)）
        power = power * 2n;
    }

    const len = queries.length;
    const ans = Array(len);
    
    // 处理每个查询
    for (let i = 0; i < len; i++) {
        const [s, e] = queries[i];
        // 区间[s,e]的乘积 = 前缀积[e+1] / 前缀积[s]
        // 模运算中除法通过乘以逆元实现：a/b mod m = a * b^(m-2) mod m（费马小定理，m为质数）
        ans[i] = Number(prefix[e + 1] * qpow(prefix[s], mod - 2n) % mod);
    }

    return ans;
};

/**
 * 快速幂计算（ modular exponentiation）
 * 计算x^n mod mod，用于高效求模逆元
 * @param {bigint} x - 底数
 * @param {bigint} n - 指数
 * @return {bigint} - 计算结果 x^n mod mod
 */
const qpow = (x, n) => {
    let result = 1n; // 结果初始化为1（乘法单位元）
    while (n > 0n) {
        // 若当前指数最低位为1，乘入当前底数
        if (n & 1n) {
            result = result * x % mod;
        }
        // 指数右移一位（折半）
        n = n >> 1n;
        // 底数平方（指数折半后，底数需平方）
        x = x * x % mod;
    }
    return result;
};

// 模数值：10^9 + 7（质数，用于取余防止结果溢出）
const mod = BigInt(1e9 + 7);

```

**前缀和：计算幂的指数的前缀和，免去取模的操作**

```js
/**
 * 计算二的幂数组中查询范围内的乘积（基于指数前缀和优化）
 * @param {number} n - 目标正整数，需分解为最少个数的2的幂之和（即其二进制表示中1的位置）
 * @param {number[][]} queries - 查询数组，每个元素为[left, right]表示查询powers数组[left, right]区间的乘积
 * @return {number[]} - 每个查询的结果数组，结果对10^9+7取余
 */
var productQueries = function (n, queries) {
    // 前缀和数组：prefix[i]表示powers数组前i个元素的指数之和（powers数组元素为2^p，这里存储p的累加和）
    // prefix[0] = 0（累加和起始点），prefix[1] = p1，prefix[2] = p1+p2，依此类推
    const prefix = [0];
    // 当前2的幂次的指数（初始为2^0的指数0）
    let p = 0;
    
    // 分解n的二进制表示，提取所有含1的位对应的指数p
    while (n) {
        // 若当前最低位为1（表示n的二进制表示中包含2^p这个项）
        if (n & 1) {
            // 将当前指数p累加到前缀和数组中（prefix[i] = 前i-1个指数之和 + 当前p）
            prefix.push(prefix[prefix.length - 1] + p);
        }
        // 右移n，处理下一个更高位（相当于检查2^(p+1)是否存在于n的分解中）
        n = n >> 1;
        // 指数p递增（当前处理的2的幂次从2^p变为2^(p+1)）
        p++;
    }

    const len = queries.length;
    const ans = Array(len);
    
    // 处理每个查询，计算指定区间内的乘积
    for (let i = 0; i < len; i++) {
        const [s, e] = queries[i];
        // 区间[s,e]的指数之和 = prefix[e+1] - prefix[s]（前缀和的差）
        // 乘积 = 2^(指数之和) mod MOD，直接通过预计算的pow2数组获取结果
        ans[i] = pow2[prefix[e + 1] - prefix[s]];
    }

    return ans;
};

// 最大可能的指数之和：n最大为1e9，其二进制表示最多30位，每个查询最多包含所有位，30*30=900，这里435是安全值
let MAXP = 435;
// 取模常数：10^9+7（防止结果溢出，题目要求）
let MOD = 1e9 + 7;
// 预计算数组：pow2[i] = 2^i mod MOD，用于O(1)查询指数之和对应的乘积结果
const pow2 = Array(MAXP + 1);
pow2[0] = 1; // 2^0 = 1

// 预计算2^0到2^MAXP的结果，每个值都对MOD取余（避免重复计算指数，优化查询效率）
for (let i = 1; i <= MAXP; i++) {
    pow2[i] = pow2[i - 1] * 2 % MOD;
}

```

#### [3152. 特殊数组 II](https://leetcode.cn/problems/special-array-ii/description/)
 
如果数组的每一对相邻元素都是两个奇偶性不同的数字，则该数组被认为是一个 特殊数组 。

你有一个整数数组 nums 和一个二维整数矩阵 queries，对于 queries[i] = [fromi, toi]，请你帮助你检查 子数组 nums[fromi..toi] 是不是一个 特殊数组 。

返回布尔数组 answer，如果 nums[fromi..toi] 是特殊数组，则 answer[i] 为 true ，否则，answer[i] 为 false 。

**统计相邻元素奇偶性不同的数对前缀和**

```js
/**
 * 判断数组中多个区间是否满足相邻元素奇偶性不同的条件
 * @param {number[]} nums - 整数数组
 * @param {number[][]} queries - 查询数组，每个查询包含两个元素[l, r]表示区间范围
 * @return {boolean[]} 每个查询对应的结果，true表示区间内所有相邻元素奇偶性不同，false则相反
 * @note 该算法使用前缀和技术预处理数组，实现O(1)时间复杂度的区间查询
 * @algorithm 核心思路：
 *   1. 预处理前缀和数组，统计相邻元素奇偶性不同的数对前缀和
 *   2. 对于每个查询，通过前缀和差快速判断区间内是否所有相邻元素奇偶性不同
 * @complexity 时间复杂度O(n + q)，空间复杂度O(n)，其中n为数组长度，q为查询数量
 */
var isArraySpecial = function(nums, queries) {
    const n = nums.length;
    // 前缀和数组：prefix[i]表示前i-1个元素中，相邻元素奇偶性不同的数对数量
    const prefix = Array(n + 1).fill(0);
    
    // 构建前缀和数组
    for (let i = 1; i < n; i++) {
        // 判断当前元素与前一个元素的奇偶性是否不同
        if (nums[i] % 2 !== nums[i-1] % 2) {
            // 若不同，则当前前缀和 = 前一个前缀和 + 1
            prefix[i + 1] = prefix[i] + 1;
        } else {
            // 若相同，则前缀和保持不变
            prefix[i + 1] = prefix[i];
        }
    }
    
    // 存储查询结果
    const ans = Array(queries.length).fill(false);
    
    // 处理每个查询
    for (let i = 0; i < queries.length; i++) {
        const [l, r] = queries[i];
        
        // 区间内相邻元素的总对数 = r - l
        // 区间内奇偶性不同的相邻元素对数 = prefix[r+1] - prefix[l+1]
        // 若两者相等，则说明所有相邻元素奇偶性都不同
        if (prefix[r + 1] - prefix[l + 1] == r - l) {
            ans[i] = true;
        }
    }

    return ans;
};

```


**统计相邻元素奇偶性相同的次数前缀和**

```js
/**
 * 判断数组是否为特殊数组，即检查查询范围内所有相邻元素是否具有不同的奇偶性
 * @param {number[]} nums - 输入的整数数组
 * @param {number[][]} queries - 查询数组，每个查询包含两个元素[l, r]，表示数组的子区间
 * @return {boolean[]} - 每个查询对应的结果，true表示子区间内所有相邻元素奇偶性不同，false表示存在至少一对相邻元素奇偶性相同
 * @description 算法核心思想：
 * 1. 构建前缀和数组prefix，其中prefix[i]表示nums[0..i-1]中相邻元素奇偶性相同的次数
 * 2. 对于每个查询[l, r]，通过prefix[r] - prefix[l]是否为0来判断子区间是否满足条件
 * 3. 时间复杂度：O(n + q)，n为nums长度，q为查询次数
 * 4. 空间复杂度：O(n)，用于存储前缀和数组
 */
var isArraySpecial = function(nums, queries) {
    const n = nums.length;
    const preifx = Array(n + 1).fill(0);
    for (let i = 1; i < n; i++) {
        preifx[i] = preifx[i - 1] + (nums[i] % 2 == nums[i -1] % 2);
    }

    const ans = [];
    for (let [l, r] of queries) {
        ans.push(preifx[r] - preifx[l] == 0)
    }

    return ans;
};

```

#### [3652. 按策略买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-using-strategy/description/)
 
给你两个整数数组 prices 和 strategy，其中：

- prices[i] 表示第 i 天某股票的价格。
- strategy[i] 表示第 i 天的交易策略，其中：
  - -1 表示买入一单位股票。
  - 0 表示持有股票。
  - 1 表示卖出一单位股票。

同时给你一个 偶数 整数 k，你可以对 strategy 进行 最多一次 修改。一次修改包括：

- 选择 strategy 中恰好 k 个 连续 元素。
- 将前 k / 2 个元素设为 0（持有）。
- 将后 k / 2 个元素设为 1（卖出）。

利润 定义为所有天数中 strategy[i] * prices[i] 的 总和 。

返回你可以获得的 最大 可能利润。

注意： 没有预算或股票持有数量的限制，因此所有买入和卖出操作均可行，无需考虑过去的操作。

##### 前缀和

统计prices的前缀和sum，sum[i]表示prices[0..i-1]的和。

统计prices * strategy的前缀和prefix，prefix[i]表示0..i-1内prices * strategy的和。

枚举所有长度为k的子数组，计算修改后的利润分为三个部分（假设当前子数组的右端点为r）：


- 子数组的左边：prefix[r - k + 1]
- 子数组的右边：prefix[n] - prefix[r + 1]
- 子数组：sum[r+1] - sum[r - k / 2 + 1]

```js
/**
 * 使用前缀和技术计算特定交易策略下的最大利润
 * @param {number[]} prices - 价格数组，包含一段时间内的资产价格
 * @param {number[]} strategy - 策略数组，与价格数组长度相同，元素为0或1，表示是否执行特定操作
 * @param {number} k - 交易窗口参数，必须为偶数，控制交易周期长度
 * @returns {number} 计算得到的最大利润值
 * @description 该算法通过构建两个前缀和数组实现O(n)时间复杂度：
 *              1. sums数组存储prices的前缀和
 *              2. prefix数组存储prices与strategy乘积的前缀和
 *              核心逻辑是寻找最优的交易窗口，通过组合不同区间的前缀和来最大化利润
 * @note 算法假设k为偶数，若k为奇数可能导致计算错误
 * @warning 确保k值不大于prices数组长度，否则可能出现索引越界
 */
var maxProfit = function(prices, strategy, k) {
    const n = prices.length;
    // 构建价格前缀和数组，sums[i + 1]表示前i个价格的总和
    const sums = Array(n + 1).fill(0);
    // 构建策略前缀和数组，prefix[i + 1]表示前i个(价格×策略)的总和
    const prefix = Array(n + 1).fill(0);

    // 填充前缀和数组
    for (let i = 0; i < n; i++) {
        sums[i + 1] = sums[i] + prices[i];
        prefix[i + 1] = prefix[i] + prices[i] * strategy[i];
    }

    // 初始利润为不进行任何特殊交易窗口的情况
    let ans = prefix[n];
    // 遍历所有可能的交易窗口，寻找最大利润
    // 公式解析：prefix[n] - prefix[i + 1] 表示右侧策略收益
    // sums[i + 1] - sums[i - k/2 + 1] 表示中间窗口价格总和
    // prefix[i - (k - 1)] 表示左侧策略收益
    for (let i = k - 1; i < n; i++) {
        ans = Math.max(ans, prefix[n] - prefix[i + 1] + sums[i + 1] - sums[i - k / 
2 + 1] + prefix[i - (k - 1)]);
    }

    return ans;
};

```

