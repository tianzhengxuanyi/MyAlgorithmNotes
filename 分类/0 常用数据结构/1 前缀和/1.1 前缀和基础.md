### 1.1 前缀和基础

#### [2438. 二的幂数组中查询范围内的乘积](https://leetcode.cn/problems/range-product-queries-of-powers/description/)

给你一个正整数 n ，你需要找到一个下标从 0 开始的数组 powers ，它包含 最少 数目的 2 的幂，且它们的和为 n 。powers 数组是 非递减 顺序的。根据前面描述，构造 powers 数组的方法是唯一的。

同时给你一个下标从 0 开始的二维整数数组 queries ，其中 queries[i] = [lefti, righti] ，其中 queries[i] 表示请你求出满足 lefti <= j <= righti 的所有 powers[j] 的乘积。

请你返回一个数组 answers ，长度与 queries 的长度相同，其中 answers[i]是第 i 个查询的答案。由于查询的结果可能非常大，请你将每个 answers[i] 都对 109 + 7 取余 。

**前缀和：（前缀乘积数组）**

枚举 n 的二进制表示中的 1，将所有的 1 对应的 2 的幂次方加入到 powers 数组中，并生成powers的前缀乘积数组。

```js
/**
 * 计算二的幂数组中查询范围内的乘积
 * @param {number} n - 目标正整数，需分解为最少个数的2的幂之和
 * @param {number[][]} queries - 查询数组，每个元素为[left, right]表示查询范围
 * @return {number[]} - 每个查询的结果数组，结果对10^9+7取余
 */
var productQueries = function(n, queries) {
    // 前缀乘积数组，prefix[0] = 1（乘法单位元），prefix[i]表示powers数组前i个元素的乘积
    const prefix = [1n];
    // 当前2的幂次值，初始为2^0 = 1
    let power = 1n;
    
    // 分解n的二进制表示，提取所有含1的位对应的2的幂次
    while (n) {
        // 若当前最低位为1（表示需要包含当前power）
        if (n & 1) {
            // 更新前缀乘积：当前前缀积 = 上一个前缀积 * 当前power，取模防止溢出
            prefix.push(prefix[prefix.length - 1] * power % mod);
        }
        // 右移n，处理下一个更高位
        n = n >> 1;
        // 更新当前power为下一个2的幂次（2^k -> 2^(k+1)）
        power = power * 2n;
    }

    const len = queries.length;
    const ans = Array(len);
    
    // 处理每个查询
    for (let i = 0; i < len; i++) {
        const [s, e] = queries[i];
        // 区间[s,e]的乘积 = 前缀积[e+1] / 前缀积[s]
        // 模运算中除法通过乘以逆元实现：a/b mod m = a * b^(m-2) mod m（费马小定理，m为质数）
        ans[i] = Number(prefix[e + 1] * qpow(prefix[s], mod - 2n) % mod);
    }

    return ans;
};

/**
 * 快速幂计算（ modular exponentiation）
 * 计算x^n mod mod，用于高效求模逆元
 * @param {bigint} x - 底数
 * @param {bigint} n - 指数
 * @return {bigint} - 计算结果 x^n mod mod
 */
const qpow = (x, n) => {
    let result = 1n; // 结果初始化为1（乘法单位元）
    while (n > 0n) {
        // 若当前指数最低位为1，乘入当前底数
        if (n & 1n) {
            result = result * x % mod;
        }
        // 指数右移一位（折半）
        n = n >> 1n;
        // 底数平方（指数折半后，底数需平方）
        x = x * x % mod;
    }
    return result;
};

// 模数值：10^9 + 7（质数，用于取余防止结果溢出）
const mod = BigInt(1e9 + 7);

```

**前缀和：计算幂的指数的前缀和，免去取模的操作**

```js
/**
 * 计算二的幂数组中查询范围内的乘积（基于指数前缀和优化）
 * @param {number} n - 目标正整数，需分解为最少个数的2的幂之和（即其二进制表示中1的位置）
 * @param {number[][]} queries - 查询数组，每个元素为[left, right]表示查询powers数组[left, right]区间的乘积
 * @return {number[]} - 每个查询的结果数组，结果对10^9+7取余
 */
var productQueries = function (n, queries) {
    // 前缀和数组：prefix[i]表示powers数组前i个元素的指数之和（powers数组元素为2^p，这里存储p的累加和）
    // prefix[0] = 0（累加和起始点），prefix[1] = p1，prefix[2] = p1+p2，依此类推
    const prefix = [0];
    // 当前2的幂次的指数（初始为2^0的指数0）
    let p = 0;
    
    // 分解n的二进制表示，提取所有含1的位对应的指数p
    while (n) {
        // 若当前最低位为1（表示n的二进制表示中包含2^p这个项）
        if (n & 1) {
            // 将当前指数p累加到前缀和数组中（prefix[i] = 前i-1个指数之和 + 当前p）
            prefix.push(prefix[prefix.length - 1] + p);
        }
        // 右移n，处理下一个更高位（相当于检查2^(p+1)是否存在于n的分解中）
        n = n >> 1;
        // 指数p递增（当前处理的2的幂次从2^p变为2^(p+1)）
        p++;
    }

    const len = queries.length;
    const ans = Array(len);
    
    // 处理每个查询，计算指定区间内的乘积
    for (let i = 0; i < len; i++) {
        const [s, e] = queries[i];
        // 区间[s,e]的指数之和 = prefix[e+1] - prefix[s]（前缀和的差）
        // 乘积 = 2^(指数之和) mod MOD，直接通过预计算的pow2数组获取结果
        ans[i] = pow2[prefix[e + 1] - prefix[s]];
    }

    return ans;
};

// 最大可能的指数之和：n最大为1e9，其二进制表示最多30位，每个查询最多包含所有位，30*30=900，这里435是安全值
let MAXP = 435;
// 取模常数：10^9+7（防止结果溢出，题目要求）
let MOD = 1e9 + 7;
// 预计算数组：pow2[i] = 2^i mod MOD，用于O(1)查询指数之和对应的乘积结果
const pow2 = Array(MAXP + 1);
pow2[0] = 1; // 2^0 = 1

// 预计算2^0到2^MAXP的结果，每个值都对MOD取余（避免重复计算指数，优化查询效率）
for (let i = 1; i <= MAXP; i++) {
    pow2[i] = pow2[i - 1] * 2 % MOD;
}

```