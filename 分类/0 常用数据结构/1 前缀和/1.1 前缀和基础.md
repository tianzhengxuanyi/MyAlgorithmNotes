### 1.1 前缀和基础

#### [2438. 二的幂数组中查询范围内的乘积](https://leetcode.cn/problems/range-product-queries-of-powers/description/)

给你一个正整数 n ，你需要找到一个下标从 0 开始的数组 powers ，它包含 最少 数目的 2 的幂，且它们的和为 n 。powers 数组是 非递减 顺序的。根据前面描述，构造 powers 数组的方法是唯一的。

同时给你一个下标从 0 开始的二维整数数组 queries ，其中 queries[i] = [lefti, righti] ，其中 queries[i] 表示请你求出满足 lefti <= j <= righti 的所有 powers[j] 的乘积。

请你返回一个数组 answers ，长度与 queries 的长度相同，其中 answers[i]是第 i 个查询的答案。由于查询的结果可能非常大，请你将每个 answers[i] 都对 109 + 7 取余 。

**前缀和：（前缀乘积数组）**

枚举 n 的二进制表示中的 1，将所有的 1 对应的 2 的幂次方加入到 powers 数组中，并生成powers的前缀乘积数组。

```js
/**
 * 计算二的幂数组中查询范围内的乘积
 * @param {number} n - 目标正整数，需分解为最少个数的2的幂之和
 * @param {number[][]} queries - 查询数组，每个元素为[left, right]表示查询范围
 * @return {number[]} - 每个查询的结果数组，结果对10^9+7取余
 */
var productQueries = function(n, queries) {
    // 前缀乘积数组，prefix[0] = 1（乘法单位元），prefix[i]表示powers数组前i个元素的乘积
    const prefix = [1n];
    // 当前2的幂次值，初始为2^0 = 1
    let power = 1n;
    
    // 分解n的二进制表示，提取所有含1的位对应的2的幂次
    while (n) {
        // 若当前最低位为1（表示需要包含当前power）
        if (n & 1) {
            // 更新前缀乘积：当前前缀积 = 上一个前缀积 * 当前power，取模防止溢出
            prefix.push(prefix[prefix.length - 1] * power % mod);
        }
        // 右移n，处理下一个更高位
        n = n >> 1;
        // 更新当前power为下一个2的幂次（2^k -> 2^(k+1)）
        power = power * 2n;
    }

    const len = queries.length;
    const ans = Array(len);
    
    // 处理每个查询
    for (let i = 0; i < len; i++) {
        const [s, e] = queries[i];
        // 区间[s,e]的乘积 = 前缀积[e+1] / 前缀积[s]
        // 模运算中除法通过乘以逆元实现：a/b mod m = a * b^(m-2) mod m（费马小定理，m为质数）
        ans[i] = Number(prefix[e + 1] * qpow(prefix[s], mod - 2n) % mod);
    }

    return ans;
};

/**
 * 快速幂计算（ modular exponentiation）
 * 计算x^n mod mod，用于高效求模逆元
 * @param {bigint} x - 底数
 * @param {bigint} n - 指数
 * @return {bigint} - 计算结果 x^n mod mod
 */
const qpow = (x, n) => {
    let result = 1n; // 结果初始化为1（乘法单位元）
    while (n > 0n) {
        // 若当前指数最低位为1，乘入当前底数
        if (n & 1n) {
            result = result * x % mod;
        }
        // 指数右移一位（折半）
        n = n >> 1n;
        // 底数平方（指数折半后，底数需平方）
        x = x * x % mod;
    }
    return result;
};

// 模数值：10^9 + 7（质数，用于取余防止结果溢出）
const mod = BigInt(1e9 + 7);

```

**前缀和：计算幂的指数的前缀和，免去取模的操作**

```js
/**
 * 计算二的幂数组中查询范围内的乘积（基于指数前缀和优化）
 * @param {number} n - 目标正整数，需分解为最少个数的2的幂之和（即其二进制表示中1的位置）
 * @param {number[][]} queries - 查询数组，每个元素为[left, right]表示查询powers数组[left, right]区间的乘积
 * @return {number[]} - 每个查询的结果数组，结果对10^9+7取余
 */
var productQueries = function (n, queries) {
    // 前缀和数组：prefix[i]表示powers数组前i个元素的指数之和（powers数组元素为2^p，这里存储p的累加和）
    // prefix[0] = 0（累加和起始点），prefix[1] = p1，prefix[2] = p1+p2，依此类推
    const prefix = [0];
    // 当前2的幂次的指数（初始为2^0的指数0）
    let p = 0;
    
    // 分解n的二进制表示，提取所有含1的位对应的指数p
    while (n) {
        // 若当前最低位为1（表示n的二进制表示中包含2^p这个项）
        if (n & 1) {
            // 将当前指数p累加到前缀和数组中（prefix[i] = 前i-1个指数之和 + 当前p）
            prefix.push(prefix[prefix.length - 1] + p);
        }
        // 右移n，处理下一个更高位（相当于检查2^(p+1)是否存在于n的分解中）
        n = n >> 1;
        // 指数p递增（当前处理的2的幂次从2^p变为2^(p+1)）
        p++;
    }

    const len = queries.length;
    const ans = Array(len);
    
    // 处理每个查询，计算指定区间内的乘积
    for (let i = 0; i < len; i++) {
        const [s, e] = queries[i];
        // 区间[s,e]的指数之和 = prefix[e+1] - prefix[s]（前缀和的差）
        // 乘积 = 2^(指数之和) mod MOD，直接通过预计算的pow2数组获取结果
        ans[i] = pow2[prefix[e + 1] - prefix[s]];
    }

    return ans;
};

// 最大可能的指数之和：n最大为1e9，其二进制表示最多30位，每个查询最多包含所有位，30*30=900，这里435是安全值
let MAXP = 435;
// 取模常数：10^9+7（防止结果溢出，题目要求）
let MOD = 1e9 + 7;
// 预计算数组：pow2[i] = 2^i mod MOD，用于O(1)查询指数之和对应的乘积结果
const pow2 = Array(MAXP + 1);
pow2[0] = 1; // 2^0 = 1

// 预计算2^0到2^MAXP的结果，每个值都对MOD取余（避免重复计算指数，优化查询效率）
for (let i = 1; i <= MAXP; i++) {
    pow2[i] = pow2[i - 1] * 2 % MOD;
}

```

#### [3152. 特殊数组 II](https://leetcode.cn/problems/special-array-ii/description/)
 
如果数组的每一对相邻元素都是两个奇偶性不同的数字，则该数组被认为是一个 特殊数组 。

你有一个整数数组 nums 和一个二维整数矩阵 queries，对于 queries[i] = [fromi, toi]，请你帮助你检查 子数组 nums[fromi..toi] 是不是一个 特殊数组 。

返回布尔数组 answer，如果 nums[fromi..toi] 是特殊数组，则 answer[i] 为 true ，否则，answer[i] 为 false 。

**统计相邻元素奇偶性不同的数对前缀和**

```js
/**
 * 判断数组中多个区间是否满足相邻元素奇偶性不同的条件
 * @param {number[]} nums - 整数数组
 * @param {number[][]} queries - 查询数组，每个查询包含两个元素[l, r]表示区间范围
 * @return {boolean[]} 每个查询对应的结果，true表示区间内所有相邻元素奇偶性不同，false则相反
 * @note 该算法使用前缀和技术预处理数组，实现O(1)时间复杂度的区间查询
 * @algorithm 核心思路：
 *   1. 预处理前缀和数组，统计相邻元素奇偶性不同的数对前缀和
 *   2. 对于每个查询，通过前缀和差快速判断区间内是否所有相邻元素奇偶性不同
 * @complexity 时间复杂度O(n + q)，空间复杂度O(n)，其中n为数组长度，q为查询数量
 */
var isArraySpecial = function(nums, queries) {
    const n = nums.length;
    // 前缀和数组：prefix[i]表示前i-1个元素中，相邻元素奇偶性不同的数对数量
    const prefix = Array(n + 1).fill(0);
    
    // 构建前缀和数组
    for (let i = 1; i < n; i++) {
        // 判断当前元素与前一个元素的奇偶性是否不同
        if (nums[i] % 2 !== nums[i-1] % 2) {
            // 若不同，则当前前缀和 = 前一个前缀和 + 1
            prefix[i + 1] = prefix[i] + 1;
        } else {
            // 若相同，则前缀和保持不变
            prefix[i + 1] = prefix[i];
        }
    }
    
    // 存储查询结果
    const ans = Array(queries.length).fill(false);
    
    // 处理每个查询
    for (let i = 0; i < queries.length; i++) {
        const [l, r] = queries[i];
        
        // 区间内相邻元素的总对数 = r - l
        // 区间内奇偶性不同的相邻元素对数 = prefix[r+1] - prefix[l+1]
        // 若两者相等，则说明所有相邻元素奇偶性都不同
        if (prefix[r + 1] - prefix[l + 1] == r - l) {
            ans[i] = true;
        }
    }

    return ans;
};

```


**统计相邻元素奇偶性相同的次数前缀和**

```js
/**
 * 判断数组是否为特殊数组，即检查查询范围内所有相邻元素是否具有不同的奇偶性
 * @param {number[]} nums - 输入的整数数组
 * @param {number[][]} queries - 查询数组，每个查询包含两个元素[l, r]，表示数组的子区间
 * @return {boolean[]} - 每个查询对应的结果，true表示子区间内所有相邻元素奇偶性不同，false表示存在至少一对相邻元素奇偶性相同
 * @description 算法核心思想：
 * 1. 构建前缀和数组prefix，其中prefix[i]表示nums[0..i-1]中相邻元素奇偶性相同的次数
 * 2. 对于每个查询[l, r]，通过prefix[r] - prefix[l]是否为0来判断子区间是否满足条件
 * 3. 时间复杂度：O(n + q)，n为nums长度，q为查询次数
 * 4. 空间复杂度：O(n)，用于存储前缀和数组
 */
var isArraySpecial = function(nums, queries) {
    const n = nums.length;
    const preifx = Array(n + 1).fill(0);
    for (let i = 1; i < n; i++) {
        preifx[i] = preifx[i - 1] + (nums[i] % 2 == nums[i -1] % 2);
    }

    const ans = [];
    for (let [l, r] of queries) {
        ans.push(preifx[r] - preifx[l] == 0)
    }

    return ans;
};

```

#### [3652. 按策略买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-using-strategy/description/)
 
给你两个整数数组 prices 和 strategy，其中：

- prices[i] 表示第 i 天某股票的价格。
- strategy[i] 表示第 i 天的交易策略，其中：
  - -1 表示买入一单位股票。
  - 0 表示持有股票。
  - 1 表示卖出一单位股票。

同时给你一个 偶数 整数 k，你可以对 strategy 进行 最多一次 修改。一次修改包括：

- 选择 strategy 中恰好 k 个 连续 元素。
- 将前 k / 2 个元素设为 0（持有）。
- 将后 k / 2 个元素设为 1（卖出）。

利润 定义为所有天数中 strategy[i] * prices[i] 的 总和 。

返回你可以获得的 最大 可能利润。

注意： 没有预算或股票持有数量的限制，因此所有买入和卖出操作均可行，无需考虑过去的操作。

##### 前缀和

统计prices的前缀和sum，sum[i]表示prices[0..i-1]的和。

统计prices * strategy的前缀和prefix，prefix[i]表示0..i-1内prices * strategy的和。

枚举所有长度为k的子数组，计算修改后的利润分为三个部分（假设当前子数组的右端点为r）：


- 子数组的左边：prefix[r - k + 1]
- 子数组的右边：prefix[n] - prefix[r + 1]
- 子数组：sum[r+1] - sum[r - k / 2 + 1]

```js
/**
 * 使用前缀和技术计算特定交易策略下的最大利润
 * @param {number[]} prices - 价格数组，包含一段时间内的资产价格
 * @param {number[]} strategy - 策略数组，与价格数组长度相同，元素为0或1，表示是否执行特定操作
 * @param {number} k - 交易窗口参数，必须为偶数，控制交易周期长度
 * @returns {number} 计算得到的最大利润值
 * @description 该算法通过构建两个前缀和数组实现O(n)时间复杂度：
 *              1. sums数组存储prices的前缀和
 *              2. prefix数组存储prices与strategy乘积的前缀和
 *              核心逻辑是寻找最优的交易窗口，通过组合不同区间的前缀和来最大化利润
 * @note 算法假设k为偶数，若k为奇数可能导致计算错误
 * @warning 确保k值不大于prices数组长度，否则可能出现索引越界
 */
var maxProfit = function(prices, strategy, k) {
    const n = prices.length;
    // 构建价格前缀和数组，sums[i + 1]表示前i个价格的总和
    const sums = Array(n + 1).fill(0);
    // 构建策略前缀和数组，prefix[i + 1]表示前i个(价格×策略)的总和
    const prefix = Array(n + 1).fill(0);

    // 填充前缀和数组
    for (let i = 0; i < n; i++) {
        sums[i + 1] = sums[i] + prices[i];
        prefix[i + 1] = prefix[i] + prices[i] * strategy[i];
    }

    // 初始利润为不进行任何特殊交易窗口的情况
    let ans = prefix[n];
    // 遍历所有可能的交易窗口，寻找最大利润
    // 公式解析：prefix[n] - prefix[i + 1] 表示右侧策略收益
    // sums[i + 1] - sums[i - k/2 + 1] 表示中间窗口价格总和
    // prefix[i - (k - 1)] 表示左侧策略收益
    for (let i = k - 1; i < n; i++) {
        ans = Math.max(ans, prefix[n] - prefix[i + 1] + sums[i + 1] - sums[i - k / 
2 + 1] + prefix[i - (k - 1)]);
    }

    return ans;
};

```

#### [3361. 两个字符串的切换距离](https://leetcode.cn/problems/shift-distance-between-two-strings/description/)
 
给你两个长度相同的字符串 s 和 t ，以及两个整数数组 nextCost 和 previousCost 。

一次操作中，你可以选择 s 中的一个下标 i ，执行以下操作 之一 ：

- 将 s[i] 切换为字母表中的下一个字母，如果 s[i] == 'z' ，切换后得到 'a' 。操作的代价为 nextCost[j] ，其中 j 表示 s[i] 在字母表中的下标。
- 将 s[i] 切换为字母表中的上一个字母，如果 s[i] == 'a' ，切换后得到 'z' 。操作的代价为 previousCost[j] ，其中 j 是 s[i] 在字母表中的下标。

切换距离 指的是将字符串 s 变为字符串 t 的 最少 操作代价总和。

请你返回从 s 到 t 的 切换距离 。

```js
/**
 * 计算两个字符串字符间的最小移位成本
 * @param {string} s - 源字符串
 * @param {string} t - 目标字符串
 * @param {number[]} nextCost - 顺时针方向移位成本数组（长度26，对应a-z）
 * @param {number[]} previousCost - 逆时针方向移位成本数组（长度26，对应a-z）
 * @returns {number} 最小总移位成本
 * @note 
 * 1. 使用前缀和优化成本计算
 * 2. 对于每个字符对，计算顺时针和逆时针两种移位方式的最小成本
 * 3. 时间复杂度O(n)，空间复杂度O(1)
 */
var shiftDistance = function (s, t, nextCost, previousCost) {
    // 构建前缀和数组（索引1-26对应字符a-z）
    const nextPrefix = Array(27).fill(0), prevPrefix = Array(27).fill(0);
    for (let i = 0; i < 26; i++) {
        nextPrefix[i + 1] = nextPrefix[i] + nextCost[i];
        prevPrefix[i + 1] = previousCost[i] + prevPrefix[i];
    }

    let ans = 0;
    for (let i = 0; i < s.length; i++) {
        // 字符转换为0-25的索引
        let codeS = s[i].charCodeAt() - "a".charCodeAt();
        let codeT = t[i].charCodeAt() - "a".charCodeAt();

        let next, prev;
        // 根据字符顺序决定计算方式
        if (codeS <= codeT) {
            // 顺时针：codeS -> codeT 的成本差
            next = Math.abs(nextPrefix[codeT] - nextPrefix[codeS]);
            // 逆时针：向前移动的环形移位成本
            prev = Math.abs(prevPrefix[prevPrefix.length - 1] - (prevPrefix[codeT + 1] - prevPrefix[codeS + 1]));
        } else {
            // 顺时针：向后移动的环形移位成本
            next = Math.abs(nextPrefix[nextPrefix.length - 1] - (nextPrefix[codeS] - nextPrefix[codeT]));
            // 逆时针：codeS -> codeT 的直接成本
            prev = Math.abs(prevPrefix[codeS + 1] - prevPrefix[codeT + 1]);
        }
        ans += Math.min(next, prev);
    }
    return ans;
};

```

##### [2055. 蜡烛之间的盘子](https://leetcode.cn/problems/plates-between-candles/description/)
 
给你一个长桌子，桌子上盘子和蜡烛排成一列。给你一个下标从 0 开始的字符串 s ，它只包含字符 '*' 和 '|' ，其中 '*' 表示一个 盘子 ，'|' 表示一支 蜡烛 。

同时给你一个下标从 0 开始的二维整数数组 queries ，其中 queries[i] = [lefti, righti] 表示 子字符串 s[lefti...righti] （包含左右端点的字符）。对于每个查询，你需要找到 子字符串中 在 两支蜡烛之间 的盘子的 数目 。如果一个盘子在 子字符串中 左边和右边 都 至少有一支蜡烛，那么这个盘子满足在 两支蜡烛之间 。

- 比方说，s = "||**||**|*" ，查询 [3, 8] ，表示的是子字符串 "*||**|" 。子字符串中在两支蜡烛之间的盘子数目为 2 ，子字符串中右边两个盘子在它们左边和右边 都 至少有一支蜡烛。

请你返回一个整数数组 answer ，其中 answer[i] 是第 i 个查询的答案。

**前缀和：**

预处理每个位置左侧和右侧最近的蜡烛位置，对于每个query，获得left和right内最外侧的蜡烛位置，使用前缀和计算这两个蜡烛之间的盘子数量。

```js
/**
 * 计算蜡烛间盘子数量（LeetCode 2055题解）
 * @param {string} s - 包含'*'(盘子)和'|'(蜡烛)的字符串
 * @param {number[][]} queries - 查询数组，每个元素为[left, right]区间
 * @returns {number[]} 每个查询对应的有效盘子数量
 * @note
 * 1. 使用前缀和预处理盘子数量
 * 2. 双指针数组预处理左右最近的蜡烛位置
 * 3. 时间复杂度O(n + m)，空间复杂度O(n)
 */
var platesBetweenCandles = function(s, queries) {
    const n = s.length;
    // 前缀和数组（索引1-based）
    const prefix = Array(n + 1).fill(0);
    // 左右最近蜡烛指针数组
    const left = Array(n).fill(0), right = Array(n).fill(n - 1);

    // 预处理左指针和前缀和
    for (let i = 0; i < n; i++) {
        if (s[i] === "*") {
            prefix[i+1] = prefix[i] + 1;
            left[i] = (i > 0) ? left[i-1] : 0;
        } else {
            prefix[i+1] = prefix[i];
            left[i] = i; // 记录当前位置为最近左蜡烛
        }
    }

    // 预处理右指针（从右向左扫描）
    for (let i = n - 2; i >= 0; i--) {
        right[i] = (s[i] == "*") ? right[i+1] : i;
    }

    const ans = Array(queries.length);
    for (let i = 0; i < queries.length; i++) {
        // 获取有效区间边界
        const l = right[queries[i][0]];   // 区间左端最近的右蜡烛
        const r = left[queries[i][1]];    // 区间右端最近的左蜡烛
        ans[i] = (l > r) ? 0 : prefix[r + 1] - prefix[l + 1];
    }
    return ans;
};

```

#### [1744. 你能在你最喜欢的那天吃到你最喜欢的糖果吗？](https://leetcode.cn/problems/can-you-eat-your-favorite-candy-on-your-favorite-day/description/)
 
给你一个下标从 0 开始的正整数数组 candiesCount ，其中 candiesCount[i] 表示你拥有的第 i 类糖果的数目。同时给你一个二维数组 queries ，其中 queries[i] = [favoriteTypei, favoriteDayi, dailyCapi] 。

你按照如下规则进行一场游戏：

- 你从第 0 天开始吃糖果。
- 你在吃完 所有 第 i - 1 类糖果之前，不能 吃任何一颗第 i 类糖果。
- 在吃完所有糖果之前，你必须每天 至少 吃 一颗 糖果。

请你构建一个布尔型数组 answer ，用以给出 queries 中每一项的对应答案。此数组满足：

- answer.length == queries.length 。answer[i] 是 queries[i] 的答案。
- answer[i] 为 true 的条件是：在每天吃 不超过 dailyCapi 颗糖果的前提下，你可以在第 favoriteDayi 天吃到 favoriteTypei 类糖果；否则 answer[i] 为 false 。

注意，只要满足上面 3 条规则中的第二条规则，你就可以在同一天吃不同类型的糖果。

请你返回得到的数组 answer 。

**前缀和：**

从第0天到第favoriteDay_i天总共可以吃的糖果数量为：[favoriteDay_i + 1, (favoriteDay_i + 1) * dailyCap_i]。

计算前缀和数组prefix，prefix[i + 1]表示从0-i种类的糖果总数量。

现在要想在第favoriteDay_i天吃到favoriteType_i类糖果，必须满足：
- prefix[favoriteType_i] < (favoriteDay_i + 1) * dailyCap_i, 0-i-1类糖果的总数量必须小于(favoriteDay_i + 1) * dailyCap_i
- prefix[favoriteDay_i + 1] >= favoriteDay_i + 1, 0-i类糖果的总数量必须大于等于favoriteDay_i + 1

```js
/**
 * 判断能否在指定条件下吃到特定类型糖果（LeetCode 1744题解）
 * @param {number[]} candiesCount - 糖果类型数量数组，索引代表类型
 * @param {number[][]} queries - 查询数组，格式为[[type, day, cap],...]
 * @returns {boolean[]} 每个查询的可行性结果
 * @note
 * 1. 使用前缀和快速计算糖果累积量
 * 2. 满足条件需同时满足：
 *    - 每天至少吃1颗：总需求 >= day+1
 *    - 容量限制下能吃够：cap*(day+1) > 前置糖果总数
 * 3. 时间复杂度O(n+m)，空间复杂度O(n)
 */
var canEat = function (candiesCount, queries) {
    // 构建前缀和数组（1-based索引）
    const n = candiesCount.length;
    const prefix = Array(n + 1).fill(0);
    for (let i = 0; i < n; i++) {
        prefix[i + 1] = prefix[i] + candiesCount[i];
    }

    const len = queries.length;
    const ans = Array(len).fill(false);
    for (let i = 0; i < len; i++) {
        let [type, day, cap] = queries[i];
        // 获取当前类型糖果的前缀和范围
        const totalNeeded = day + 1;     // 最少需要totalNeeded颗
        const maxPossible = cap * totalNeeded; // 容量限制下最大可获得量
        
        // 检查是否满足两个条件
        if (prefix[type + 1] >= totalNeeded && maxPossible > prefix[type]) {
            ans[i] = true;
        }
    }
    return ans;
};

```


