### 进阶

#### [1948. 删除系统中的重复文件夹](https://leetcode.cn/problems/delete-duplicate-folders-in-system/description/)
 
由于一个漏洞，文件系统中存在许多重复文件夹。给你一个二维数组 paths，其中 paths[i] 是一个表示文件系统中第 i 个文件夹的绝对路径的数组。

- 例如，["one", "two", "three"] 表示路径 "/one/two/three" 。

如果两个文件夹（不需要在同一层级）包含 非空且相同的 子文件夹 集合 并具有相同的子文件夹结构，则认为这两个文件夹是相同文件夹。相同文件夹的根层级 不 需要相同。如果存在两个（或两个以上）相同 文件夹，则需要将这些文件夹和所有它们的子文件夹 标记 为待删除。

- 例如，下面文件结构中的文件夹 "/a" 和 "/b" 相同。它们（以及它们的子文件夹）应该被 全部 标记为待删除：
    - /a
    - /a/x
    - /a/x/y
    - /a/z
    - /b
    - /b/x
    - /b/x/y
    - /b/z

- 然而，如果文件结构中还包含路径 "/b/w" ，那么文件夹 "/a" 和 "/b" 就不相同。注意，即便添加了新的文件夹 "/b/w" ，仍然认为 "/a/x" 和 "/b/x" 相同。

一旦所有的相同文件夹和它们的子文件夹都被标记为待删除，文件系统将会 删除 所有上述文件夹。文件系统只会执行一次删除操作。执行完这一次删除操作后，不会删除新出现的相同文件夹。

返回二维数组 ans ，该数组包含删除所有标记文件夹之后剩余文件夹的路径。路径可以按 任意顺序 返回。

```js
/**
 * @param {string[][]} paths - 二维数组，每个子数组表示文件系统中一个文件夹的绝对路径
 * @return {string[][]} - 删除所有重复文件夹后剩余文件夹的路径
 */
var deleteDuplicateFolder = function (paths) {
    // 创建字典树的根节点
    const head = new TrieNode();

    // 遍历所有路径，将其插入到字典树中
    for (let path of paths) {
        // 从根节点开始
        let curr = head;
        // 遍历路径中的每个文件夹名
        for (let s of path) {
            // 如果当前节点的子节点中不包含该文件夹名
            if (!curr.nexts.has(s)) {
                // 创建一个新的节点并添加到子节点中
                curr.nexts.set(s, new TrieNode());
            }
            // 移动到下一个节点
            curr = curr.nexts.get(s);
            // 设置当前节点的名称
            curr.name = s;
        }
    }

    // 用于存储序列化表达式到节点的映射
    const exprToNode = new Map();
    // 遍历根节点的所有子节点，生成序列化表达式
    for (let node of head.nexts.values()) {
        genExpr(node, exprToNode);
    }
    // 存储最终结果的数组
    const ans = [];
    // 用于存储当前路径的数组
    const path = [];

    // 遍历根节点的所有子节点，进行深度优先搜索
    for (let node of head.nexts.values()) {
        dfs(node, path, ans);
    }

    return ans;
};

/**
 * 字典树节点类
 */
class TrieNode {
    constructor() {
        // 节点名称
        this.name = '';
        // 存储子节点的映射，键为文件夹名，值为对应的节点
        this.nexts = new Map();
        // 标记该节点是否需要删除
        this.deleted = false;
    }
}

/**
 * 生成节点的序列化表达式，并标记重复节点
 * @param {TrieNode} node - 当前节点
 * @param {Map} exprToNode - 序列化表达式到节点的映射
 * @return {string} - 当前节点的序列化表达式
 */
function genExpr(node, exprToNode) {
    // 如果当前节点没有子节点，直接返回节点名称
    if (node.nexts.size === 0) return node.name;

    // 存储子节点序列化表达式的数组
    const paths = [];
    // 遍历当前节点的所有子节点
    for (let next of node.nexts.values()) {
        // 递归生成子节点的序列化表达式，并添加括号
        paths.push(`(${genExpr(next, exprToNode)})`);
    }
    // 对子节点的序列化表达式进行排序
    paths.sort();
    // 将排序后的序列化表达式拼接成字符串
    let serializationPaths = paths.join("");
    // 如果该序列化表达式已经存在于映射中
    if (exprToNode.has(serializationPaths)) {
        // 标记当前节点和之前的节点为需要删除
        node.deleted = true;
        exprToNode.get(serializationPaths).deleted = true;
    } else {
        // 将该序列化表达式和当前节点存入映射中
        exprToNode.set(serializationPaths, node);
    }

    // 返回当前节点的名称和子节点序列化表达式拼接后的字符串
    return node.name + serializationPaths;
}

/**
 * 深度优先搜索，收集未被删除的节点路径
 * @param {TrieNode} node - 当前节点
 * @param {string[]} path - 当前路径
 * @param {string[][]} ans - 存储最终结果的数组
 */
function dfs(node, path, ans) {
    // 如果当前节点被标记为删除，直接返回
    if (node.deleted) return;
    // 将当前节点的名称添加到路径中
    path.push(node.name);
    // 将当前路径添加到结果数组中
    ans.push([...path]);
    // 遍历当前节点的所有子节点
    for (let next of node.nexts.values()) {
        // 递归进行深度优先搜索
        dfs(next, path, ans);
    }
    // 回溯，移除当前节点的名称
    path.pop();
}

```