### 6.1 基础

#### [208. 实现 Trie (前缀树)](https://leetcode.cn/problems/implement-trie-prefix-tree/description/)

Trie（发音类似 "try"）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补全和拼写检查。

请你实现 Trie 类：

- Trie() 初始化前缀树对象。
- void insert(String word) 向前缀树中插入字符串 word 。
- boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。
- boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。
 

```js

/**
 * 定义 Trie 类，用于实现前缀树数据结构。
 */
var Trie = function () {
    // 初始化前缀树的根节点
    this.head = new TrieNode();
};

/**
 * 定义 TrieNode 类，代表前缀树的节点。
 */
var TrieNode = function () {
    // 标记该节点是否为一个单词的结尾
    this.end = false;
    // 存储 26 个小写英文字母对应的子节点，初始化为空数组
    this.next = Array(26);
}

/** 
 * 向前缀树中插入字符串 word。
 * @param {string} word - 要插入的字符串。
 * @return {void}
 */
Trie.prototype.insert = function (word) {
    // 从根节点开始遍历
    let node = this.head;

    // 遍历字符串中的每个字符
    for (let w of word) {
        // 计算字符对应的索引（a 对应 0，b 对应 1，以此类推）
        let code = w.charCodeAt() - 97;
        // 如果该字符对应的子节点不存在，则创建一个新的 TrieNode
        if (!node.next[code]) {
            node.next[code] = new TrieNode();
        }
        // 移动到下一个节点
        node = node.next[code];
    }
    // 标记该节点为一个单词的结尾
    node.end = true;
};

/** 
 * 在前缀树中查找字符串 word。
 * @param {string} word - 要查找的字符串。
 * @return {number} - 返回 0 表示未找到，1 表示找到前缀，2 表示找到完整单词。
 */
Trie.prototype.find = function (word) {
    // 从根节点开始遍历
    let node = this.head;
    // 遍历字符串中的每个字符
    for (let w of word) {
        // 计算字符对应的索引（a 对应 0，b 对应 1，以此类推）
        let code = w.charCodeAt() - 97;
        // 如果该字符对应的子节点不存在，说明未找到，返回 0
        if (!node.next[code]) {
            return 0;
        }
        // 移动到下一个节点
        node = node.next[code];
    }

    // 如果该节点是一个单词的结尾，返回 2；否则返回 1
    return node.end ? 2 : 1;
};

/** 
 * 检查字符串 word 是否在前缀树中。
 * @param {string} word - 要检查的字符串。
 * @return {boolean} - 如果存在返回 true，否则返回 false。
 */
Trie.prototype.search = function (word) {
    // 调用 find 方法，只有找到完整单词时返回 true
    return this.find(word) === 2;
};

/** 
 * 检查是否存在以 prefix 为前缀的字符串。
 * @param {string} prefix - 要检查的前缀。
 * @return {boolean} - 如果存在返回 true，否则返回 false。
 */
Trie.prototype.startsWith = function (prefix) {
    // 调用 find 方法，只要找到前缀或完整单词就返回 true
    return this.find(prefix) > 0;
};


/** 
 * Your Trie object will be instantiated and called as such:
 * var obj = new Trie()
 * obj.insert(word)
 * var param_2 = obj.search(word)
 * var param_3 = obj.startsWith(prefix)
 */
```

#### [1233. 删除子文件夹](https://leetcode.cn/problems/remove-sub-folders-from-the-filesystem/description/)

你是一位系统管理员，手里有一份文件夹列表 folder，你的任务是要删除该列表中的所有 子文件夹，并以 任意顺序 返回剩下的文件夹。

如果文件夹 folder[i] 位于另一个文件夹 folder[j] 下，那么 folder[i] 就是 folder[j] 的 子文件夹 。folder[j] 的子文件夹必须以 folder[j] 开头，后跟一个 "/"。例如，"/a/b" 是 "/a" 的一个子文件夹，但 "/b" 不是 "/a/b/c" 的一个子文件夹。

文件夹的「路径」是由一个或多个按以下格式串联形成的字符串：'/' 后跟一个或者多个小写英文字母。

例如，"/leetcode" 和 "/leetcode/problems" 都是有效的路径，而空字符串和 "/" 不是。

**字典树：**
```js
/**
 * 从文件夹列表中删除所有子文件夹，并返回剩余的文件夹列表。
 * @param {string[]} folder - 包含文件夹路径的字符串数组。
 * @return {string[]} - 删除子文件夹后剩余的文件夹路径数组。
 */
var removeSubfolders = function(folder) {
    // 初始化前缀树的根节点
    const head = new TrieNode();
    // 遍历文件夹列表，将每个文件夹路径插入到前缀树中
    for (let path of folder) {
        // 从根节点开始遍历
        let curr = head;
        // 将路径按 '/' 分割成多个部分，并遍历每一部分
        for (let s of path.split("/")) {
            // 如果当前部分为空字符串，跳过
            if (s === '') continue;
            // 如果当前节点的子节点中不包含当前部分
            if (!curr.nexts.has(s)) {
                // 创建一个新的 TrieNode 作为当前部分的子节点
                curr.nexts.set(s, new TrieNode());
            }
            // 移动到当前部分对应的子节点
            curr = curr.nexts.get(s);
            // 记录当前节点对应的文件夹名称
            curr.name = s;
        }
        // 标记该节点为一个完整文件夹路径的结尾
        curr.end = true;
    }

    // 用于存储最终结果的数组
    const ans = [];
    // 用于构建文件夹路径的数组，初始包含一个空字符串
    const path = [''];
    
    // 遍历根节点的所有子节点
    for (let node of head.nexts.values()) {
        // 对每个子节点进行深度优先搜索
        dfs(node, ans, path)
    }

    // 返回最终结果数组
    return ans;
};

/**
 * 定义 TrieNode 类，代表前缀树的节点。
 */
class TrieNode {
    constructor() {
        // 使用 Map 存储子节点，键为文件夹名称，值为对应的 TrieNode
        this.nexts = new Map();
        // 标记该节点是否为一个完整文件夹路径的结尾
        this.end = false;
        // 记录当前节点对应的文件夹名称
        this.name = '';
    }
}

/**
 * 深度优先搜索函数，用于遍历前缀树并收集非子文件夹的路径。
 * @param {TrieNode} node - 当前遍历到的节点。
 * @param {string[]} ans - 用于存储最终结果的数组。
 * @param {string[]} path - 用于构建文件夹路径的数组。
 */
const dfs = (node, ans, path) => {
    // 将当前节点的文件夹名称添加到路径数组中
    path.push(node.name);
    // 如果当前节点是一个完整文件夹路径的结尾
    if (node.end) {
        // 将当前路径数组用 '/' 连接成字符串，并添加到结果数组中
        ans.push(path.join('/'))
    } else {
        // 否则，继续遍历当前节点的所有子节点
        for (let next of node.nexts.values()) {
            dfs(next, ans, path);
        }
    }
    // 回溯，移除当前节点的文件夹名称
    path.pop();
}

```

**排序：**

```js
/**
 * 从文件夹列表中删除所有子文件夹，并返回剩余的文件夹列表。
 * @param {string[]} folder - 包含文件夹路径的字符串数组。
 * @return {string[]} - 删除子文件夹后剩余的文件夹路径数组。
 */
var removeSubfolders = function(folder) {
    // 对文件夹列表按字典序进行排序
    folder.sort();
    // 初始化结果数组，将排序后的第一个文件夹路径添加进去
    const ans = [folder[0]];

    // 从第二个文件夹开始遍历排序后的文件夹列表
    for (let i = 1; i < folder.length; i++) {
        // 获取结果数组中最后一个文件夹路径
        let pre = ans[ans.length - 1];
        // 检查当前文件夹是否为结果数组中最后一个文件夹的子文件夹
        // 若不是子文件夹，则需要满足以下条件之一：
        // 1. 当前文件夹长度不大于前一个文件夹长度
        // 2. 当前文件夹的前部分与前一个文件夹不相同
        // 3. 当前文件夹在前一个文件夹长度位置的字符不是 '/'
        if (!(folder[i].length > pre.length && folder[i].slice(0, pre.length) == pre && folder[i][pre.length] === '/')) {
            // 若不是子文件夹，将其添加到结果数组中
            ans.push(folder[i]);
        }
    }

    // 返回删除子文件夹后的结果数组
    return ans;
};

```