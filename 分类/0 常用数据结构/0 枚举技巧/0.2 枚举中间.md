### 枚举中间

#### [3067. 在带权树网络中统计可连接服务器对数目](https://leetcode.cn/problems/count-pairs-of-connectable-servers-in-a-weighted-tree-network/description/)

给你一棵无根带权树，树中总共有 n 个节点，分别表示 n 个服务器，服务器从 0 到 n - 1 编号。同时给你一个数组 edges ，其中 edges[i] = [ai, bi, weighti] 表示节点 ai 和 bi 之间有一条双向边，边的权值为 weighti 。再给你一个整数 signalSpeed 。

如果两台服务器 a 和 b 是通过服务器 c 可连接的，则：

- a < b ，a != c 且 b != c 。
- 从 c 到 a 的距离是可以被 signalSpeed 整除的。
- 从 c 到 b 的距离是可以被 signalSpeed 整除的。
- 从 c 到 b 的路径与从 c 到 a 的路径没有任何公共边。

请你返回一个长度为 n 的整数数组 count ，其中 count[i] 表示通过服务器 i 可连接 的服务器对的 数目 。

**思路**

dfs 定义为计算以 i 为根的子树中，i 到节点 j 的距离可以被 signalSpeed 整除的节点 j 的个数。

count[i] 为 i 的后续节点的 dfs 结果两两相乘。

```js
/**
 * 计算每个服务器节点可连接的服务器对数量
 * 问题背景：在网络拓扑中，判断通过当前服务器节点能够相互通信的服务器对数量
 * 通信条件：两个服务器之间的路径经过当前节点，且路径上的信号传输距离是信号速度的整数倍
 * @param {number[][]} edges - 网络拓扑的边列表，每个元素为[x, y, w]表示节点x和y之间有一条权重为w的双向边
 * @param {number} signalSpeed - 信号传输速度，用于判断路径是否有效
 * @return {number[]} 结果数组，索引i处的值表示节点i可连接的服务器对数量
 * @complexity 时间复杂度：O(n^2)，其中n为服务器节点数量，每个节点可能需要遍历整个图
 * @note 该算法使用深度优先搜索(DFS)结合枚举中间节点的策略来统计有效连接对
 */
var countPairsOfConnectableServers = function (edges, signalSpeed) {
  const n = edges.length + 1; // 计算服务器节点总数（边数+1）
  const graph = Array.from({ length: n }, () => []);

  // 构建邻接表表示的图结构
  for (let [x, y, w] of edges) {
    graph[x].push([y, w]), graph[y].push([x, w]);
  }

  /**
   * 深度优先搜索计算子树中可连接的服务器数量
   * @param {number} i - 当前遍历的节点
   * @param {number} fa - 父节点，用于避免回环
   * @param {number} d - 从起始节点到当前节点的距离
   * @return {number} 以i为根的子树中可连接的服务器数量
   */
  const dfs = (i, fa, d) => {
    let r = 0; // 记录可连接的服务器数量
    for (let [nx, w] of graph[i]) {
      if (nx == fa) continue; // 跳过父节点，避免重复访问
      let currD = d + w; // 累计距离
      // 如果当前距离是信号速度的整数倍，则该节点是可连接的
      if (currD % signalSpeed === 0) r++;
      // 递归搜索子节点，并累加结果
      r += dfs(nx, i, currD);
    }
    return r;
  };

  const ans = Array(n).fill(0); // 结果数组初始化
  for (let i = 0; i < n; i++) {
    if (graph[i].length == 0) continue; // 跳过孤立节点
    let sum = 0; // 累计已处理子树的可连接服务器数量
    for (let [nx, w] of graph[i]) {
      // 计算当前子树中可连接的服务器数量
      // 注意：需要加上当前边本身是否满足距离条件
      let r = dfs(nx, i, w) + (w % signalSpeed == 0 ? 1 : 0);
      // 核心公式：当前子树的可连接数量 * 之前所有子树的可连接数量总和
      // 这是因为当前子树中的每个节点都能与之前子树中的每个节点形成新的连接对
      ans[i] += sum * r;
      sum += r; // 更新累计和
    }
  }
  return ans;
};
```

#### [1534. 统计好三元组](https://leetcode.cn/problems/count-good-triplets/description/)

给你一个整数数组 arr ，以及 a、b 、c 三个整数。请你统计其中好三元组的数量。

如果三元组 (arr[i], arr[j], arr[k]) 满足下列全部条件，则认为它是一个 好三元组 。

- 0 <= i < j < k < arr.length
- |arr[i] - arr[j]| <= a
- |arr[j] - arr[k]| <= b
- |arr[i] - arr[k]| <= c

其中 |x| 表示 x 的绝对值。

返回 好三元组的数量 。

##### 暴力

```js
/**
 * @param {number[]} arr
 * @param {number} a
 * @param {number} b
 * @param {number} c
 * @return {number}
 */
var countGoodTriplets = function (arr, a, b, c) {
  const n = arr.length;

  let ans = 0;
  // 枚举三元组的第一个元素
  for (let i = 0; i < n - 2; i++) {
    // 枚举三元组的第二个元素
    for (let j = i + 1; j < n - 1; j++) {
      if (Math.abs(arr[i] - arr[j]) <= a) {
        // 枚举三元组的第三个元素
        for (let k = j + 1; k < n; k++) {
          if (
            Math.abs(arr[j] - arr[k]) <= b &&
            Math.abs(arr[i] - arr[k]) <= c
          ) {
            ans++;
          }
        }
      }
    }
  }

  return ans;
};
```

##### 枚举中间元素 + 前缀

枚举中间元素 j , 然后枚举右元素 k , 根据 aj 和 ak 可以得出 ai 的范围为：

- aj - a <= ai <= aj + a
- ak - c <= ai <= ak + c

得出：

- max(aj - a, ak - c, 0) <= ai <= min(aj + a, ak + c, MX), MX 为数组最大值

现在要求出 0 - j 中 ai 的数量，可以统计 0 - j 中出现数组的数量的前缀和，用前缀和计算 ai 的数量。

每次枚举完 j 后，更新 aj + 1 - MX 的前缀和

```js
/**
 * 功能：计算数组中满足条件的三元组(i,j,k)数量，其中i<j<k且|arr[i]-arr[j]|<=a、|arr[j]-arr[k]|<=b、|arr[i]-arr[k]|<=c
 * 参数：
 *   arr - {number[]} 输入的整数数组
 *   a - {number} 第一个条件的阈值
 *   b - {number} 第二个条件的阈值
 *   c - {number} 第三个条件的阈值
 * 返回值：{number} 满足条件的三元组数量
 * 算法核心思想：枚举中间元素j，利用前缀和优化计数满足条件的(i,k)对
 * 时间复杂度：O(n²)，其中n为数组长度，通过前缀和将三重循环优化为二重循环
 * 空间复杂度：O(M)，其中M为数组中的最大值，用于存储前缀和数组
 */
var countGoodTriplets = function (arr, a, b, c) {
  const n = arr.length,
    MX = Math.max(...arr); // MX为数组中的最大值，用于确定前缀和数组大小
  const prefix = Array(MX + 2).fill(0); // 前缀和数组，用于快速统计范围内元素数量
  let ans = 0; // 结果计数器，记录符合条件的三元组数量

  // 枚举中间元素j，作为三元组的中间元素
  for (let j = 0; j < n - 1; j++) {
    // 当j不是第一个元素时，处理右侧元素k并统计符合条件的i
    if (j > 0) {
      // 遍历j右侧的元素k
      for (let k = j + 1; k < n; k++) {
        // 检查j和k是否满足条件|arr[j]-arr[k]| <= b
        if (Math.abs(arr[j] - arr[k]) <= b) {
          // 计算i需要满足的范围：arr[i]需在[arr[j]-a, arr[j]+a]和[arr[k]-c, arr[k]+c]的交集中
          let limitHi = Math.min(a + arr[j], c + arr[k], MX);
          let limitLo = Math.max(arr[j] - a, arr[k] - c, 0);

          // 当有效范围存在时，通过前缀和计算该范围内的元素数量
          if (limitHi >= limitLo) {
            ans += prefix[limitHi + 1] - prefix[limitLo];
          }
        }
      }
    }

    // 将当前元素arr[j]加入前缀和数组，供后续j' > j的情况使用
    for (let l = arr[j] + 1; l < MX + 2; l++) {
      prefix[l] += 1;
    }
  }

  return ans;
};
```

##### 枚举中间元素 + 排序 + 三指针

枚举中间元素 j , 然后枚举左元素 ai 收集到 left 中, 枚举右元素 ak 放到 right 数组中。如果此时 left 和 right 是有序的，枚举 ai 可以得到 ak 的范围 [ai - c, ai + c]，随着 ai 的增大这个范围也在增大。可以用两个指针 p1 和 p2 分别指向 right 中 < ai - c 和 <= ai + c 的下标，符合条件的 ak 数量为 p2 - p1。

可以先用 idx 记录以元素值排序的下标数组，可枚举时可以时 left 和 right 保证有序。

```js
/**
 * 功能：计算数组中满足条件的三元组(i,j,k)数量，其中i<j<k且|arr[i]-arr[j]|<=a、|arr[j]-arr[k]|<=b、|arr[i]-arr[k]|<=c
 * 参数：
 *   arr - {number[]} 输入的整数数组
 *   a - {number} 第一个条件的阈值
 *   b - {number} 第二个条件的阈值
 *   c - {number} 第三个条件的阈值
 * 返回值：{number} 满足条件的三元组数量
 * 算法核心思想：通过排序索引优化枚举顺序，使用双指针技术高效统计符合条件的(i,k)对
 * 时间复杂度：O(n²)，其中n为数组长度，排序索引数组O(n log n)，主循环O(n²)
 * 空间复杂度：O(n)，用于存储排序索引及左右元素列表
 */
var countGoodTriplets = function (arr, a, b, c) {
  const n = arr.length;
  // 创建按数组值排序的索引数组，优化枚举顺序
  const idx = Array.from({ length: n }, (_, i) => i).sort(
    (a, b) => arr[a] - arr[b]
  );
  let ans = 0;

  // 枚举排序后的每个索引j作为三元组的中间元素
  for (let j of idx) {
    let left = []; // 存储满足条件的左侧元素i (i < j)
    let right = []; // 存储满足条件的右侧元素k (k > j)

    // 筛选符合条件的i和k
    for (let i of idx) {
      // i必须在j的左侧且满足|arr[i]-arr[j]| <= a
      if (i < j && Math.abs(arr[i] - arr[j]) <= a) {
        left.push(i);
      }
      // k必须在j的右侧且满足|arr[i]-arr[j]| <= b
      if (i > j && Math.abs(arr[i] - arr[j]) <= b) {
        right.push(i);
      }
    }

    // 双指针技术统计满足|arr[i]-arr[k]| <= c的(i,k)对
    let p1 = 0,
      p2 = 0,
      len = left.length;
    // 对每个k，寻找满足arr[k]-c <= arr[i] <= arr[k]+c的i数量
    for (let k of right) {
      // p1移动到第一个大于arr[k]+c的位置
      while (p1 < len && arr[left[p1]] <= arr[k] + c) {
        p1++;
      }
      // p2移动到第一个大于等于arr[k]-c的位置
      while (p2 < len && arr[left[p2]] < arr[k] - c) {
        p2++;
      }
      // [p2, p1)区间内的元素数量即为有效i的数量
      ans += p1 - p2;
    }
  }

  return ans;
};
```
