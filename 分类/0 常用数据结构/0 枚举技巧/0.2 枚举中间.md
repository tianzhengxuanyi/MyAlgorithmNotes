### 枚举中间

#### [3067. 在带权树网络中统计可连接服务器对数目](https://leetcode.cn/problems/count-pairs-of-connectable-servers-in-a-weighted-tree-network/description/)
 
给你一棵无根带权树，树中总共有 n 个节点，分别表示 n 个服务器，服务器从 0 到 n - 1 编号。同时给你一个数组 edges ，其中 edges[i] = [ai, bi, weighti] 表示节点 ai 和 bi 之间有一条双向边，边的权值为 weighti 。再给你一个整数 signalSpeed 。

如果两台服务器 a 和 b 是通过服务器 c 可连接的，则：

- a < b ，a != c 且 b != c 。
- 从 c 到 a 的距离是可以被 signalSpeed 整除的。
- 从 c 到 b 的距离是可以被 signalSpeed 整除的。
- 从 c 到 b 的路径与从 c 到 a 的路径没有任何公共边。

请你返回一个长度为 n 的整数数组 count ，其中 count[i] 表示通过服务器 i 可连接 的服务器对的 数目 。

**思路**

dfs 定义为计算以 i 为根的子树中，i 到节点 j 的距离可以被 signalSpeed 整除的节点 j 的个数。

count[i] 为 i 的后续节点的 dfs 结果两两相乘。

```js
/**
 * 计算每个服务器节点可连接的服务器对数量
 * 问题背景：在网络拓扑中，判断通过当前服务器节点能够相互通信的服务器对数量
 * 通信条件：两个服务器之间的路径经过当前节点，且路径上的信号传输距离是信号速度的整数倍
 * @param {number[][]} edges - 网络拓扑的边列表，每个元素为[x, y, w]表示节点x和y之间有一条权重为w的双向边
 * @param {number} signalSpeed - 信号传输速度，用于判断路径是否有效
 * @return {number[]} 结果数组，索引i处的值表示节点i可连接的服务器对数量
 * @complexity 时间复杂度：O(n^2)，其中n为服务器节点数量，每个节点可能需要遍历整个图
 * @note 该算法使用深度优先搜索(DFS)结合枚举中间节点的策略来统计有效连接对
 */
var countPairsOfConnectableServers = function (edges, signalSpeed) {
    const n = edges.length + 1; // 计算服务器节点总数（边数+1）
    const graph = Array.from({ length: n }, () => []);

    // 构建邻接表表示的图结构
    for (let [x, y, w] of edges) {
        graph[x].push([y, w]), graph[y].push([x, w]);
    }

    /**
     * 深度优先搜索计算子树中可连接的服务器数量
     * @param {number} i - 当前遍历的节点
     * @param {number} fa - 父节点，用于避免回环
     * @param {number} d - 从起始节点到当前节点的距离
     * @return {number} 以i为根的子树中可连接的服务器数量
     */
    const dfs = (i, fa, d) => {
        let r = 0; // 记录可连接的服务器数量
        for (let [nx, w] of graph[i]) {
            if (nx == fa) continue; // 跳过父节点，避免重复访问
            let currD = d + w; // 累计距离
            // 如果当前距离是信号速度的整数倍，则该节点是可连接的
            if (currD % signalSpeed === 0) r++;
            // 递归搜索子节点，并累加结果
            r += dfs(nx, i, currD);
        }
        return r;
    }

    const ans = Array(n).fill(0); // 结果数组初始化
    for (let i = 0; i < n; i++) {
        if (graph[i].length == 0) continue; // 跳过孤立节点
        let sum = 0; // 累计已处理子树的可连接服务器数量
        for (let [nx, w] of graph[i]) {
            // 计算当前子树中可连接的服务器数量
            // 注意：需要加上当前边本身是否满足距离条件
            let r = dfs(nx, i, w) + (w % signalSpeed == 0 ? 1 : 0);
            // 核心公式：当前子树的可连接数量 * 之前所有子树的可连接数量总和
            // 这是因为当前子树中的每个节点都能与之前子树中的每个节点形成新的连接对
            ans[i] += sum * r;
            sum += r; // 更新累计和
        }
    }
    return ans;
};

```