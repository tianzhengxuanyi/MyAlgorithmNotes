### 枚举右维护左

#### [1. 两数之和](https://leetcode.cn/problems/two-sum/description/)

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。

你可以按任意顺序返回答案。

```js
/**
 * 两数之和：使用哈希表实现的高效解法
 * 算法思路：枚举数组右侧元素，同时在左侧维护一个哈希表存储已遍历元素及其索引
 * 当发现目标值与当前元素的差值存在于哈希表中时，返回两个元素的索引
 * 
 * @param {number[]} nums - 输入的整数数组
 * @param {number} target - 目标和值
 * @return {number[]} 满足条件的两个元素的索引数组 [index1, index2]，其中index1 < index2
 * @note 时间复杂度：O(n)，空间复杂度：O(n)，n为数组长度
 * @see 该实现利用了哈希表的O(1)查找特性，比暴力枚举法(O(n²))更高效
 */
var twoSum = function (nums, target) {
    const map = new Map(); // 哈希表存储已遍历元素的值到索引的映射
    for (let i = 0; i < nums.length; i++) {
        // 检查当前元素与目标值的差值是否已存在于哈希表中
        if (map.has(target - nums[i])) {
            return [map.get(target - nums[i]), i]; // 找到匹配对，返回两个索引
        }
        map.set(nums[i], i); // 将当前元素加入哈希表，供后续元素查找
    }
};

```

#### [3584. 子序列首尾元素的最大乘积](https://leetcode.cn/problems/maximum-product-of-first-and-last-elements-of-a-subsequence/description/)

返回任意大小为 m 的 子序列 中首尾元素乘积的最大值。

子序列 是可以通过删除原数组中的一些元素（或不删除任何元素），且不改变剩余元素顺序而得到的数组。

```js
/**
 * 最大乘积子数组：枚举右边界维护左区间极值的解法
 * 算法思路：枚举数组右侧元素作为子数组的右端点，同时维护左侧窗口内的最大值和最小值
 * 由于负数的存在，最小负值与当前元素相乘可能得到最大值，因此需要同时跟踪最大和最小值
 * 
 * @param {number[]} nums - 输入的整数数组
 * @param {number} m - 子数组的固定长度
 * @return {number} 长度为m的连续子数组的最大乘积值
 * @note 时间复杂度：O(n)，空间复杂度：O(1)，n为数组长度
 * @warning 假设m始终小于等于nums.length，未处理m > nums.length的边界情况
 */
var maximumProduct = function (nums, m) {
    let ans = -Infinity; // 初始化最大乘积为负无穷大
    let mx = nums[0];    // 当前窗口内的最大值
    let mn = nums[0];    // 当前窗口内的最小值

    // 枚举右侧边界，从m-1位置开始（确保窗口大小为m）
    for (let i = m - 1; i < nums.length; i++) {
        // 更新当前窗口的最大值和最小值（仅考虑窗口内的元素）
        mx = Math.max(mx, nums[i - m + 1]);
        mn = Math.min(mn, nums[i - m + 1]);
        
        // 计算当前窗口的乘积可能性：当前元素分别与窗口内最大/最小值相乘
        ans = Math.max(ans, nums[i] * mx, nums[i] * mn);
    }

    return ans;
};

```