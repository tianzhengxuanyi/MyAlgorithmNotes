### 枚举右维护左

#### [1. 两数之和](https://leetcode.cn/problems/two-sum/description/)

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。

你可以按任意顺序返回答案。

```js
/**
 * 两数之和：使用哈希表实现的高效解法
 * 算法思路：枚举数组右侧元素，同时在左侧维护一个哈希表存储已遍历元素及其索引
 * 当发现目标值与当前元素的差值存在于哈希表中时，返回两个元素的索引
 * 
 * @param {number[]} nums - 输入的整数数组
 * @param {number} target - 目标和值
 * @return {number[]} 满足条件的两个元素的索引数组 [index1, index2]，其中index1 < index2
 * @note 时间复杂度：O(n)，空间复杂度：O(n)，n为数组长度
 * @see 该实现利用了哈希表的O(1)查找特性，比暴力枚举法(O(n²))更高效
 */
var twoSum = function (nums, target) {
    const map = new Map(); // 哈希表存储已遍历元素的值到索引的映射
    for (let i = 0; i < nums.length; i++) {
        // 检查当前元素与目标值的差值是否已存在于哈希表中
        if (map.has(target - nums[i])) {
            return [map.get(target - nums[i]), i]; // 找到匹配对，返回两个索引
        }
        map.set(nums[i], i); // 将当前元素加入哈希表，供后续元素查找
    }
};

```

#### [3584. 子序列首尾元素的最大乘积](https://leetcode.cn/problems/maximum-product-of-first-and-last-elements-of-a-subsequence/description/)

返回任意大小为 m 的 子序列 中首尾元素乘积的最大值。

子序列 是可以通过删除原数组中的一些元素（或不删除任何元素），且不改变剩余元素顺序而得到的数组。

```js
/**
 * 最大乘积子数组：枚举右边界维护左区间极值的解法
 * 算法思路：枚举数组右侧元素作为子数组的右端点，同时维护左侧窗口内的最大值和最小值
 * 由于负数的存在，最小负值与当前元素相乘可能得到最大值，因此需要同时跟踪最大和最小值
 * 
 * @param {number[]} nums - 输入的整数数组
 * @param {number} m - 子数组的固定长度
 * @return {number} 长度为m的连续子数组的最大乘积值
 * @note 时间复杂度：O(n)，空间复杂度：O(1)，n为数组长度
 * @warning 假设m始终小于等于nums.length，未处理m > nums.length的边界情况
 */
var maximumProduct = function (nums, m) {
    let ans = -Infinity; // 初始化最大乘积为负无穷大
    let mx = nums[0];    // 当前窗口内的最大值
    let mn = nums[0];    // 当前窗口内的最小值

    // 枚举右侧边界，从m-1位置开始（确保窗口大小为m）
    for (let i = m - 1; i < nums.length; i++) {
        // 更新当前窗口的最大值和最小值（仅考虑窗口内的元素）
        mx = Math.max(mx, nums[i - m + 1]);
        mn = Math.min(mn, nums[i - m + 1]);
        
        // 计算当前窗口的乘积可能性：当前元素分别与窗口内最大/最小值相乘
        ans = Math.max(ans, nums[i] * mx, nums[i] * mn);
    }

    return ans;
};

```


#### [2905. 找出满足差值条件的下标 II](https://leetcode.cn/problems/find-indices-with-index-and-value-difference-ii/description/)
 
给你一个下标从 0 开始、长度为 n 的整数数组 nums ，以及整数 indexDifference 和整数 valueDifference 。

你的任务是从范围 [0, n - 1] 内找出  2 个满足下述所有条件的下标 i 和 j ：

abs(i - j) >= indexDifference 且
abs(nums[i] - nums[j]) >= valueDifference
返回整数数组 answer。如果存在满足题目要求的两个下标，则 answer = [i, j] ；否则，answer = [-1, -1] 。如果存在多组可供选择的下标对，只需要返回其中任意一组即可。

注意：i 和 j 可能 相等 。

```js
/**
 * 查找满足条件的两个索引
 * @param {number[]} nums 输入数组
 * @param {number} indexDifference 索引差的最小值
 * @param {number} valueDifference 值差的最小值
 * @return {number[]} 满足条件的两个索引，若无则返回[-1, -1]
 */
var findIndices = function (nums, indexDifference, valueDifference) {
  // 初始化最小值和最大值及其索引
  let mn = nums[0], mx = nums[0];
  let mnj = 0, mxj = 0;
  
  // 从indexDifference开始遍历数组
  for (let i = indexDifference; i < nums.length; i++) {
    // 获取当前元素前indexDifference位置的元素
    let prev = nums[i - indexDifference];
    
    // 更新最小值及其索引
    if (prev < mn) {
      mn = prev;
      mnj = i - indexDifference;
    }
    // 更新最大值及其索引
    if (prev > mx) {
      mx = prev;
      mxj = i - indexDifference;
    }
    
    // 检查当前元素与最小值的差是否满足条件
    if (Math.abs(mn - nums[i]) >= valueDifference) {
      return [i, mnj]
    } 
    // 检查当前元素与最大值的差是否满足条件
    else if (Math.abs(mx - nums[i]) >= valueDifference) {
      return [i, mxj]
    }
  }

  // 没有找到满足条件的索引对
  return [-1, -1]
};

```

#### [456. 132 模式](https://leetcode.cn/problems/132-pattern/description/)
 
给你一个整数数组 nums ，数组中共有 n 个整数。132 模式的子序列 由三个整数 nums[i]、nums[j] 和 nums[k] 组成，并同时满足：i < j < k 和 nums[i] < nums[k] < nums[j] 。

如果 nums 中存在 132 模式的子序列 ，返回 true ；否则，返回 false 。

##### 枚举1（单调栈）

```js
/**
 * 判断数组中是否存在132模式的子序列
 * 132模式指存在i < j < k，使得nums[i] < nums[k] < nums[j]的三元组
 * @param {number[]} nums - 输入的整数数组
 * @return {boolean} 如果存在132模式返回true，否则返回false
 * @algorithm 单调栈解法
 * @complexity 时间复杂度O(n)，空间复杂度O(n)，其中n为数组长度
 * @note 采用从后往前遍历的策略，维护一个单调递减栈存储可能的nums[j]，同时跟踪最大的nums[k]
 */
var find132pattern = function(nums) {
    const st = []; // 单调栈，存储可能的nums[j]（3的位置），保持栈内元素递减
    let k = -Infinity; // 存储当前找到的最大nums[k]（2的位置）
    
    // 从后往前遍历数组，寻找可能的i（1的位置）
    for (let i = nums.length - 1; i >= 0; i--) {
        // 当前元素nums[i]小于k，说明找到132模式（nums[i] < k < 栈中元素）
        if (nums[i] < k) return true;
        
        // 当当前元素大于栈顶时，弹出栈顶并更新k
        // 确保k始终是栈中比当前元素小的最大值
        while (st.length && nums[i] > st[st.length - 1]) {
            k = Math.max(k, st.pop());
        }
        
        // 将当前元素入栈，作为可能的nums[j]候选
        st.push(nums[i]);
    }s
    
    // 遍历结束未找到132模式
    return false;
};

```