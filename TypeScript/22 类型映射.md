#### 类型映射

映射（mapping）指的是，将一种类型按照映射规则，转换成另一种类型，通常用于对象类型。

```ts
type A = {
  foo: number;
  bar: number;
};

type B = {
  [prop in keyof A]: string;
};
```

在语法上，[prop in keyof A]是一个属性名表达式，表示这里的属性名需要计算得到。具体的计算规则如下：

- prop：属性名变量，名字可以随便起。
- in：运算符，用来取出右侧的联合类型的每一个成员。
- keyof A：返回类型A的每一个属性名，组成一个联合类型。

复制原始类型：
```ts
type A = {
  foo: number;
  bar: string;
};

type B = {
  [prop in keyof A]: A[prop];
};
```

#### 映射修饰符 

映射会原样复制原始对象的可选属性和只读属性。
```ts
type A = {
  a?: string;
  readonly b: number;
};

type B = {
  [Prop in keyof A]: A[Prop];
};

// 等同于
type B = {
  a?: string;
  readonly b: number;
};
```

- +修饰符：写成+?或+readonly，为映射属性添加?修饰符或readonly修饰符。
- –修饰符：写成-?或-readonly，为映射属性移除?修饰符或readonly修饰符。
- 没有+或-前缀的修饰符，默认是+。

```ts
// 添加可选属性
type Optional<Type> = {
  [Prop in keyof Type]+?: Type[Prop];
};

// 移除可选属性
type Concrete<Type> = {
  [Prop in keyof Type]-?: Type[Prop];
};

// 添加 readonly
type CreateImmutable<Type> = {
  +readonly [Prop in keyof Type]: Type[Prop];
};

// 移除 readonly
type CreateMutable<Type> = {
  -readonly [Prop in keyof Type]: Type[Prop];
};
```

#### 键名重映射

键名重映射的语法是在键名映射的后面加上**as + 新类型**子句。这里的“新类型”通常是一个模板字符串，里面可以对原始键名进行各种操作。

```ts
interface Person {
  name: string;
  age: number;
  location: string;
}

type Getters<T> = {
  [P in keyof T
    as `get${Capitalize<string & P>}`]: () => T[P];
};

type LazyPerson = Getters<Person>;
// 等同于
type LazyPerson = {
  getName: () => string;
  getAge: () => number;
  getLocation: () => string;
}
```

上面示例中，类型LazyPerson是类型Person的映射，并且把键名改掉了。

它的修改键名的代码是一个模板字符串`get${Capitalize<string & P>}`，下面是各个部分的解释。

- get：为键名添加的前缀。
- Capitalize<T>：一个原生的工具泛型，用来将T的首字母变成大写。
- string & P：一个交叉类型，其中的P是 keyof 运算符返回的键名联合类型string|number|symbol，但是Capitalize<T>只能接受字符串作为类型参数，因此string & P只返回P的字符串属性名。

**属性过滤**

键名重映射还可以过滤掉某些属性。下面的例子是只保留字符串属性。
```ts
type User = {
  name: string,
  age: number
}

type Filter<T> = {
  [K in keyof T
    as T[K] extends string ? K : never]: string
}

type FilteredUser = Filter<User> // { name: string }
```

**联合类型的映射**

由于键名重映射可以修改键名类型，所以原始键名的类型不必是string|number|symbol，任意的联合类型都可以用来进行键名重映射。
```ts
type S = {
  kind: 'square',
  x: number,
  y: number,
};

type C = {
  kind: 'circle',
  radius: number,
};

type MyEvents<Events extends { kind: string }> = {
  [E in Events as E['kind']]: (event: E) => void;
}

type Config = MyEvents<S|C>;
// 等同于
type Config = {
  square: (event:S) => void;
  circle: (event:C) => void;
}
```