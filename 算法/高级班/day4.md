### 题目1

给定一个数组arr，长度为N且每个值都是正数，代表N个人的体重。再给定一个正数limit，代表一艘船的载重。

以下是坐船规则，

1）每艘船最多只能做两人；

2）乘客的体重和不能超过limit。

返回如果同时让这N个人过河最少需要几条船。

**思路：（从中间到两边的双指针）**

1. 将arr从小到大排序；
2. 找到小于等于limit/2最右位置，L指针指向这个位置，R指针为L+1。如果没有找到则返回N（如limit=10，[6,7,8,9]，每个人只能自己单独一条船）;
3. 判断arr[L] + arr[R]和limit之间大小：
   1. arr[L]+arr[R] > limit，L指针左移；
   2. arr[L]+arr[R] <= limit，R指针右移，假设R连续从R0移动到R1后不再满足arr[L]+arr[R] <= limit，L指针向左移R1-R0（R指针右移并且L指针左移?）；
4. 指针移动时统计以下3类数的数量：
   1. a：满足arr[L]+arr[R] <= limit中L指针所指向数组中元素个数（L和R对应元素可坐一条船过河）；
   2. b：满足arr[L]+arr[R] > limit中L指针所指向数组中元素个数（L对应元素可与满足arr[L]+arr[R] > limit的其他元素坐一条船）；
   3. c：指针停止时arr.length - 1 - R（单独坐一条船）；
5. 计算公式a + Math.ceil(b / 2) + c;

![](../image/高级班day4-1.png)

### 题目2

给定一个字符串str，求最长的回文子序列。注意区分子序列和子串的不同

**思路：（贪心：范围上尝试模型）**

**范围上尝试模型的可能性总结依赖于i和j**

1. 建立dp表，dp[i][j]表示str在范围（i，j）上的最长回文子序列；
2. i <= j，所以dp表下半部分不用填。i == j时dp[i][j] = 1（base case）；
3. dp[i][j]有四种可能：
   1. dp[i][j]上最长回文子序列以i位置开头、j位置结尾，dp[i][j] = dp[i+1][j-1] + 2（str[i]必须等于str[j]）;
   2. dp[i][j]上最长回文子序列以i位置开头、不以j位置结尾，dp[i][j] = dp[i][j-1]；
   3. dp[i][j]上最长回文子序列不以i位置开头、以j位置结尾，dp[i][j] = dp[i+1][j]；
   4. dp[i][j]上最长回文子序列不以i位置开头、不以j位置结尾，dp[i][j] = dp[i+1][j-1]；
4. 求四种可能性中最大值；


### 题目3

给定一个字符串str，如果可以在str的任意位置添加字符，请返回在添加字符最少的情况下，让str整体都是回文字符串的一种结果。

【举例】

str="ABA"。str本身就是回文串，不需要添加字符，所以返回"ABA"。

str="AB"。可以在'A'之前添加'B'，使str整体都是回文串，故可以返回"BAB"。也可以在'B'之后添加'A'，使str整体都是回文串，故也可以返回"ABA"。

总之，只要添加的字符数最少，返回其中一种结果即可。

**思路：（贪心：范围上尝试模型）**

1. 建立dp表，dp[i][j]表示str在范围（i，j）上任意位置添加字符，让str整体都是回文字符串的最少情况；
2. 当i等于j时返回0（base case）；
3. dp[i][j]有三种可能：
   1. 搞定 i+1 到 j 位置的字符，然后再加一个搞定 i 位置的字符，所以 dp [i+1][j]+1
   2. 搞定 i 到 j-1 位置的字符，然后再加一个搞定 j 位置的字符，所以 dp [i][j-1]+1
   3. 如果 i 位置的和 j 位置的字符一样， 只有在一样的情况下，就看 dp [i+1][j-1]
   
    然后 dp [i][j] 就是三种或者两种 (如果 i 位置不等于 j) 最小值
4. 有了这个最后的值后，我们可以从那个右上角的答案出发去找源自于哪里，从而对我们的原来字符串做添加变成回文

然后接着… 逆着倒回去看从哪里来的，决定到底该加哪个，然后最后到达对角线结束

这张表记录着所有的解，我们可以走其他路就是另外一个解 (虽然不是对于这个问题是正确答案，但是结果也是个回文)

还原路径，当初怎么决策出来的现在怎么还原出去，一定能够得到一个路径的解

### 题目4

给定一个字符串str，返回把str全部切成回文子串的最小分割数。

【举例】
str="ABA"。

不需要切割，str本身就是回文串，所以返回0。

str="ACDCDCDAD"。

最少需要切2次变成3个回文子串，比如"A"、"CDCDC"和"DAD"，所以返回2。


**思路：（贪心从左往右的尝试）**

f (i) 代表 i 开始以及以后所有的，最少需要切割几次

- 一开始是 0 位置
  - 我们可以让第一个字符自己就是一个回文，然后调用 f (1)
  - 我们可以让前两个字符 (必须是回文才可以), 然后调用 f (2)
  - …
  - 我们可以让前 x 个字符 (必须是回文才可以), 然后调用 f (x)

验证回文通过预处理的技巧，实现复杂度为O(1)

### 题目5

对于一个字符串, 从前开始读和从后开始读是一样的, 我们就称这个字符串是回文串。

例如"ABCBA","AA", "A" 是回文串, 而"ABCD", "AAB"不是回文串。

牛牛特别喜欢回文串, 他手中有一个字符串s, 牛牛在思考能否从字符串中移除部分(0个或多个)字符使其变为回文串，并且牛牛认为空串不是回文串。

牛牛发现移除的方案可能有很多种, 希望你来帮他计算一下一共有多少种移除方案可以使s变为回文串。

对于两种移除方案, 如果移除的字符依次构成的序列不一样就是不同的方案。

例如，XXY 4种 ABA 5种

【说明】

这是今年的原题，提供的说明和例子都很让人费解。现在根据当时题目的所有测试用例，重新解释当时的题目

含义：
1. "1AB23CD21"，你可以选择删除A、B、C、D，然后剩下子序列{1,2,3,2,1}，只要剩下的子序列是同一个，那
么就只算1种方法，和A、B、C、D选择什么样的删除顺序没有关系。
2. "121A1"，其中有两个{1,2,1}的子序列，第一个{1,2,1}是由{位置0，位置1，位置2}构成，第二个{1,2,1}是由{位置0，位置1，位置4}构成。这两个子序列被认为是不同的子序列。也就是说在本题中，认为字面值一样但是位置不同的字符就是不同的。
3. 其实这道题是想求，str中有多少个不同的子序列，每一种子序列只对应一种删除方法，那就是把多余的东西去掉，而和去掉的顺序无关。
4. 也许你觉得我的解释很荒谬，但真的是这样，不然解释不了为什么，XXY 4种 ABA 5种，而且其他的测试用例都印证了这一点。


**思路：（范围上尝试，可能性的归纳）**

dp[i][j]   i....j有多少种保留方案是回文串

1）以i以j

2）不i不j

3）不i以j

4）以i不j

dp[i][j-1] = 2）+4）

a b a             {a} {b} {a} {aa} {aba}

012               0     1   2   0 2   0 1 2

     开头必须 结尾必须

1）以0           以2                        {aa}  {aba}

2）不0           以2                        {a}

3）不0           不2                        {b}

4）以0           不2                        {a}

dp[i][j]          str[i……j] 所有可能的回文情况都算，有多少回文串？

1）以i以j

2）不i不j

3）不i以j

4）以i不j

dp[i][j-1]  2）+4）

dp[i+1][j-1]     2)

dp[i+1][j]  2）+3）

dp[i][j]

可能性 2) 3) 4)相加为：  dp[i][j-1]+dp[i+1][j]-dp[i+1][j+1]


