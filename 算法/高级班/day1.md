### 题目一
给定一个数组，求如果排序之后，相邻两数的最大差值。要求时间复杂度O(N)，且要求不能用非基于比较的排序。

**思路：（构建平凡解）** 

1. 遍历数组得出数组最小值和最大值，根据最小值和最大值将数组等分为n+1个区域（数组长度为n）；
2. 准备n+1个桶，遍历数组，将对应值放入对应范围的桶中（设置n+1个桶**【平凡解】**，舍弃桶里面相邻数的差值）。
   1. 相邻数可能出现在同一个桶，也可以出现在不同的相邻非空桶间（忽略空桶），因准备了n+1个桶，n个数放置必有一个桶是空的。桶里面相邻数的差值一定小于空桶左右两侧相邻数的差值（因为每个桶的范围是相同的，跨越一个空桶的差值最少为range = (max-min)/n+1，而桶里面相邻数的差值最大为range）
3. 每个桶准备三个值，1. 是否进过值 2. 进来的最小值 3. 进来的最大值
4. 每个桶的最小值减去上个非空桶的最大值，比较得出最大差值；

### 题目二
给出n个数字 a_1,...,a_n，问最多有多少不重叠的非空区间，使得每个区间内数字的
xor都等于0。

**思路：（假设答案，分析答案性质）**

动态规划
1. 建立dp数组，dp[i] 表示0~i范围内区间数字xor为0的最大区间数；
2. 当arr[0]为0则dp[0] = 1，否则dp[0] = 0。
3. 现在已知dp[i-1]，求dp[i]。假设数组在0~i上最优的划分方式中包含下标i的最后一块区间为k~i，k~i有如下两种情况：
   1. k~i区间内的数字xor不为0，此时dp[i] = dp[i-1]
   2. k~i区间内的数字xor为0，此时dp[i] = dp[k-1] + 1
   3. dp[i]最终为max(dp[i-1], dp[k-1]);
4. 获取下标k：
   1. 生成变量xorSum，记录遍历数组时的累计异或和；
   2. 生成map，每遍历一个下标时记录当时的xorSum(从0都某个下标位置的前缀异或和)和xorSum最近一次出现的下标map{xorSum, lastestIndex}
   3. 要获取当下标i时的k，在map找此时xorSum最近一次出现的下标index，k=index+1。假设数组xor到下标i时的xorSum为1000，此时0~index的xor和也为1000，表明index+1~i的异或和为0（1000 ^ 0 == 1000）
   

### 题目三

现有n1+n2种面值的硬币，其中前n1种为普通币，可以取任意枚，后n2种为纪念币，
每种最多只能取一枚，每种硬币有一个面值，问能用多少种方法拼出m的面值？

**思路：**

普通币arr1 纪念币arr2
1. 用arr1拼出0 -> a1（方法数），arr2拼出m -> b1（方法数）；用arr1拼出1 -> a2（方法数），arr2拼出m-1 -> b2（方法数）；... 用arr1拼出m -> a(m+1)（方法数），arr2拼出0 -> b(m+1)（方法数）;总的方法数为a1*b1 + a2*b2 + ... a(m+1)*b(m+1)
2. 提前用动态规划得出arr1和arr2的动态规划表（拼硬币问题）


### 题目四

定两个一维int数组A和B. 其中：A是长度为m、元素从小到大排好序的有序数组。B是长度为n、元素从小
到大排好序的有序数组。希望从A和B数组中，找出最大的k个数字（视频讲的是第k小的数），要求：使用
尽量少的比较次数。

**思路一（外排）：**

1. 两个指针指向A和B的开头，谁小谁移动，找到第K小的数；
2. 时间复杂度O(m+n)

**思路二（二分）：**

1. 二分得出A数组的中点，可以得出A中点压过A中的个数，在二分得出压过B中的个数，这也求得A中点在整体中的位置，如果小了向上，大了向上二分。
2. 如果在A中二分没有找到第k小的数，则在B中继续二分。
3. 时间复杂度O(logm + logn)

**思路三（算法原型：求两个等长有序数组的上中位点）**
最优解O(logN)：

算法原型：如果两个有序数组长度一样，怎么找到上中位数

1）两个数组长度都为偶数

A[a,b,c,d]   B[a',b',c',d']

如果b==b' 则是上中位数

b> b' 则c不是上中位数，b'也不是上中位数，可能的是a，b，c'，d'，递归求上中位数

子问题的上中位数就是整个问题的上中位数

2）两个数组长度都是奇数

A[1，2，3，4，5]   B[1'，2'，3'，4'，5']

如果3 = 3'，则是第五小的数

3 > 3’，则3，4，5不可能，1'，2'也不可能

则可能的有1，2和3'，4'，5'，则手动比较2和3'，如果3' >=2，则是第五小的数，否则1，2和4'，5'递归

假设A数组长度为10，B数组长度为17，第K小

1）1=< K <= 10，A拿出1~K，B拿出1~K'，求出上中位数

2）10 < K =< 17  排除掉B数组的K-10-1和最后17-K个数手动比较B数组的K-10数和A中的10，如果大于等于，则是，否则多淘汰一个数接着递归求出上中位数

3）17 < K <=27  排除掉A数组的 K-17-1的数 排除掉B数组的K-10-1的数然后在剩下的数中，先判断A数组的K-17和17'，如果A数组的K-17>=17'，则是第K小，否则抛弃

比较B数组的K-10和A数组的10比，不是就多淘汰一个

接着剩下的数递归求上中位数

### 题目五（剑指offer 62 约瑟夫问题）

某公司招聘，有n个人入围，HR在黑板上依次写下m个正整数A1、A2、……、Am，然后让这n个人围成一个圈，并按照顺时针顺序为他们编号0、1、2、……、n-1。录取规则是：

第一轮从0号的人开始，取用黑板上的第1个数字，也就是A1黑板上的数字按次序循环取用，即如果某轮用了第m个，则下一轮需要用第1个；

如果某轮用到第k个，则下轮需要用第k+1个（k < m）
每一轮按照黑板上的次序取用到一个数字Ax，淘汰掉从当前轮到的人开始按照顺时针顺序数到的第Ax个人，下一轮开始时轮到的人即为被淘汰掉的人的顺时针顺序下一个人

被淘汰的人直接回家，所以不会被后续轮次计数时数到

经过n-1轮后，剩下的最后1人被录取

所以最后被录取的人的编号与（n，m，A1，A2，……，Am）相关。
输入描述：
第一行是一个正整数N，表示有N组参数
从第二行开始，每行有若干个正整数，依次存放n、m、A1、……、Am，一共有N行，也就是上面的N组参
数。
输出描述：
输出有N行，每行对应相应的那组参数确定的录取之人的编号示例1:
输入
1
4 2 3 1
输出
1

[思路](https://blog.csdn.net/weixin_45377141/article/details/125436765?spm=1001.2014.3001.5502)