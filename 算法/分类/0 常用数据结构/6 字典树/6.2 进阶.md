### 进阶

#### [1948. 删除系统中的重复文件夹](https://leetcode.cn/problems/delete-duplicate-folders-in-system/description/)
 
由于一个漏洞，文件系统中存在许多重复文件夹。给你一个二维数组 paths，其中 paths[i] 是一个表示文件系统中第 i 个文件夹的绝对路径的数组。

- 例如，["one", "two", "three"] 表示路径 "/one/two/three" 。

如果两个文件夹（不需要在同一层级）包含 非空且相同的 子文件夹 集合 并具有相同的子文件夹结构，则认为这两个文件夹是相同文件夹。相同文件夹的根层级 不 需要相同。如果存在两个（或两个以上）相同 文件夹，则需要将这些文件夹和所有它们的子文件夹 标记 为待删除。

- 例如，下面文件结构中的文件夹 "/a" 和 "/b" 相同。它们（以及它们的子文件夹）应该被 全部 标记为待删除：
    - /a
    - /a/x
    - /a/x/y
    - /a/z
    - /b
    - /b/x
    - /b/x/y
    - /b/z

- 然而，如果文件结构中还包含路径 "/b/w" ，那么文件夹 "/a" 和 "/b" 就不相同。注意，即便添加了新的文件夹 "/b/w" ，仍然认为 "/a/x" 和 "/b/x" 相同。

一旦所有的相同文件夹和它们的子文件夹都被标记为待删除，文件系统将会 删除 所有上述文件夹。文件系统只会执行一次删除操作。执行完这一次删除操作后，不会删除新出现的相同文件夹。

返回二维数组 ans ，该数组包含删除所有标记文件夹之后剩余文件夹的路径。路径可以按 任意顺序 返回。

```js
/**
 * @param {string[][]} paths - 二维数组，每个子数组表示文件系统中一个文件夹的绝对路径
 * @return {string[][]} - 删除所有重复文件夹后剩余文件夹的路径
 */
var deleteDuplicateFolder = function (paths) {
    // 创建字典树的根节点
    const head = new TrieNode();

    // 遍历所有路径，将其插入到字典树中
    for (let path of paths) {
        // 从根节点开始
        let curr = head;
        // 遍历路径中的每个文件夹名
        for (let s of path) {
            // 如果当前节点的子节点中不包含该文件夹名
            if (!curr.nexts.has(s)) {
                // 创建一个新的节点并添加到子节点中
                curr.nexts.set(s, new TrieNode());
            }
            // 移动到下一个节点
            curr = curr.nexts.get(s);
            // 设置当前节点的名称
            curr.name = s;
        }
    }

    // 用于存储序列化表达式到节点的映射
    const exprToNode = new Map();
    // 遍历根节点的所有子节点，生成序列化表达式
    for (let node of head.nexts.values()) {
        genExpr(node, exprToNode);
    }
    // 存储最终结果的数组
    const ans = [];
    // 用于存储当前路径的数组
    const path = [];

    // 遍历根节点的所有子节点，进行深度优先搜索
    for (let node of head.nexts.values()) {
        dfs(node, path, ans);
    }

    return ans;
};

/**
 * 字典树节点类
 */
class TrieNode {
    constructor() {
        // 节点名称
        this.name = '';
        // 存储子节点的映射，键为文件夹名，值为对应的节点
        this.nexts = new Map();
        // 标记该节点是否需要删除
        this.deleted = false;
    }
}

/**
 * 生成节点的序列化表达式，并标记重复节点
 * @param {TrieNode} node - 当前节点
 * @param {Map} exprToNode - 序列化表达式到节点的映射
 * @return {string} - 当前节点的序列化表达式
 */
function genExpr(node, exprToNode) {
    // 如果当前节点没有子节点，直接返回节点名称
    if (node.nexts.size === 0) return node.name;

    // 存储子节点序列化表达式的数组
    const paths = [];
    // 遍历当前节点的所有子节点
    for (let next of node.nexts.values()) {
        // 递归生成子节点的序列化表达式，并添加括号
        paths.push(`(${genExpr(next, exprToNode)})`);
    }
    // 对子节点的序列化表达式进行排序
    paths.sort();
    // 将排序后的序列化表达式拼接成字符串
    let serializationPaths = paths.join("");
    // 如果该序列化表达式已经存在于映射中
    if (exprToNode.has(serializationPaths)) {
        // 标记当前节点和之前的节点为需要删除
        node.deleted = true;
        exprToNode.get(serializationPaths).deleted = true;
    } else {
        // 将该序列化表达式和当前节点存入映射中
        exprToNode.set(serializationPaths, node);
    }

    // 返回当前节点的名称和子节点序列化表达式拼接后的字符串
    return node.name + serializationPaths;
}

/**
 * 深度优先搜索，收集未被删除的节点路径
 * @param {TrieNode} node - 当前节点
 * @param {string[]} path - 当前路径
 * @param {string[][]} ans - 存储最终结果的数组
 */
function dfs(node, path, ans) {
    // 如果当前节点被标记为删除，直接返回
    if (node.deleted) return;
    // 将当前节点的名称添加到路径中
    path.push(node.name);
    // 将当前路径添加到结果数组中
    ans.push([...path]);
    // 遍历当前节点的所有子节点
    for (let next of node.nexts.values()) {
        // 递归进行深度优先搜索
        dfs(next, path, ans);
    }
    // 回溯，移除当前节点的名称
    path.pop();
}

```

#### [211. 添加与搜索单词 - 数据结构设计](https://leetcode.cn/problems/design-add-and-search-words-data-structure/description/)
 
请你设计一个数据结构，支持 添加新单词 和 查找字符串是否与任何先前添加的字符串匹配 。

实现词典类 WordDictionary ：

- WordDictionary() 初始化词典对象
- void addWord(word) 将 word 添加到数据结构中，之后可以对它进行匹配
- bool search(word) 如果数据结构中存在字符串与 word 匹配，则返回 true ；否则，返回  false 。word 中可能包含一些 '.' ，每个 . 都可以表示任何一个字母。

```js

// 功能：支持通配符"."搜索的字典树实现
// 设计模式：组合模式，支持精确匹配和模糊搜索
var WordDictionary = function() {
    this.head = new TrieNode();  // 创建字典树根节点
};

/** 
 * 功能：向字典树中添加单词
 * 参数：word - 要添加的单词字符串
 * 时间复杂度：O(m)，m为单词长度
 * 空间复杂度：O(m)，最坏情况下需要创建m个新节点
 */
WordDictionary.prototype.addWord = function(word) {
    let node = this.head;               // 从根节点开始
    for (let chr of word) {             // 遍历单词每个字符
        let code = chr.charCodeAt() - 97;  // 计算字符索引（a=0, z=25）
        if (!node.next[code]) {         // 如果路径不存在
            node.next[code] = new TrieNode(chr);  // 创建新节点
        }
        node = node.next[code];         // 移动到子节点
    }
    node.end = true;                    // 标记单词结尾
};

/** 
 * 功能：在字典树中搜索单词，支持通配符"."匹配任意字符
 * 参数：word - 要搜索的单词，可包含通配符"."
 * 返回：boolean - 是否找到匹配的单词
 * 时间复杂度：最坏情况O(26^m)，平均情况O(m)
 * 空间复杂度：O(m) 递归栈深度
 */
WordDictionary.prototype.search = function(word) {
    // 深度优先搜索辅助函数
    // 参数：node - 当前节点，i - 当前字符索引
    const dfs = (node, i) => {
        // 边界条件：到达单词末尾
        if (i == word.length) {
            // 检查当前节点是否为有效单词结尾
            if (node && node.end) {
                return true;  // 找到完整匹配
            } else {
                return false; // 路径存在但不是单词结尾
            }
        }
        if (!node) return false;  // 节点不存在，搜索失败
        
        // 处理当前字符
        if (word[i] != ".") {
            // 精确匹配：处理普通字符
            let code = word[i].charCodeAt() - 97;  // 计算字符索引
            if (!node.next[code]) return false;     // 路径不存在
            return dfs(node.next[code], i + 1);     // 递归搜索下一字符
        } else {
            // 通配符匹配：尝试所有可能的子节点
            for (let nx of node.next) {
                // 如果子节点存在且递归搜索成功
                if (nx && dfs(nx, i + 1)) {
                    return true;  // 找到匹配路径
                }
            }
        }
        return false;  // 所有路径都未找到匹配
    }

    return dfs(this.head, 0);  // 从根节点开始搜索
};

// 字典树节点构造函数
// 功能：创建字典树节点，存储字符值和状态信息
// 参数：val - 节点对应的字符值
function TrieNode(val) {
    this.name = val;                    // 节点存储的字符
    this.end = false;                   // 标记是否为单词结尾
    this.next = Array(26);              // 26个子节点指针数组
}


/** 
 * Your WordDictionary object will be instantiated and called as such:
 * var obj = new WordDictionary()
 * obj.addWord(word)
 * var param_2 = obj.search(word)
 */
```

#### [212. 单词搜索 II](https://leetcode.cn/problems/word-search-ii/description/)
 
给定一个 m x n 二维字符网格 board 和一个单词（字符串）列表 words， 返回所有二维网格上的单词 。

单词必须按照字母顺序，通过 相邻的单元格 内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。

```js
/**
 * 字典树(Trie)数据结构的进阶应用
 * 本文件包含使用字典树结合深度优先搜索(DFS)在字符网格中查找单词的算法实现
 * 实现了LeetCode中的Word Search II问题解决方案
 */

/**
 * 在二维字符网格中查找给定单词列表中的所有单词
 * @param {character[][]} board - 二维字符网格，用于搜索单词
 * @param {string[]} words - 待查找的单词列表
 * @return {string[]} 在网格中找到的所有单词
 * @note 该算法使用字典树优化单词查找效率，并通过DFS遍历网格
 * @complexity 时间复杂度: O(M×N×4^L)，其中M、N是网格维度，L是单词的最大长度；空间复杂度: O(K)，其中K是所有单词的字符总数
 */
var findWords = function (board, words) {
    const m = board.length,  // 网格的行数
        n = board[0].length; // 网格的列数
    
    // 初始化字典树根节点
    const trie = new TrieNode();
    
    // 将所有单词插入字典树中
    for (let word of words) {
        let node = trie;
        for (let chr of word) {
            let code = chr.charCodeAt() - 97; // 将字符转换为0-25的索引
            if (!node.next[code]) {
                node.next[code] = new TrieNode(code);
            }
            node = node.next[code];
        }
        node.end = true; // 标记单词结束
    }

    // 存储找到的单词结果
    const ans = [];
    
    /**
     * 深度优先搜索函数，用于在网格中查找单词
     * @param {number} i - 当前行索引
     * @param {number} j - 当前列索引
     * @param {TrieNode} fa - 当前字典树节点
     * @param {string[]} path - 当前搜索路径形成的字符数组
     */
    const dfs = (i, j, fa, path) => {
        let t = board[i][j];
        let code = board[i][j].charCodeAt() - 97;
        let node = fa.next[code];
        
        // 如果字典树中没有当前字符对应的节点，直接返回
        if (!node) return;
        
        // 将当前字符加入路径
        path.push(t);
        // 标记当前位置已访问
        board[i][j] = "#";
        
        // 如果当前节点是单词结束节点，将形成的单词加入结果集
        if (node.end) {
            ans.push(path.join(""));
            node.end = false; // ☆防止重复添加相同单词
        }

        // 向四个方向进行深度优先搜索
        for (let [di, dj] of d) {
            let ni = i + di, // 新的行索引
                nj = j + dj; // 新的列索引
            // 检查边界条件和是否已访问
            if (ni < 0 || nj < 0 || ni >= m || nj >= n || board[ni][nj] == "#") continue;
            dfs(ni, nj, node, path);
        }
        
        // 回溯：恢复路径和访问标记
        path.pop();
        board[i][j] = t;
    };

    // 从网格的每个位置开始搜索
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            dfs(i, j, trie, []);
        }
    }

    return ans;
};

/**
 * 字典树节点构造函数
 * @param {number} val - 节点对应的字符编码(0-25)
 */
function TrieNode(val) {
    this.name = val;       // 节点对应的字符编码
    this.next = Array(26); // 存储26个小写字母的子节点
    this.end = false;      // 标记该节点是否是某个单词的结束
}

/**
 * 方向数组，用于DFS中的四向遍历（右、左、下、上）
 * 每个元素为[行偏移量, 列偏移量]
 */
const d = [
    [0, 1],  // 向右
    [0, -1], // 向左
    [1, 0],  // 向下
    [-1, 0], // 向上
];

```

#### [745. 前缀和后缀搜索](https://leetcode.cn/problems/prefix-and-suffix-search/description/)

设计一个包含一些单词的特殊词典，并能够通过前缀和后缀来检索单词。

实现 WordFilter 类：

- WordFilter(string[] words) 使用词典中的单词 words 初始化对象。
- f(string pref, string suff) 返回词典中具有前缀 pref 和后缀 suff 的单词的下标。如果存在不止一个满足要求的下标，返回其中 最大的下标 。如果不存在这样的单词，返回 -1 。

```js
/**
 * 字典树(Trie)数据结构的进阶应用
 * 本文件包含一个支持前缀和后缀同时匹配的单词过滤器实现
 * 使用特殊的字典树结构，每个节点存储前缀字符和后缀字符的组合
 */

/**
 * WordFilter类 - 支持前缀和后缀同时匹配的单词过滤器
 * 该类使用特殊的字典树结构，每个节点存储前缀字符和后缀字符的组合
 */
/**
 * 初始化WordFilter实例
 * @param {string[]} words - 单词数组，用于构建过滤器
 * @note 构造函数会构建一个特殊的字典树，每个节点存储前缀字符和后缀字符的组合
 *       对于每个单词，从前往后和从后往前同时遍历，构建字符对节点
 */
var WordFilter = function (words) {
    this.trie = new TrieNode(); // 初始化字典树根节点
    
    // 遍历每个单词构建字典树
    for (let i = 0; i < words.length; i++) {
        let node = this.trie;
        let n = words[i].length;
        
        // 对于单词的每个位置，同时处理前缀和后缀字符
        for (let j = 0; j < n; j++) {
            let p = words[i][j], // 前缀方向的当前字符
                s = words[i][n - j - 1]; // 后缀方向的当前字符
            let key = p + s; // 构建字符对键
            
            // 如果字符对节点不存在，则创建
            if (!node.next.has(key)) {
                node.next.set(key, new TrieNode(key));
            }
            node = node.next.get(key);
            // 记录当前路径上最大的单词索引
            node.idx = Math.max(node.idx, i);
        }
    }
};

/** 
 * 根据前缀和后缀查询满足条件的单词索引
 * @param {string} pref - 前缀字符串
 * @param {string} suff - 后缀字符串
 * @return {number} 满足条件的单词的最大索引，如果没有匹配的单词则返回-1
 * @note 该方法首先尝试同时匹配前缀和后缀，如果无法完全匹配，则通过DFS继续匹配剩余部分
 */
WordFilter.prototype.f = function (pref, suff) {
    let node = this.trie;
    let i = 0, // 前缀匹配的当前位置
        j = suff.length - 1; // 后缀匹配的当前位置
    
    // 尝试同时匹配前缀和后缀的公共部分
    while (i < pref.length && j >= 0) {
        let key = pref[i] + suff[j];
        if (!node.next.has(key)) return -1; // 如果字符对不存在，直接返回-1
        node = node.next.get(key);
        i++, j--;
    }
    
    /**
     * 深度优先搜索函数，用于匹配剩余的前缀或后缀
     * @param {number} i - 当前匹配位置
     * @param {boolean} isPref - 是否正在匹配前缀
     * @param {TrieNode} node - 当前字典树节点
     * @return {number} 满足条件的单词的最大索引，如果没有匹配则返回-1
     */
    const dfs = (i, isPref, node) => {
        // 检查是否完成了所有必要的匹配
        if (isPref ? i == pref.length : i < 0) {
            return node.idx; // 返回当前节点记录的最大索引
        }
        let res = -1;
        // 尝试匹配剩余位置的所有可能字符
        for (let j = 0; j <= 25; j++) {
            // 根据是匹配前缀还是后缀构建不同的字符对键
            let key = isPref 
                ? pref[i] + String.fromCharCode(j + 97) // 固定前缀字符，尝试所有可能的后缀字符
                : String.fromCharCode(j + 97) + suff[i]; // 尝试所有可能的前缀字符，固定后缀字符
            
            if (node.next.has(key)) {
                // 递归搜索，并记录最大索引
                res = Math.max(res, dfs(i + (isPref ? 1 : -1), isPref, node.next.get(key)));
            }
        }
        return res;
    };
    
    // 根据未匹配完的部分，调用相应的DFS继续搜索
    if (i < pref.length) {
        // 前缀还有剩余部分未匹配
        return dfs(i, true, node);
    } else if (j >= 0) {
        // 后缀还有剩余部分未匹配
        return dfs(j, false, node);
    } else {
        // 前缀和后缀都完全匹配
        return node.idx;
    }
};

/**
 * 字典树节点构造函数
 * @param {string} val - 节点对应的字符对键
 * @note 这里使用Map存储子节点，键为字符对，值为子节点
 */
function TrieNode(val) {
    this.name = val;       // 节点对应的字符对键
    this.next = new Map(); // 存储子节点的Map，键为字符对，值为TrieNode
    this.idx = -1;         // 记录经过该节点的单词的最大索引
}

/** 
 * Your WordFilter object will be instantiated and called as such:
 * var obj = new WordFilter(words)
 * var param_1 = obj.f(pref,suff)
 */
```