### 进阶

#### [1948. 删除系统中的重复文件夹](https://leetcode.cn/problems/delete-duplicate-folders-in-system/description/)
 
由于一个漏洞，文件系统中存在许多重复文件夹。给你一个二维数组 paths，其中 paths[i] 是一个表示文件系统中第 i 个文件夹的绝对路径的数组。

- 例如，["one", "two", "three"] 表示路径 "/one/two/three" 。

如果两个文件夹（不需要在同一层级）包含 非空且相同的 子文件夹 集合 并具有相同的子文件夹结构，则认为这两个文件夹是相同文件夹。相同文件夹的根层级 不 需要相同。如果存在两个（或两个以上）相同 文件夹，则需要将这些文件夹和所有它们的子文件夹 标记 为待删除。

- 例如，下面文件结构中的文件夹 "/a" 和 "/b" 相同。它们（以及它们的子文件夹）应该被 全部 标记为待删除：
    - /a
    - /a/x
    - /a/x/y
    - /a/z
    - /b
    - /b/x
    - /b/x/y
    - /b/z

- 然而，如果文件结构中还包含路径 "/b/w" ，那么文件夹 "/a" 和 "/b" 就不相同。注意，即便添加了新的文件夹 "/b/w" ，仍然认为 "/a/x" 和 "/b/x" 相同。

一旦所有的相同文件夹和它们的子文件夹都被标记为待删除，文件系统将会 删除 所有上述文件夹。文件系统只会执行一次删除操作。执行完这一次删除操作后，不会删除新出现的相同文件夹。

返回二维数组 ans ，该数组包含删除所有标记文件夹之后剩余文件夹的路径。路径可以按 任意顺序 返回。

```js
/**
 * @param {string[][]} paths - 二维数组，每个子数组表示文件系统中一个文件夹的绝对路径
 * @return {string[][]} - 删除所有重复文件夹后剩余文件夹的路径
 */
var deleteDuplicateFolder = function (paths) {
    // 创建字典树的根节点
    const head = new TrieNode();

    // 遍历所有路径，将其插入到字典树中
    for (let path of paths) {
        // 从根节点开始
        let curr = head;
        // 遍历路径中的每个文件夹名
        for (let s of path) {
            // 如果当前节点的子节点中不包含该文件夹名
            if (!curr.nexts.has(s)) {
                // 创建一个新的节点并添加到子节点中
                curr.nexts.set(s, new TrieNode());
            }
            // 移动到下一个节点
            curr = curr.nexts.get(s);
            // 设置当前节点的名称
            curr.name = s;
        }
    }

    // 用于存储序列化表达式到节点的映射
    const exprToNode = new Map();
    // 遍历根节点的所有子节点，生成序列化表达式
    for (let node of head.nexts.values()) {
        genExpr(node, exprToNode);
    }
    // 存储最终结果的数组
    const ans = [];
    // 用于存储当前路径的数组
    const path = [];

    // 遍历根节点的所有子节点，进行深度优先搜索
    for (let node of head.nexts.values()) {
        dfs(node, path, ans);
    }

    return ans;
};

/**
 * 字典树节点类
 */
class TrieNode {
    constructor() {
        // 节点名称
        this.name = '';
        // 存储子节点的映射，键为文件夹名，值为对应的节点
        this.nexts = new Map();
        // 标记该节点是否需要删除
        this.deleted = false;
    }
}

/**
 * 生成节点的序列化表达式，并标记重复节点
 * @param {TrieNode} node - 当前节点
 * @param {Map} exprToNode - 序列化表达式到节点的映射
 * @return {string} - 当前节点的序列化表达式
 */
function genExpr(node, exprToNode) {
    // 如果当前节点没有子节点，直接返回节点名称
    if (node.nexts.size === 0) return node.name;

    // 存储子节点序列化表达式的数组
    const paths = [];
    // 遍历当前节点的所有子节点
    for (let next of node.nexts.values()) {
        // 递归生成子节点的序列化表达式，并添加括号
        paths.push(`(${genExpr(next, exprToNode)})`);
    }
    // 对子节点的序列化表达式进行排序
    paths.sort();
    // 将排序后的序列化表达式拼接成字符串
    let serializationPaths = paths.join("");
    // 如果该序列化表达式已经存在于映射中
    if (exprToNode.has(serializationPaths)) {
        // 标记当前节点和之前的节点为需要删除
        node.deleted = true;
        exprToNode.get(serializationPaths).deleted = true;
    } else {
        // 将该序列化表达式和当前节点存入映射中
        exprToNode.set(serializationPaths, node);
    }

    // 返回当前节点的名称和子节点序列化表达式拼接后的字符串
    return node.name + serializationPaths;
}

/**
 * 深度优先搜索，收集未被删除的节点路径
 * @param {TrieNode} node - 当前节点
 * @param {string[]} path - 当前路径
 * @param {string[][]} ans - 存储最终结果的数组
 */
function dfs(node, path, ans) {
    // 如果当前节点被标记为删除，直接返回
    if (node.deleted) return;
    // 将当前节点的名称添加到路径中
    path.push(node.name);
    // 将当前路径添加到结果数组中
    ans.push([...path]);
    // 遍历当前节点的所有子节点
    for (let next of node.nexts.values()) {
        // 递归进行深度优先搜索
        dfs(next, path, ans);
    }
    // 回溯，移除当前节点的名称
    path.pop();
}

```

#### [211. 添加与搜索单词 - 数据结构设计](https://leetcode.cn/problems/design-add-and-search-words-data-structure/description/)
 
请你设计一个数据结构，支持 添加新单词 和 查找字符串是否与任何先前添加的字符串匹配 。

实现词典类 WordDictionary ：

- WordDictionary() 初始化词典对象
- void addWord(word) 将 word 添加到数据结构中，之后可以对它进行匹配
- bool search(word) 如果数据结构中存在字符串与 word 匹配，则返回 true ；否则，返回  false 。word 中可能包含一些 '.' ，每个 . 都可以表示任何一个字母。

```js

// 功能：支持通配符"."搜索的字典树实现
// 设计模式：组合模式，支持精确匹配和模糊搜索
var WordDictionary = function() {
    this.head = new TrieNode();  // 创建字典树根节点
};

/** 
 * 功能：向字典树中添加单词
 * 参数：word - 要添加的单词字符串
 * 时间复杂度：O(m)，m为单词长度
 * 空间复杂度：O(m)，最坏情况下需要创建m个新节点
 */
WordDictionary.prototype.addWord = function(word) {
    let node = this.head;               // 从根节点开始
    for (let chr of word) {             // 遍历单词每个字符
        let code = chr.charCodeAt() - 97;  // 计算字符索引（a=0, z=25）
        if (!node.next[code]) {         // 如果路径不存在
            node.next[code] = new TrieNode(chr);  // 创建新节点
        }
        node = node.next[code];         // 移动到子节点
    }
    node.end = true;                    // 标记单词结尾
};

/** 
 * 功能：在字典树中搜索单词，支持通配符"."匹配任意字符
 * 参数：word - 要搜索的单词，可包含通配符"."
 * 返回：boolean - 是否找到匹配的单词
 * 时间复杂度：最坏情况O(26^m)，平均情况O(m)
 * 空间复杂度：O(m) 递归栈深度
 */
WordDictionary.prototype.search = function(word) {
    // 深度优先搜索辅助函数
    // 参数：node - 当前节点，i - 当前字符索引
    const dfs = (node, i) => {
        // 边界条件：到达单词末尾
        if (i == word.length) {
            // 检查当前节点是否为有效单词结尾
            if (node && node.end) {
                return true;  // 找到完整匹配
            } else {
                return false; // 路径存在但不是单词结尾
            }
        }
        if (!node) return false;  // 节点不存在，搜索失败
        
        // 处理当前字符
        if (word[i] != ".") {
            // 精确匹配：处理普通字符
            let code = word[i].charCodeAt() - 97;  // 计算字符索引
            if (!node.next[code]) return false;     // 路径不存在
            return dfs(node.next[code], i + 1);     // 递归搜索下一字符
        } else {
            // 通配符匹配：尝试所有可能的子节点
            for (let nx of node.next) {
                // 如果子节点存在且递归搜索成功
                if (nx && dfs(nx, i + 1)) {
                    return true;  // 找到匹配路径
                }
            }
        }
        return false;  // 所有路径都未找到匹配
    }

    return dfs(this.head, 0);  // 从根节点开始搜索
};

// 字典树节点构造函数
// 功能：创建字典树节点，存储字符值和状态信息
// 参数：val - 节点对应的字符值
function TrieNode(val) {
    this.name = val;                    // 节点存储的字符
    this.end = false;                   // 标记是否为单词结尾
    this.next = Array(26);              // 26个子节点指针数组
}


/** 
 * Your WordDictionary object will be instantiated and called as such:
 * var obj = new WordDictionary()
 * obj.addWord(word)
 * var param_2 = obj.search(word)
 */
```