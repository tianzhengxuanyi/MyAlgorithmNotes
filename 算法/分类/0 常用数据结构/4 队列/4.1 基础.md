### 队列基础

#### 933. 最近的请求次数
 
写一个 RecentCounter 类来计算特定时间范围内最近的请求。

请你实现 RecentCounter 类：

- RecentCounter() 初始化计数器，请求数为 0 。
- int ping(int t) 在时间 t 添加一个新请求，其中 t 表示以毫秒为单位的某个时间，并返回过去 3000 毫秒内发生的所有请求数（包括新请求）。确切地说，返回在 [t-3000, t] 内发生的请求数。

保证 每次对 ping 的调用都使用比之前更大的 t 值

```js
/**
 * 最近请求次数计数器类
 * 用于统计特定时间范围内（过去3000毫秒）的请求数量
 */
var RecentCounter = function () {
    this.q = [];  // 存储请求时间戳的队列
    this.l = 0;   // 有效窗口的左边界索引（指向队列中第一个有效的请求时间）
};

/** 
 * @param {number} t - 当前请求的时间戳（毫秒）
 * @return {number} - 过去3000毫秒内的请求总数（包含当前请求）
 */
RecentCounter.prototype.ping = function (t) {
    this.q.push(t);  // 将当前请求时间加入队列尾部
    
    // 移动左边界，剔除超过3000毫秒窗口的过期请求
    // 循环条件：左边界未越界 且 当前左边界对应的请求时间已过期（小于t-3000）
    while (this.l < this.q.length && this.q[this.l] < t - 3000) {
        this.l++;  // 左边界右移，丢弃过期请求
    }
    
    // 有效请求数 = 队列总长度 - 左边界索引（窗口内元素数量）
    return this.q.length - this.l;
};


/** 
 * Your RecentCounter object will be instantiated and called as such:
 * var obj = new RecentCounter()
 * var param_1 = obj.ping(t)
 */
```

#### [950. 按递增顺序显示卡牌](https://leetcode.cn/problems/reveal-cards-in-increasing-order/description/)
 
牌组中的每张卡牌都对应有一个唯一的整数。你可以按你想要的顺序对这套卡片进行排序。

最初，这些卡牌在牌组里是正面朝下的（即，未显示状态）。

现在，重复执行以下步骤，直到显示所有卡牌为止：

- 从牌组顶部抽一张牌，显示它，然后将其从牌组中移出。
- 如果牌组中仍有牌，则将下一张处于牌组顶部的牌放在牌组的底部。
- 如果仍有未显示的牌，那么返回步骤 1。否则，停止行动。

返回能以递增顺序显示卡牌的牌组顺序。

答案中的第一张牌被认为处于牌堆顶部。

**题解：**

对排序后的卡片（arr）从右向左进行模拟操作，逆向模拟牌组的抽牌过程。

```js
/**
 * 功能：通过队列操作实现卡牌递增顺序的逆序重构
 * 参数：deck - 原始卡牌数组（数字类型）
 * 返回：按递增顺序排列且满足题目揭示规则的卡牌序列
 * 算法思想：
 *   1. 基于队列的逆向模拟（从排序后的结果倒推原始排列）
 *   2. 时间复杂度：O(n log n)（排序） + O(n)（队列操作） → 总体 O(n log n)
 *   3. 空间复杂度：O(n)（辅助队列存储）
 */
var deckRevealedIncreasing = function(deck) {
    const n = deck.length;
    // 1. 将数组排序为递增序列（准备逆序重构）
    deck.sort((a, b) => a - b);

    // 初始化队列：从最大元素开始构建（最后被揭示的元素）
    const q = [deck[n-1]];

    // 2. 逆向模拟卡牌揭示过程（从倒数第二个元素开始）
    for (let i = n - 2; i >= 0; i--) {
        // 队列操作步骤：
        // a. 将队尾元素移到队首 → 模拟揭示后放回牌底的操作
        q.unshift(q.pop());
        // b. 将当前元素插入队首 → 模拟当前揭示的卡牌
        q.unshift(deck[i]);
    }
    
    return q;
};

```

#### [649. Dota2 参议院](https://leetcode.cn/problems/dota2-senate/description/)
 
Dota2 的世界里有两个阵营：Radiant（天辉）和 Dire（夜魇）

Dota2 参议院由来自两派的参议员组成。现在参议院希望对一个 Dota2 游戏里的改变作出决定。他们以一个基于轮为过程的投票进行。在每一轮中，每一位参议员都可以行使两项权利中的 一 项：

- 禁止一名参议员的权利：参议员可以让另一位参议员在这一轮和随后的几轮中丧失 所有的权利 。
- 宣布胜利：如果参议员发现有权利投票的参议员都是 同一个阵营的 ，他可以宣布胜利并决定在游戏中的有关变化。

给你一个字符串 senate 代表每个参议员的阵营。字母 'R' 和 'D'分别代表了 Radiant（天辉）和 Dire（夜魇）。然后，如果有 n 个参议员，给定字符串的大小将是 n。

以轮为基础的过程从给定顺序的第一个参议员开始到最后一个参议员结束。这一过程将持续到投票结束。所有失去权利的参议员将在过程中被跳过。

假设每一位参议员都足够聪明，会为自己的政党做出最好的策略，你需要预测哪一方最终会宣布胜利并在 Dota2 游戏中决定改变。输出应该是 "Radiant" 或 "Dire" 。

**思路：**

贪心的想，每一个阵营的人都投另外阵营最早投票的人，这样最优。

无限循环模拟投票过程，直到一方失去投票权利的人数(lossCnt)等于本方的总人数(total)，结束循环：
- 遍历当当前i
  - 如果当前参议员失去了投票权利(loss[i] == 1)，则跳过
  - 如果在i之前存在具有投票权利、另外一个阵营的人，则当前i的人失去投票权利，lossCnt加一
  - 如果在i之前不存在具有投票权利、另外一个阵营的人，则将当前阵营具有投票权利的人数加一

```js
/**
 * 功能：模拟参议院投票过程，预测最终获胜党派
 * 参数：senate - 参议员序列（'R'代表Radiant，'D'代表Dire）
 * 返回：最终获胜党派名称（'Radiant' 或 'Dire'）
 * 算法思想：
 *   1. 贪心策略 + 循环队列模拟（时间复杂度 O(n)）
 *   2. 使用两个计数器跟踪待行使的禁令数量
 *   3. 空间复杂度：O(n)（使用数组记录淘汰状态）
 */
var predictPartyVictory = function (senate) {
    const n = senate.length;
    const loss = Array(n).fill(0); // 淘汰状态标记数组
    
    // 统计双方总人数
    let totalR = 0, totalD = 0;
    for (let i of senate) {
        i == "D" ? totalD++ : totalR++;
    }

    // 实时计数器与淘汰计数器
    let cntR = 0, cntD = 0;
    let lossR = 0, lossD = 0;

    // 循环队列模拟（最多进行n轮）
    for (let i = 0; totalR != lossR && totalD != lossD; i++) {
        const idx = i % n; // 循环访问队列
        if (loss[idx]) continue; // 跳过已淘汰成员

        // Dire党派成员处理逻辑
        if (senate[idx] == "D") {
            if (cntR > 0) { // 有Radiant的待处理禁令
                cntR--;
                loss[idx] = 1; // 标记当前Dire成员被淘汰
                lossD++;
                continue;
            } else {
                cntD++; // 积累Dire的禁令
            }
        }

        // Radiant党派成员处理逻辑
        if (senate[idx] == "R") {
            if (cntD > 0) { // 有Dire的待处理禁令
                cntD--;
                loss[idx] = 1; // 标记当前Radiant成员被淘汰
                lossR++;
                continue;
            } else {
                cntR++; // 积累Radiant的禁令
            }
        }
    }

    // 根据剩余存活成员判断胜负
    return totalR == lossR ? "Dire" : "Radiant";
};

```

##### 队列模拟

```js
/**
 * 功能：使用双队列模拟参议院投票过程，预测最终获胜党派
 * 参数：senate - 参议员序列（'R'代表Radiant，'D'代表Dire）
 * 返回：获胜党派名称（'Radiant' 或 'Dire'）
 * 算法思想：
 *   1. 队列存储原始索引实现循环访问（时间复杂度 O(n)）
 *   2. 通过索引比较实现投票权优先级判断
 *   3. 空间复杂度：O(n)（双队列存储）
 */
var predictPartyVictory = function(senate) {
    const n = senate.length;
    // 初始化双队列存储参议员原始索引
    const Radiant = [], Dire = [];
    for (let i = 0; i < n; i++) {
        senate[i] == "R" ? Radiant.push(i) : Dire.push(i);
    }

    // 模拟多轮投票过程
    while (Radiant.length && Dire.length) {
        // 比较队列头部元素的原始索引
        if (Radiant[0] < Dire[0]) {
            // Radiant参议员行使权力，保留到下一轮（索引 +n 实现循环）
            Radiant.push(Radiant[0] + n);
        } else {
            // Dire参议员行使权力，保留到下一轮
            Dire.push(Dire[0] + n);
        }
        // 移除已处理参议员（无论胜负）
        Radiant.shift(), Dire.shift();
    }

    // 根据剩余队列判断获胜方
    return Radiant.length ? "Radiant" : "Dire";
};

```
