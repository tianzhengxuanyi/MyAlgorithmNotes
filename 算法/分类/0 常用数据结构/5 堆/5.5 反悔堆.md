#### [LCP 30. 魔塔游戏](https://leetcode.cn/problems/p0NxJO/description/)

小扣当前位于魔塔游戏第一层，共有 N 个房间，编号为 0 ~ N-1。每个房间的补血道具/怪物对于血量影响记于数组 nums，其中正数表示道具补血数值，即血量增加对应数值；负数表示怪物造成伤害值，即血量减少对应数值；0 表示房间对血量无影响。

小扣初始血量为 1，且无上限。假定小扣原计划按房间编号升序访问所有房间补血/打怪，为保证血量始终为正值，小扣需对房间访问顺序进行调整，每次仅能将一个怪物房间（负数的房间）调整至访问顺序末尾。请返回小扣最少需要调整几次，才能顺利访问所有房间。若调整顺序也无法访问完全部房间，请返回 -1。

**反悔贪心：**

先计算所有房间的血量变化 sum，如果 sum < 0，说明无论如何调整顺序，血量都无法保持正值，返回 -1。

遍历数组，将所有负数加入小根堆，当血量小于 1 时，将堆顶元素弹出，血量增加堆顶元素（将之前扣血最多的怪物房间调整至访问顺序末尾，因为事先判断可以访问完，所以调整到末尾的房间不需要再考虑），操作次数增加 1。


```js
/**
 * 魔法塔反悔堆算法（贪心策略）
 * 核心思路：当血量不足时，通过反悔机制撤回之前最不利的负收益操作
 * 时间复杂度：O(n log n) 每个元素最多入队/出队一次
 * 空间复杂度：O(n) 优先队列存储空间
 * @param {number[]} nums 事件序列（正数为奖励，负数为惩罚）
 * @return {number} 需要反悔的最小次数
 */
var magicTower = function(nums) {
    // 先验检查：总收益必须非负
    let sum = _.sum(nums);
    if (sum < 0) return -1;

    // 最小优先队列（存储遇到的负收益事件）
    const pq = new MinPriorityQueue();
    let cnt = 0, hp = 1; // cnt:反悔次数  hp:当前血量

    for (let x of nums) {
        // 遇到负收益时存入优先队列
        if (x < 0) {
            pq.enqueue(x);
        }

        // 应用当前事件
        hp += x;

        // 血量不足时触发反悔机制
        if (hp < 1) {
            // 取出历史最小负收益（队列中最小的负数，即绝对值最大的损失）
            hp -= pq.dequeue().element;
            cnt++; // 反悔次数增加
        }
    }
    return cnt;
};

```

#### [871. 最低加油次数](https://leetcode.cn/problems/minimum-number-of-refueling-stops/description/)
 
汽车从起点出发驶向目的地，该目的地位于出发位置东面 target 英里处。

沿途有加油站，用数组 stations 表示。其中 stations[i] = [positioni, fueli] 表示第 i 个加油站位于出发位置东面 positioni 英里处，并且有 fueli 升汽油。

假设汽车油箱的容量是无限的，其中最初有 startFuel 升燃料。它每行驶 1 英里就会用掉 1 升汽油。当汽车到达加油站时，它可能停下来加油，将所有汽油从加油站转移到汽车中。

为了到达目的地，汽车所必要的最低加油次数是多少？如果无法到达目的地，则返回 -1 。

注意：如果汽车到达加油站时剩余燃料为 0，它仍然可以在那里加油。如果汽车到达目的地时剩余燃料为 0，仍然认为它已经到达目的地。

```js
/**
 * 加油站反悔堆算法（贪心策略）
 * 核心思路：在油量不足时，通过反悔机制选择历史最大加油量进行补充
 * 时间复杂度：O(n log n) 每个加油站最多入队/出队一次
 * 空间复杂度：O(n) 优先队列存储空间
 * @param {number} target 目标距离
 * @param {number} startFuel 初始油量
 * @param {number[][]} stations 加油站数组[[位置1, 油量1], [位置2, 油量2]]
 * @return {number} 最少加油次数
 */
var minRefuelStops = function (target, startFuel, stations) {
    // 添加虚拟终点加油站（距离为target，油量为0）
    stations.push([target, 0]);
    const pq = new MaxPriorityQueue(); // 最大优先队列（存储可反悔的加油量）
    let fuel = startFuel; // 当前油量
    let ans = 0; // 加油次数

    // 遍历所有加油站（含虚拟终点）
    for (let [p, f] of stations) {
        // 油量不足以到达当前加油站时，触发反悔机制
        while (!pq.isEmpty() && fuel < p) {
            fuel += pq.dequeue().element; // 取出历史最大加油量
            ans++; // 增加加油次数
        }

        // 反悔后仍无法到达当前加油站
        if (fuel < p) return -1;

        // 将当前加油站油量存入优先队列（到达后才能加油）
        pq.enqueue(f);
    }
    return ans;
};

```