### 5.1 基础

#### [1046. 最后一块石头的重量](https://leetcode.cn/problems/last-stone-weight/description/)
 
有一堆石头，每块石头的重量都是正整数。

每一回合，从中选出两块 最重的 石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下：

- 如果 x == y，那么两块石头都会被完全粉碎；
- 如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。

最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 0。

```js
/**
 * 使用最大堆实现石头碰撞问题
 * @param {number[]} stones - 石头重量数组
 * @return {number} - 最后剩余的石头重量（若无剩余返回0）
 * @description 
 * 1. 基于最大堆的特性每次取两个最重石头碰撞
 * 2. 时间复杂度：O(n log n)，堆操作时间复杂度主导
 * 3. 空间复杂度：O(n)，堆存储所有元素
 * @note 当石头重量相同时直接跳过入堆操作
 */
var lastStoneWeight = function (stones) {
    // 初始化最大堆（假设MaxPriorityQueue已实现）
    const pq = MaxPriorityQueue.fromArray(stones);
    
    // 循环处理直到剩余≤1个元素
    while (pq.size() > 1) {
        let x = pq.dequeue(), y = pq.dequeue();
        
        // 仅在不同重量时产生新石头
        if (x !== y) {
            pq.enqueue(Math.abs(x - y)); // 差值入堆
        }
    }
    
    // 安全访问可能为空的堆顶
    return pq.dequeue() ?? 0; 
};

```

#### [2558. 从数量最多的堆取走礼物](https://leetcode.cn/problems/take-gifts-from-the-richest-pile/description/)
 
给你一个整数数组 gifts ，表示各堆礼物的数量。每一秒，你需要执行以下操作：

- 选择礼物数量最多的那一堆。
- 如果不止一堆都符合礼物数量最多，从中选择任一堆即可。
- 将堆中的礼物数量减少到堆中原来礼物数量的平方根，向下取整。

返回在 k 秒后剩下的礼物数量。

##### 优先队列

```js
/**
 * 计算k次操作后剩余礼物总价值
 * @param {number[]} gifts - 礼物价值数组（正整数）
 * @param {number} k - 操作次数
 * @return {number} - 剩余礼物价值总和
 * @description 
 * 1. 使用最大堆实现高效获取最大值
 * 2. 每次操作取最大值取其平方根
 * 3. 时间复杂度：O(n + k log n) 建堆O(n)，每次堆操作O(log n)
 * 4. 空间复杂度：O(n) 堆存储空间
 * @note 每次操作会实时更新总价值减少量
 */
var pickGifts = function(gifts, k) {
    // 初始化最大堆（假设MaxPriorityQueue已实现）
    const pq = MaxPriorityQueue.fromArray(gifts);
    
    // 计算初始总和
    let ans = gifts.reduce((a, b) => a + b, 0);
    
    // 执行k次操作
    for (let i = 0; i < k; i++) {
        let c = pq.dequeue();
        let sq = Math.floor(Math.sqrt(c));  // 取平方根并向下取整
        ans -= (c - sq);  // 更新总价值
        pq.enqueue(sq);    // 新值重新入堆
    }
    
    return ans;
};

```

##### 原地堆化

```js
/**
 * 基于手动堆实现礼物价值计算
 * @param {number[]} gifts - 礼物价值数组（元素需>0）
 * @param {number} k - 操作次数
 * @return {number} - 剩余礼物价值总和
 * @description 
 * 1. 手动实现最大堆的构建与维护
 * 2. 时间复杂度：O(n + k log n) 建堆O(n)，每次操作O(log n)
 * 3. 空间复杂度：O(1) 原地修改数组
 */
var pickGifts = function (gifts, k) {
    // 将数组堆化为最大堆
    heapfiy(gifts);
    
    // 执行k次操作
    for (let i = 0; i < k; i++) {
        // 取堆顶并取平方根
        gifts[0] = Math.floor(Math.sqrt(gifts[0]));
        // 调整堆结构
        sink(gifts, 0);
    }
    // 使用lodash求和（需确保已导入）
    return _.sum(gifts)
};

/**
 * 将数组转换为最大堆
 * @param {number[]} h - 待堆化数组
 * @description 
 * 从最后一个非叶子节点开始反向遍历
 * 时间复杂度：O(n)
 */
const heapfiy = (h) => {
    for (let i = Math.floor(h.length / 2); i >= 0; i--) {
        sink(h, i)
    }
}

/**
 * 元素下沉操作
 * @param {number[]} h - 堆数组
 * @param {number} i - 当前节点索引
 * @description 
 * 1. 比较左右子节点选择较大者
 * 2. 时间复杂度：O(log n)
 */
const sink = (h, i) => {
    let size = h.length;
    while (2 * i + 1 < size) {
        let j = 2 * i + 1;
        // 选择较大子节点
        if (j + 1 < size && h[j + 1] > h[j]) {
            j++;
        }
        // 堆性质满足时终止
        if (h[j] <= h[i]) {
            break;
        }
        // 交换节点值
        [h[i], h[j]] = [h[j], h[i]];
        i = j;
    }
}

```

#### [703. 数据流中的第 K 大元素](https://leetcode.cn/problems/kth-largest-element-in-a-stream/description/)
 
设计一个找到数据流中第 k 大元素的类（class）。注意是排序后的第 k 大元素，不是第 k 个不同的元素。

请实现 KthLargest 类：

- KthLargest(int k, int[] nums) 使用整数 k 和整数流 nums 初始化对象。
- int add(int val) 将 val 插入数据流 nums 后，返回当前数据流中第 k 大的元素。
 

```js
/**
 * 维护数据流中第K大元素的类
 * @description 
 * 1. 使用最小堆保持前K大元素
 * 2. 初始化时间复杂度：O(n log k)
 * 3. add操作时间复杂度：O(log k)
 * 4. 空间复杂度：O(k)
 */
class KthLargest {
    /**
     * @param {number} k - 需要维护的第K大元素值
     * @param {number[]} nums - 初始元素数组
     * @description 
     * 初始化时构建容量为k的最小堆：
     * - 当堆未满时直接添加元素
     * - 当堆已满且新元素更大时替换堆顶
     */
    constructor(k, nums) {
        this.k = k;
        this.pq = new MinPriorityQueue();
        // 初始化堆（保持堆大小≤k）
        for (let x of nums) {
            if (this.pq.size() < k) {
                this.pq.enqueue(x);
                continue;
            }
            // 仅当新元素大于当前第k大时才更新
            if (x > this.pq.front()) {
                this.pq.enqueue(x);
                this.pq.dequeue();
            }
        }
    }

    /**
     * 添加新元素并返回当前第K大值
     * @param {number} val - 新添加的元素
     * @returns {number} - 当前的第K大元素
     * @note 当val小于当前第K大元素时不会改变堆内容
     */
    add(val) {
        if (this.pq.size() < this.k) {
            this.pq.enqueue(val);
        } else if (val > this.pq.front()) {
            // 替换堆顶元素并调整堆
            this.pq.enqueue(val);
            this.pq.dequeue();
        }
        return this.pq.front();
    }
}


/** 
 * Your KthLargest object will be instantiated and called as such:
 * var obj = new KthLargest(k, nums)
 * var param_1 = obj.add(val)
 */
```