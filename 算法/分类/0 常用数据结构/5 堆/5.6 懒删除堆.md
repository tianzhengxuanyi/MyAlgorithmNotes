### 5.6 懒删除堆

#### [2349. 设计数字容器系统](https://leetcode.cn/problems/design-a-number-container-system/description/)
 
设计一个数字容器系统，可以实现以下功能：

- 在系统中给定下标处 插入 或者 替换 一个数字。
- 返回 系统中给定数字的最小下标。

请你实现一个 NumberContainers 类：

- NumberContainers() 初始化数字容器系统。
- void change(int index, int number) 在下标 index 处填入 number 。如果该下标 index 处已经有数字了，那么用 number 替换该数字。
- int find(int number) 返回给定数字 number 在系统中的最小下标。如果系统中没有 number ，那么返回 -1 。

```js
/**
 * 数字容器管理系统（支持懒删除堆优化）
 * @class
 * @author YourName
 * @created 2023-08-01
 * @version 1.0
 */
var NumberContainers = function() {
    /** @type {Map<number, number>} 索引到数字的映射 */
    this.idxToNumber = new Map();
    
    /** 
     * @type {Map<number, MinPriorityQueue>} 数字到索引堆的映射
     * @description 使用最小堆维护每个数字对应的最小可用索引
     */
    this.numberToIdx = new Map();
};

/**
 * 更新指定索引的数字
 * @param {number} index - 需要更新的索引位置
 * @param {number} number - 需要设置的新数字
 * @returns {void}
 * @note 时间复杂度 O(log n)，使用最小堆维护索引顺序
 */
NumberContainers.prototype.change = function(index, number) {
    let idxs = this.numberToIdx.get(number) ?? new MinPriorityQueue();
    idxs.enqueue(index);
    this.numberToIdx.set(number, idxs);
    this.idxToNumber.set(index, number);
};

/**
 * 查找指定数字的最小可用索引
 * @param {number} number - 需要查找的数字
 * @returns {number} 最小有效索引或-1（未找到）
 * @throws {Error} 当堆中存在脏数据时自动清理
 * @complexity 最坏情况 O(k log n)（k为需要清理的无效条目数）
 */
NumberContainers.prototype.find = function(number) {
    let idxs = this.numberToIdx.get(number);
    if (!idxs) return -1;
    
    // 懒删除机制：移除已被修改的无效索引
    while (!idxs.isEmpty() && 
           this.idxToNumber.get(idxs.front()) !== number) {
        idxs.dequeue();
    }
    
    return idxs.isEmpty() ? -1 : idxs.front();
};


/** 
 * Your NumberContainers object will be instantiated and called as such:
 * var obj = new NumberContainers()
 * obj.change(index,number)
 * var param_2 = obj.find(number)
 */
```

#### [3607. 电网维护](https://leetcode.cn/problems/power-grid-maintenance/description/)
 
给你一个整数 c，表示 c 个电站，每个电站有一个唯一标识符 id，从 1 到 c 编号。

这些电站通过 n 条 双向 电缆互相连接，表示为一个二维数组 connections，其中每个元素 connections[i] = [ui, vi] 表示电站 ui 和电站 vi 之间的连接。直接或间接连接的电站组成了一个 电网 。

最初，所有 电站均处于在线（正常运行）状态。

另给你一个二维数组 queries，其中每个查询属于以下 两种类型之一 ：

- [1, x]：请求对电站 x 进行维护检查。如果电站 x 在线，则它自行解决检查。如果电站 x 已离线，则检查由与 x 同一 电网 中 编号最小 的在线电站解决。如果该电网中 不存在 任何 在线 电站，则返回 -1。

- [2, x]：电站 x 离线（即变为非运行状态）。

返回一个整数数组，表示按照查询中出现的顺序，所有类型为 [1, x] 的查询结果。

注意：电网的结构是固定的；离线（非运行）的节点仍然属于其所在的电网，且离线操作不会改变电网的连接性。

```js
/**
 * 处理网络连接查询（支持离线操作）
 * @param {number} c - 节点总数
 * @param {number[][]} connections - 初始连接集合
 * @param {number[][]} queries - 查询集合
 * @returns {number[]} 查询结果数组
 * @complexity 时间复杂度 O(q log n)，q为查询次数
 */
var processQueries = function (c, connections, queries) {
    // 初始化并查集
    const us = new UnionSet(c + 1);
    
    // 建立初始连接
    for (let [x, y] of connections) {
        us.union(x, y);
    }

    // 为每个连通分量创建优先队列
    let rootQueue = new Map();
    for (let i = 1; i <= c; i++) {
        let fa = us.find(i);
        let q = rootQueue.get(fa) ?? new MinPriorityQueue();
        q.enqueue(i);
        rootQueue.set(fa, q);
    };

    let ans = [], 
        // 离线标记数组
        offlines = Array(c + 1).fill(0);

    // 处理查询请求
    for (let [p, x] of queries) {
        if (p == 1) {  // 在线查询
            if (offlines[x] == 0) {
                ans.push(x);
            } else {
                // 懒删除机制：清理失效节点
                let q = rootQueue.get(us.find(x));
                while (!q.isEmpty() && offlines[q.front()]) {
                    q.dequeue();
                }
                ans.push(q.isEmpty() ? -1 : q.front());
            }
        } else {  // 离线标记
            offlines[x] = 1;
        }
    }
    return ans;
};

/**
 * 并查集实现类
 * @class
 * @description 支持路径压缩和按秩合并优化
 */
class UnionSet {
    /**
     * @constructor
     * @param {number} n - 初始元素数量
     */
    constructor(n) {
        /** @type {number[]} 父节点数组 */
        this.fa = Array.from({ length: n }, (_, i) => i);
        /** @type {number[]} 子树大小数组 */
        this.size = Array(n).fill(0);
    }

    /**
     * 带路径压缩的查找
     * @param {number} x - 目标节点
     * @returns {number} 根节点
     * @complexity 近似 O(α(n)) */
    find(x) {
        if (x !== this.fa[x]) {
            this.fa[x] = this.find(this.fa[x]);
        }
        return this.fa[x];
    }

    /**
     * 按秩合并
     * @param {number} x - 节点1
     * @param {number} y - 节点2
     * @returns {boolean} 是否成功合并
     * @throws {Error} 当节点超出范围时抛出异常
     */
    union(x, y) {
        let fax = this.find(x), 
            fay = this.find(y);
        if (fax == fay) return false;

        // 按秩合并优化
        if (this.size[fax] > this.size[fay]) {
            this.size[fax] += this.size[fay];
            this.fa[fay] = fax;
        } else {
            this.size[fay] += this.size[fax];
            this.fa[fax] = fay;
        }
        return true;
    }
}

```