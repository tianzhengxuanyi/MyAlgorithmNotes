### 5.4 第k小、大

#### [264. 丑数 II](https://leetcode.cn/problems/ugly-number-ii/description/)
 
给你一个整数 n ，请你找出并返回第 n 个 丑数 。

丑数 就是质因子只包含 2、3 和 5 的正整数。

```js
/**
 * 计算第n个丑数（预生成法）
 * 算法策略：最小堆 + 哈希表去重
 * 时间复杂度：O(n log n) 空间复杂度：O(n)
 * 丑数定义：只包含质因数2、3、5的正整数
 * @param {number} n - 需要获取的丑数序号
 * @return {number} - 第n个丑数
 */
var nthUglyNumber = function(n) {
    return nums[n - 1];  // 直接返回预生成数组
};

// 预生成前1690个丑数（题目约束范围）
const MX = 1690;
const nums = Array(MX);

// 初始化最小堆和去重集合
let q = new MinPriorityQueue();
let set = new Set([1]);  // 初始种子为第一个丑数1
q.enqueue(1);

// 动态生成丑数序列
for (let i = 0; i < MX; i++) {
    // 取出当前最小丑数
    let front = q.dequeue();
    nums[i] = front;

    // 生成新的候选丑数
    let x = 2 * front, 
        y = 3 * front, 
        z = 5 * front;

    // 维护堆和集合（避免重复）
    if (!set.has(x)) {
        set.add(x), q.enqueue(x);
    }
    if (!set.has(y)) {
        set.add(y), q.enqueue(y);
    }
    if (!set.has(z)) {
        set.add(z), q.enqueue(z);
    }
}

```

#### [378. 有序矩阵中第 K 小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/description/)

给你一个 n x n 矩阵 matrix ，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。
请注意，它是 排序后 的第 k 小元素，而不是第 k 个 不同 的元素。

你必须找到一个内存复杂度优于 O(n2) 的解决方案。

##### 优先队列

```js
/**
 * 在行/列有序矩阵中查找第k小元素（堆优化版）
 * 算法策略：多指针归并 + 最小堆
 * 时间复杂度：O(k log n) 空间复杂度：O(n)
 * @param {number[][]} matrix - 行和列均升序排列的二维数组
 * @param {number} k - 需要查找的序号
 * @return {number} - 第k小的元素值
 */
var kthSmallest = function(matrix, k) {
    const m = matrix.length, n = matrix[0].length;
    
    // 初始化最小堆：存储每行的首个元素
    const pq = new MinPriorityQueue(p => p[0]);
    for (let i = 0; i < m; i++) {
        pq.enqueue([matrix[i][0], i, 0]);  // [值, 行号, 列号]
    }

    // 执行k-1次出队操作
    for (let i = 0; i < k - 1; i++) {
        let [v, r, c] = pq.dequeue();
        
        // 将同一行的下一个元素入队
        if (c + 1 < n) {
            pq.enqueue([matrix[r][c + 1], r, c + 1]);
        }
    }

    // 第k次队首元素即为结果
    return pq.front()[0];
};

```

#### [373. 查找和最小的 K 对数字](https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/description/)
 
给定两个以 非递减顺序排列 的整数数组 nums1 和 nums2 , 以及一个整数 k 。

定义一对值 (u,v)，其中第一个元素来自 nums1，第二个元素来自 nums2 。

请找到和最小的 k 个数对 (u1,v1),  (u2,v2)  ...  (uk,vk) 。

```js
/**
 * 查找两个有序数组中k对最小和的数对
 * @param {number[]} nums1 - 第一个有序数组（升序）
 * @param {number[]} nums2 - 第二个有序数组（升序）
 * @param {number} k - 需要返回的数对数量
 * @returns {number[][]} 前k个最小和的数对
 * @complexity 时间复杂度 O(k log min(n1,k))，空间复杂度 O(min(n1,k))
 * 
 * @algorithm 多路归并算法
 * 1. 初始化优先队列：将nums1中每个元素与nums2首元素组成初始对
 * 2. 每次弹出当前最小对后，补充nums2中下一个元素的组合
 * 3. 保证队列中始终维持最小候选对
 */
var kSmallestPairs = function(nums1, nums2, k) {
    const n1 = nums1.length, n2 = nums2.length;
    // 初始化最小堆（按数对和排序）
    const pq = new MinPriorityQueue(p => p[0] + p[1]);
    
    // 初始填充：每个nums1元素对应nums2的第一个元素
    // 仅需取前k个nums1元素优化空间
    for (let i = 0; i < Math.min(n1, k); i++) {
        pq.enqueue([nums1[i], nums2[0], i, 0]);
    }

    const ans = [];
    // 最多取k个元素或所有可能组合
    for (let i = 0; i < k && !pq.isEmpty(); i++) {
        // 弹出当前最小对 [值1, 值2, nums1索引, nums2索引]
        let [x, y, u, v] = pq.dequeue();
        ans.push([x, y]);
        
        // 补充下一个可能的候选对（同一nums1元素的下一个nums2元素）
        if (v + 1 < n2) {
            pq.enqueue([nums1[u], nums2[v + 1], u, v + 1]);
        }
    }
    return ans;
};

```