### 5.3 重排元素

#### [984. 不含 AAA 或 BBB 的字符串](https://leetcode.cn/problems/string-without-aaa-or-bbb/description/)
 
给定两个整数 a 和 b ，返回 任意 字符串 s ，要求满足：

- s 的长度为 a + b，且正好包含 a 个 'a' 字母与 b 个 'b' 字母；
- 子串 'aaa' 没有出现在 s 中；
- 子串 'bbb' 没有出现在 s 中。

**题解：**

```js
/**
 * 重构字符串避免三个连续相同字符（贪心算法）
 * 核心策略：优先排列剩余数量多的字符，动态调整排列模式
 * 时间复杂度：O(n) 空间复杂度：O(1)
 * @param {number} a - 字符a的数量
 * @param {number} b - 字符b的数量
 * @return {string} 符合规则的字符串
 */
var strWithout3a3b = function (a, b) {
    let ans = "";
    // 主循环：交替处理剩余字符
    while (a > 0 || b > 0) {
        // 情况1：a的数量较多时，采用aab模式排列
        if (a > b && b > 0) {
            ans += "aab";
            a -= 2;
            b -= 1;
        } 
        // 情况2：b的数量较多时，采用abb模式排列
        else if (b > a && a > 0) {
            ans += "abb";
            b -= 2;
            a -= 1;
        }
        // 情况3：数量相等时直接交替排列
        else if (a == b && a > 0) {
            ans += "ab".repeat(a);
            break;
        }
        // 边界情况处理：当某一字符单独剩余时
        else if (a > 0) {
            ans += "a".repeat(a);
            break;
        } else {
            // 确保b字符不会出现在开头形成3连b
            ans = "b".repeat(b) + ans;
            break;
        }
    }
    return ans;
};

```

#### [767. 重构字符串](https://leetcode.cn/problems/reorganize-string/description/)
 
给定一个字符串 s ，检查是否能重新排布其中的字母，使得两相邻的字符不同。

返回 s 的任意可能的重新排列。若不可行，返回空字符串 "" 。


```js
/**
 * 重组字符串避免相邻重复（最大堆实现）
 * 核心算法：贪心策略 + 优先队列
 * 时间复杂度：O(n log k) 空间复杂度：O(k) 
 * 其中n为字符串长度，k为不同字符数量
 * @param {string} s - 输入字符串
 * @return {string} - 重组后的字符串（无法重组返回空字符串）
 */
var reorganizeString = function (s) {
    // 统计字符频率
    const cnt = new Map();
    for (let chr of s) {
        cnt.set(chr, (cnt.get(chr) ?? 0) + 1);
    }

    // 创建最大优先队列（按字符频率排序）
    const q = new MaxPriorityQueue(p => p[1]);
    for (let item of cnt.entries()) {
        q.enqueue(item);
    }

    // 验证最大频率是否合法
    let m = q.front()[1];
    if (m > s.length - m + 1) {
        return "";
    }

    let ans = "";
    // 双字符交替排列策略
    while (!q.isEmpty()) {
        // 处理最后单个字符的特殊情况
        if (q.size() == 1 && q.front()[1] > 1) return "";
        
        // 取出当前频率最高的两个字符
        let [x, xCnt] = q.dequeue();
        let [y, yCnt] = q.dequeue() ?? ["", 0];
        
        // 交替拼接字符
        ans += x + y;
        
        // 更新频率并重新入队
        xCnt--, yCnt--;
        if (xCnt > 0) q.enqueue([x, xCnt]);
        if (yCnt > 0) q.enqueue([y, yCnt]);
    }

    return ans;
};

```