### 5.7 对顶堆

#### [295. 数据流的中位数](https://leetcode.cn/problems/find-median-from-data-stream/)
 
中位数是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。

- 例如 arr = [2,3,4] 的中位数是 3 。
- 例如 arr = [2,3] 的中位数是 (2 + 3) / 2 = 2.5 。

实现 MedianFinder 类:

- MedianFinder() 初始化 MedianFinder 对象。

- void addNum(int num) 将数据流中的整数 num 添加到数据结构中。

- double findMedian() 返回到目前为止所有元素的中位数。与实际答案相差 10-5 以内的答案将被接受。

```js

/**
 * 数据流中位数对顶堆实现
 * 核心思路：使用最大堆(left)和最小堆(right)维护有序数据流
 * 时间复杂度：
 *  - addNum: O(log n)
 *  - findMedian: O(1)
 * 空间复杂度：O(n)
 */
var MedianFinder = function () {
    // 左半部分使用最大堆（存储较小的一半数字）
    this.left = new MaxPriorityQueue();
    // 右半部分使用最小堆（存储较大的一半数字）
    this.right = new MinPriorityQueue();
};

/** 
 * 添加数字并保持堆平衡
 * @param {number} num 要添加的数字
 * @return {void}
 */
MedianFinder.prototype.addNum = function (num) {
    // 当两堆大小相等时，优先填充右堆
    if (this.left.size() === this.right.size()) {
        this.right.enqueue(num);
        // 将右堆最小值转移到左堆（保证左堆所有元素 <= 右堆）
        this.left.enqueue(this.right.dequeue().element);
    } else {
        // 当左堆较大时，优先填充左堆
        this.left.enqueue(num);
        // 将左堆最大值转移到右堆（维持大小平衡）
        this.right.enqueue(this.left.dequeue().element);
    }
};

/**
 * 获取当前数据流中位数
 * @return {number}
 */
MedianFinder.prototype.findMedian = function () {
    // 当左堆较大时直接返回堆顶
    if (this.left.size() > this.right.size()) {
        return this.left.front().element;
    }
    // 两堆大小相等时取平均值
    return (this.left.front().element + this.right.front().element) / 2;
};

/** 
 * Your MedianFinder object will be instantiated and called as such:
 * var obj = new MedianFinder()
 * obj.addNum(num)
 * var param_2 = obj.findMedian()
 */
```

#### [480. 滑动窗口中位数](https://leetcode.cn/problems/sliding-window-median/description/)
 
中位数是有序序列最中间的那个数。如果序列的长度是偶数，则没有最中间的数；此时中位数是最中间的两个数的平均数。

例如：

- [2,3,4]，中位数是 3
- [2,3]，中位数是 (2 + 3) / 2 = 2.5

给你一个数组 nums，有一个长度为 k 的窗口从最左端滑动到最右端。窗口中有 k 个数，每次窗口向右移动 1 位。你的任务是找出每次窗口移动后得到的新窗口中元素的中位数，并输出由它们组成的数组。

```js
/**
 * 滑动窗口中位数算法实现（对顶堆方案）
 * @param {number[]} nums - 输入数字序列
 * @param {number} k - 窗口大小
 * @returns {number[]} 各窗口的中位数数组
 * @note 
 * 1. 使用两个惰性堆(left大顶堆/right小顶堆)维护窗口元素
 * 2. 保持left堆容量≥right堆，最多大1个元素
 * 3. 采用惰性删除策略优化删除操作性能
 */
var medianSlidingWindow = function (nums, k) {
    // 初始化双堆结构
    const left = new LazyHeap();    // 大顶堆维护较小半数
    const right = new LazyHeap(true); // 小顶堆维护较大半数
    const ans = [];

    // 滑动窗口双指针
    for (let l = 0, r = 0; r < nums.length; r++) {
        // 新元素入堆策略：保持两堆平衡
        let x = nums[r];
        if (left.size == right.size) {
            left.enqueue(right.enqueueDequeue(x)); // 先入right再转给left
        } else {
            right.enqueue(left.enqueueDequeue(x)); // 先入left再转给right
        }

        // 初始化阶段跳过不完整窗口
        if (r < k - 1) continue;

        // 计算当前窗口中位数
        if (left.size == right.size) {
            ans.push((left.front() + right.front()) / 2); // 偶数取平均
        } else {
            ans.push(left.front()); // 奇数取left堆顶
        }

        // 处理左指针移出窗口元素
        if (nums[l] <= left.front()) {
            left.remove(nums[l]);
            // 维持堆平衡：当right堆更大时转移元素
            if (right.size > left.size) {
                left.enqueue(right.dequeue());
            }
        } else {
            right.remove(nums[l]);
            // 维持堆平衡：当left堆超过right堆1个以上
            if (left.size > right.size + 1) {
                right.enqueue(left.dequeue())
            }
        }
        l++;
    }
    return ans;
};

/**
 * 惰性堆实现（支持延迟删除）
 * @class
 * @property {PriorityQueue} pq - 基础优先队列
 * @property {Map} removeCnt - 待删除元素计数器
 * @property {number} size - 有效元素数量
 */
class LazyHeap {
    /**
     * @constructor
     * @param {boolean} [isMin=false] - 是否为小顶堆（默认大顶堆）
     */
    constructor(isMin) {
        this.pq = isMin ? new MinPriorityQueue() : new MaxPriorityQueue();
        this.removeCnt = new Map(); // 元素删除标记计数器
        this.size = 0; // 有效元素计数
    }

    /**
     * 实际执行待删除元素的清理操作
     * @private
     */
    #applyRemove() {
        // 清理堆顶无效元素直到遇到有效元素
        while (!this.pq.isEmpty()) {
            let top = this.pq.front();
            let cnt = this.removeCnt.get(top) ?? 0;
            if (cnt == 0) break;
            this.pq.dequeue();
            this.removeCnt.set(top, cnt - 1);
        }
    }

    /**
     * 获取堆顶元素（执行删除清理后）
     * @returns {number} 当前有效堆顶元素
     */
    front() {
        this.#applyRemove();
        return this.pq.front();
    }

    /**
     * 元素入堆
     * @param {number} x - 待插入元素
     */
    enqueue(x) {
        this.pq.enqueue(x);
        this.size++;
    }

    /**
     * 元素出堆（执行删除清理后）
     * @returns {number} 出堆元素
     */
    dequeue() {
        this.#applyRemove();
        this.size--;
        return this.pq.dequeue();
    }

    /**
     * 标记删除元素（惰性删除）
     * @param {number} x - 待删除元素
     * @note 实际删除延迟到下次访问堆顶时执行
     */
    remove(x) {
        this.removeCnt.set(x, (this.removeCnt.get(x) ?? 0) + 1);
        this.size--;
    }

    /**
     * 先入队后出队操作
     * @param {number} x - 待插入元素
     * @returns {number} 出队元素
     * @note 用于维护堆平衡的原子操作
     */
    enqueueDequeue(x) {
        this.pq.enqueue(x);
        this.#applyRemove();
        return this.pq.dequeue();
    }
}

```