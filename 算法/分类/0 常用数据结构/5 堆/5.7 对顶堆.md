### 5.7 对顶堆

#### [295. 数据流的中位数](https://leetcode.cn/problems/find-median-from-data-stream/)
 
中位数是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。

- 例如 arr = [2,3,4] 的中位数是 3 。
- 例如 arr = [2,3] 的中位数是 (2 + 3) / 2 = 2.5 。

实现 MedianFinder 类:

- MedianFinder() 初始化 MedianFinder 对象。

- void addNum(int num) 将数据流中的整数 num 添加到数据结构中。

- double findMedian() 返回到目前为止所有元素的中位数。与实际答案相差 10-5 以内的答案将被接受。

```js

/**
 * 数据流中位数对顶堆实现
 * 核心思路：使用最大堆(left)和最小堆(right)维护有序数据流
 * 时间复杂度：
 *  - addNum: O(log n)
 *  - findMedian: O(1)
 * 空间复杂度：O(n)
 */
var MedianFinder = function () {
    // 左半部分使用最大堆（存储较小的一半数字）
    this.left = new MaxPriorityQueue();
    // 右半部分使用最小堆（存储较大的一半数字）
    this.right = new MinPriorityQueue();
};

/** 
 * 添加数字并保持堆平衡
 * @param {number} num 要添加的数字
 * @return {void}
 */
MedianFinder.prototype.addNum = function (num) {
    // 当两堆大小相等时，优先填充右堆
    if (this.left.size() === this.right.size()) {
        this.right.enqueue(num);
        // 将右堆最小值转移到左堆（保证左堆所有元素 <= 右堆）
        this.left.enqueue(this.right.dequeue().element);
    } else {
        // 当左堆较大时，优先填充左堆
        this.left.enqueue(num);
        // 将左堆最大值转移到右堆（维持大小平衡）
        this.right.enqueue(this.left.dequeue().element);
    }
};

/**
 * 获取当前数据流中位数
 * @return {number}
 */
MedianFinder.prototype.findMedian = function () {
    // 当左堆较大时直接返回堆顶
    if (this.left.size() > this.right.size()) {
        return this.left.front().element;
    }
    // 两堆大小相等时取平均值
    return (this.left.front().element + this.right.front().element) / 2;
};

/** 
 * Your MedianFinder object will be instantiated and called as such:
 * var obj = new MedianFinder()
 * obj.addNum(num)
 * var param_2 = obj.findMedian()
 */
```