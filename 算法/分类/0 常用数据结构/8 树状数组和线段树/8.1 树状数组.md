### 树状数组

#### [3072. 将元素分配到两个数组中 II](https://leetcode.cn/problems/distribute-elements-into-two-arrays-ii/description/)

给你一个下标从 **1** 开始、长度为 `n` 的整数数组 `nums` 。

现定义函数 `greaterCount` ，使得 `greaterCount(arr, val)` 返回数组 `arr` 中 **严格大于** `val` 的元素数量。

你需要使用 `n` 次操作，将 `nums` 的所有元素分配到两个数组 `arr1` 和 `arr2` 中。在第一次操作中，将 `nums[1]` 追加到 `arr1` 。在第二次操作中，将 `nums[2]` 追加到 `arr2` 。之后，在第 `i` 次操作中：

- 如果 `greaterCount(arr1, nums[i]) > greaterCount(arr2, nums[i])` ，将 `nums[i]` 追加到 `arr1` 。
- 如果 `greaterCount(arr1, nums[i]) < greaterCount(arr2, nums[i])` ，将 `nums[i]` 追加到 `arr2` 。
- 如果 `greaterCount(arr1, nums[i]) == greaterCount(arr2, nums[i])` ，将 `nums[i]` 追加到元素数量较少的数组中。
- 如果仍然相等，那么将 `nums[i]` 追加到 `arr1` 。

连接数组 `arr1` 和 `arr2` 形成数组 `result` 。例如，如果 `arr1 == [1,2,3]` 且 `arr2 == [4,5,6]` ，那么 `result = [1,2,3,4,5,6]` 。

返回整数数组 `result` 。

**示例 1：**

```
输入：nums = [2,1,3,3]
输出：[2,3,1,3]
解释：在前两次操作后，arr1 = [2] ，arr2 = [1] 。
在第 3 次操作中，两个数组中大于 3 的元素数量都是零，并且长度相等，因此，将 nums[3] 追加到 arr1 。
在第 4 次操作中，两个数组中大于 3 的元素数量都是零，但 arr2 的长度较小，因此，将 nums[4] 追加到 arr2 。
在 4 次操作后，arr1 = [2,3] ，arr2 = [1,3] 。
因此，连接形成的数组 result 是 [2,3,1,3] 。
```

**示例 2：**

```
输入：nums = [5,14,3,1,2]
输出：[5,3,1,2,14]
解释：在前两次操作后，arr1 = [5] ，arr2 = [14] 。
在第 3 次操作中，两个数组中大于 3 的元素数量都是一，并且长度相等，因此，将 nums[3] 追加到 arr1 。
在第 4 次操作中，arr1 中大于 1 的元素数量大于 arr2 中的数量（2 > 1），因此，将 nums[4] 追加到 arr1 。
在第 5 次操作中，arr1 中大于 2 的元素数量大于 arr2 中的数量（2 > 1），因此，将 nums[5] 追加到 arr1 。
在 5 次操作后，arr1 = [5,3,1,2] ，arr2 = [14] 。
因此，连接形成的数组 result 是 [5,3,1,2,14] 。
```

**示例 3：**

```
输入：nums = [3,3,3,3]
输出：[3,3,3,3]
解释：在 4 次操作后，arr1 = [3,3] ，arr2 = [3,3] 。
因此，连接形成的数组 result 是 [3,3,3,3] 。
```

**提示：**

- `3 <= n <= 105`
- `1 <= nums[i] <= 109`

##### 树状数组

```js
/**
 * @param {number[]} nums - 输入的原始数组
 * @return {number[]} - 按照特定规则分割后的结果数组（arr1和arr2的拼接）
 * @description 该函数将输入数组分割为两个子数组arr1和arr2，分割规则基于
 *              元素的相对大小关系和子数组长度，使用树状数组高效计算前缀和
 * 时间复杂度：O(n log n)，空间复杂度：O(n)
 */
var resultArray = function (nums) {
  const n = nums.length; // 原始数组长度
  const fenwick = new Fenwick(n); // 初始化树状数组用于高效区间查询

  const arr1 = [],
    arr2 = []; // 存储分割后的两个子数组

  // 预处理：创建索引数组并按原数组值排序
  // sorted数组存储的是原始数组索引，按对应的值从小到大排序
  const sorted = Array.from({ length: n }, (_, i) => i).sort(
    (a, b) => nums[a] - nums[b]
  );

  // 建立原始索引到排序后位置的映射
  const idxToSorted = Array(n);
  for (let i = 0; i < n; i++) {
    idxToSorted[sorted[i]] = i;
  }

  // 初始化：将前两个元素分别加入arr1和arr2
  arr1.push(nums[0]), arr2.push(nums[1]);
  // 在树状数组中标记：arr1中的元素对应位置加1，arr2中的元素对应位置减1
  // 这样区间查询结果即为两个数组中大于等于某值的元素数量差
  fenwick.update(idxToSorted[0], 1), fenwick.update(idxToSorted[1], -1);

  /**
   * 二分查找实现：查找第一个大于等于目标值的元素位置
   * @param {number} target - 目标值
   * @return {number} - 第一个大于等于target的元素在排序数组中的位置
   */
  const lowerBound = (target) => {
    let l = 0,
      r = n - 1; // 初始化二分查找的左右边界
    while (l <= r) {
      let m = Math.floor((r - l) / 2) + l; // 计算中间位置（避免整数溢出）
      if (nums[sorted[m]] < target) {
        l = m + 1; // 目标在右半部分
      } else {
        r = m - 1; // 目标在左半部分或当前位置
      }
    }
    return l; // 返回第一个大于等于target的位置
  };

  // 处理剩余的元素（从第三个元素开始）
  for (let i = 2; i < n; i++) {
    // 查找第一个大于nums[i]的元素位置
    let pos = lowerBound(nums[i] + 1);
    // 计算在arr1和arr2中，大于nums[i]的元素数量差
    let diff = pos >= n ? 0 : fenwick.sumRange(pos, n - 1);

    // 分配规则：
    // 1. 如果diff > 0，说明arr1中大于当前元素的数量更多，放入arr1
    // 2. 如果diff = 0，且arr1长度小于等于arr2，放入arr1
    // 3. 其他情况放入arr2
    if (diff > 0 || (diff == 0 && arr1.length <= arr2.length)) {
      arr1.push(nums[i]);
      fenwick.update(idxToSorted[i], 1); // 在树状数组中标记为arr1元素
    } else {
      arr2.push(nums[i]);
      fenwick.update(idxToSorted[i], -1); // 在树状数组中标记为arr2元素
    }
  }

  // 返回拼接后的结果数组
  return arr1.concat(arr2);
};

/**
 * 树状数组（Fenwick Tree / Binary Indexed Tree）类实现
 * 支持单点更新和区间查询操作
 */
class Fenwick {
  /**
   * 初始化树状数组
   * @param {number} n - 数组大小
   */
  constructor(n) {
    this.tree = Array(n + 1).fill(0); // 树状数组，索引0不使用
  }

  /**
   * 更新指定位置的值
   * @param {number} index - 要更新的位置（0-base）
   * @param {number} val - 要增加的值
   */
  update(index, val) {
    // 转换为1-base索引，并更新所有覆盖该位置的区间
    // i += i & -i 用于找到所有包含当前位置的上级区间
    for (let i = index + 1; i < this.tree.length; i += i & -i) {
      this.tree[i] += val;
    }
  }

  /**
   * 计算前缀和（从索引1到i的元素和）
   * @param {number} i - 前缀和的右边界（1-base）
   * @return {number} - 计算得到的前缀和
   */
  prefixSum(i) {
    let sum = 0;
    // i &= i - 1 用于移除二进制表示中最低位的1，找到所有包含在当前区间中的子区间
    for (; i > 0; i &= i - 1) {
      sum += this.tree[i];
    }
    return sum;
  }

  /**
   * 计算区间和
   * @param {number} l - 区间左边界（0-base）
   * @param {number} r - 区间右边界（0-base）
   * @return {number} - 区间[l, r]的元素和
   */
  sumRange(l, r) {
    // 区间和 = 右边界前缀和 - 左边界前一个位置的前缀和
    return this.prefixSum(r + 1) - this.prefixSum(l);
  }
}
```

#### [307. 区域和检索 - 数组可修改](https://leetcode.cn/problems/range-sum-query-mutable/description/)

给你一个数组 `nums` ，请你完成两类查询。

1. 其中一类查询要求 **更新** 数组  `nums`  下标对应的值
2. 另一类查询要求返回数组  `nums`  中索引  `left`  和索引  `right`  之间（ **包含**）的 nums 元素的 **和** ，其中  `left <= right`

实现 `NumArray` 类：

- `NumArray(int[] nums)` 用整数数组 `nums` 初始化对象
- `void update(int index, int val)` 将 `nums[index]` 的值 **更新** 为 `val`
- `int sumRange(int left, int right)` 返回数组  `nums`  中索引  `left`  和索引  `right`  之间（ **包含**）的 nums 元素的 **和** （即，`nums[left] + nums[left + 1], ..., nums[right]`）

**示例 1：**

```
输入：
["NumArray", "sumRange", "update", "sumRange"]
[[[1, 3, 5]], [0, 2], [1, 2], [0, 2]]
输出：
[null, 9, null, 8]

解释：
NumArray numArray = new NumArray([1, 3, 5]);
numArray.sumRange(0, 2); // 返回 1 + 3 + 5 = 9
numArray.update(1, 2);   // nums = [1,2,5]
numArray.sumRange(0, 2); // 返回 1 + 2 + 5 = 8
```

**提示：**

- `1 <= nums.length <= 3 * 104`
- `-100 <= nums[i] <= 100`
- `0 <= index < nums.length`
- `-100 <= val <= 100`
- `0 <= left <= right < nums.length`
- 调用 `update` 和 `sumRange` 方法次数不大于  `3 * 104`

##### 树状数组

```js
/**
 * 树状数组（Binary Indexed Tree / Fenwick Tree）类实现
 * 树状数组是一种支持单点更新和区间查询的数据结构，特别适用于处理前缀和操作
 */

/**
 * 初始化树状数组
 * @param {number[]} nums - 初始数组数据
 * @description 构造函数通过遍历初始数组，调用update方法构建树状数组
 * 时间复杂度：O(n log n)，空间复杂度：O(n)
 */
var NumArray = function (nums) {
  const n = nums.length;
  this.nums = Array(n).fill(0); // 存储原始数组值，用于计算更新时的差值
  // 0-base转换为1-base：树状数组通常使用1索引以简化计算
  this.tree = Array(n + 1).fill(0); // 树状数组，大小为n+1（索引0不使用）
  for (let i = 0; i < n; i++) {
    this.update(i, nums[i]); // 逐个初始化元素，构建树状数组
  }
};

/**
 * 更新指定索引的值
 * @param {number} index - 要更新的元素索引（0-base）
 * @param {number} val - 新的元素值
 * @return {void}
 * @description 计算值的变化量，然后更新树状数组中所有包含该索引的区间
 * 时间复杂度：O(log n)
 */
NumArray.prototype.update = function (index, val) {
  const delta = val - this.nums[index]; // 计算新旧值的差值
  this.nums[index] = val; // 更新原始数组中的值
  // 0-base转换为1-base：将用户传入的0索引转换为树状数组使用的1索引
  for (let i = index + 1; i < this.tree.length; i += i & -i) {
    // i & -i 计算最低位的1所代表的值
    this.tree[i] += delta; // 更新所有包含该位置的区间和
  }
};

/**
 * 计算区间和
 * @param {number} left - 区间左边界（0-base，包含）
 * @param {number} right - 区间右边界（0-base，包含）
 * @return {number} - 区间[left, right]的元素和
 * @description 利用前缀和的性质：区间和 = 右边界前缀和 - 左边界前一个位置的前缀和
 * 时间复杂度：O(log n)
 */
NumArray.prototype.sumRange = function (left, right) {
  // 0-base转换为1-base：计算前缀和时需要将索引加1
  return this.prefixSum(right + 1) - this.prefixSum(left); // 区间和 = sum[0..right] - sum[0..left-1]
};

/**
 * 计算前缀和（树状数组核心操作）
 * @param {number} i - 前缀和的右边界（1-base）
 * @return {number} - 从索引1到i的元素和
 * @description 利用树状数组的性质，累加所有包含在区间[1,i]中的区间和
 * 时间复杂度：O(log n)
 */
NumArray.prototype.prefixSum = function (i) {
  let sum = 0; // 用于存储累加结果
  // i &= i - 1 操作会移除i的二进制表示中最低位的1
  // 例如：1100 (12) & 1011 (11) = 1000 (8)
  for (; i > 0; i &= i - 1) {
    sum += this.tree[i]; // 累加当前区间的值
  }
  return sum; // 返回计算得到的前缀和
};

/**
 * Your NumArray object will be instantiated and called as such:
 * var obj = new NumArray(nums)
 * obj.update(index,val)
 * var param_2 = obj.sumRange(left,right)
 */
```
