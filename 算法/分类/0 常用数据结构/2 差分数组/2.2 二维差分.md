### 二维差分

#### [2536. 子矩阵元素加 1](https://leetcode.cn/problems/increment-submatrices-by-one/description/)
 
给你一个正整数 n ，表示最初有一个 n x n 、下标从 0 开始的整数矩阵 mat ，矩阵中填满了 0 。

另给你一个二维整数数组 query 。针对每个查询 query[i] = [row1i, col1i, row2i, col2i] ，请你执行下述操作：

- 找出 左上角 为 (row1i, col1i) 且 右下角 为 (row2i, col2i) 的子矩阵，将子矩阵中的 每个元素 加 1 。也就是给所有满足 row1i <= x <= row2i 和 col1i <= y <= col2i 的 mat[x][y] 加 1 。

返回执行完所有操作后得到的矩阵 mat 。


```js
/**
 * 对n x n的初始零矩阵执行一系列子矩阵加1操作，并返回最终矩阵
 * @param {number} n - 矩阵的大小（n x n）
 * @param {number[][]} queries - 二维查询数组，每个查询为[row1, col1, row2, col2]，表示子矩阵范围
 * @return {number[][]} 执行所有查询后得到的矩阵
 */
var rangeAddQueries = function (n, queries) {
    // 创建(n+1)x(n+1)的差分数组，多开一行一列避免边界判断
    const diffs = Array.from({ length: n + 1 }, () => Array(n + 1).fill(0));
    
    // 处理每个查询，通过差分数组标记子矩阵加1的范围
    for (let [r1, c1, r2, c2] of queries) {
        // 左上角加1（子矩阵起始位置）
        diffs[r1][c1] += 1;
        // 右下角行+1处减1（子矩阵结束行的下一行）
        diffs[r2 + 1][c1] -= 1;
        // 右下角列+1处减1（子矩阵结束列的下一列）
        diffs[r1][c2 + 1] -= 1;
        // 右下角行+1列+1处加1（抵消双重减1的影响）
        diffs[r2 + 1][c2 + 1] += 1;
    }
    
    // 创建结果矩阵，用于存储前缀和计算后的最终值
    const prefix = Array.from({ length: n }, () => Array(n).fill(0));
    
    // 计算二维前缀和，将差分数组转换为实际矩阵值
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
            // 前缀和公式：当前值 = 上 + 左 - 左上（去重） + 差分数组当前值
            prefix[i][j] = (prefix[i - 1]?.[j] ?? 0) + (prefix[i][j - 1] ?? 0) - (prefix[i-1]?.[j-1] ?? 0) + diffs[i][j];
        }
    }
    
    return prefix;
};

```

#### [2132. 用邮票贴满网格图](https://leetcode.cn/problems/stamping-the-grid/description/)

给你一个 m x n 的二进制矩阵 grid ，每个格子要么为 0 （空）要么为 1 （被占据）。

给你邮票的尺寸为 stampHeight x stampWidth 。我们想将邮票贴进二进制矩阵中，且满足以下 限制 和 要求 ：

- 覆盖所有 空 格子。
- 不覆盖任何 被占据 的格子。
- 我们可以放入任意数目的邮票。
- 邮票可以相互有 重叠 部分。
- 邮票不允许 旋转 。
- 邮票必须完全在矩阵 内 。

如果在满足上述要求的前提下，可以放入邮票，请返回 true ，否则返回 false 。

```js
/**
 * 判断是否可以在给定网格中放置邮票，以覆盖所有空格子且不覆盖被占据格子
 * @param {number[][]} grid - m x n的二进制矩阵，0表示空格子，1表示被占据格子
 * @param {number} stampHeight - 邮票的高度
 * @param {number} stampWidth - 邮票的宽度
 * @return {boolean} 如果能满足条件放置邮票则返回true，否则返回false
 */
var possibleToStamp = function (grid, stampHeight, stampWidth) {
    const m = grid.length, n = grid[0].length;
    // 差分数组：多开2行2列以避免边界判断（stamp可能放置在边缘）
    const diff = Array.from({ length: m + 2 }, () => Array(n + 2).fill(0));
    // 前缀和数组：用于快速判断子矩阵是否全为空（0）
    const prefix = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));

    // 第一步：初始化差分数组（标记被占据格子）并构建前缀和数组
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            // 被占据格子（1）在差分数组中标记为不可覆盖区域
            if (grid[i][j] == 1) {
                diff[i][j] += 1;
                diff[i + 1][j] -= 1;
                diff[i][j + 1] -= 1;
                diff[i + 1][j + 1] += 1;
            }
            // 构建网格的前缀和，用于后续判断子矩阵是否为空
            prefix[i + 1][j + 1] = prefix[i + 1][j] + prefix[i][j + 1] - prefix[i][j] + grid[i][j];
        }
    }

    // 第二步：尝试放置所有可能的邮票，并更新差分数组
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            // 计算邮票右下角坐标（i,j为左上角）
            let ni = i + stampHeight - 1, nj = j + stampWidth - 1;
            // 检查条件：1.邮票在网格内 2.子矩阵[i..ni][j..nj]全为空（前缀和为0）
            if (ni < m && nj < n && prefix[ni + 1][nj + 1] - prefix[ni + 1][j] - prefix[i][nj + 1] + prefix[i][j] == 0) {
                // 在差分数组中标记放置邮票的区域（+1表示覆盖）
                diff[i][j] += 1;
                diff[ni + 1][j] -= 1;
                diff[i][nj + 1] -= 1;
                diff[ni + 1][nj + 1] += 1;
            }
        }
    }

    // 第三步：计算差分数组的前缀和，验证所有格子是否被覆盖
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            // 计算当前格子的覆盖次数（差分数组的二维前缀和）
            grid[i][j] = (grid[i][j - 1] ?? 0) + (grid[i - 1]?.[j] ?? 0) - (grid[i - 1]?.[j - 1] ?? 0) + diff[i][j];
            // 如果存在未覆盖的格子（覆盖次数为0），直接返回false
            if (grid[i][j] == 0) return false;
        }
    }
    // 所有格子均被覆盖，返回true
    return true;
};

```