### 邻项消除

#### 3561. 移除相邻字符
 
给你一个由小写英文字母组成的字符串 s。

你 必须 在字符串 s 中至少存在两个 连续 字符时，反复执行以下操作：

- 移除字符串中 最左边 的一对按照字母表 连续 的相邻字符（无论是按顺序还是逆序，例如 'a' 和 'b'，或 'b' 和 'a'）。
将剩余字符向左移动以填补空隙。
- 当无法再执行任何操作时，返回最终的字符串。

注意：字母表是循环的，因此 'a' 和 'z' 也视为连续。

```js
/**
 * 功能：使用栈结构消除相邻的循环字母对（如ab、ba、yz、za等）
 * 参数：s - 输入字符串（仅包含小写字母）
 * 返回：处理后的字符串
 * 算法思想：
 *   1. 栈匹配消除法（时间复杂度 O(n)）
 *   2. 空间复杂度：O(n)（最坏情况栈存储全部字符）
 */
var resultingString = function (s) {
    const st = [s[0]]; // 初始化栈存储第一个字符

    // 遍历字符串实现邻项检查
    for (let i = 1; i < s.length; i++) {
        // 栈非空时检查相邻字符
        if (st.length && check(s[i], st[st.length - 1])) {
            st.pop(); // 消除相邻字符
        } else {
            st.push(s[i]); // 保留非相邻字符
        }
    }
    return st.join(""); // 将栈中剩余元素拼接为结果
};

/**
 * 辅助函数：检查两个字符是否为循环相邻
 * 参数：a, b - 需要比较的字符
 * 返回：boolean（true表示相邻需要消除）
 * 算法原理：
 *   利用ASCII码差值判断相邻性（差值为1或25时成立）
 */
const check = (a, b) => {
    const code = Math.abs(a.charCodeAt() - b.charCodeAt());
    return code === 1 || code === 25; // 1: 正序相邻，25: z-a特殊情况
};

```

#### [1209. 删除字符串中的所有相邻重复项 II](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string-ii/description/)
 
给你一个字符串 s，「k 倍重复项删除操作」将会从 s 中选择 k 个相邻且相等的字母，并删除它们，使被删去的字符串的左侧和右侧连在一起。

你需要对 s 重复进行无限次这样的删除操作，直到无法继续为止。

在执行完所有删除操作后，返回最终得到的字符串。

本题答案保证唯一。

**题解：**

用栈存储[字符， 字符连续出现的次数]：
- 遍历字符串，若当前字符与栈顶字符相同，栈顶字符次数加一，否则入栈[当前字符，1]
- 若栈顶字符次数等于k，弹出栈顶字符
- 遍历结束，栈中剩余字符即为结果

```js
/**
 * 使用栈结构实现邻项消除算法
 * @param {string} s - 待处理的原始字符串
 * @param {number} k - 需要消除的连续相同字符阈值
 * @returns {string} - 处理后的字符串
 * @时间复杂度 O(n) 每个字符入栈/出栈操作一次
 * @空间复杂度 O(n) 最坏情况下栈存储全部字符
 */
var removeDuplicates = function (s, k) {
    // 使用栈记录[字符，当前连续计数]
    const st = [];
    
    // 第一遍遍历：构建字符计数栈
    for (let ch of s) {
        // 栈顶字符与当前字符相同
        if (ch === st[st.length - 1]?.[0]) {
            // 达到消除阈值
            if (st[st.length - 1][1] + 1 === k) {
                st.pop();  // 消除当前字符序列
            } else {
                st[st.length - 1][1]++;  // 增加连续计数
            }
        } else {
            st.push([ch, 1]);  // 新字符入栈
        }
    }

    // 第二遍遍历：重构结果字符串
    let ans = "";
    for (let [ch, cnt] of st) {
        ans += ch.repeat(cnt);  // 根据计数展开字符
    }
    
    return ans;
};

```

#### [735. 小行星碰撞](https://leetcode.cn/problems/asteroid-collision/description/)
 
给定一个整数数组 asteroids，表示在同一行的小行星。数组中小行星的索引表示它们在空间中的相对位置。

对于数组中的每一个元素，其绝对值表示小行星的大小，正负表示小行星的移动方向（正表示向右移动，负表示向左移动）。每一颗小行星以相同的速度移动。

找出碰撞后剩下的所有小行星。碰撞规则：两个小行星相互碰撞，较小的小行星会爆炸。如果两颗小行星大小相同，则两颗小行星都会爆炸。两颗移动方向相同的小行星，永远不会发生碰撞。


```js
/**
 * 使用栈结构解决小行星碰撞问题
 * @param {number[]} asteroids - 小行星数组（包含正负值表示移动方向）
 * @return {number[]} - 碰撞后剩余的小行星数组
 * @时间复杂度 O(n) 每个元素最多入栈出栈各一次
 * @空间复杂度 O(n) 最坏情况需要存储所有小行星
 */
var asteroidCollision = function(asteroids) {
    const n = asteroids.length;
    const st = []; // 存储存活小行星的栈

    // 遍历所有小行星
    for (let i = 0; i < n; i++) {
        let alive = true; // 当前小行星是否存活标志
        
        // 碰撞条件判断：栈顶向右(>0)且当前向左(<0)
        while (alive && (st[st.length - 1] > 0 && asteroids[i] < 0)) {
            // 比较绝对值大小决定存活状态
            alive = st[st.length - 1] < -asteroids[i];
            
            // 栈顶小行星较小则消除
            if (st[st.length - 1] <= -asteroids[i]) {
                st.pop(); // 移除被摧毁的栈顶小行星
            }
        }
        
        // 经过所有碰撞后仍存活则入栈
        if (alive) {
            st.push(asteroids[i]);
        }
    }
    
    return st; // 返回最终存活的小行星序列
};

```

#### 1717. 删除子字符串的最大得分
 
给你一个字符串 s 和两个整数 x 和 y 。你可以执行下面两种操作任意次。

- 删除子字符串 "ab" 并得到 x 分。
    - 比方说，从 "cabxbae" 删除 ab ，得到 "cxbae" 。
- 删除子字符串"ba" 并得到 y 分。
    - 比方说，从 "cabxbae" 删除 ba ，得到 "cabxe" 。

请返回对 s 字符串执行上面操作若干次能得到的最大得分。

##### 栈

```js
/**
 * 双栈贪心算法实现最大增益计算
 * @param {string} s - 包含'a'和'b'的输入字符串
 * @param {number} x - 'ab'组合的得分
 * @param {number} y - 'ba'组合的得分
 * @return {number} - 可获得的最大分数
 * @时间复杂度 O(n) 两次线性遍历
 * @空间复杂度 O(n) 双栈存储最坏情况
 */
var maximumGain = function (s, x, y) {
    const n = s.length;
    // 第一阶段：优先处理高价值组合
    let target = x > y ? 'ab' : 'ba';
    let score = Math.max(x, y);
    const stack = []; // 存储字符索引的栈

    let ans = 0;
    // 第一次遍历处理高优先级组合
    for (let i = 0; i < n; i++) {
        // 栈顶元素与当前字符形成目标组合
        if (stack.length && (s[stack[stack.length - 1]] + s[i] === target)) {
            stack.pop(); // 消除组合获取分数
            ans += score;
        } else {
            stack.push(i); // 保留当前字符索引
        }
    }

    // 第二阶段：处理剩余低价值组合
    target = x > y ? 'ba' : 'ab';
    score = Math.min(x, y);
    const stack2 = [];
    
    // 遍历第一阶段剩余字符
    for (const idx of stack) {
        // 栈顶元素与当前字符形成次优组合
        if (stack2.length && s[stack2[stack2.length - 1]] + s[idx] === target) {
            stack2.pop();
            ans += score;
        } else {
            stack2.push(idx);
        }
    }

    return ans;
};

```

##### 贪心

```js
/**
 * 计算从字符串 s 中移除 "ab" 或 "ba" 子串所能获得的最大分数。
 * @param {string} s - 输入的字符串，包含字符 'a' 和 'b' 以及其他字符。
 * @param {number} x - 移除子串 "ab" 可获得的分数。
 * @param {number} y - 移除子串 "ba" 可获得的分数。
 * @return {number} - 所能获得的最大分数。
 */
var maximumGain = function (s, x, y) {
    // mxS为优先移除的子串字符(ab / ba)中的第二个字符
    let mnS = x > y ? 'a' : 'b', mxS = x > y ? 'b' : 'a', 
        // 记录较小的分数
        mnScore = Math.min(x, y), 
        // 记录较大的分数
        mxScore = Math.max(x, y); 
    // 初始化最终得分
    let ans = 0, 
        // 记录字符 mnS 的计数
        cntMn = 0, 
        // 记录字符 mxS 的计数
        cntMx = 0; 

    // 遍历字符串 s 中的每个字符
    for (let i of s) {
        // 如果当前字符既不是 mnS 也不是 mxS
        if (i !== mnS && i !== mxS) {
            // 累加剩余 mnS 和 mxS 能组成的最小对子数乘以较小分数
            ans += Math.min(cntMn, cntMx) * mnScore; 
            // 重置 mnS 和 mxS 的计数
            cntMn = 0, cntMx = 0; 
            // 跳过本次循环，继续下一个字符
            continue; 
        }

        // 如果当前字符是 mxS
        if (i === mxS) {
            // 如果 mnS 的计数大于 0，说明可以组成分数较大的子串
            if (cntMn > 0) {
                // 累加较大分数
                ans += mxScore; 
                // mnS 的计数减 1
                cntMn -= 1; 
            } else {
                // 若 mnS 计数为 0，mxS 计数加 1
                cntMx += 1; 
            }
        } else {
            // 若当前字符是 mnS，mnS 计数加 1
            cntMn += 1; 
        }
    }
    // 处理遍历结束后剩余的 mnS 和 mxS，累加它们能组成的最小对子数乘以较小分数
    return ans + Math.min(cntMn, cntMx) * mnScore; 
};
```

#### [2197. 替换数组中的非互质数](https://leetcode.cn/problems/replace-non-coprime-numbers-in-array/description/)
 
给你一个整数数组 nums 。请你对数组执行下述操作：

- 从 nums 中找出 任意 两个 相邻 的 非互质 数。
- 如果不存在这样的数，终止 这一过程。
- 否则，删除这两个数，并 替换 为它们的 最小公倍数（Least Common Multiple，LCM）。
- 只要还能找出两个相邻的非互质数就继续 重复 这一过程。

返回修改后得到的 最终 数组。可以证明的是，以 任意 顺序替换相邻的非互质数都可以得到相同的结果。

生成的测试用例可以保证最终数组中的值 小于或者等于 10^8 。

两个数字 x 和 y 满足 非互质数 的条件是：GCD(x, y) > 1 ，其中 GCD(x, y) 是 x 和 y 的 最大公约数 。

**栈**
```js
/**
 * 栈结构实现非互质邻项合并算法
 * @param {number[]} nums - 输入整数数组
 * @return {number[]} - 合并后的数组
 * @时间复杂度 O(n) 每个元素最多入栈出栈各一次
 * @空间复杂度 O(n) 栈存储最坏情况
 */
var replaceNonCoprimes = function(nums) {
    const st = []; // 使用数组模拟栈结构
    
    // 遍历处理每个元素
    for (let i of nums) {
        let curr = i; // 当前待处理值
        
        // 合并非互质邻项（栈非空且gcd>1）
        while (st.length && gcd(curr, st[st.length - 1]) > 1) {
            curr = LCM(curr, st.pop()); // 弹出栈顶并计算最小公倍数
        }
        st.push(curr); // 将合并结果压入栈
    }
    
    return st; // 返回最终栈内容
};

/**
 * 欧几里得算法求最大公约数
 * @param {number} x - 第一个操作数
 * @param {number} y - 第二个操作数
 * @return {number} - x和y的最大公约数
 * @时间复杂度 O(log min(x,y))
 */
const gcd = (x, y) => {
    while (y !== 0) {
        let t = x % y; // 计算余数
        x = y;          // 更新x为除数
        y = t;          // 更新y为余数
    }
    return x;
}

/**
 * 计算最小公倍数
 * @param {number} x - 第一个操作数
 * @param {number} y - 第二个操作数
 * @return {number} - x和y的最小公倍数
 * @数学公式 LCM(x,y) = x*y / GCD(x,y)
 */
const LCM = (x, y) => x * y / gcd(x, y);

```


**原地模拟栈：**

```js
/**
 * 原地替换非互质相邻数算法
 * @param {number[]} nums - 输入整数数组
 * @return {number[]} - 处理后的数组
 * @时间复杂度 O(n) 每个元素最多处理两次
 * @空间复杂度 O(1) 原地修改输入数组
 */
var replaceNonCoprimes = function(nums) {
    let p = -1; // 模拟栈指针，指向最后一个有效元素
    
    // 遍历处理所有元素
    for (let i of nums) {
        let curr = i; // 当前待处理值
        
        // 合并相邻非互质数（栈非空且gcd>1）
        while (p >= 0 && gcd(curr, nums[p]) > 1) {
            curr = LCM(curr, nums[p--]); // 弹出栈顶并计算LCM
        }
        nums[++p] = curr; // 将合并结果压入栈
    }
    
    // 截断数组到有效长度
    nums.length = p + 1;
    return nums;
};

/**
 * 欧几里得算法求最大公约数
 * @param {number} x - 第一个数
 * @param {number} y - 第二个数
 * @return {number} - 最大公约数
 * @时间复杂度 O(log min(x,y))
 */
const gcd = (x, y) => {
    while (y !== 0) {
        let t = x % y; // 取模运算
        x = y;         // 更新x为前一步的y
        y = t;         // 更新y为余数
    }
    return x;
}

/**
 * 计算最小公倍数
 * @param {number} x - 第一个数
 * @param {number} y - 第二个数
 * @return {number} - 最小公倍数
 * @数学原理 LCM(x,y) = x*y / GCD(x,y)
 */
const LCM = (x, y) => x * y / gcd(x, y);

```