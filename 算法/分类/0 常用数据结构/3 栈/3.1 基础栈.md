### 基础栈


#### [844. 比较含退格的字符串](https://leetcode.cn/problems/backspace-string-compare/description/)
 
给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 true 。# 代表退格字符。

注意：如果对空文本输入退格字符，文本继续为空。

##### 栈模拟

```js
/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */
var backspaceCompare = function (s, t) {
    const s1 = [], s2 = [];
    for (let i = 0; i < s.length; i++) {
        if (s[i] === "#") {
            s1.pop()
        } else {
            s1.push(s[i])
        }
    }
    for (let i = 0; i < t.length; i++) {
        if (t[i] === "#") {
            s2.pop()
        } else {
            s2.push(t[i])
        }
    }
    return s1.join() === s2.join();
};
```

##### 双指针

```js
/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */
// 双指针解法：从字符串末尾向前遍历，高效处理退格字符
var backspaceCompare = function (s, t) {
    // 初始化双指针，分别指向两个字符串的末尾
    let p1 = s.length - 1, p2 = t.length - 1;
    
    // 当任一字符串还有未处理的字符时，继续循环
    while (p1 >= 0 || p2 >= 0) {
        // c1和c2用于记录需要跳过的字符数（退格计数）
        let c1 = 0, c2 = 0;
        
        // 处理字符串s的退格：找到下一个有效字符
        // 循环条件：指针未越界 且 (当前是退格符 或 还有未处理的退格计数)
        while (p1 >= 0 && (s[p1] === "#" || c1 !== 0)) {
            if (s[p1] === "#") {
                c1++; // 遇到退格符，增加需要跳过的字符数
            } else {
                c1--; // 遇到普通字符，消耗一个退格计数（跳过当前字符）
            }
            p1--; // 移动指针向前
        }
        
        // 处理字符串t的退格：找到下一个有效字符（逻辑同上）
        while (p2 >= 0 && (t[p2] === "#" || c2 !== 0)) {
            if (t[p2] === "#") {
                c2++; // 遇到退格符，增加需要跳过的字符数
            } else {
                c2--; // 遇到普通字符，消耗一个退格计数（跳过当前字符）
            }
            p2--; // 移动指针向前
        }
        
        // 比较当前有效字符，若不相等则直接返回false
        if (s[p1] !== t[p2]) {
            return false;
        }
        
        // 移动指针继续比较前一个字符
        p1--;
        p2--;
    }
    
    // 若两个指针都遍历完所有字符，则返回true
    return true;
};

```

#### [1472. 设计浏览器历史记录](https://leetcode.cn/problems/design-browser-history/description/)
 
你有一个只支持单个标签页的 浏览器 ，最开始你浏览的网页是 homepage ，你可以访问其他的网站 url ，也可以在浏览历史中后退 steps 步或前进 steps 步。

请你实现 BrowserHistory 类：

- BrowserHistory(string homepage) ，用 homepage 初始化浏览器类。
- void visit(string url) 从当前页跳转访问 url 对应的页面  。执行此操作会把浏览历史前进的记录全部删除。
- string back(int steps) 在浏览历史中后退 steps 步。如果你只能在浏览历史中后退至多 x 步且 steps > x ，那么你只后退 x 步。请返回后退 至多 steps 步以后的 url 。
- string forward(int steps) 在浏览历史中前进 steps 步。如果你只能在浏览历史中前进至多 x 步且 steps > x ，那么你只前进 x 步。请返回前进 至多 steps步以后的 url 。

```js
/**
 * @param {string} homepage
 */
var BrowserHistory = function (homepage) {
    // 初始化浏览历史栈，首页作为初始元素
    this.stack = [homepage];
    // 当前页面在栈中的索引（初始指向首页）
    this.idx = 0;
};

/** 
 * @param {string} url
 * @return {void}
 */
BrowserHistory.prototype.visit = function (url) {
    // 1. 清除前进历史：截断栈至当前索引+1（删除当前页之后的所有记录）
    this.stack.length = this.idx + 1;
    // 2. 将新页面添加到历史栈
    this.stack.push(url);
    // 3. 更新当前索引为新页面位置（栈顶）
    this.idx = this.stack.length - 1;
    return url;
};

/** 
 * @param {number} steps
 * @return {string}
 */
BrowserHistory.prototype.back = function (steps) {
    // 计算后退后的索引：确保不小于0（防止超出历史记录起点）
    this.idx = Math.max(0, this.idx - steps);
    // 返回后退后当前页面的URL
    return this.stack[this.idx];
};

/** 
 * @param {number} steps
 * @return {string}
 */
BrowserHistory.prototype.forward = function (steps) {
    // 计算前进后的索引：确保不大于栈末尾（防止超出历史记录终点）
    this.idx = Math.min(this.stack.length - 1, this.idx + steps);
    // 返回前进后当前页面的URL
    return this.stack[this.idx];
};


/** 
 * Your BrowserHistory object will be instantiated and called as such:
 * var obj = new BrowserHistory(homepage)
 * obj.visit(url)
 * var param_2 = obj.back(steps)
 * var param_3 = obj.forward(steps)
 */
```

#### [946. 验证栈序列](https://leetcode.cn/problems/validate-stack-sequences/description/)
 
给定 pushed 和 popped 两个序列，每个序列中的 值都不重复，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 true；否则，返回 false 。

