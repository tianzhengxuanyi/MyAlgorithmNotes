### 进阶

#### [3170. 删除星号以后字典序最小的字符串](https://leetcode.cn/problems/lexicographically-minimum-string-after-removing-stars/description/)
 
给你一个字符串 s 。它可能包含任意数量的 '*' 字符。你的任务是删除所有的 '*' 字符。

当字符串还存在至少一个 '*' 字符时，你可以执行以下操作：

删除最左边的 '*' 字符，同时删除该星号字符左边一个字典序 最小 的字符。如果有多个字典序最小的字符，你可以删除它们中的任意一个。
请你返回删除所有 '*' 字符以后，剩余字符连接而成的 字典序最小 的字符串。

给你一个字符串 s 。它可能包含任意数量的 '*' 字符。你的任务是删除所有的 '*' 字符。

当字符串还存在至少一个 '*' 字符时，你可以执行以下操作：

- 删除最左边的 '*' 字符，同时删除该星号字符左边一个字典序 最小 的字符。如果有多个字典序最小的字符，你可以删除它们中的任意一个。

请你返回删除所有 '*' 字符以后，剩余字符连接而成的 字典序最小 的字符串。

**单调栈：**

每次遇见*时，需要弹出左边字典序最小的字符，如果有多个字典序最小的字符，弹出最靠右边的字符。

对于26个字母，每个字母都维护一个单调栈，栈顶元素为当前字母的最靠右边的位置。

每次遇见*时，遍历26个字母，找到字典序最小的字母，弹出栈顶元素。

```js
/**
 * @param {string} s
 * @return {string}
 */
var clearStars = function(s) {
    const n = s.length;
    const cnt = Array.from({length: 26}, () => []); // 26字母的索引栈（a-z）
    const arr = s.split("") // 转换为数组便于修改
    
    // 第一遍遍历处理星号
    for (let i = 0; i < n; i++) {
        if (arr[i] === '*') {
            // 寻找最小字典序的非空字符栈
            for (let j = 0; j < 26; j++) {
                if (cnt[j].length > 0) {
                    arr[cnt[j].pop()] = '*' // 标记要删除的字符
                    break;
                }
            }
        } else {
            // 记录字符索引到对应字母的栈
            cnt[arr[i].charCodeAt() - 97].push(i);
        }
    }

    // 构建最终结果（过滤星号）
    let ans = '';
    for (let i of arr) {
        if (i !== '*') ans += i;
    }

    return ans;
};
```

#### [155. 最小栈](https://leetcode.cn/problems/min-stack/description/)
 
设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。

实现 MinStack 类:

- MinStack() 初始化堆栈对象。
- void push(int val) 将元素val推入堆栈。
- void pop() 删除堆栈顶部的元素。
- int top() 获取堆栈顶部的元素。
- int getMin() 获取堆栈中的最小元素。

```js
/**
 * 最小栈数据结构实现，支持常数时间内获取最小值
 * 核心思想：使用栈存储[值, 当前最小值]的二元组，每次操作维护最小值信息
 */
var MinStack = function() {
    // 初始化栈，存储格式为 [值, 当前最小值]
    // 初始元素为哨兵节点，[0, Infinity] 中 Infinity 作为初始最小值的基准
    this.st = [[0, Infinity]];
};

/** 
 * @param {number} val - 要推入栈的元素值
 * @return {void}
 * 推入元素时，同步记录当前栈中的最小值（当前值与栈顶存储的最小值中的较小者）
 */
MinStack.prototype.push = function(val) {
    // 新元素的最小值 = min(当前值, 栈顶元素记录的最小值)
    this.st.push([val, Math.min(val, this.getMin())]);
};

/**
 * @return {void}
 * 弹出栈顶元素，由于栈顶元素存储了当时的最小值，弹出后栈顶自动恢复为上一个状态的最小值
 */
MinStack.prototype.pop = function() {
    this.st.pop();
};

/**
 * @return {number} - 栈顶元素的值
 * 获取栈顶元素的值（二元组的第一个元素）
 */
MinStack.prototype.top = function() {
    return this.st[this.st.length - 1][0];
};

/**
 * @return {number} - 当前栈中的最小值
 * 获取栈顶元素存储的最小值（二元组的第二个元素），实现O(1)时间复杂度
 */
MinStack.prototype.getMin = function() {
    return this.st[this.st.length - 1][1];
};

/** 
 * Your MinStack object will be instantiated and called as such:
 * var obj = new MinStack()
 * obj.push(val)
 * obj.pop()
 * var param_3 = obj.top()
 * var param_4 = obj.getMin()
 */

```

#### [1381. 设计一个支持增量操作的栈](https://leetcode.cn/problems/design-a-stack-with-increment-operation/description/)
 
请你设计一个支持对其元素进行增量操作的栈。

实现自定义栈类 CustomStack ：

- CustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量。
- void push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。
- int pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。
- void inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。

```js
/**
 * 支持增量操作的自定义栈实现
 * 核心思想：通过辅助数组记录增量值，避免对栈底元素直接修改，实现高效的批量增量操作
 */

/**
 * @param {number} maxSize - 栈的最大容量
 * 构造函数初始化栈的存储结构、增量跟踪数组和栈顶指针
 * - st: 存储栈元素的数组，容量为 maxSize
 * - addVal: 辅助数组，用于记录增量值，避免频繁修改栈底元素
 * - top: 栈顶指针，初始为 -1 表示栈为空
 */
var CustomStack = function(maxSize) {
    this.st = Array(maxSize);
    this.addVal = Array(maxSize).fill(0);
    this.top = -1;
};

/** 
 * @param {number} x - 要推入栈的元素值
 * @return {void}
 * 向栈顶推入元素，仅当栈未满时执行
 * 栈满条件：栈顶指针等于数组最后一个索引（st.length - 1）
 */
CustomStack.prototype.push = function(x) {
    if (this.top == (this.st.length - 1)) return;
    this.st[++this.top] = x;
};

/**
 * @return {number} - 栈顶元素值（若栈空返回 -1）
 * 弹出栈顶元素并返回其实际值（原始值 + 累积增量）
 * 核心逻辑：
 * 1. 栈空时直接返回 -1
 * 2. 计算当前栈顶元素的实际值：原始值（st[top]）+ 该位置累积的增量（addVal[top]）
 * 3. 弹出后若栈非空，将当前位置的增量值传递给新栈顶（确保后续弹出时能正确累加）
 * 4. 重置弹出位置的增量值为 0（避免影响后续操作）
 */
CustomStack.prototype.pop = function() {
    if (this.top == -1) return -1;
    let ret = this.st[this.top] + this.addVal[this.top];
    this.top--;
    if (this.top >= 0) {
        this.addVal[this.top] += this.addVal[this.top + 1];
    }
    this.addVal[this.top + 1] = 0;
    return ret;
};

/** 
 * @param {number} k - 要增量的栈底元素数量（从栈底向上数 k 个）
 * @param {number} val - 增量值
 * @return {void}
 * 对栈底的 k 个元素（或所有元素，若栈元素不足 k 个）执行增量操作
 * 核心优化：通过 addVal 数组记录增量，仅在对应边界位置累加，避免遍历修改多个元素
 * - limit: 确定增量操作的边界索引（取 k-1 和当前栈顶索引的最小值）
 * - 当 limit 有效（>=0）时，在 addVal[limit] 处累加增量值，后续弹出时自动传递
 */
CustomStack.prototype.increment = function(k, val) {
    let limit = Math.min(k - 1, this.top);
    if (limit >= 0) {
        this.addVal[limit] += val;
    }
};

/** 
 * Your CustomStack object will be instantiated and called as such:
 * var obj = new CustomStack(maxSize)
 * obj.push(x)
 * var param_2 = obj.pop()
 * obj.increment(k,val)
 */

```

#### [636. 函数的独占时间](https://leetcode.cn/problems/exclusive-time-of-functions/description/)
 
有一个 单线程 CPU 正在运行一个含有 n 道函数的程序。每道函数都有一个位于  0 和 n-1 之间的唯一标识符。

函数调用 存储在一个 调用栈 上 ：当一个函数调用开始时，它的标识符将会推入栈中。而当一个函数调用结束时，它的标识符将会从栈中弹出。标识符位于栈顶的函数是 当前正在执行的函数 。每当一个函数开始或者结束时，将会记录一条日志，包括函数标识符、是开始还是结束、以及相应的时间戳。

给你一个由日志组成的列表 logs ，其中 logs[i] 表示第 i 条日志消息，该消息是一个按 "{function_id}:{"start" | "end"}:{timestamp}" 进行格式化的字符串。例如，"0:start:3" 意味着标识符为 0 的函数调用在时间戳 3 的 起始开始执行 ；而 "1:end:2" 意味着标识符为 1 的函数调用在时间戳 2 的 末尾结束执行。注意，函数可以 调用多次，可能存在递归调用 。

函数的 独占时间 定义是在这个函数在程序所有函数调用中执行时间的总和，调用其他函数花费的时间不算该函数的独占时间。例如，如果一个函数被调用两次，一次调用执行 2 单位时间，另一次调用执行 1 单位时间，那么该函数的 独占时间 为 2 + 1 = 3 。

以数组形式返回每个函数的 独占时间 ，其中第 i 个下标对应的值表示标识符 i 的函数的独占时间。

```js
/**
 * 计算函数的独占时间总和
 * @param {number} n - 函数总数（标识符范围为 0 到 n-1）
 * @param {string[]} logs - 日志数组，每条日志格式为 "{function_id}:{start|end}:{timestamp}"
 * @return {number[]} - 每个函数的独占时间总和，索引对应函数标识符
 * 
 * 核心思路：使用栈记录函数调用层级，通过时间戳差值计算各函数执行时间
 * 独占时间定义：函数自身执行的时间，不包含其调用的子函数执行时间
 */
var exclusiveTime = function(n, logs) {
    const st = [];                  // 函数调用栈，存储当前活跃的函数标识符（调用未结束）
    const ans = Array(n).fill(0);   // 结果数组，记录每个函数的独占时间总和
    let prevT = 0;                  // 上一个日志的时间戳，用于计算时间差

    // 遍历每条日志，处理函数开始或结束事件
    for (let log of logs) {
        // 解析日志：分割为函数ID、事件类型（start/end）、时间戳
        let curr = log.split(":");
        let ts = curr[2] - 0,       // 当前日志的时间戳（转为数字）
            idx = curr[0],          // 当前函数标识符
            type = curr[1];         // 事件类型（start/end）

        if (type === "end") {
            // 处理函数结束事件：
            // 1. 计算当前函数从prevT到ts的执行时间（+1是因为end时间戳包含在执行时间内）
            ans[idx] += ts - prevT + 1;
            // 2. 更新prevT为下一个时间片的开始（当前结束时间+1）
            prevT = ts + 1;
            // 3. 函数执行结束，从调用栈弹出
            st.pop();
        } else {
            // 处理函数开始事件：
            // 1. 若栈不为空，说明有父函数在执行，累加父函数的独占时间（从prevT到当前开始时间）
            if (st.length) {
                ans[st[st.length - 1]] += ts - prevT;
            }
            // 2. 更新prevT为当前开始时间
            prevT = ts;
            // 3. 将当前函数压入调用栈，表示开始执行
            st.push(idx);
        }
    }

    return ans;
};

```

#### [895. 最大频率栈](https://leetcode.cn/problems/maximum-frequency-stack/description/)
 
设计一个类似堆栈的数据结构，将元素推入堆栈，并从堆栈中弹出出现频率最高的元素。

实现 FreqStack 类:

- FreqStack() 构造一个空的堆栈。
- void push(int val) 将一个整数 val 压入栈顶。
- int pop() 删除并返回堆栈中出现频率最高的元素。

如果出现频率最高的元素不只一个，则移除并返回最接近栈顶的元素。

```js
/**
 * 最大频率栈实现
 * 特点：支持弹出出现频率最高的元素，若多个元素频率相同则弹出最近添加的元素
 * 核心设计：使用频率分层存储结构，每个频率对应一个栈，实现高效的频率跟踪和元素访问
 */
var FreqStack = function () {
    this.st = [];          // 二维数组，st[cnt]表示频率为cnt的元素栈，栈内保持插入顺序
    this.map = new Map();  // 元素频率映射表，key:元素值，value:该元素当前的频率
    this.max = -1;         // 当前最大频率值，用于快速定位最高频率栈
};

/**
 * @param {number} val - 要压入栈的元素值
 * @return {void}
 * 压栈逻辑：
 * 1. 更新元素频率：若元素不存在则初始化为1，否则频率+1
 * 2. 更新最大频率：如果当前元素新频率大于max，则更新max
 * 3. 分层存储：将元素添加到对应频率层的栈中（若该频率层不存在则创建）
 */
FreqStack.prototype.push = function (val) {
    // 更新元素频率，使用空值合并运算符处理首次出现的元素
    this.map.set(val, (this.map.get(val) ?? 0) + 1);
    let cnt = this.map.get(val);
    
    // 更新最大频率
    if (cnt > this.max) {
        this.max = cnt;
    }
    
    // 确保频率层数组存在，然后将元素加入对应频率的栈
    !this.st[cnt] && (this.st[cnt] = []);
    this.st[cnt].push(val);
};

/**
 * @return {number} - 弹出的元素值（频率最高且最近添加的）
 * 弹栈逻辑：
 * 1. 从当前最高频率栈弹出栈顶元素（最近添加的）
 * 2. 更新该元素的频率（减1）
 * 3. 维护最大频率：若最高频率栈为空，则将max减1
 */
FreqStack.prototype.pop = function () {
    // 从最高频率栈弹出最近添加的元素
    let res = this.st[this.max].pop();
    
    // 更新该元素的频率
    this.map.set(res, (this.map.get(res) - 1));
    
    // 若最高频率栈已空，更新max为当前最大频率
    if (this.st[this.max].length == 0) {
        this.max--;
    }
    
    return res;
};

/**
 * Your FreqStack object will be instantiated and called as such:
 * var obj = new FreqStack()
 * obj.push(val)
 * var param_2 = obj.pop()
 */

```