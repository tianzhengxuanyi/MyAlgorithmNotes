### 进阶

#### [3170. 删除星号以后字典序最小的字符串](https://leetcode.cn/problems/lexicographically-minimum-string-after-removing-stars/description/)
 
给你一个字符串 s 。它可能包含任意数量的 '*' 字符。你的任务是删除所有的 '*' 字符。

当字符串还存在至少一个 '*' 字符时，你可以执行以下操作：

删除最左边的 '*' 字符，同时删除该星号字符左边一个字典序 最小 的字符。如果有多个字典序最小的字符，你可以删除它们中的任意一个。
请你返回删除所有 '*' 字符以后，剩余字符连接而成的 字典序最小 的字符串。

给你一个字符串 s 。它可能包含任意数量的 '*' 字符。你的任务是删除所有的 '*' 字符。

当字符串还存在至少一个 '*' 字符时，你可以执行以下操作：

- 删除最左边的 '*' 字符，同时删除该星号字符左边一个字典序 最小 的字符。如果有多个字典序最小的字符，你可以删除它们中的任意一个。

请你返回删除所有 '*' 字符以后，剩余字符连接而成的 字典序最小 的字符串。

**单调栈：**

每次遇见*时，需要弹出左边字典序最小的字符，如果有多个字典序最小的字符，弹出最靠右边的字符。

对于26个字母，每个字母都维护一个单调栈，栈顶元素为当前字母的最靠右边的位置。

每次遇见*时，遍历26个字母，找到字典序最小的字母，弹出栈顶元素。

```js
/**
 * @param {string} s
 * @return {string}
 */
var clearStars = function(s) {
    const n = s.length;
    const cnt = Array.from({length: 26}, () => []); // 26字母的索引栈（a-z）
    const arr = s.split("") // 转换为数组便于修改
    
    // 第一遍遍历处理星号
    for (let i = 0; i < n; i++) {
        if (arr[i] === '*') {
            // 寻找最小字典序的非空字符栈
            for (let j = 0; j < 26; j++) {
                if (cnt[j].length > 0) {
                    arr[cnt[j].pop()] = '*' // 标记要删除的字符
                    break;
                }
            }
        } else {
            // 记录字符索引到对应字母的栈
            cnt[arr[i].charCodeAt() - 97].push(i);
        }
    }

    // 构建最终结果（过滤星号）
    let ans = '';
    for (let i of arr) {
        if (i !== '*') ans += i;
    }

    return ans;
};
```

#### [155. 最小栈](https://leetcode.cn/problems/min-stack/description/)
 
设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。

实现 MinStack 类:

- MinStack() 初始化堆栈对象。
- void push(int val) 将元素val推入堆栈。
- void pop() 删除堆栈顶部的元素。
- int top() 获取堆栈顶部的元素。
- int getMin() 获取堆栈中的最小元素。

```js
/**
 * 最小栈数据结构实现，支持常数时间内获取最小值
 * 核心思想：使用栈存储[值, 当前最小值]的二元组，每次操作维护最小值信息
 */
var MinStack = function() {
    // 初始化栈，存储格式为 [值, 当前最小值]
    // 初始元素为哨兵节点，[0, Infinity] 中 Infinity 作为初始最小值的基准
    this.st = [[0, Infinity]];
};

/** 
 * @param {number} val - 要推入栈的元素值
 * @return {void}
 * 推入元素时，同步记录当前栈中的最小值（当前值与栈顶存储的最小值中的较小者）
 */
MinStack.prototype.push = function(val) {
    // 新元素的最小值 = min(当前值, 栈顶元素记录的最小值)
    this.st.push([val, Math.min(val, this.getMin())]);
};

/**
 * @return {void}
 * 弹出栈顶元素，由于栈顶元素存储了当时的最小值，弹出后栈顶自动恢复为上一个状态的最小值
 */
MinStack.prototype.pop = function() {
    this.st.pop();
};

/**
 * @return {number} - 栈顶元素的值
 * 获取栈顶元素的值（二元组的第一个元素）
 */
MinStack.prototype.top = function() {
    return this.st[this.st.length - 1][0];
};

/**
 * @return {number} - 当前栈中的最小值
 * 获取栈顶元素存储的最小值（二元组的第二个元素），实现O(1)时间复杂度
 */
MinStack.prototype.getMin = function() {
    return this.st[this.st.length - 1][1];
};

/** 
 * Your MinStack object will be instantiated and called as such:
 * var obj = new MinStack()
 * obj.push(val)
 * obj.pop()
 * var param_3 = obj.top()
 * var param_4 = obj.getMin()
 */

```

#### [1381. 设计一个支持增量操作的栈](https://leetcode.cn/problems/design-a-stack-with-increment-operation/description/)
 
请你设计一个支持对其元素进行增量操作的栈。

实现自定义栈类 CustomStack ：

- CustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量。
- void push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。
- int pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。
- void inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。

```js
/**
 * 支持增量操作的自定义栈实现
 * 核心思想：通过辅助数组记录增量值，避免对栈底元素直接修改，实现高效的批量增量操作
 */

/**
 * @param {number} maxSize - 栈的最大容量
 * 构造函数初始化栈的存储结构、增量跟踪数组和栈顶指针
 * - st: 存储栈元素的数组，容量为 maxSize
 * - addVal: 辅助数组，用于记录增量值，避免频繁修改栈底元素
 * - top: 栈顶指针，初始为 -1 表示栈为空
 */
var CustomStack = function(maxSize) {
    this.st = Array(maxSize);
    this.addVal = Array(maxSize).fill(0);
    this.top = -1;
};

/** 
 * @param {number} x - 要推入栈的元素值
 * @return {void}
 * 向栈顶推入元素，仅当栈未满时执行
 * 栈满条件：栈顶指针等于数组最后一个索引（st.length - 1）
 */
CustomStack.prototype.push = function(x) {
    if (this.top == (this.st.length - 1)) return;
    this.st[++this.top] = x;
};

/**
 * @return {number} - 栈顶元素值（若栈空返回 -1）
 * 弹出栈顶元素并返回其实际值（原始值 + 累积增量）
 * 核心逻辑：
 * 1. 栈空时直接返回 -1
 * 2. 计算当前栈顶元素的实际值：原始值（st[top]）+ 该位置累积的增量（addVal[top]）
 * 3. 弹出后若栈非空，将当前位置的增量值传递给新栈顶（确保后续弹出时能正确累加）
 * 4. 重置弹出位置的增量值为 0（避免影响后续操作）
 */
CustomStack.prototype.pop = function() {
    if (this.top == -1) return -1;
    let ret = this.st[this.top] + this.addVal[this.top];
    this.top--;
    if (this.top >= 0) {
        this.addVal[this.top] += this.addVal[this.top + 1];
    }
    this.addVal[this.top + 1] = 0;
    return ret;
};

/** 
 * @param {number} k - 要增量的栈底元素数量（从栈底向上数 k 个）
 * @param {number} val - 增量值
 * @return {void}
 * 对栈底的 k 个元素（或所有元素，若栈元素不足 k 个）执行增量操作
 * 核心优化：通过 addVal 数组记录增量，仅在对应边界位置累加，避免遍历修改多个元素
 * - limit: 确定增量操作的边界索引（取 k-1 和当前栈顶索引的最小值）
 * - 当 limit 有效（>=0）时，在 addVal[limit] 处累加增量值，后续弹出时自动传递
 */
CustomStack.prototype.increment = function(k, val) {
    let limit = Math.min(k - 1, this.top);
    if (limit >= 0) {
        this.addVal[limit] += val;
    }
};

/** 
 * Your CustomStack object will be instantiated and called as such:
 * var obj = new CustomStack(maxSize)
 * obj.push(x)
 * var param_2 = obj.pop()
 * obj.increment(k,val)
 */

```