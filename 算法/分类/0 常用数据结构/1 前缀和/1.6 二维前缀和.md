### 二维前缀和

#### [1314. 矩阵区域和](https://leetcode.cn/problems/matrix-block-sum/description/)
 
给你一个 m x n 的矩阵 mat 和一个整数 k ，请你返回一个矩阵 answer ，其中每个 answer[i][j] 是所有满足下述条件的元素 mat[r][c] 的和： 

- i - k <= r <= i + k, 
- j - k <= c <= j + k 且
- (r, c) 在矩阵内。

```js
/**
 * 功能：使用二维前缀和算法计算矩阵中每个元素周围k范围内的元素和
 * 参数：
 *   mat - 二维数值数组，表示输入矩阵
 *   k - 整数，表示邻域半径
 * 返回：
 *   二维数值数组，每个元素替换为对应k邻域的和
 * 时间复杂度：O(m*n)，其中m/n为矩阵行列数
 * 空间复杂度：O(m*n)，需要存储前缀和数组
 */
var matrixBlockSum = function (mat, k) {
    const m = mat.length, n = mat[0].length;
    // 初始化(m+1)x(n+1)的前缀和数组，避免边界判断
    const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));

    // 构建前缀和数组（积分图）
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            // 二维前缀和公式：当前值 = 上方前缀和 + 左方前缀和 - 左上角前缀和 + 当前元素值
            dp[i+1][j+1] = dp[i][j+1] + dp[i+1][j] - dp[i][j] + mat[i][j]; 
        }
    }

    // 计算每个元素的k邻域和
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            // 计算有效查询范围，防止越界
            let topR = Math.max(0, i - k);      // 上边界
            let bottomR = Math.min(i + k, m - 1); // 下边界
            let leftC = Math.max(0, j - k);     // 左边界
            let rightC = Math.min(j + k, n - 1); // 右边界

            // 区域和计算公式：
            // 右下角 - 右上方区域 - 左下方区域 + 左上角补偿
            mat[i][j] = dp[bottomR +1][rightC + 1] 
                       - dp[bottomR + 1][leftC]
                       - dp[topR][rightC + 1] 
                       + dp[topR][leftC];
        }
    }
    return mat;
};

```

#### [1292. 元素和小于等于阈值的正方形的最大边长](https://leetcode.cn/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/description/)
 
给你一个大小为 m x n 的矩阵 mat 和一个整数阈值 threshold。

请你返回元素总和小于或等于阈值的正方形区域的最大边长；如果没有这样的正方形区域，则返回 0 。

```js
/**
 * 功能：在二维矩阵中查找满足和阈值条件的最大正方形边长
 * 参数：
 *   mat - 二维数值矩阵（m行n列）
 *   threshold - 允许的最大子矩阵和阈值
 * 返回：满足条件的最大正方形边长（整数）
 * 时间复杂度：O(m*n*min(m,n)) - 构建前缀和O(mn)，最坏情况每个点遍历min(m,n)次
 * 空间复杂度：O(mn) - 需要存储(m+1)*(n+1)的前缀和数组
 */
var maxSideLength = function (mat, threshold) {
    // 矩阵维度 m行n列
    const m = mat.length,
        n = mat[0].length;
    
    // 构建二维前缀和数组（从(0,0)到(i,j)的矩形区域和）
    const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));
    let ans = 0; // 记录最大边长

    /* 预处理阶段：计算二维前缀和 */
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            // 前缀和递推公式：当前点 = 左方和 + 上方和 - 左上重复部分 + 当前矩阵值
            dp[i + 1][j + 1] = dp[i + 1][j] + dp[i][j + 1] - dp[i][j] + mat[i][j];
        }
    }

    /* 查找阶段：遍历每个点作为右下角 */
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            // 当前点能形成的最大边长（取行列较小值）
            let d = Math.min(i, j);
            
            // 从边长0开始逐步扩大检测范围（k=0时为1x1的正方形）
            for (let k = 0; k <= d; k++) {
                /* 计算边长为k+1的正方形的和：
                   sum = dp[i+1][j+1] - 左边界区域和 - 上边界区域和 + 左上重复扣除区域 */
                if (dp[i + 1][j + 1] - dp[i + 1][j - k] - dp[i - k][j + 1] + dp[i - k][j - k] <= threshold) {
                    ans = Math.max(ans, k + 1);
                } else {
                    // 提前终止：当前边长不满足时，更大边长也不会满足（前缀和递增特性）
                    break;
                }
            }
        }
    }

    return ans;
};

```