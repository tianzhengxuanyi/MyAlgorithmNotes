### 距离和

#### [1685. 有序数组中差绝对值之和](https://leetcode.cn/problems/sum-of-absolute-differences-in-a-sorted-array/description/) 

给你一个 非递减 有序整数数组 nums 。

请你建立并返回一个整数数组 result，它跟 nums 长度相同，且result[i] 等于 nums[i] 与数组中所有其他元素差的绝对值之和。

换句话说， result[i] 等于 sum(|nums[i]-nums[j]|) ，其中 0 <= j < nums.length 且 j != i （下标从 0 开始）。

##### 距离和

```
ai - a0
ai - a1 
ai - a2
...   
ai - ai 
ai+1 - ai
ai+2 - ai
...       
an-1 - ai
sum = (i + 1 - (n - 1 - (i + 1) + 1)) * ai - prefix[i+1] + prefix[n] - prefix[i+1]
    = (2 * i + 2 - n) * ai - prefix[i+1] + prefix[n] - prefix[i+1]
```

```js
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var getSumAbsoluteDifferences = function(nums) {
    const n = nums.length;
    // 前缀和数组，prefix[i] 表示 nums 中前 i 个元素的和（nums[0] 到 nums[i-1]）
    const prefix = Array(n + 1).fill(0);
    const result = Array(n); 
    // 构建前缀和数组：prefix[i+1] = prefix[i] + nums[i]
    for (let i = 0; i < n; i++) {
        prefix[i+1] = prefix[i] + nums[i];
    }
    // 计算每个位置 i 的结果值
    for (let i = 0; i < n; i++) {
        // 公式推导：
        // 左侧元素（j <= i）的绝对值之和：nums[i] * (i + 1) - prefix[i + 1]
        // 右侧元素（j > i）的绝对值之和：(prefix[n] - prefix[i+1]) - nums[i] * (n - i - 1)
        // 合并后得到：(2i + 2 - n) * nums[i] + (prefix[n] - 2 * prefix[i+1])
        result[i] = (2 * i + 2 - n) * nums[i] + (prefix[n] - 2 * prefix[i+1]);
    }
    return result;
};

```

##### 贡献量

先计算result[0]，然后根据result[0]计算result[1]，result[2]，...，result[n-1]。

`si = si-1 + (2*i - n) * (ai - ai-1)`

```js
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var getSumAbsoluteDifferences = function(nums) {
    const n = nums.length;
    const result = Array(n).fill(0);
    for (let i = 1; i < n; i++) {
        result[0] += nums[i] - nums[0];
    }
    for (let i = 1; i < n; i++) {
        result[i] = result[i - 1] + (2*i - n) * (nums[i] - nums[i-1]);
    }
    return result;
};

// ai - a0     ai+1 - a0    ai+1 - ai + ai - a0
// ai - a1     ai+1 - a1    ai+1 - ai + ai - a1
// ai - a2     ai+1 - a2    ai+1 - ai + ai - a2
// ....        ....         ...
// ai - ai     ai+1  - ai   ai+1 - ai + ai - ai
// ai+1 - ai   ai+1 - ai+1  ai+1 - ai - (ai+1 - ai)
// ai+2 - ai   ai+2 - ai+1  ai+2 - ai - (ai+1 - ai)
// ...         ...          ...
// an-1 - ai   an-1 - ai+1  an-1 - ai - (ai+1 - ai)


// si          si+1         si+1 = si + (i + 1) * (ai+1 - ai) - (n - 1 - (i + 1) + 1) * (ai+1 - ai)
// si+1 = si + (i + 1 - (n - i - 1)) * (ai+1 - ai)
//      = si + (2*i -n + 2) * (ai+1 - ai)

// si = si-1 + (2*i - n) * (ai - ai-1)
```

#### [2615. 等值距离和](https://leetcode.cn/problems/sum-of-distances/description/)
 
给你一个下标从 0 开始的整数数组 nums 。现有一个长度等于 nums.length 的数组 arr 。对于满足 nums[j] == nums[i] 且 j != i 的所有 j ，arr[i] 等于所有 |i - j| 之和。如果不存在这样的 j ，则令 arr[i] 等于 0 。

返回数组 arr 。

```js
/**
 * 计算数组中每个元素到所有相同元素的距离和
 * 
 * 实现思路：
 * 1. 使用哈希表记录相同元素的索引位置
 * 2. 对每个相同元素组进行前缀和预处理
 * 3. 通过数学公式推导快速计算各位置的距离和
 * 
 * @param {number[]} nums - 输入数组，元素范围为 [-1e5, 1e5]
 * @returns {number[]} 每个元素对应的距离和数组
 * @note 时间复杂度 O(n) 空间复杂度 O(n)
 * @see 前缀和优化公式推导：对于排序后的索引数组，利用前缀和将O(n^2)优化到O(n)
 */
var distance = function(nums) {
    const n = nums.length;
    const map = new Map();
    // 构建哈希表：值 -> 索引数组
    for (let i = 0; i < n; i++) {
        let idx = map.get(nums[i]) ?? [];
        idx.push(i);
        map.set(nums[i], idx);
    }

    const ans = Array(n).fill(0);
    // 处理每个相同元素组
    for (let idx of map.values()) {
        let len = idx.length;
        if (len == 1) continue;

        // 前缀和预处理：prefix[i] 表示前i个元素的和
        let prefix = Array(len + 1).fill(0);
        for (let i = 0; i < len; i++) {
            prefix[i + 1] = prefix[i] + idx[i];
        }

        // 核心计算公式推导：
        // 对于第i个位置，总距离和 = (左边元素数 - 右边元素数)*当前索引 - 2*左边前缀和 + 总前缀和
        for (let i = 0; i < len; i++) {
            ans[idx[i]] = (2 * i + 2 - len) * idx[i] - 2 * prefix[i+1] + prefix[len];
        }
    }

    return ans;
};

// ai - a0
// ai - a1
// ...
// ai - ai
// ai+1 - ai
// ...
// an-1 - ai
// sum = (i + 1 - (n - 1 - (i + 1) + 1))  * ai - 2 * prefix[i+1] + prefix[n]
//     = (2 * i + 2 - n) * ai - 2 * prefix[i+1] + prefix[n]
```

#### [2602. 使数组元素全部相等的最少操作次数](https://leetcode.cn/problems/minimum-operations-to-make-all-array-elements-equal/description/)
 
给你一个正整数数组 nums 。

同时给你一个长度为 m 的整数数组 queries 。第 i 个查询中，你需要将 nums 中所有元素变成 queries[i] 。你可以执行以下操作 任意 次：

- 将数组里一个元素 增大 或者 减小 1 。

请你返回一个长度为 m 的数组 answer ，其中 answer[i]是将 nums 中所有元素变成 queries[i] 的 最少 操作次数。

注意，每次查询后，数组变回最开始的值。

```js
/**
 * 计算使数组元素等于查询值所需的最小操作次数
 * 
 * 实现思路：
 * 1. 排序数组并计算前缀和
 * 2. 对每个查询值使用二分查找确定分割点
 * 3. 应用数学公式快速计算操作次数
 * 
 * @param {number[]} nums - 输入数组
 * @param {number[]} queries - 查询值数组
 * @returns {number[]} 每个查询值对应的最小操作次数
 * @note 时间复杂度 O(n log n + m log n) 空间复杂度 O(n)
 */
var minOperations = function (nums, queries) {
    const n = nums.length;
    nums.sort((a, b) => a - b);
    // 前缀和数组：prefix[i] 表示前i个元素的和
    const prefix = Array(n + 1).fill(0);
    for (let i = 0; i < n; i++) {
        prefix[i + 1] = prefix[i] + nums[i];
    }

    const len = queries.length;
    const ans = Array(len).fill(0);
    // 处理每个查询值
    for (let i = 0; i < len; i++) {
        // 通过二分查找确定分割点
        let j = lowerBound(nums, queries[i]) - 1;
        // 计算公式：总操作次数 = (左侧元素数 - 右侧元素数)*查询值 - 2*左侧和 + 总和
        ans[i] = (2 * j + 2 - n) * queries[i] - 2 * prefix[j + 1] + prefix[n]
    }
    return ans;
};

/**
 * 二分查找寻找第一个大于target的元素位置
 * @param {number[]} nums - 已排序数组
 * @param {number} target - 目标值
 * @returns {number} 插入位置索引
 * @note 使用左闭右闭区间实现，时间复杂度 O(log n)
 */
const lowerBound = (nums, target) => {
    let l = 0, r = nums.length - 1;
    while (l <= r) {
        let mid = Math.floor((r - l) / 2) + l;
        if (nums[mid] <= target) {
            l = mid + 1;  // 向右收缩左边界
        } else {
            r = mid - 1;  // 向左收缩右边界
        }
    }
    return l;
}

// q - a0
// q - a1
// ...
// q - aj
// aj+1 - q
// ...
// an-1 - q
// sum = (j + 1 - (n - 1- (j + 1) + 1)) * q - 2 * prefix[j+1] + prefix[n]
//     = (2*j + 2 - n) * q - 2 * prefix[j+1] + prefix[n]
```