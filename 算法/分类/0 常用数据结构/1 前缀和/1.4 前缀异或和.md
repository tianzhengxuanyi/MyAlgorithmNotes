### 前缀异或和

#### [1177. 构建回文串检测](https://leetcode.cn/problems/can-make-palindrome-from-substring/description/)
 
给你一个字符串 s，请你对 s 的子串进行检测。

每次检测，待检子串都可以表示为 queries[i] = [left, right, k]。我们可以 **重新排列** 子串 s[left], ..., s[right]，并从中选择 最多 k 项替换成任何小写英文字母。 

如果在上述检测过程中，子串可以变成回文形式的字符串，那么检测结果为 true，否则结果为 false。

返回答案数组 answer[]，其中 answer[i] 是第 i 个待检子串 queries[i] 的检测结果。

注意：在替换时，子串中的每个字母都必须作为 独立的 项进行计数，也就是说，如果 s[left..right] = "aaa" 且 k = 2，我们只能替换其中的两个字母。（另外，任何检测都不会修改原始字符串 s，可以认为每次检测都是独立的）

**前缀疑异或和：**

转换： 可以重新排列[left, right]的子串，等价于只要子串中每个字符的出现次数都是偶数，那么就可以重新排列成回文串。所以只需要统计[left, right]子串中字符的出现次数。
    - 如果字符出现次数为偶数，表示不需要操作
    - 如果出现次数为奇数的字符为n个，那么只需要替换floor(n / 2)个字符即可
范围[left,right]字符出现次数的奇偶性：
    - 可以使用前缀异或和来统计[left, right]子串中字符的出现次数的奇偶性
    - 定义pre[i + 1]表示s[0, i]的字符出现次数的奇偶性，pre[i + 1] = pre[i] ^ (1 << (s[i] - 'a'))
    - 那么[left, right]子串中字符的出现次数的奇偶性为pre[right + 1] ^ pre[left]

```js
/**
 * 判断子串通过字符替换能否形成回文
 * 
 * 实现思路：
 * 1. 使用前缀异或和记录字符出现次数的奇偶性
 * 2. 通过位运算快速计算子串字符奇偶状态
 * 3. 统计需要调整的字符数量并与允许次数比较
 * 
 * @param {string} s - 输入字符串，仅包含小写字母
 * @param {number[][]} queries - 查询数组，每个元素包含[left, right, maxReplace]
 * @return {boolean[]} 每个查询是否满足条件
 * @note 时间复杂度 O(n + m) 空间复杂度 O(n)
 * @see 利用位掩码的异或特性：相同字符异或两次会抵消
 */
var canMakePaliQueries = function(s, queries) {
    const n = s.length, m = queries.length;
    // 前缀异或数组：每个元素记录当前位置的字符奇偶状态（26位掩码）
    const prefix = Array(n + 1).fill(0);
    for (let i = 0; i < n; i++) {
        // 计算字符的位掩码（a=第0位，b=第1位...z=第25位）
        prefix[i + 1] = prefix[i] ^ (1 << (s[i].charCodeAt() - 97));
    }

    const ans = Array(m);
    for (let i = 0; i < m; i++) {
        let [l, r, c] = queries[i];
        // 计算子串的异或结果：出现奇数次的字符位为1
        let mask = prefix[r + 1] ^ prefix[l];
        
        // 统计奇数次的字符数量
        let cnt = 0;
        while (mask) {
            cnt++;
            mask &= (mask - 1); // 清除最低位的1
        }
        
        /* 回文特性判断：
         * 允许的替换次数 >= 需要调整的字符对数
         * 奇数长度允许1个字符出现奇数次（中间字符）
         * 因此需要调整的字符对数为 Math.floor(cnt / 2)
         */
        ans[i] = Math.floor(cnt / 2) <= c;
    }
    return ans;
};

```

#### [1371. 每个元音包含偶数次的最长子字符串](https://leetcode.cn/problems/find-the-longest-substring-containing-vowels-in-even-counts/description/)
 
给你一个字符串 s ，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即 'a'，'e'，'i'，'o'，'u' ，在子字符串中都恰好出现了偶数次。

```js
/**
 * 查找包含每个元音字母偶数次的最长子字符串长度
 * 
 * 核心思路：使用位掩码记录元音出现次数的奇偶状态，通过前缀异或和思想寻找最长有效子串
 * 位掩码规则：用5个二进制位分别表示a/e/i/o/u的出现次数奇偶性（0为偶，1为奇）
 * 
 * @param {string} s - 输入字符串
 * @return {number} 满足条件的最长子字符串长度
 */
var findTheLongestSubstring = function (s) {
    // 存储掩码首次出现的索引，初始状态mask=0（所有元音均出现0次，为偶数）对应索引-1
    const map = new Map([[0, -1]]);
    let mask = 0, ans = 0;  // mask: 元音奇偶状态掩码；ans: 最长有效子串长度
    
    for (let i = 0; i < s.length; i++) {
        // 若当前字符是元音，更新对应位的奇偶状态（异或1翻转该位）
        if (s[i] in alphbet) {
            mask ^= (1 << alphbet[s[i]]);  // 1 << n 将第n位设为1，异或操作翻转该位
        }
        
        // 若当前掩码已存在于map中，说明[首次出现索引+1, 当前i]区间内所有元音出现次数为偶数
        if (map.has(mask)) {
            // 更新最长子串长度：当前索引 - 首次出现索引
            ans = Math.max(ans, i - map.get(mask));
        } else {
            // 存储掩码首次出现的索引
            map.set(mask, i);
        }
    }
    return ans;
};

// 元音字母到位掩码位置的映射（a对应第0位，e对应第1位，以此类推）
const alphbet = {
    "a": 0,
    "e": 1,
    "i": 2,
    "o": 3,
    "u": 4,
}

```

#### [1310. 子数组异或查询](https://leetcode.cn/problems/xor-queries-of-a-subarray/description/)

有一个正整数数组 arr，现给你一个对应的查询数组 queries，其中 queries[i] = [Li, Ri]。

对于每个查询 i，请你计算从 Li 到 Ri 的 XOR 值（即 arr[Li] xor arr[Li+1] xor ... xor arr[Ri]）作为本次查询的结果。

并返回一个包含给定查询 queries 所有结果的数组。

```js
/**
 * 计算子数组异或查询结果
 * 
 * 核心思路：利用前缀异或和特性高效计算子数组异或值
 * XOR性质：a ^ a = 0，a ^ 0 = a，因此区间[L, R]的异或值 = 前缀[0..R] ^ 前缀[0..L-1]
 * 
 * @param {number[]} arr - 输入的正整数数组
 * @param {number[][]} queries - 查询数组，每个元素为[Li, Ri]表示查询区间[Li, Ri]的异或值
 * @return {number[]} 包含所有查询结果的数组
 * @note 时间复杂度：O(n + m)，n为arr长度，m为queries长度；空间复杂度：O(n)
 */
var xorQueries = function(arr, queries) {
    const n = arr.length, n1 = queries.length;
    // 前缀异或数组：prefix[i]表示arr[0..i-1]的异或结果，prefix[0] = 0（空数组的异或值）
    const prefix = Array(n + 1).fill(0);
    // 构建前缀异或数组：prefix[i+1] = prefix[i] ^ arr[i]（即前i个元素的异或和）
    for (let i = 0; i < n; i++) {
        prefix[i + 1] = prefix[i] ^ arr[i];
    }
    const ans = Array(n1);
    // 处理每个查询：区间[L, R]的异或值 = prefix[L] ^ prefix[R+1]
    for (let i = 0; i < n1; i++) {
        let [l, r] = queries[i];
        ans[i] = prefix[l] ^ prefix[r + 1];
    }
    return ans;
};

```