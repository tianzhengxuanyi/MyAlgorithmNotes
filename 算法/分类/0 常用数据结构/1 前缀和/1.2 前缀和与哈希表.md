### 1.2 前缀和与哈希表

#### [930. 和相同的二元子数组](https://leetcode.cn/problems/binary-subarrays-with-sum/description/)

给你一个二元数组 nums ，和一个整数 goal ，请你统计并返回有多少个和为 goal 的 非空 子数组。

子数组 是数组的一段连续部分。

##### 前缀和

```js
/**
 * 统计和为目标值的子数组数量（LeetCode 560题解）
 * @param {number[]} nums - 二进制数组（元素为0或1）
 * @param {number} goal - 目标和
 * @return {number} 满足条件的子数组数量
 * @note
 * 1. 使用前缀和配合哈希表实现O(n)时间复杂度
 * 2. 哈希表存储前缀和出现次数
 * 3. 核心公式：currentPrefix - previousPrefix = goal
 */
var numSubarraysWithSum = function(nums, goal) {
    let prefix = 0;
    // 哈希表记录前缀和出现次数（初始存在前缀和为0的情况）
    const cnt = new Map([[0, 1]]);
    let ans = 0;

    for (let i = 0; i < nums.length; i++) {
        prefix += nums[i];  // 计算当前前缀和
        // 查找符合 previousPrefix = currentPrefix - goal 的计数
        ans += cnt.get(prefix - goal) || 0;
        // 更新当前前缀和的计数
        cnt.set(prefix, (cnt.get(prefix) || 0) + 1);
    }
    return ans;
};

```

##### 滑动窗口

```js
/**
 * 计算二进制数组中满足指定和的子数组个数（滑动窗口解法）
 * @param {number[]} nums 二进制数组（仅含0/1元素）
 * @param {number} goal 目标子数组和
 * @return {number} 满足条件的子数组数量
 * 
 * 实现原理：
 * 1. 使用双滑动窗口维护两个区间[l1,r]和[l2,r]
 * 2. sum1维护严格大于goal的窗口左边界l1
 * 3. sum2维护大于等于goal的窗口左边界l2
 * 4. 每个右端点r的有效子数组数为 l2 - l1
 * 
 * 时间复杂度：O(n) 空间复杂度：O(1)
 */
var numSubarraysWithSum = function (nums, goal) {
    let sum1 = 0, sum2 = 0; // 维护两个滑动窗口的和
    let l1 = 0, l2 = 0;    // 两个窗口的左边界
    let ans = 0;
    
    for (let r = 0; r < nums.length; r++) {
        sum1 += nums[r];   // 累加当前元素到两个窗口
        sum2 += nums[r];
        
        // 收缩sum1窗口直到sum <= goal
        while (sum1 > goal && l1 <= r) {
            sum1 -= nums[l1++];
        }
        
        // 收缩sum2窗口直到sum < goal
        while (sum2 >= goal && l2 <= r) {
            sum2 -= nums[l2++];
        }
        
        // 有效子数组数为两个左边界之差
        ans += (l2 - l1);
    }
    return ans;
};

```

#### [1524. 和为奇数的子数组数目](https://leetcode.cn/problems/number-of-sub-arrays-with-odd-sum/description/)

给你一个整数数组 arr 。请你返回和为 奇数 的子数组数目。

由于答案可能会很大，请你将结果对 10^9 + 7 取余后返回。

```js
/**
 * 计算数组中满足条件的子数组数量（和为奇数的子数组）
 * @param {number[]} arr - 输入数组
 * @returns {number} 满足条件的子数组数量
 * @note 使用前缀和与奇偶计数优化，时间复杂度O(n)
 */
var numOfSubarrays = function(arr) {
    let ans = 0, 
        evenCnt = 0, // 记录当前偶数前缀和的数量
        oddCnt = 0,  // 记录当前奇数前缀和的数量
        sum = 0;     // 运行中的前缀和

    // 遍历数组元素
    for (let i of arr) {
        sum += i;
        
        // 当前前缀和为奇数时
        if (sum % 2) {
            // 新增子数组数 = 1（当前元素本身） + 之前偶数前缀和的数量
            ans = (ans + 1 + evenCnt) % MOD;
            oddCnt++; // 更新奇数前缀和计数
        } else {
            // 新增子数组数 = 之前奇数前缀和的数量
            ans = (ans + oddCnt) % MOD;
            evenCnt++; // 更新偶数前缀和计数
        }
    }
    return ans;
};

// 模数常量（题目要求取模）
const MOD = 1e9 + 7;

```

#### [974. 和可被 K 整除的子数组](https://leetcode.cn/problems/subarray-sums-divisible-by-k/description/)

给定一个整数数组 nums 和一个整数 k ，返回其中元素之和可被 k 整除的非空 子数组 的数目。

子数组 是数组中 连续 的部分。

```js
/**
 * 计算可被k整除的子数组数量
 * @param {number[]} nums - 输入数组
 * @param {number} k - 除数
 * @returns {number} 满足条件的子数组数量
 * @note 使用前缀和+同余定理，时间复杂度O(n)
 */
var subarraysDivByK = function(nums, k) {
    let sum = 0, // 当前前缀和
        cnt = Array(k).fill(0); // 记录余数出现次数的哈希表
    let ans = 0;
    cnt[0] = 1; // 初始化余数为0的情况

    // 遍历数组元素
    for (let i of nums) {
        sum += i;
        // 处理负数余数：(sum % k + k) % k
        let m = (sum % k + k) % k; 
        
        // 累加相同余数的出现次数
        ans += cnt[m];
        // 更新当前余数计数
        cnt[m] += 1;
    }
    return ans;
};

```

#### [523. 连续的子数组和](https://leetcode.cn/problems/continuous-subarray-sum/description/)

给你一个整数数组 nums 和一个整数 k ，如果 nums 有一个 好的子数组 返回 true ，否则返回 false：

一个 好的子数组 是：

- 长度 至少为 2 ，且
- 子数组元素总和为 k 的倍数。

注意：

- 子数组 是数组中 连续 的部分。
- 如果存在一个整数 n ，令整数 x 符合 x = n * k ，则称 x 是 k 的一个倍数。0 始终 视为 k 的一个倍数。

```js
/**
 * 检查是否存在长度≥2的子数组，其和是k的倍数
 * @param {number[]} nums - 输入数组
 * @param {number} k - 目标倍数
 * @returns {boolean} 是否存在符合条件的子数组
 * @note 使用前缀和+同余定理，时间复杂度O(n)
 */
var checkSubarraySum = function(nums, k) {
    let sum = nums[0]; // 初始化前缀和
    let cnt = new Set([0]); // 存储历史余数的哈希集合

    // 从第二个元素开始遍历
    for (let i = 1; i < nums.length; i++) {
        sum += nums[i]; // 累加当前元素到前缀和
        
        // 检查当前余数是否存在于历史记录中
        if (cnt.has(sum % k)) {
            return true; // 找到符合条件的子数组
        }
        
        // 将前一个前缀和的余数存入集合（延迟一个位置）
        cnt.add((sum - nums[i]) % k);
    }
    return false;
};

```