### 1.2 前缀和与哈希表

#### [930. 和相同的二元子数组](https://leetcode.cn/problems/binary-subarrays-with-sum/description/)

给你一个二元数组 nums ，和一个整数 goal ，请你统计并返回有多少个和为 goal 的 非空 子数组。

子数组 是数组的一段连续部分。

##### 前缀和

```js
/**
 * 统计和为目标值的子数组数量（LeetCode 560题解）
 * @param {number[]} nums - 二进制数组（元素为0或1）
 * @param {number} goal - 目标和
 * @return {number} 满足条件的子数组数量
 * @note
 * 1. 使用前缀和配合哈希表实现O(n)时间复杂度
 * 2. 哈希表存储前缀和出现次数
 * 3. 核心公式：currentPrefix - previousPrefix = goal
 */
var numSubarraysWithSum = function (nums, goal) {
  let prefix = 0;
  // 哈希表记录前缀和出现次数（初始存在前缀和为0的情况）
  const cnt = new Map([[0, 1]]);
  let ans = 0;

  for (let i = 0; i < nums.length; i++) {
    prefix += nums[i]; // 计算当前前缀和
    // 查找符合 previousPrefix = currentPrefix - goal 的计数
    ans += cnt.get(prefix - goal) || 0;
    // 更新当前前缀和的计数
    cnt.set(prefix, (cnt.get(prefix) || 0) + 1);
  }
  return ans;
};
```

##### 滑动窗口

```js
/**
 * 计算二进制数组中满足指定和的子数组个数（滑动窗口解法）
 * @param {number[]} nums 二进制数组（仅含0/1元素）
 * @param {number} goal 目标子数组和
 * @return {number} 满足条件的子数组数量
 *
 * 实现原理：
 * 1. 使用双滑动窗口维护两个区间[l1,r]和[l2,r]
 * 2. sum1维护严格大于goal的窗口左边界l1
 * 3. sum2维护大于等于goal的窗口左边界l2
 * 4. 每个右端点r的有效子数组数为 l2 - l1
 *
 * 时间复杂度：O(n) 空间复杂度：O(1)
 */
var numSubarraysWithSum = function (nums, goal) {
  let sum1 = 0,
    sum2 = 0; // 维护两个滑动窗口的和
  let l1 = 0,
    l2 = 0; // 两个窗口的左边界
  let ans = 0;

  for (let r = 0; r < nums.length; r++) {
    sum1 += nums[r]; // 累加当前元素到两个窗口
    sum2 += nums[r];

    // 收缩sum1窗口直到sum <= goal
    while (sum1 > goal && l1 <= r) {
      sum1 -= nums[l1++];
    }

    // 收缩sum2窗口直到sum < goal
    while (sum2 >= goal && l2 <= r) {
      sum2 -= nums[l2++];
    }

    // 有效子数组数为两个左边界之差
    ans += l2 - l1;
  }
  return ans;
};
```

#### [1524. 和为奇数的子数组数目](https://leetcode.cn/problems/number-of-sub-arrays-with-odd-sum/description/)

给你一个整数数组 arr 。请你返回和为 奇数 的子数组数目。

由于答案可能会很大，请你将结果对 10^9 + 7 取余后返回。

```js
/**
 * 计算数组中满足条件的子数组数量（和为奇数的子数组）
 * @param {number[]} arr - 输入数组
 * @returns {number} 满足条件的子数组数量
 * @note 使用前缀和与奇偶计数优化，时间复杂度O(n)
 */
var numOfSubarrays = function (arr) {
  let ans = 0,
    evenCnt = 0, // 记录当前偶数前缀和的数量
    oddCnt = 0, // 记录当前奇数前缀和的数量
    sum = 0; // 运行中的前缀和

  // 遍历数组元素
  for (let i of arr) {
    sum += i;

    // 当前前缀和为奇数时
    if (sum % 2) {
      // 新增子数组数 = 1（当前元素本身） + 之前偶数前缀和的数量
      ans = (ans + 1 + evenCnt) % MOD;
      oddCnt++; // 更新奇数前缀和计数
    } else {
      // 新增子数组数 = 之前奇数前缀和的数量
      ans = (ans + oddCnt) % MOD;
      evenCnt++; // 更新偶数前缀和计数
    }
  }
  return ans;
};

// 模数常量（题目要求取模）
const MOD = 1e9 + 7;
```

#### [974. 和可被 K 整除的子数组](https://leetcode.cn/problems/subarray-sums-divisible-by-k/description/)

给定一个整数数组 nums 和一个整数 k ，返回其中元素之和可被 k 整除的非空 子数组 的数目。

子数组 是数组中 连续 的部分。

```js
/**
 * 计算可被k整除的子数组数量
 * @param {number[]} nums - 输入数组
 * @param {number} k - 除数
 * @returns {number} 满足条件的子数组数量
 * @note 使用前缀和+同余定理，时间复杂度O(n)
 */
var subarraysDivByK = function (nums, k) {
  let sum = 0, // 当前前缀和
    cnt = Array(k).fill(0); // 记录余数出现次数的哈希表
  let ans = 0;
  cnt[0] = 1; // 初始化余数为0的情况

  // 遍历数组元素
  for (let i of nums) {
    sum += i;
    // 处理负数余数：(sum % k + k) % k
    let m = ((sum % k) + k) % k;

    // 累加相同余数的出现次数
    ans += cnt[m];
    // 更新当前余数计数
    cnt[m] += 1;
  }
  return ans;
};
```

#### [523. 连续的子数组和](https://leetcode.cn/problems/continuous-subarray-sum/description/)

给你一个整数数组 nums 和一个整数 k ，如果 nums 有一个 好的子数组 返回 true ，否则返回 false：

一个 好的子数组 是：

- 长度 至少为 2 ，且
- 子数组元素总和为 k 的倍数。

注意：

- 子数组 是数组中 连续 的部分。
- 如果存在一个整数 n ，令整数 x 符合 x = n \* k ，则称 x 是 k 的一个倍数。0 始终 视为 k 的一个倍数。

```js
/**
 * 检查是否存在长度≥2的子数组，其和是k的倍数
 * @param {number[]} nums - 输入数组
 * @param {number} k - 目标倍数
 * @returns {boolean} 是否存在符合条件的子数组
 * @note 使用前缀和+同余定理，时间复杂度O(n)
 */
var checkSubarraySum = function (nums, k) {
  let sum = nums[0]; // 初始化前缀和
  let cnt = new Set([0]); // 存储历史余数的哈希集合

  // 从第二个元素开始遍历
  for (let i = 1; i < nums.length; i++) {
    sum += nums[i]; // 累加当前元素到前缀和

    // 检查当前余数是否存在于历史记录中
    if (cnt.has(sum % k)) {
      return true; // 找到符合条件的子数组
    }

    // 将前一个前缀和的余数存入集合（延迟一个位置）
    cnt.add((sum - nums[i]) % k);
  }
  return false;
};
```

#### [437. 路径总和 III](https://leetcode.cn/problems/path-sum-iii/description/)

给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。

路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

**前缀和 + 回溯**

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * 功能：计算二叉树中路径和等于目标值的路径数量（路径可以从任意节点开始和结束，但必须是向下的方向）
 * @param {TreeNode} root - 二叉树的根节点
 * @param {number} targetSum - 目标路径和
 * @return {number} 满足条件的路径数量
 * 算法思想：使用前缀和结合哈希表优化路径和计算，避免重复计算
 * 时间复杂度：O(n)，其中n为二叉树节点数，每个节点仅访问一次
 * 空间复杂度：O(h)，h为树的高度，主要用于递归栈和哈希表存储
 */
var pathSum = function (root, targetSum) {
  // 哈希表存储前缀和出现的次数，初始化前缀和0出现1次（处理从根节点开始的路径）
  const cnt = new Map([[0, 1]]);
  let ans = 0; // 记录满足条件的路径数量

  // 深度优先搜索函数
  // @param {TreeNode} node - 当前遍历的节点
  // @param {number} d - 从根节点到当前节点的前缀和
  const dfs = (node, d) => {
    if (!node) return; // 递归终止条件：节点为空

    // 当前路径的前缀和（从根节点到当前节点）
    let curr = d + node.val;

    // 关键：如果存在前缀和为curr - targetSum的路径，说明从该路径的下一个节点到当前节点的路径和为targetSum
    ans += cnt.get(curr - targetSum) ?? 0;

    // 更新哈希表：当前前缀和出现次数+1
    cnt.set(curr, (cnt.get(curr) ?? 0) + 1);

    // 递归遍历左右子树
    dfs(node.left, curr);
    dfs(node.right, curr);

    // 回溯：当前节点处理完毕，从哈希表中移除当前前缀和（避免影响其他路径）
    cnt.set(curr, cnt.get(curr) - 1);
  };

  // 从根节点开始深度优先搜索，初始前缀和为0
  dfs(root, 0);
  return ans;
};
```

#### [2588. 统计美丽子数组数目](https://leetcode.cn/problems/count-the-number-of-beautiful-subarrays/description/)

给你一个下标从 0 开始的整数数组 nums 。每次操作中，你可以：

- 选择两个满足 0 <= i, j < nums.length 的不同下标 i 和 j 。
- 选择一个非负整数 k ，满足 nums[i] 和 nums[j] 在二进制下的第 k 位（下标编号从 0 开始）是 1 。
- 将 nums[i] 和 nums[j] 都减去 2^k 。

如果一个子数组内执行上述操作若干次（包括 0 次）后，该子数组可以变成一个全为 0 的数组，那么我们称它是一个 美丽 的子数组。

请你返回数组 nums 中 美丽子数组 的数目。

子数组是一个数组中一段连续 非空 的元素序列。

注意：所有元素最初都是 0 的子数组被认为是美丽的，因为不需要进行任何操作。

**前缀和：**

美丽的子数组中，nums[i]到 nums[j]的二进制下的第 k 位为 1 的个数为偶数，只有这样才能两两配对变为 0。

所以 nums[i]到 nums[j]的异或和为 0，才能满足条件。

```js
/**
 * 功能：计算数组中「美丽子数组」的数量（美丽子数组指元素XOR和为0的子数组）
 * @param {number[]} nums - 输入的整数数组
 * @return {number} 美丽子数组的数量
 * 算法思想：利用异或前缀和结合哈希表统计，将子数组异或和问题转化为前缀和相等问题
 * 时间复杂度：O(n)，其中n为数组长度，每个元素仅遍历一次
 * 空间复杂度：O(n)，哈希表最多存储n+1个不同的前缀和
 */
var beautifulSubarrays = function (nums) {
  // 哈希表存储异或前缀和出现的次数，初始化前缀和0出现1次
  // （处理从数组起始位置开始的子数组）
  const cnt = new Map([[0, 1]]);
  let ans = 0; // 记录美丽子数组的数量
  let xor = 0; // 当前位置的异或前缀和（从数组开头到当前位置的异或和）

  // 遍历数组，计算异或前缀和并统计美丽子数组数量
  for (let x of nums) {
    // 更新当前异或前缀和：xor ^= x 等价于 xor = xor ^ x
    xor ^= x;

    // 关键：如果当前前缀和xor在哈希表中存在，则说明存在子数组异或和为0
    // 数量为哈希表中该前缀和出现的次数
    ans += cnt.get(xor) ?? 0;

    // 更新哈希表：当前前缀和出现次数+1
    cnt.set(xor, (cnt.get(xor) ?? 0) + 1);
  }

  return ans;
};
```

#### [525. 连续数组](https://leetcode.cn/problems/contiguous-array/description/)

给定一个二进制数组 nums , 找到含有相同数量的 0 和 1 的最长连续子数组，并返回该子数组的长度。

**前缀和：**

计算前缀和，如果 nums[i]为 0，前缀和-1，为 1，前缀和+1。

将设当前前缀和为 sum，需要寻找 0-i-1 中前缀和同样为 sum 的最小下标

```js
/**
 * 功能：寻找二进制数组中含有相同数量0和1的最长连续子数组的长度
 * @param {number[]} nums - 只包含0和1的二进制数组
 * @return {number} 满足条件的最长子数组长度，若不存在则返回0
 * 算法思想：将0视为-1，转化为寻找和为0的最长子数组问题，利用前缀和结合哈希表实现
 * 时间复杂度：O(n)，其中n为数组长度，每个元素仅遍历一次
 * 空间复杂度：O(n)，哈希表最多存储n+1个不同的前缀和
 */
var findMaxLength = function (nums) {
  // 哈希表存储前缀和第一次出现的索引，初始化前缀和0对应索引-1
  // （处理从数组起始位置开始的子数组）
  const map = new Map([[0, -1]]);
  let ans = 0; // 记录最长子数组长度
  let cnt = 0; // 当前前缀和（将0视为-1，1视为1的累加和）

  // 遍历数组，计算前缀和并更新最长子数组长度
  for (let i = 0; i < nums.length; i++) {
    // 更新当前前缀和：遇到1加1，遇到0减1（等价于加-1）
    cnt += nums[i] === 1 ? 1 : -1;

    // 关键：如果当前前缀和已存在于哈希表中，说明两个索引之间的子数组和为0
    // 计算子数组长度并更新最大值
    if (map.has(cnt)) {
      ans = Math.max(ans, i - map.get(cnt));
    } else {
      // 仅存储前缀和第一次出现的索引，确保后续遇到相同前缀和时能得到最长子数组
      map.set(cnt, i);
    }
  }

  return ans;
};
```

#### [3026. 最大好子数组和](https://leetcode.cn/problems/maximum-good-subarray-sum/description/)

给你一个长度为 n 的数组 nums 和一个 正 整数 k 。

如果 nums 的一个子数组中，第一个元素和最后一个元素 差的绝对值恰好 为 k ，我们称这个子数组为 好 的。换句话说，如果子数组 nums[i..j] 满足 |nums[i] - nums[j]| == k ，那么它是一个好子数组。

请你返回 nums 中 好 子数组的 最大 和，如果没有好子数组，返回 0

**前缀和：**

注意： 前缀和 p[i]表示 nums[0]到 nums[i-1]的和，这样寻找到 nums[j]的时候前缀和直接为 sum - p[j];

```js
/**
 * 寻找数组中和满足特定条件的最大子数组和
 * @param {number[]} nums - 输入的整数数组
 * @param {number} k - 目标差值
 * @return {number} - 满足条件的最大子数组和，如果不存在则返回0
 *
 * 算法思路：前缀和 + 哈希表优化
 * 时间复杂度：O(n)，其中n是nums数组的长度
 * 空间复杂度：O(n)，哈希表最多存储n个不同的前缀和
 */
var maximumSubarraySum = function (nums, k) {
  // 创建哈希表存储前缀和的最小值，键为前缀和，值为该前缀和对应的最小前缀和
  const map = new Map();
  // 初始化前缀和为0
  let sum = 0;
  // 初始化结果为负无穷大
  let ans = -Infinity;

  for (let i = 0; i < nums.length; i++) {
    // 前缀和 p[i]表示 nums[0]到 nums[i-1]的和
    // 如果当前数字已在哈希表中，更新其对应的前缀和为较小值；否则添加到哈希表
    map.set(nums[i], Math.min(map.get(nums[i]) ?? Infinity, sum));
    // 更新前缀和，加上当前数字
    sum += nums[i];

    // 情况1：寻找第一个元素为k + nums[i]的最小前缀和
    if (map.has(k + nums[i])) {
      ans = Math.max(ans, sum - map.get(k + nums[i]));
    }
    // 情况2：寻找第一个元素为nums[i] - k的最小前缀和
    if (map.has(nums[i] - k)) {
      ans = Math.max(ans, sum - map.get(-k + nums[i]));
    }
  }

  // 如果没有找到满足条件的子数组，返回0；否则返回找到的最大子数组和
  return ans == -Infinity ? 0 : ans;
};
```

#### [1477. 找两个和为目标值且不重叠的子数组](https://leetcode.cn/problems/find-two-non-overlapping-sub-arrays-each-with-target-sum/description/)

给你一个整数数组 arr 和一个整数值 target 。

请你在 arr 中找 两个互不重叠的子数组 且它们的和都等于 target 。可能会有多种方案，请你返回满足要求的两个子数组长度和的 最小值 。

请返回满足要求的最小长度和，如果无法找到这样的两个子数组，请返回 -1 。

**前缀和 + 动态规划**

- prefix[i + 1]， 0 - i 的和
- f[i + 1]，表示 0 - i 中，和为 target 的子数组的最小长度

用 map 记录前缀和的右边界，遍历到 i 时，通过 map 找到 sum - target 的右边界 j，为第二个子数组，在通过 f[j]获得 0-j-1 子数组和为 target 的最小长度。

```js
/**
 * 寻找两个不重叠子数组，使其和等于目标值的最小总长度
 * @param {number[]} arr - 输入的整数数组
 * @param {number} target - 目标子数组和
 * @return {number} - 返回满足条件的最小总长度，若不存在则返回-1
 *
 * 算法思路：前缀和 + 动态规划优化
 * 时间复杂度：O(n)，其中n是arr数组的长度
 * 空间复杂度：O(n)，哈希表最多存储n个不同的前缀和
 */
var minSumOfLengths = function (arr, target) {
  const n = arr.length;
  // 哈希表存储前缀和与对应的右边界索引
  const map = new Map([[0, 0]]);
  // f数组记录到当前位置为止的最短有效子数组长度
  const f = Array(n + 1).fill(Infinity);
  let sum = 0;
  let ans = Infinity;

  for (let i = 0; i < n; i++) {
    sum += arr[i];
    // 检查是否存在满足条件的前缀和
    if (map.has(sum - target)) {
      let l = map.get(sum - target);
      // 更新最小总长度（当前子数组长度 + 之前的最短长度）
      ans = Math.min(ans, i - l + 1 + f[l]);
      // 优化：提前返回最小可能值
      if (ans == 2) return ans;
      // 更新当前位置的最短子数组长度
      f[i + 1] = Math.min(f[i], i - l + 1);
    } else {
      // 保持前一个位置的最短长度
      f[i + 1] = f[i];
    }
    // 记录当前前缀和对应的右边界（i+1保证左闭右开）
    map.set(sum, i + 1);
  }

  return ans == Infinity ? -1 : ans;
};
```
