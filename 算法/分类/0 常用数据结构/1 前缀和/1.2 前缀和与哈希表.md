### 1.2 前缀和与哈希表

#### [930. 和相同的二元子数组](https://leetcode.cn/problems/binary-subarrays-with-sum/description/)

给你一个二元数组 nums ，和一个整数 goal ，请你统计并返回有多少个和为 goal 的 非空 子数组。

子数组 是数组的一段连续部分。

##### 前缀和

```js
/**
 * 统计和为目标值的子数组数量（LeetCode 560题解）
 * @param {number[]} nums - 二进制数组（元素为0或1）
 * @param {number} goal - 目标和
 * @return {number} 满足条件的子数组数量
 * @note
 * 1. 使用前缀和配合哈希表实现O(n)时间复杂度
 * 2. 哈希表存储前缀和出现次数
 * 3. 核心公式：currentPrefix - previousPrefix = goal
 */
var numSubarraysWithSum = function (nums, goal) {
  let prefix = 0;
  // 哈希表记录前缀和出现次数（初始存在前缀和为0的情况）
  const cnt = new Map([[0, 1]]);
  let ans = 0;

  for (let i = 0; i < nums.length; i++) {
    prefix += nums[i]; // 计算当前前缀和
    // 查找符合 previousPrefix = currentPrefix - goal 的计数
    ans += cnt.get(prefix - goal) || 0;
    // 更新当前前缀和的计数
    cnt.set(prefix, (cnt.get(prefix) || 0) + 1);
  }
  return ans;
};
```

##### 滑动窗口

```js
/**
 * 计算二进制数组中满足指定和的子数组个数（滑动窗口解法）
 * @param {number[]} nums 二进制数组（仅含0/1元素）
 * @param {number} goal 目标子数组和
 * @return {number} 满足条件的子数组数量
 *
 * 实现原理：
 * 1. 使用双滑动窗口维护两个区间[l1,r]和[l2,r]
 * 2. sum1维护严格大于goal的窗口左边界l1
 * 3. sum2维护大于等于goal的窗口左边界l2
 * 4. 每个右端点r的有效子数组数为 l2 - l1
 *
 * 时间复杂度：O(n) 空间复杂度：O(1)
 */
var numSubarraysWithSum = function (nums, goal) {
  let sum1 = 0,
    sum2 = 0; // 维护两个滑动窗口的和
  let l1 = 0,
    l2 = 0; // 两个窗口的左边界
  let ans = 0;

  for (let r = 0; r < nums.length; r++) {
    sum1 += nums[r]; // 累加当前元素到两个窗口
    sum2 += nums[r];

    // 收缩sum1窗口直到sum <= goal
    while (sum1 > goal && l1 <= r) {
      sum1 -= nums[l1++];
    }

    // 收缩sum2窗口直到sum < goal
    while (sum2 >= goal && l2 <= r) {
      sum2 -= nums[l2++];
    }

    // 有效子数组数为两个左边界之差
    ans += l2 - l1;
  }
  return ans;
};
```

#### [1524. 和为奇数的子数组数目](https://leetcode.cn/problems/number-of-sub-arrays-with-odd-sum/description/)

给你一个整数数组 arr 。请你返回和为 奇数 的子数组数目。

由于答案可能会很大，请你将结果对 10^9 + 7 取余后返回。

```js
/**
 * 计算数组中满足条件的子数组数量（和为奇数的子数组）
 * @param {number[]} arr - 输入数组
 * @returns {number} 满足条件的子数组数量
 * @note 使用前缀和与奇偶计数优化，时间复杂度O(n)
 */
var numOfSubarrays = function (arr) {
  let ans = 0,
    evenCnt = 0, // 记录当前偶数前缀和的数量
    oddCnt = 0, // 记录当前奇数前缀和的数量
    sum = 0; // 运行中的前缀和

  // 遍历数组元素
  for (let i of arr) {
    sum += i;

    // 当前前缀和为奇数时
    if (sum % 2) {
      // 新增子数组数 = 1（当前元素本身） + 之前偶数前缀和的数量
      ans = (ans + 1 + evenCnt) % MOD;
      oddCnt++; // 更新奇数前缀和计数
    } else {
      // 新增子数组数 = 之前奇数前缀和的数量
      ans = (ans + oddCnt) % MOD;
      evenCnt++; // 更新偶数前缀和计数
    }
  }
  return ans;
};

// 模数常量（题目要求取模）
const MOD = 1e9 + 7;
```

#### [974. 和可被 K 整除的子数组](https://leetcode.cn/problems/subarray-sums-divisible-by-k/description/)

给定一个整数数组 nums 和一个整数 k ，返回其中元素之和可被 k 整除的非空 子数组 的数目。

子数组 是数组中 连续 的部分。

```js
/**
 * 计算可被k整除的子数组数量
 * @param {number[]} nums - 输入数组
 * @param {number} k - 除数
 * @returns {number} 满足条件的子数组数量
 * @note 使用前缀和+同余定理，时间复杂度O(n)
 */
var subarraysDivByK = function (nums, k) {
  let sum = 0, // 当前前缀和
    cnt = Array(k).fill(0); // 记录余数出现次数的哈希表
  let ans = 0;
  cnt[0] = 1; // 初始化余数为0的情况

  // 遍历数组元素
  for (let i of nums) {
    sum += i;
    // 处理负数余数：(sum % k + k) % k
    let m = ((sum % k) + k) % k;

    // 累加相同余数的出现次数
    ans += cnt[m];
    // 更新当前余数计数
    cnt[m] += 1;
  }
  return ans;
};
```

#### [523. 连续的子数组和](https://leetcode.cn/problems/continuous-subarray-sum/description/)

给你一个整数数组 nums 和一个整数 k ，如果 nums 有一个 好的子数组 返回 true ，否则返回 false：

一个 好的子数组 是：

- 长度 至少为 2 ，且
- 子数组元素总和为 k 的倍数。

注意：

- 子数组 是数组中 连续 的部分。
- 如果存在一个整数 n ，令整数 x 符合 x = n \* k ，则称 x 是 k 的一个倍数。0 始终 视为 k 的一个倍数。

```js
/**
 * 检查是否存在长度≥2的子数组，其和是k的倍数
 * @param {number[]} nums - 输入数组
 * @param {number} k - 目标倍数
 * @returns {boolean} 是否存在符合条件的子数组
 * @note 使用前缀和+同余定理，时间复杂度O(n)
 */
var checkSubarraySum = function (nums, k) {
  let sum = nums[0]; // 初始化前缀和
  let cnt = new Set([0]); // 存储历史余数的哈希集合

  // 从第二个元素开始遍历
  for (let i = 1; i < nums.length; i++) {
    sum += nums[i]; // 累加当前元素到前缀和

    // 检查当前余数是否存在于历史记录中
    if (cnt.has(sum % k)) {
      return true; // 找到符合条件的子数组
    }

    // 将前一个前缀和的余数存入集合（延迟一个位置）
    cnt.add((sum - nums[i]) % k);
  }
  return false;
};
```

#### [437. 路径总和 III](https://leetcode.cn/problems/path-sum-iii/description/)

给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。

路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

**前缀和 + 回溯**

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * 功能：计算二叉树中路径和等于目标值的路径数量（路径可以从任意节点开始和结束，但必须是向下的方向）
 * @param {TreeNode} root - 二叉树的根节点
 * @param {number} targetSum - 目标路径和
 * @return {number} 满足条件的路径数量
 * 算法思想：使用前缀和结合哈希表优化路径和计算，避免重复计算
 * 时间复杂度：O(n)，其中n为二叉树节点数，每个节点仅访问一次
 * 空间复杂度：O(h)，h为树的高度，主要用于递归栈和哈希表存储
 */
var pathSum = function (root, targetSum) {
  // 哈希表存储前缀和出现的次数，初始化前缀和0出现1次（处理从根节点开始的路径）
  const cnt = new Map([[0, 1]]);
  let ans = 0; // 记录满足条件的路径数量

  // 深度优先搜索函数
  // @param {TreeNode} node - 当前遍历的节点
  // @param {number} d - 从根节点到当前节点的前缀和
  const dfs = (node, d) => {
    if (!node) return; // 递归终止条件：节点为空

    // 当前路径的前缀和（从根节点到当前节点）
    let curr = d + node.val;

    // 关键：如果存在前缀和为curr - targetSum的路径，说明从该路径的下一个节点到当前节点的路径和为targetSum
    ans += cnt.get(curr - targetSum) ?? 0;

    // 更新哈希表：当前前缀和出现次数+1
    cnt.set(curr, (cnt.get(curr) ?? 0) + 1);

    // 递归遍历左右子树
    dfs(node.left, curr);
    dfs(node.right, curr);

    // 回溯：当前节点处理完毕，从哈希表中移除当前前缀和（避免影响其他路径）
    cnt.set(curr, cnt.get(curr) - 1);
  };

  // 从根节点开始深度优先搜索，初始前缀和为0
  dfs(root, 0);
  return ans;
};
```

#### [2588. 统计美丽子数组数目](https://leetcode.cn/problems/count-the-number-of-beautiful-subarrays/description/)

给你一个下标从 0 开始的整数数组 nums 。每次操作中，你可以：

- 选择两个满足 0 <= i, j < nums.length 的不同下标 i 和 j 。
- 选择一个非负整数 k ，满足 nums[i] 和 nums[j] 在二进制下的第 k 位（下标编号从 0 开始）是 1 。
- 将 nums[i] 和 nums[j] 都减去 2^k 。

如果一个子数组内执行上述操作若干次（包括 0 次）后，该子数组可以变成一个全为 0 的数组，那么我们称它是一个 美丽 的子数组。

请你返回数组 nums 中 美丽子数组 的数目。

子数组是一个数组中一段连续 非空 的元素序列。

注意：所有元素最初都是 0 的子数组被认为是美丽的，因为不需要进行任何操作。

**前缀和：**

美丽的子数组中，nums[i]到 nums[j]的二进制下的第 k 位为 1 的个数为偶数，只有这样才能两两配对变为 0。

所以 nums[i]到 nums[j]的异或和为 0，才能满足条件。

```js
/**
 * 功能：计算数组中「美丽子数组」的数量（美丽子数组指元素XOR和为0的子数组）
 * @param {number[]} nums - 输入的整数数组
 * @return {number} 美丽子数组的数量
 * 算法思想：利用异或前缀和结合哈希表统计，将子数组异或和问题转化为前缀和相等问题
 * 时间复杂度：O(n)，其中n为数组长度，每个元素仅遍历一次
 * 空间复杂度：O(n)，哈希表最多存储n+1个不同的前缀和
 */
var beautifulSubarrays = function (nums) {
  // 哈希表存储异或前缀和出现的次数，初始化前缀和0出现1次
  // （处理从数组起始位置开始的子数组）
  const cnt = new Map([[0, 1]]);
  let ans = 0; // 记录美丽子数组的数量
  let xor = 0; // 当前位置的异或前缀和（从数组开头到当前位置的异或和）

  // 遍历数组，计算异或前缀和并统计美丽子数组数量
  for (let x of nums) {
    // 更新当前异或前缀和：xor ^= x 等价于 xor = xor ^ x
    xor ^= x;

    // 关键：如果当前前缀和xor在哈希表中存在，则说明存在子数组异或和为0
    // 数量为哈希表中该前缀和出现的次数
    ans += cnt.get(xor) ?? 0;

    // 更新哈希表：当前前缀和出现次数+1
    cnt.set(xor, (cnt.get(xor) ?? 0) + 1);
  }

  return ans;
};
```
