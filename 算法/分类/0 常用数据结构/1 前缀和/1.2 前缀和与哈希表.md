### 1.2 前缀和与哈希表

#### [930. 和相同的二元子数组](https://leetcode.cn/problems/binary-subarrays-with-sum/description/)

给你一个二元数组 nums ，和一个整数 goal ，请你统计并返回有多少个和为 goal 的 非空 子数组。

子数组 是数组的一段连续部分。

##### 前缀和

```js
/**
 * 统计和为目标值的子数组数量（LeetCode 560题解）
 * @param {number[]} nums - 二进制数组（元素为0或1）
 * @param {number} goal - 目标和
 * @return {number} 满足条件的子数组数量
 * @note
 * 1. 使用前缀和配合哈希表实现O(n)时间复杂度
 * 2. 哈希表存储前缀和出现次数
 * 3. 核心公式：currentPrefix - previousPrefix = goal
 */
var numSubarraysWithSum = function (nums, goal) {
  let prefix = 0;
  // 哈希表记录前缀和出现次数（初始存在前缀和为0的情况）
  const cnt = new Map([[0, 1]]);
  let ans = 0;

  for (let i = 0; i < nums.length; i++) {
    prefix += nums[i]; // 计算当前前缀和
    // 查找符合 previousPrefix = currentPrefix - goal 的计数
    ans += cnt.get(prefix - goal) || 0;
    // 更新当前前缀和的计数
    cnt.set(prefix, (cnt.get(prefix) || 0) + 1);
  }
  return ans;
};
```

##### 滑动窗口

```js
/**
 * 计算二进制数组中满足指定和的子数组个数（滑动窗口解法）
 * @param {number[]} nums 二进制数组（仅含0/1元素）
 * @param {number} goal 目标子数组和
 * @return {number} 满足条件的子数组数量
 *
 * 实现原理：
 * 1. 使用双滑动窗口维护两个区间[l1,r]和[l2,r]
 * 2. sum1维护严格大于goal的窗口左边界l1
 * 3. sum2维护大于等于goal的窗口左边界l2
 * 4. 每个右端点r的有效子数组数为 l2 - l1
 *
 * 时间复杂度：O(n) 空间复杂度：O(1)
 */
var numSubarraysWithSum = function (nums, goal) {
  let sum1 = 0,
    sum2 = 0; // 维护两个滑动窗口的和
  let l1 = 0,
    l2 = 0; // 两个窗口的左边界
  let ans = 0;

  for (let r = 0; r < nums.length; r++) {
    sum1 += nums[r]; // 累加当前元素到两个窗口
    sum2 += nums[r];

    // 收缩sum1窗口直到sum <= goal
    while (sum1 > goal && l1 <= r) {
      sum1 -= nums[l1++];
    }

    // 收缩sum2窗口直到sum < goal
    while (sum2 >= goal && l2 <= r) {
      sum2 -= nums[l2++];
    }

    // 有效子数组数为两个左边界之差
    ans += l2 - l1;
  }
  return ans;
};
```

#### [1524. 和为奇数的子数组数目](https://leetcode.cn/problems/number-of-sub-arrays-with-odd-sum/description/)

给你一个整数数组 arr 。请你返回和为 奇数 的子数组数目。

由于答案可能会很大，请你将结果对 10^9 + 7 取余后返回。

```js
/**
 * 计算数组中满足条件的子数组数量（和为奇数的子数组）
 * @param {number[]} arr - 输入数组
 * @returns {number} 满足条件的子数组数量
 * @note 使用前缀和与奇偶计数优化，时间复杂度O(n)
 */
var numOfSubarrays = function (arr) {
  let ans = 0,
    evenCnt = 0, // 记录当前偶数前缀和的数量
    oddCnt = 0, // 记录当前奇数前缀和的数量
    sum = 0; // 运行中的前缀和

  // 遍历数组元素
  for (let i of arr) {
    sum += i;

    // 当前前缀和为奇数时
    if (sum % 2) {
      // 新增子数组数 = 1（当前元素本身） + 之前偶数前缀和的数量
      ans = (ans + 1 + evenCnt) % MOD;
      oddCnt++; // 更新奇数前缀和计数
    } else {
      // 新增子数组数 = 之前奇数前缀和的数量
      ans = (ans + oddCnt) % MOD;
      evenCnt++; // 更新偶数前缀和计数
    }
  }
  return ans;
};

// 模数常量（题目要求取模）
const MOD = 1e9 + 7;
```

#### [974. 和可被 K 整除的子数组](https://leetcode.cn/problems/subarray-sums-divisible-by-k/description/)

给定一个整数数组 nums 和一个整数 k ，返回其中元素之和可被 k 整除的非空 子数组 的数目。

子数组 是数组中 连续 的部分。

```js
/**
 * 计算可被k整除的子数组数量
 * @param {number[]} nums - 输入数组
 * @param {number} k - 除数
 * @returns {number} 满足条件的子数组数量
 * @note 使用前缀和+同余定理，时间复杂度O(n)
 */
var subarraysDivByK = function (nums, k) {
  let sum = 0, // 当前前缀和
    cnt = Array(k).fill(0); // 记录余数出现次数的哈希表
  let ans = 0;
  cnt[0] = 1; // 初始化余数为0的情况

  // 遍历数组元素
  for (let i of nums) {
    sum += i;
    // 处理负数余数：(sum % k + k) % k
    let m = ((sum % k) + k) % k;

    // 累加相同余数的出现次数
    ans += cnt[m];
    // 更新当前余数计数
    cnt[m] += 1;
  }
  return ans;
};
```

#### [523. 连续的子数组和](https://leetcode.cn/problems/continuous-subarray-sum/description/)

给你一个整数数组 nums 和一个整数 k ，如果 nums 有一个 好的子数组 返回 true ，否则返回 false：

一个 好的子数组 是：

- 长度 至少为 2 ，且
- 子数组元素总和为 k 的倍数。

注意：

- 子数组 是数组中 连续 的部分。
- 如果存在一个整数 n ，令整数 x 符合 x = n \* k ，则称 x 是 k 的一个倍数。0 始终 视为 k 的一个倍数。

```js
/**
 * 检查是否存在长度≥2的子数组，其和是k的倍数
 * @param {number[]} nums - 输入数组
 * @param {number} k - 目标倍数
 * @returns {boolean} 是否存在符合条件的子数组
 * @note 使用前缀和+同余定理，时间复杂度O(n)
 */
var checkSubarraySum = function (nums, k) {
  let sum = nums[0]; // 初始化前缀和
  let cnt = new Set([0]); // 存储历史余数的哈希集合

  // 从第二个元素开始遍历
  for (let i = 1; i < nums.length; i++) {
    sum += nums[i]; // 累加当前元素到前缀和

    // 检查当前余数是否存在于历史记录中
    if (cnt.has(sum % k)) {
      return true; // 找到符合条件的子数组
    }

    // 将前一个前缀和的余数存入集合（延迟一个位置）
    cnt.add((sum - nums[i]) % k);
  }
  return false;
};
```

#### [437. 路径总和 III](https://leetcode.cn/problems/path-sum-iii/description/)

给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。

路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

**前缀和 + 回溯**

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * 功能：计算二叉树中路径和等于目标值的路径数量（路径可以从任意节点开始和结束，但必须是向下的方向）
 * @param {TreeNode} root - 二叉树的根节点
 * @param {number} targetSum - 目标路径和
 * @return {number} 满足条件的路径数量
 * 算法思想：使用前缀和结合哈希表优化路径和计算，避免重复计算
 * 时间复杂度：O(n)，其中n为二叉树节点数，每个节点仅访问一次
 * 空间复杂度：O(h)，h为树的高度，主要用于递归栈和哈希表存储
 */
var pathSum = function (root, targetSum) {
  // 哈希表存储前缀和出现的次数，初始化前缀和0出现1次（处理从根节点开始的路径）
  const cnt = new Map([[0, 1]]);
  let ans = 0; // 记录满足条件的路径数量

  // 深度优先搜索函数
  // @param {TreeNode} node - 当前遍历的节点
  // @param {number} d - 从根节点到当前节点的前缀和
  const dfs = (node, d) => {
    if (!node) return; // 递归终止条件：节点为空

    // 当前路径的前缀和（从根节点到当前节点）
    let curr = d + node.val;

    // 关键：如果存在前缀和为curr - targetSum的路径，说明从该路径的下一个节点到当前节点的路径和为targetSum
    ans += cnt.get(curr - targetSum) ?? 0;

    // 更新哈希表：当前前缀和出现次数+1
    cnt.set(curr, (cnt.get(curr) ?? 0) + 1);

    // 递归遍历左右子树
    dfs(node.left, curr);
    dfs(node.right, curr);

    // 回溯：当前节点处理完毕，从哈希表中移除当前前缀和（避免影响其他路径）
    cnt.set(curr, cnt.get(curr) - 1);
  };

  // 从根节点开始深度优先搜索，初始前缀和为0
  dfs(root, 0);
  return ans;
};
```

#### [2588. 统计美丽子数组数目](https://leetcode.cn/problems/count-the-number-of-beautiful-subarrays/description/)

给你一个下标从 0 开始的整数数组 nums 。每次操作中，你可以：

- 选择两个满足 0 <= i, j < nums.length 的不同下标 i 和 j 。
- 选择一个非负整数 k ，满足 nums[i] 和 nums[j] 在二进制下的第 k 位（下标编号从 0 开始）是 1 。
- 将 nums[i] 和 nums[j] 都减去 2^k 。

如果一个子数组内执行上述操作若干次（包括 0 次）后，该子数组可以变成一个全为 0 的数组，那么我们称它是一个 美丽 的子数组。

请你返回数组 nums 中 美丽子数组 的数目。

子数组是一个数组中一段连续 非空 的元素序列。

注意：所有元素最初都是 0 的子数组被认为是美丽的，因为不需要进行任何操作。

**前缀和：**

美丽的子数组中，nums[i]到 nums[j]的二进制下的第 k 位为 1 的个数为偶数，只有这样才能两两配对变为 0。

所以 nums[i]到 nums[j]的异或和为 0，才能满足条件。

```js
/**
 * 功能：计算数组中「美丽子数组」的数量（美丽子数组指元素XOR和为0的子数组）
 * @param {number[]} nums - 输入的整数数组
 * @return {number} 美丽子数组的数量
 * 算法思想：利用异或前缀和结合哈希表统计，将子数组异或和问题转化为前缀和相等问题
 * 时间复杂度：O(n)，其中n为数组长度，每个元素仅遍历一次
 * 空间复杂度：O(n)，哈希表最多存储n+1个不同的前缀和
 */
var beautifulSubarrays = function (nums) {
  // 哈希表存储异或前缀和出现的次数，初始化前缀和0出现1次
  // （处理从数组起始位置开始的子数组）
  const cnt = new Map([[0, 1]]);
  let ans = 0; // 记录美丽子数组的数量
  let xor = 0; // 当前位置的异或前缀和（从数组开头到当前位置的异或和）

  // 遍历数组，计算异或前缀和并统计美丽子数组数量
  for (let x of nums) {
    // 更新当前异或前缀和：xor ^= x 等价于 xor = xor ^ x
    xor ^= x;

    // 关键：如果当前前缀和xor在哈希表中存在，则说明存在子数组异或和为0
    // 数量为哈希表中该前缀和出现的次数
    ans += cnt.get(xor) ?? 0;

    // 更新哈希表：当前前缀和出现次数+1
    cnt.set(xor, (cnt.get(xor) ?? 0) + 1);
  }

  return ans;
};
```

#### [525. 连续数组](https://leetcode.cn/problems/contiguous-array/description/)

给定一个二进制数组 nums , 找到含有相同数量的 0 和 1 的最长连续子数组，并返回该子数组的长度。

**前缀和：**

计算前缀和，如果 nums[i]为 0，前缀和-1，为 1，前缀和+1。

将设当前前缀和为 sum，需要寻找 0-i-1 中前缀和同样为 sum 的最小下标

```js
/**
 * 功能：寻找二进制数组中含有相同数量0和1的最长连续子数组的长度
 * @param {number[]} nums - 只包含0和1的二进制数组
 * @return {number} 满足条件的最长子数组长度，若不存在则返回0
 * 算法思想：将0视为-1，转化为寻找和为0的最长子数组问题，利用前缀和结合哈希表实现
 * 时间复杂度：O(n)，其中n为数组长度，每个元素仅遍历一次
 * 空间复杂度：O(n)，哈希表最多存储n+1个不同的前缀和
 */
var findMaxLength = function (nums) {
  // 哈希表存储前缀和第一次出现的索引，初始化前缀和0对应索引-1
  // （处理从数组起始位置开始的子数组）
  const map = new Map([[0, -1]]);
  let ans = 0; // 记录最长子数组长度
  let cnt = 0; // 当前前缀和（将0视为-1，1视为1的累加和）

  // 遍历数组，计算前缀和并更新最长子数组长度
  for (let i = 0; i < nums.length; i++) {
    // 更新当前前缀和：遇到1加1，遇到0减1（等价于加-1）
    cnt += nums[i] === 1 ? 1 : -1;

    // 关键：如果当前前缀和已存在于哈希表中，说明两个索引之间的子数组和为0
    // 计算子数组长度并更新最大值
    if (map.has(cnt)) {
      ans = Math.max(ans, i - map.get(cnt));
    } else {
      // 仅存储前缀和第一次出现的索引，确保后续遇到相同前缀和时能得到最长子数组
      map.set(cnt, i);
    }
  }

  return ans;
};
```

#### [3026. 最大好子数组和](https://leetcode.cn/problems/maximum-good-subarray-sum/description/)

给你一个长度为 n 的数组 nums 和一个 正 整数 k 。

如果 nums 的一个子数组中，第一个元素和最后一个元素 差的绝对值恰好 为 k ，我们称这个子数组为 好 的。换句话说，如果子数组 nums[i..j] 满足 |nums[i] - nums[j]| == k ，那么它是一个好子数组。

请你返回 nums 中 好 子数组的 最大 和，如果没有好子数组，返回 0

**前缀和：**

注意： 前缀和 p[i]表示 nums[0]到 nums[i-1]的和，这样寻找到 nums[j]的时候前缀和直接为 sum - p[j];

```js
/**
 * 寻找数组中和满足特定条件的最大子数组和
 * @param {number[]} nums - 输入的整数数组
 * @param {number} k - 目标差值
 * @return {number} - 满足条件的最大子数组和，如果不存在则返回0
 *
 * 算法思路：前缀和 + 哈希表优化
 * 时间复杂度：O(n)，其中n是nums数组的长度
 * 空间复杂度：O(n)，哈希表最多存储n个不同的前缀和
 */
var maximumSubarraySum = function (nums, k) {
  // 创建哈希表存储前缀和的最小值，键为前缀和，值为该前缀和对应的最小前缀和
  const map = new Map();
  // 初始化前缀和为0
  let sum = 0;
  // 初始化结果为负无穷大
  let ans = -Infinity;

  for (let i = 0; i < nums.length; i++) {
    // 前缀和 p[i]表示 nums[0]到 nums[i-1]的和
    // 如果当前数字已在哈希表中，更新其对应的前缀和为较小值；否则添加到哈希表
    map.set(nums[i], Math.min(map.get(nums[i]) ?? Infinity, sum));
    // 更新前缀和，加上当前数字
    sum += nums[i];

    // 情况1：寻找第一个元素为k + nums[i]的最小前缀和
    if (map.has(k + nums[i])) {
      ans = Math.max(ans, sum - map.get(k + nums[i]));
    }
    // 情况2：寻找第一个元素为nums[i] - k的最小前缀和
    if (map.has(nums[i] - k)) {
      ans = Math.max(ans, sum - map.get(-k + nums[i]));
    }
  }

  // 如果没有找到满足条件的子数组，返回0；否则返回找到的最大子数组和
  return ans == -Infinity ? 0 : ans;
};
```

#### [1477. 找两个和为目标值且不重叠的子数组](https://leetcode.cn/problems/find-two-non-overlapping-sub-arrays-each-with-target-sum/description/)

给你一个整数数组 arr 和一个整数值 target 。

请你在 arr 中找 两个互不重叠的子数组 且它们的和都等于 target 。可能会有多种方案，请你返回满足要求的两个子数组长度和的 最小值 。

请返回满足要求的最小长度和，如果无法找到这样的两个子数组，请返回 -1 。

**前缀和 + 动态规划**

- prefix[i + 1]， 0 - i 的和
- f[i + 1]，表示 0 - i 中，和为 target 的子数组的最小长度

用 map 记录前缀和的右边界，遍历到 i 时，通过 map 找到 sum - target 的右边界 j，为第二个子数组，在通过 f[j]获得 0-j-1 子数组和为 target 的最小长度。

```js
/**
 * 寻找两个不重叠子数组，使其和等于目标值的最小总长度
 * @param {number[]} arr - 输入的整数数组
 * @param {number} target - 目标子数组和
 * @return {number} - 返回满足条件的最小总长度，若不存在则返回-1
 *
 * 算法思路：前缀和 + 动态规划优化
 * 时间复杂度：O(n)，其中n是arr数组的长度
 * 空间复杂度：O(n)，哈希表最多存储n个不同的前缀和
 */
var minSumOfLengths = function (arr, target) {
  const n = arr.length;
  // 哈希表存储前缀和与对应的右边界索引
  const map = new Map([[0, 0]]);
  // f数组记录到当前位置为止的最短有效子数组长度
  const f = Array(n + 1).fill(Infinity);
  let sum = 0;
  let ans = Infinity;

  for (let i = 0; i < n; i++) {
    sum += arr[i];
    // 检查是否存在满足条件的前缀和
    if (map.has(sum - target)) {
      let l = map.get(sum - target);
      // 更新最小总长度（当前子数组长度 + 之前的最短长度）
      ans = Math.min(ans, i - l + 1 + f[l]);
      // 优化：提前返回最小可能值
      if (ans == 2) return ans;
      // 更新当前位置的最短子数组长度
      f[i + 1] = Math.min(f[i], i - l + 1);
    } else {
      // 保持前一个位置的最短长度
      f[i + 1] = f[i];
    }
    // 记录当前前缀和对应的右边界（i+1保证左闭右开）
    map.set(sum, i + 1);
  }

  return ans == Infinity ? -1 : ans;
};
```

#### [1124. 表现良好的最长时间段](https://leetcode.cn/problems/longest-well-performing-interval/description/)

给你一份工作时间表 hours，上面记录着某一位员工每天的工作小时数。

我们认为当员工一天中的工作小时数大于 8 小时的时候，那么这一天就是「劳累的一天」。

所谓「表现良好的时间段」，意味在这段时间内，「劳累的天数」是严格 大于「不劳累的天数」。

请你返回「表现良好时间段」的最大长度。

##### **前缀和 + 哈希表**

hours 中，大于 8 小时的为 1，小于等于 8 小时的为 -1。

遍历 hours，计算前缀和 sum，用 map 记录 sum 第一次出现的位置。

假设当前遍历到i，前缀和为 sum:
- 如果sum > 0，说明0-i-1中，劳累的天数大于不劳累的天数，直接更新ans为i+1
- 如果sum <= 0，，需要寻找0-i-1中前缀和小于sum的最左侧下标。
  - 因为hours转换为1和-1，所以前缀和sum - 1一定存在，且为前缀和小于sum的最左侧下标。如果存在比sum-1更小的前缀和，那么它一定要从sum-1的位置-1才能到达。

```js
/**
 * 计算最长表现良好时间段（表现良好天数 > 非良好天数）
 * @param {number[]} hours - 每日工作时间数组
 * @returns {number} 最长符合条件的时间段长度
 * @note 使用前缀和+哈希表优化，时间复杂度O(n)
 */
var longestWPI = function (hours) {
    const n = hours.length;
    const map = new Map([[0, -1]]); // 初始化哈希表，key为前缀和，value为首次出现索引
    let ans = 0, sum = 0; // ans记录最大长度，sum为前缀和

    // 遍历每个小时记录
    for (let i = 0; i < n; i++) {
        // 计算当前前缀和（表现良好+1，否则-1）
        sum += (hours[i] > 8 ? 1 : -1);

        // 当前前缀和>0时，整个数组都满足条件
        if (sum > 0) {
            ans = Math.max(ans, i + 1);
        } else {
            // 查找是否存在sum-1的前缀和，确保有更多表现良好天数
            if (map.has(sum - 1)) {
                ans = Math.max(ans, i - map.get(sum - 1));
            }
        }

        // 仅记录前缀和的首次出现位置
        if (!map.has(sum)) {
            map.set(sum, i);
        }
    }
    return ans;
};

```

##### 单调栈

**单调递减栈的作用：** 筛选最优左边界候选
栈 st 中存储的是 prefix 数组索引，且这些索引对应的 prefix 值严格单调递减。这样做的原因是：

- 排除非最优候选：若存在两个索引 i1 < i2，且 prefix[i1] ≤ prefix[i2]，则 i2 永远不可能成为最优左边界。
因为对任意 j > i2，若 prefix[j] > prefix[i2]，则 prefix[j] 必然也 > prefix[i1]，且 j - i1 > j - i2（i1 更小），此时 i2 无意义，可被舍弃。
- 保留潜在最优候选：栈中只保留 prefix 值更小的索引，确保每个元素都是可能的“最小 i”（即未来可能与最大 j 匹配的最优左边界）。

**逆序遍历查找距离最远的更大元素**
当逆序遍历 j（从后往前查找右边界）时：

- 由于栈是单调递减的，若 prefix[j] > prefix[栈顶索引]，则栈顶索引就是当前 j 能匹配的最小 i（此时 j - i 最大）。
- 弹出栈顶后，继续检查新栈顶是否满足条件，直到栈为空或不满足 prefix[j] > prefix[栈顶索引]，确保不遗漏更大的 j - i。

```js
/**
 * @param {number[]} hours - 员工每天的工作小时数数组
 * @return {number} - 表现良好时间段的最大长度
 */
var longestWPI = function (hours) {
    const n = hours.length;
    // prefix[i]表示前i天的"劳累度差值"：劳累天数(>8小时) - 不劳累天数(<=8小时)
    const prefix = Array(n + 1).fill(0);
    // 单调栈：存储prefix数组中递减序列的索引（用于后续快速查找有效区间）
    const st = [0]; 
    let ans = 0; // 记录最大长度结果

    // 第一遍遍历：计算prefix数组并构建单调栈
    for (let i = 0; i < n; i++) {
        // 计算当前prefix值：若当天劳累则+1，否则-1
        prefix[i + 1] = prefix[i] + (hours[i] > 8 ? 1 : -1);
        
        // 若当前prefix值>0，说明从第0天到第i天是有效区间，直接更新结果
        if (prefix[i + 1] > 0) {
            ans = Math.max(ans, i + 1);
        }
        
        // 维护单调栈：只保留prefix值递减的索引（确保栈内元素对应prefix值严格递减）
        // 当栈为空或当前prefix值小于栈顶索引对应的prefix值时，将当前索引入栈
        if (!st.length || prefix[i + 1] < prefix[st[st.length - 1] + 1]) {
            st.push(i);
        }
    }

    // 第二遍遍历：从后往前查找最大有效区间
    for (let i = n - 1; i >= 0; i--) {
        // 当栈非空且当前prefix值大于栈顶索引对应的prefix值时，说明找到了有效区间
        // 弹出栈顶元素并计算区间长度，更新最大长度
        while (st.length && prefix[i + 1] > prefix[st[st.length - 1] + 1]) {
            ans = Math.max(ans, i - st.pop());
        }
    }

    return ans;
};

```

#### [3381. 长度可被 K 整除的子数组的最大元素和](https://leetcode.cn/problems/maximum-subarray-sum-with-length-divisible-by-k/description/)
 
给你一个整数数组 nums 和一个整数 k 。

返回 nums 中一个 非空子数组 的 最大 和，要求该子数组的长度可以 被 k 整除。

**前缀和 + 哈希表**

哈希表记录 [i % k, 最小prefix[i]]

```js
/**
 * 寻找满足特定条件的最大子数组和（同余定理应用）
 * @param {number[]} nums - 输入整数数组
 * @param {number} k - 模数，用于同余条件判断
 * @returns {number} 满足 (子数组长度 % k == 0) 条件的最大子数组和
 * @note 算法核心思想：
 * 1. 利用前缀和快速计算子数组和
 * 2. 应用同余定理优化查找效率（当 i ≡ j mod k 时，j+1 到 i 的子数组长度能被k整除）
 * 3. 使用哈希表记录最小前缀和实现O(1)时间查找
 * 时间复杂度：O(n) 空间复杂度：O(k)
 */
var maxSubarraySum = function (nums, k) {
    // 初始化哈希表：键为余数，值为对应最小前缀和
    const map = new Map([[(-1 % k + k) % k, 0]]);
    let sum = 0;
    let ans = -Infinity;

    // 遍历计算前缀和
    for (let i = 0; i < nums.length; i++) {
        sum += nums[i];
        
        // 计算当前前缀和对k的余数
        let m = i % k;

        // 当存在相同余数时，计算潜在最大值
        if (map.has(m)) {
            // 当前前缀和 - 历史最小前缀和 = 当前最大候选值
            ans = Math.max(ans, sum - map.get(m));
        }

        // 维护最小前缀和：保留相同余数下的最小前缀和
        map.set(m, Math.min(sum, map.get(m) ?? Infinity))
    }
    return ans;
};

```

#### [2488. 统计中位数为 K 的子数组 ](https://leetcode.cn/problems/count-subarrays-with-median-k/description/)

给你一个长度为 n 的数组 nums ，该数组由从 1 到 n 的 不同 整数组成。另给你一个正整数 k 。

统计并返回 nums 中的 中位数 等于 k 的非空子数组的数目。

注意：

- 数组的中位数是按 递增 顺序排列后位于 中间 的那个元素，如果数组长度为偶数，则中位数是位于中间靠 左 的那个元素。
  - 例如，[2,3,1,4] 的中位数是 2 ，[8,4,3,5,1] 的中位数是 4 。
- 子数组是数组中的一个连续部分。

**前缀和 + 哈希表**

假设子数组长度为奇数:
  1. 中位数为k，表示子数组中k的左右元素数量相等
  2. 设子数组中左侧大于k的元素数量为lMx，左侧小于k的元素数量为lMn，右侧大于k的元素数量为rMx，右侧小于k的元素数量为rMn
  3. 则有 lMx + rMx = lMn + rMn => lMx - lMn = rMn - rMx
  4. 因此将k的左侧中大于k的元素设为1，小于k的元素设为-1，k的右侧中大于k的元素设为-1，小于k的元素设为1。
  5. 计算0-kIdx-1的后缀和并用hash记录数量，枚举计算kIdx+1-n的前缀和是查找hash中相等的数量
假设子数组长度为偶数:
  1. 则有 lMx + rMx = lMn + rMn + 1 => lMx - lMn = rMn - rMx + 1


```js
/**
 * 统计中位数为 K 的子数组数目
 * @param {number[]} nums - 由1到n的不同整数组成的数组
 * @param {number} k - 目标中位数
 * @return {number} 中位数等于k的非空子数组数目
 * @note 算法核心思想：前缀和+哈希表优化，时间复杂度O(n)，空间复杂度O(n)
 */
var countSubarrays = function (nums, k) {
    const n = nums.length;
    let kIdx = -1;
    
    // 找到k在数组中的位置
    for (let i = 0; i < n; i++) {
        if (nums[i] == k) {
            kIdx = i;
            break;
        }
    }
    
    let sum = 0;
    // 哈希表记录k左侧后缀和出现的次数，初始状态sum=0出现1次
    let leftCnt = new Map([[0, 1]]);
    
    // 计算k左侧的后缀和：大于k的元素记为1，小于k的元素记为-1
    for (let i = kIdx - 1; i >= 0; i--) {
        sum += nums[i] > k ? 1 : -1;
        leftCnt.set(sum, (leftCnt.get(sum) ?? 0) + 1);
    }
    
    // 初始答案：右侧rMn - rMx = 0的情况
    let ans = leftCnt.get(0) + (leftCnt.get(1) ?? 0);
    sum = 0;
    
    // 计算k右侧的前缀和：大于k的元素记为-1，小于k的元素记为1
    for (let i = kIdx + 1; i < n; i++) {
        sum += nums[i] > k ? -1 : 1;
        
        // 情况1：子数组长度为奇数，需要lMx - lMn = rMn - rMx
        ans += leftCnt.get(sum) ?? 0;
        // 情况2：子数组长度为偶数，需要lMx - lMn = rMn - rMx + 1
        ans += leftCnt.get(sum + 1) ?? 0;
    }
    
    return ans;
};

```