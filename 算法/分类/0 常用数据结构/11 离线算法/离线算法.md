### 离线算法

#### [2343. 裁剪数字后查询第 K 小的数字](https://leetcode.cn/problems/query-kth-smallest-trimmed-number/description/)

给你一个下标从 **0** 开始的字符串数组 `nums` ，其中每个字符串 **长度相等** 且只包含数字。

再给你一个下标从 **0** 开始的二维整数数组 `queries` ，其中 `queries[i] = [ki, trimi]` 。对于每个 `queries[i]` ，你需要：

* 将 `nums` 中每个数字 **裁剪** 到剩下 **最右边** `trimi` 个数位。
* 在裁剪过后的数字中，找到 `nums` 中第 `ki` 小数字对应的 **下标** 。如果两个裁剪后数字一样大，那么下标 **更小** 的数字视为更小的数字。
* 将 `nums` 中每个数字恢复到原本字符串。

请你返回一个长度与 `queries` 相等的数组`answer`，其中`answer[i]`是第`i`次查询的结果。

**提示：**

* 裁剪到剩下最右边 `x` 个数位的意思是不断删除最左边的数位，直到剩下 `x` 个数位。
* `nums` 中的字符串可能会有前导 0 。

**示例 1：**

```
输入：nums = ["102","473","251","814"], queries = [[1,1],[2,3],[4,2],[1,2]]
输出：[2,2,1,0]
解释：
1. 裁剪到只剩 1 个数位后，nums = ["2","3","1","4"] 。最小的数字是 1 ，下标为 2 。
2. 裁剪到剩 3 个数位后，nums 没有变化。第 2 小的数字是 251 ，下标为 2 。
3. 裁剪到剩 2 个数位后，nums = ["02","73","51","14"] 。第 4 小的数字是 73 ，下标为 1 。
4. 裁剪到剩 2 个数位后，最小数字是 2 ，下标为 0 。
   注意，裁剪后数字 "02" 值为 2 。
```

**示例 2：**

```
输入：nums = ["24","37","96","04"], queries = [[2,1],[2,2]]
输出：[3,0]
解释：
1. 裁剪到剩 1 个数位，nums = ["4","7","6","4"] 。第 2 小的数字是 4 ，下标为 3 。
   有两个 4 ，下标为 0 的 4 视为小于下标为 3 的 4 。
2. 裁剪到剩 2 个数位，nums 不变。第二小的数字是 24 ，下标为 0 。
```

**提示：**

* `1 <= nums.length <= 100`
* `1 <= nums[i].length <= 100`
* `nums[i]` 只包含数字。
* 所有 `nums[i].length` 的长度 **相同** 。
* `1 <= queries.length <= 100`
* `queries[i].length == 2`
* `1 <= ki <= nums.length`
* `1 <= trimi <= nums[0].length`

**进阶：**你能使用 **基数排序算法** 解决此问题吗？这种解法的复杂度又是多少？

##### 离线

```js
/**
 * 查找每个查询中指定修剪位数后的第k小数字的原始索引
 * @param {string[]} nums - 包含数字字符串的数组，所有字符串长度相同
 * @param {number[][]} queries - 二维数组，每个子数组[ k, trim ]表示：
 *                              - k: 修剪后要查找的第k小的元素（从1开始）
 *                              - trim: 需要从右往左修剪的位数
 * @return {number[]} 结果数组，每个元素对应查询的原始数组中的索引
 * @note 该算法采用增量排序策略，逐步从右到左比较数字位，避免重复排序
 * @complexity 时间复杂度：O(m log m + mx * n log n + m)，其中n是nums长度，m是queries长度，mx是最大的trim值
 */
var smallestTrimmedNumbers = function (nums, queries) {
    const n = nums.length, m = queries.length;
    // 创建原始索引数组，用于跟踪排序后的原始位置
    const idx = Array.from({ length: n }, (_, i) => i);
    // 对查询按trim值从小到大排序，以便按顺序处理
    const sorted = Array.from({ length: m }, (_, i) => i).sort((a, b) => queries[a][1] - queries[b][1]);
    // 确定最大的trim值和字符串长度
    const mx = queries[sorted[m - 1]][1], chrLen = nums[0].length;
    const ans = Array(m);
    
    // 从1开始逐位增加trim位数，直到最大trim值
    for (let i = 1, j = 0; i <= mx; i++) {
        // 按当前trim位数从右往左第i位进行排序
        // 注意：charAt返回字符，这里通过减法操作自动转为ASCII码比较
        idx.sort((a, b) => nums[a].charAt(chrLen - i) - nums[b].charAt(chrLen - i));
        
        // 处理所有trim值等于当前i的查询
        while (j < m && queries[sorted[j]][1] <= i) {
            let [k, trim] = queries[sorted[j]];
            if (trim == i) {
                // 找到第k小的元素（注意索引从0开始，所以k-1）
                ans[sorted[j]] = idx[k - 1];
            }
            j++;
        }
    }
    
    return ans;
};

```

##### 基数排序 + 离线

```js
/**
 * 查找每个查询中指定修剪位数后的第k小数字的原始索引（使用离线算法+基数排序优化）
 * @param {string[]} nums - 包含数字字符串的数组，所有字符串长度相同
 * @param {number[][]} queries - 二维数组，每个子数组[ k, trim ]表示：
 *                              - k: 修剪后要查找的第k小的元素（从1开始）
 *                              - trim: 需要从右往左修剪的位数
 * @return {number[]} 结果数组，每个元素对应查询的原始数组中的索引
 * @note 该算法结合了离线处理和基数排序的思想，通过增量方式逐步构建排序结果
 * @complexity 时间复杂度：O(m log m + mx * n + m)，其中n是nums长度，m是queries长度，mx是最大的trim值
 *              空间复杂度：O(n + m + 10)，10表示数字0-9的桶
 */
var smallestTrimmedNumbers = function (nums, queries) {
    const n = nums.length, m = queries.length;
    // 创建原始索引数组，用于跟踪排序后的原始位置
    let idx = Array.from({ length: n }, (_, i) => i);
    
    // 对查询按trim值从小到大排序（离线处理的关键步骤）
    // sorted数组存储的是查询的原始索引，按trim值排序
    const sorted = Array.from({ length: m }, (_, i) => i).sort((a, b) => queries[a][1] - queries[b][1]);
    
    // 确定最大的trim值和数字字符串的长度
    const mx = queries[sorted[m - 1]][1], chrLen = nums[0].length;
    const ans = Array(m);
    
    // 从1开始逐位增加trim位数，直到最大trim值
    for (let i = 1, j = 0; i <= mx; i++) {
        // 使用基数排序的思想，按当前位（从右数第i位）进行桶排序
        const buckets = Array.from({length: 10}, () => []); // 创建0-9共10个桶
        
        // 根据当前处理的位，将索引分配到对应的桶中
        for (let index of idx) {
            // 获取当前数字字符串从右数第i位的字符
            buckets[nums[index].charAt(chrLen - i)].push(index);
        }
        
        // 清空原索引数组，准备重构排序后的索引
        idx.length = 0;
        
        // 按0-9的顺序将桶中的索引合并回idx数组（保证稳定排序）
        for (let bucket of buckets) {
            idx.push(...bucket);
        }
        
        // 处理所有trim值等于当前i的查询
        while (j < m && queries[sorted[j]][1] <= i) {
            let [k, trim] = queries[sorted[j]];
            if (trim == i) {
                // 找到第k小的元素的原始索引（注意索引从0开始，所以k-1）
                ans[sorted[j]] = idx[k - 1];
            }
            j++;
        }
    }
    
    return ans;
};

```