### 7.1 并查集基础

#### [3532. 针对图的路径存在性查询 I](https://leetcode.cn/problems/path-existence-queries-in-a-graph-i/description/)
 
给你一个整数 n，表示图中的节点数量，这些节点按从 0 到 n - 1 编号。

同时给你一个长度为 n 的整数数组 nums，该数组按 非递减 顺序排序，以及一个整数 maxDiff。

如果满足 |nums[i] - nums[j]| <= maxDiff（即 nums[i] 和 nums[j] 的 绝对差 至多为 maxDiff），则节点 i 和节点 j 之间存在一条 无向边 。

此外，给你一个二维整数数组 queries。对于每个 queries[i] = [ui, vi]，需要判断节点 ui 和 vi 之间是否存在路径。

返回一个布尔数组 answer，其中 answer[i] 等于 true 表示在第 i 个查询中节点 ui 和 vi 之间存在路径，否则为 false。

##### 并查集
```js
/**
 * 功能：使用并查集判断数组中相邻元素差值不超过maxDiff的路径存在性
 * 参数：n - 数组长度，nums - 数值数组，maxDiff - 最大差值，queries - 查询数组
 * 返回：boolean[] - 每个查询的结果数组
 * 时间复杂度：O(n + q * α(n))，空间复杂度：O(n)
 */
var pathExistenceQueries = function (n, nums, maxDiff, queries) {
    const st = new UnionSet(n);  // 创建并查集实例
    
    // 构建连通分量：连接相邻且差值不超过maxDiff的元素
    for (let i = 1; i < n; i++) {
        if (nums[i] - nums[i - 1] <= maxDiff) {
            st.union(i, i - 1);  // 合并相邻符合条件的元素
        }
    }
    
    const ans = [];
    // 处理每个查询：检查两个元素是否在同一个连通分量中
    for (let [x, y] of queries) {
        ans.push(st.find(x) == st.find(y))  // 判断连通性
    }
    return ans;
};

/**
 * 并查集类实现
 * 功能：支持路径压缩和按秩合并的并查集数据结构
 */
class UnionSet {
    constructor(n) {
        this.fa = Array.from({ length: n }, (_, i) => i);  // 父节点数组，初始每个元素自成一派
        this.size = Array(n).fill(0);                     // 集合大小数组，用于按秩合并
    }

    /**
     * 查找操作：找到元素x的根节点（代表元素）
     * 参数：x - 要查找的元素
     * 返回：x所在集合的根节点
     * 时间复杂度：O(α(n))，近似常数时间
     */
    find(x) {
        if (x == this.fa[x]) return x;                    // 找到根节点
        this.fa[x] = this.find(this.fa[x]);              // 路径压缩：直接指向根节点
        return this.fa[x];                               // 返回根节点
    }

    /**
     * 合并操作：将元素x和y所在的集合合并
     * 参数：x, y - 要合并的两个元素
     * 返回：boolean - 是否成功合并（原本不在同一集合）
     * 时间复杂度：O(α(n))，近似常数时间
     */
    union(x, y) {
        let fx = this.find(x), fy = this.find(y);        // 找到两个元素的根节点
        if (fx == fy) return false;                      // 已经在同一集合，无需合并
        
        // 按秩合并：将小树合并到大树下，保持树的高度较小
        if (this.size[fx] < this.size[fy]) {
            this.fa[fx] = fy;                            // 将fx的根指向fy
            this.size[fy] += this.size[fx];              // 更新集合大小
        } else {
            this.fa[fy] = fx;                            // 将fy的根指向fx
            this.size[fx] += this.size[fy];              // 更新集合大小
        }
        return true;                                     // 合并成功
    }
}

```

##### 二分
```js
/**
 * 功能：使用二分查找判断数组中相邻元素差值超过maxDiff的断点位置
 * 参数：n - 数组长度，nums - 数值数组，maxDiff - 最大差值，queries - 查询数组
 * 返回：boolean[] - 每个查询的结果数组
 * 时间复杂度：O(n + q * logk)，空间复杂度：O(k) 其中k为断点数量
 */
var pathExistenceQueries = function (n, nums, maxDiff, queries) {
    const idx = [];  // 存储断点位置（差值超过maxDiff的位置）
    
    // 查找所有断点位置：相邻元素差值超过maxDiff的位置
    for (let i = 0; i < n - 1; i++) {
        if (nums[i + 1] - nums[i] > maxDiff) {
            idx.push(i);  // 记录断点位置（i和i+1之间断开）
        }
    }
    
    const ans = [];
    // 处理每个查询：检查两个元素是否在同一个连续段中
    for (let [u, v] of queries) {
        let ui = lowerBound(u, idx), vi = lowerBound(v, idx);
        ans.push(ui == vi);  // 如果断点索引相同，说明在同一连续段
    }
    return ans;
};

/**
 * 二分查找函数：查找目标值在断点数组中的插入位置
 * 功能：返回第一个大于等于target的断点位置索引
 * 参数：target - 目标位置，nums - 断点位置数组（已排序）
 * 返回：number - 断点数组中的索引位置
 * 时间复杂度：O(logk)，k为断点数量
 */
function lowerBound(target, nums) {
    let l = 0, r = nums.length - 1;
    // 二分查找：在断点数组中查找target的插入位置
    while (l <= r) {
        let m = Math.floor((r - l) / 2) + l;  // 计算中间位置，避免溢出
        if (nums[m] < target) {
            l = m + 1;  // 目标在右侧
        } else {
            r = m - 1;  // 目标在左侧或等于
        }
    }
    return l;  // 返回插入位置（第一个大于等于target的索引）
}

```

#### [990. 等式方程的可满足性](https://leetcode.cn/problems/satisfiability-of-equality-equations/description/)
 
给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 equations[i] 的长度为 4，并采用两种不同的形式之一："a==b" 或 "a!=b"。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。

只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 true，否则返回 false。

```js
/**
 * 功能：判断一组等式是否可能同时成立
 * 参数：equations - 字符串数组，每个字符串表示一个等式（如 "a==b" 或 "a!=b"）
 * 返回：布尔值 - 如果所有等式可以同时成立返回true，否则返回false
 * 算法核心思想：使用并查集（Union-Find）数据结构处理等式关系
 * 时间复杂度：O(nα(n))，其中n是等式数量，α是阿克曼函数的反函数（近似于常数）
 * 空间复杂度：O(1) - 固定大小的并查集（26个字母）
 */
var equationsPossible = function (equations) {
    // 初始化大小为26的并查集（对应26个小写字母）
    const st = new UnionSet(26);
    // 存储所有不等关系的数组
    const diff = [];
    
    // 第一步：处理所有等式关系，将相等的变量合并到同一集合
    for (let eq of equations) {
        // 将字符转换为0-25的索引（'a'-'z'）
        let x = eq[0].charCodeAt() - 97, y = eq[3].charCodeAt() - 97;
        if (eq[1] == "=") {
            // 如果是相等关系，合并两个变量所在的集合
            st.union(x, y)
        } else {
            // 如果是不等关系，暂时记录下来
            diff.push([x, y]);
        }
    }
    
    // 第二步：检查所有不等关系是否与已建立的相等关系矛盾
    for (let [x, y] of diff) {
        // 如果两个应该不等的变量在同一个集合中，说明存在矛盾
        if (st.isSame(x, y)) return false;
    }
    
    // 没有发现矛盾，所有等式可以同时成立
    return true;
};

/**
 * 并查集（Union-Find）数据结构
 * 用于高效地管理元素的分组情况，支持合并集合和判断元素是否在同一集合
 */
class UnionSet {
    /**
     * 构造函数
     * 参数：n - 元素数量（这里未使用，因为固定处理26个字母）
     */
    constructor(n) {
        // 初始化父节点数组，每个元素的父节点初始为自身
        this.fa = Array.from({ length: 26 }, (_, i) => i);
    }

    /**
     * 查找元素所在集合的代表元素（根节点）
     * 参数：x - 要查找的元素
     * 返回：元素x所在集合的根节点
     * 特点：采用路径压缩优化，提高后续查找效率
     */
    find(x) {
        // 如果x不是根节点，则递归查找其父节点
        if (x == this.fa[x]) return this.fa[x];
        // 路径压缩：将x的父节点直接设为根节点
        this.fa[x] = this.find(this.fa[x]);
        return this.fa[x];
    }

    /**
     * 判断两个元素是否在同一集合中
     * 参数：x, y - 要判断的两个元素
     * 返回：布尔值 - 如果在同一集合返回true，否则返回false
     */
    isSame(x, y) {
        // 两个元素在同一集合当且仅当它们的根节点相同
        return this.find(x) === this.find(y);
    }

    /**
     * 合并两个元素所在的集合
     * 参数：x, y - 要合并的两个元素
     * 返回：布尔值 - 如果合并成功（原本不在同一集合）返回true，否则返回false
     */
    union(x, y) {
        // 找到x和y的根节点
        let fax = this.find(x), fay = this.find(y);
        // 如果已经在同一集合，无需合并
        if (fax == fay) return false;
        // 合并两个集合：将x的根节点的父节点设为y的根节点
        this.fa[fax] = fay;
        return true;
    }
}

```