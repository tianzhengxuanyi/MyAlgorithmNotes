### 并查集的进阶

#### [765. 情侣牵手](https://leetcode.cn/problems/couples-holding-hands/description/)

n 对情侣坐在连续排列的 2n 个座位上，想要牵到对方的手。

人和座位由一个整数数组 row 表示，其中 row[i] 是坐在第 i 个座位上的人的 ID。情侣们按顺序编号，第一对是 (0, 1)，第二对是 (2, 3)，以此类推，最后一对是 (2n-2, 2n-1)。

返回 最少交换座位的次数，以便每对情侣可以并肩坐在一起。 每次交换可选择任意两人，让他们站起来交换座位。

```js
/**
 * 计算让所有情侣坐在一起所需的最小交换次数
 * @param {number[]} row - 表示情侣初始座位的数组，其中元素为个人编号
 * @return {number} - 所需的最小交换次数
 * @算法核心思想：使用并查集寻找连通分量，最小交换次数 = 总对数 - 连通分量数
 * @时间复杂度：O(nα(n))，其中n为情侣对数，α为阿克曼函数的反函数，近似常数
 * @空间复杂度：O(n)
 */
var minSwapsCouples = function(row) {
    const n = row.length / 2; // 计算情侣的总对数
    const st = new UnionSet(n); // 初始化并查集，每个元素代表一对情侣的位置
    
    // 遍历每一对相邻的座位
    for (let i = 1; i < 2 * n; i += 2) {
        // 将相邻两个人所在的情侣对合并到同一个集合
        // Math.floor(num/2) 将个人编号转换为其所属的情侣对编号
        st.union(Math.floor(row[i] / 2), Math.floor(row[i - 1] / 2));
    }
    
    // 最小交换次数 = 情侣总对数 - 连通分量数
    return n - st.cc;
};

/**
 * 并查集数据结构实现
 * 用于高效地管理元素的合并与查找操作
 */
class UnionSet {
    /**
     * 初始化并查集
     * @param {number} n - 元素数量
     */
    constructor(n) {
        // 初始化父节点数组，每个元素指向自己
        this.fa = Array.from({length: n}, (_, i) => i);
        // 连通分量计数，初始时每个元素都是一个独立的连通分量
        this.cc = n;
    }

    /**
     * 查找元素所属的集合（带路径压缩优化）
     * @param {number} x - 要查找的元素
     * @return {number} - 元素所属集合的代表元素（根节点）
     */
    find(x) {
        // 路径压缩：将查找路径上的每个节点直接连接到根节点
        if (x == this.fa[x]) return this.fa[x];
        this.fa[x] = this.find(this.fa[x]);
        return this.fa[x];
    }

    /**
     * 合并两个元素所在的集合
     * @param {number} x - 第一个元素
     * @param {number} y - 第二个元素
     * @return {boolean} - 合并是否成功（如果原本就在同一集合则返回false）
     */
    union(x, y) {
        let fx = this.find(x), fy = this.find(y);
        // 如果已经在同一集合中，则不需要合并
        if (fx == fy) return false;
        // 合并两个集合
        this.fa[fx] = fy;
        // 连通分量数减1
        this.cc--;
    }
}

```

#### [3551. 数位和排序需要的最小交换次数](https://leetcode.cn/problems/minimum-swaps-to-sort-by-digit-sum/description/)

给你一个由 互不相同 的正整数组成的数组 nums，需要根据每个数字的数位和（即每一位数字相加求和）按 升序 对数组进行排序。如果两个数字的数位和相等，则较小的数字排在前面。

返回将 nums 排列为上述排序顺序所需的 最小 交换次数。

一次 交换 定义为交换数组中两个不同位置的值。

```js
/**
 * 计算将数组排序所需的最小交换次数
 * @param {number[]} nums - 待排序的数字数组
 * @return {number} - 将数组排序所需的最小交换次数
 * @算法核心思想：使用并查集寻找排列中的循环依赖，最小交换次数 = 元素总数 - 连通分量数
 * @时间复杂度：O(n log n)，主要来自排序操作
 * @空间复杂度：O(n)
 */
var minSwaps = function (nums) {
    const n = nums.length; // 获取数组长度
    const digitSum = Array(n); // 存储每个元素的数字和及原始索引
    
    // 计算每个元素的数字和并保存其原始索引
    for (let i = 0; i < n; i++) {
        digitSum[i] = [dSum(nums[i]), i]; // [数字和, 原始索引]
    }
    
    // 按照数字和升序排序，如果数字和相同则按照原数值升序排序
    digitSum.sort((a, b) => {
        return a[0] - b[0] || nums[a[1]] - nums[b[1]];
    })
    
    const st = new UnionSet(n); // 初始化并查集
    
    // 构建并查集：将排序后位置i的元素与其原始位置连接起来
    for (let i = 0; i < n; i++) {
        st.union(i, digitSum[i][1]);
    }
    
    // 最小交换次数 = 元素总数 - 连通分量数
    return n - st.cc;
};

/**
 * 并查集数据结构实现
 * 用于高效地管理元素的合并与查找操作
 */
class UnionSet {
    /**
     * 初始化并查集
     * @param {number} n - 元素数量
     */
    constructor(n) {
        // 初始化父节点数组，每个元素指向自己
        this.fa = Array.from({ length: n }, (_, i) => i);
        // 连通分量计数，初始时每个元素都是一个独立的连通分量
        this.cc = n;
    }

    /**
     * 查找元素所属的集合（带路径压缩优化）
     * @param {number} x - 要查找的元素
     * @return {number} - 元素所属集合的代表元素（根节点）
     */
    find(x) {
        // 路径压缩：将查找路径上的每个节点直接连接到根节点
        if (this.fa[x] == x) return this.fa[x];
        this.fa[x] = this.find(this.fa[x]);
        return this.fa[x];
    }

    /**
     * 合并两个元素所在的集合
     * @param {number} x - 第一个元素
     * @param {number} y - 第二个元素
     * @return {boolean} - 合并是否成功（如果原本就在同一集合则返回false）
     */
    union(x, y) {
        let fx = this.find(x), fy = this.find(y);
        // 如果已经在同一集合中，则不需要合并
        if (fx == fy) return false;
        // 合并两个集合
        this.fa[fx] = fy;
        // 连通分量数减1
        this.cc--;
        return true;
    }
}

/**
 * 计算一个数字的各位数字之和
 * @param {number} d - 输入数字
 * @return {number} - 各位数字之和
 */
const dSum = (d) => {
    let sum = 0;
    while (d) {
        sum += d % 10; // 取当前数字的最后一位并累加
        d = Math.floor(d / 10); // 移除最后一位
    }
    return sum;
}

```

#### [2471. 逐层排序二叉树所需的最少操作数目](https://leetcode.cn/problems/minimum-number-of-operations-to-sort-a-binary-tree-by-level/description/)

给你一个 值互不相同 的二叉树的根节点 root 。

在一步操作中，你可以选择 同一层 上任意两个节点，交换这两个节点的值。

返回每一层按 严格递增顺序 排序所需的最少操作数目。

节点的 层数 是该节点和根节点之间的路径的边数。

##### 并查集 + 层序遍历

```js
/**
 * 二叉树节点的定义
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */

/**
 * 计算二叉树每层排序所需的最小交换次数总和
 * @param {TreeNode} root - 二叉树的根节点
 * @return {number} - 所有层排序所需的最小交换次数总和
 * @算法核心思想：层序遍历二叉树，对每层使用并查集计算最小交换次数
 * @时间复杂度：O(n log n)，其中n为二叉树节点数，主要来自排序操作
 * @空间复杂度：O(n)
 */
var minimumOperations = function(root) {
    const nums = []; // 存储每层节点值的二维数组
    let q = [[root, 0]]; // 用于BFS的队列，每个元素是[节点, 深度]
    
    // 层序遍历收集每层的节点值
    while (q.length) {
        let [curr, depth] = q.shift(); // 取出队列中的第一个节点及其深度
        
        // 如果当前深度的数组不存在，则创建
        if (!nums[depth]) {
            nums[depth] = [];
        }
        
        // 将当前节点的值添加到对应深度的数组中
        nums[depth].push(curr.val);
        
        // 将左子节点加入队列（如果存在）
        if (curr.left) {
            q.push([curr.left, depth + 1]);
        }
        
        // 将右子节点加入队列（如果存在）
        if (curr.right) {
            q.push([curr.right, depth + 1]);
        }
    }
    
    let ans = 0; // 存储总交换次数
    
    // 从第一层开始（根节点所在层通常不需要排序）
    for (let i = 1; i < nums.length; i++) {
        let curr = nums[i], len = curr.length; // 当前层的节点值数组和长度
        
        // 创建一个包含值和原始索引的数组，并按值排序
        let sorted = curr.map((v, i) => ([v, i])).sort((a, b) => a[0] - b[0]);
        
        let st = new UnionSet(len); // 初始化并查集
        
        // 构建并查集：将排序后位置i的元素与其原始位置连接起来
        for (let i= 0; i < len; i++) {
            st.union(i, sorted[i][1]);
        }
        
        // 当前层的最小交换次数 = 元素总数 - 连通分量数，并累加到结果中
        ans += len - st.cc;
    }
    
    return ans;
};

/**
 * 并查集数据结构实现
 * 用于高效地管理元素的合并与查找操作
 */
class UnionSet {
    /**
     * 初始化并查集
     * @param {number} n - 元素数量
     */
    constructor(n) {
        // 初始化父节点数组，每个元素指向自己
        this.fa = Array.from({length: n}, (_, i) => i);
        // 连通分量计数，初始时每个元素都是一个独立的连通分量
        this.cc = n;
    }

    /**
     * 查找元素所属的集合（带路径压缩优化）
     * @param {number} x - 要查找的元素
     * @return {number} - 元素所属集合的代表元素（根节点）
     */
    find(x) {
        // 路径压缩：将查找路径上的每个节点直接连接到根节点
        if (x == this.fa[x]) return this.fa[x];
        this.fa[x] = this.find(this.fa[x]);
        return this.fa[x];
    }

    /**
     * 合并两个元素所在的集合
     * @param {number} x - 第一个元素
     * @param {number} y - 第二个元素
     * @return {boolean} - 合并是否成功（如果原本就在同一集合则返回false）
     */
    union(x, y) {
        let fx = this.find(x), fy = this.find(y);
        // 如果已经在同一集合中，则不需要合并
        if (fx == fy) return false;
        // 合并两个集合
        this.fa[fx] = fy;
        // 连通分量数减1
        this.cc--;
        return true;
    }
}

```

##### 置换环

```js
/**
 * 二叉树节点的定义
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */

/**
 * 计算二叉树每层排序所需的最小交换次数总和
 * @param {TreeNode} root - 二叉树的根节点
 * @return {number} - 所有层排序所需的最小交换次数总和
 * @算法核心思想：层序遍历二叉树，对每层使用循环检测方法计算最小交换次数
 * @时间复杂度：O(n log n)，其中n为二叉树节点数，主要来自排序操作
 * @空间复杂度：O(n)
 */
var minimumOperations = function (root) {
    let ans = 0; // 存储总交换次数
    let q = [root]; // 用于BFS的队列，初始包含根节点

    // BFS遍历二叉树的每一层
    while (q.length) {
        let temp = []; // 存储下一层的所有节点
        
        // 收集当前层的所有子节点
        for (let node of q) {
            if (node.left) temp.push(node.left);
            if (node.right) temp.push(node.right);
        }
        
        let n = q.length; // 当前层的节点数量
        
        // 创建索引数组并按节点值排序，得到每个位置的元素应该移动到的目标位置
        let sorted = Array.from({ length: n }, (_, i) => i).sort((a, b) => {
            return q[a].val - q[b].val;
        })
        
        let visited = Array(n).fill(false); // 标记节点是否已处理过
        ans += n; // 先假设每个元素都需要交换，然后减去已在正确位置的元素
        
        // 检测并统计当前层中的循环数量
        for (let i = 0; i < n; i++) {
            if (visited[i]) continue; // 如果当前位置已处理过，则跳过
            
            // 遍历一个完整的循环
            let j = i;
            while (!visited[j]) {
                visited[j] = true; // 标记当前位置为已处理
                j = sorted[j]; // 移动到下一个位置
            }
            
            ans--; // 每个循环可以减少一次交换次数
        }

        q = temp; // 移动到下一层
    }
    
    return ans; // 返回所有层的最小交换次数总和
};

```