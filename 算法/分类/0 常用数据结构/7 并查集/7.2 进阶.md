### 并查集的进阶

#### [765. 情侣牵手](https://leetcode.cn/problems/couples-holding-hands/description/)

n 对情侣坐在连续排列的 2n 个座位上，想要牵到对方的手。

人和座位由一个整数数组 row 表示，其中 row[i] 是坐在第 i 个座位上的人的 ID。情侣们按顺序编号，第一对是 (0, 1)，第二对是 (2, 3)，以此类推，最后一对是 (2n-2, 2n-1)。

返回 最少交换座位的次数，以便每对情侣可以并肩坐在一起。 每次交换可选择任意两人，让他们站起来交换座位。

```js
/**
 * 计算让所有情侣坐在一起所需的最小交换次数
 * @param {number[]} row - 表示情侣初始座位的数组，其中元素为个人编号
 * @return {number} - 所需的最小交换次数
 * @算法核心思想：使用并查集寻找连通分量，最小交换次数 = 总对数 - 连通分量数
 * @时间复杂度：O(nα(n))，其中n为情侣对数，α为阿克曼函数的反函数，近似常数
 * @空间复杂度：O(n)
 */
var minSwapsCouples = function(row) {
    const n = row.length / 2; // 计算情侣的总对数
    const st = new UnionSet(n); // 初始化并查集，每个元素代表一对情侣的位置
    
    // 遍历每一对相邻的座位
    for (let i = 1; i < 2 * n; i += 2) {
        // 将相邻两个人所在的情侣对合并到同一个集合
        // Math.floor(num/2) 将个人编号转换为其所属的情侣对编号
        st.union(Math.floor(row[i] / 2), Math.floor(row[i - 1] / 2));
    }
    
    // 最小交换次数 = 情侣总对数 - 连通分量数
    return n - st.cc;
};

/**
 * 并查集数据结构实现
 * 用于高效地管理元素的合并与查找操作
 */
class UnionSet {
    /**
     * 初始化并查集
     * @param {number} n - 元素数量
     */
    constructor(n) {
        // 初始化父节点数组，每个元素指向自己
        this.fa = Array.from({length: n}, (_, i) => i);
        // 连通分量计数，初始时每个元素都是一个独立的连通分量
        this.cc = n;
    }

    /**
     * 查找元素所属的集合（带路径压缩优化）
     * @param {number} x - 要查找的元素
     * @return {number} - 元素所属集合的代表元素（根节点）
     */
    find(x) {
        // 路径压缩：将查找路径上的每个节点直接连接到根节点
        if (x == this.fa[x]) return this.fa[x];
        this.fa[x] = this.find(this.fa[x]);
        return this.fa[x];
    }

    /**
     * 合并两个元素所在的集合
     * @param {number} x - 第一个元素
     * @param {number} y - 第二个元素
     * @return {boolean} - 合并是否成功（如果原本就在同一集合则返回false）
     */
    union(x, y) {
        let fx = this.find(x), fy = this.find(y);
        // 如果已经在同一集合中，则不需要合并
        if (fx == fy) return false;
        // 合并两个集合
        this.fa[fx] = fy;
        // 连通分量数减1
        this.cc--;
    }
}

```

#### [3551. 数位和排序需要的最小交换次数](https://leetcode.cn/problems/minimum-swaps-to-sort-by-digit-sum/description/)

给你一个由 互不相同 的正整数组成的数组 nums，需要根据每个数字的数位和（即每一位数字相加求和）按 升序 对数组进行排序。如果两个数字的数位和相等，则较小的数字排在前面。

返回将 nums 排列为上述排序顺序所需的 最小 交换次数。

一次 交换 定义为交换数组中两个不同位置的值。

```js
/**
 * 计算将数组排序所需的最小交换次数
 * @param {number[]} nums - 待排序的数字数组
 * @return {number} - 将数组排序所需的最小交换次数
 * @算法核心思想：使用并查集寻找排列中的循环依赖，最小交换次数 = 元素总数 - 连通分量数
 * @时间复杂度：O(n log n)，主要来自排序操作
 * @空间复杂度：O(n)
 */
var minSwaps = function (nums) {
    const n = nums.length; // 获取数组长度
    const digitSum = Array(n); // 存储每个元素的数字和及原始索引
    
    // 计算每个元素的数字和并保存其原始索引
    for (let i = 0; i < n; i++) {
        digitSum[i] = [dSum(nums[i]), i]; // [数字和, 原始索引]
    }
    
    // 按照数字和升序排序，如果数字和相同则按照原数值升序排序
    digitSum.sort((a, b) => {
        return a[0] - b[0] || nums[a[1]] - nums[b[1]];
    })
    
    const st = new UnionSet(n); // 初始化并查集
    
    // 构建并查集：将排序后位置i的元素与其原始位置连接起来
    for (let i = 0; i < n; i++) {
        st.union(i, digitSum[i][1]);
    }
    
    // 最小交换次数 = 元素总数 - 连通分量数
    return n - st.cc;
};

/**
 * 并查集数据结构实现
 * 用于高效地管理元素的合并与查找操作
 */
class UnionSet {
    /**
     * 初始化并查集
     * @param {number} n - 元素数量
     */
    constructor(n) {
        // 初始化父节点数组，每个元素指向自己
        this.fa = Array.from({ length: n }, (_, i) => i);
        // 连通分量计数，初始时每个元素都是一个独立的连通分量
        this.cc = n;
    }

    /**
     * 查找元素所属的集合（带路径压缩优化）
     * @param {number} x - 要查找的元素
     * @return {number} - 元素所属集合的代表元素（根节点）
     */
    find(x) {
        // 路径压缩：将查找路径上的每个节点直接连接到根节点
        if (this.fa[x] == x) return this.fa[x];
        this.fa[x] = this.find(this.fa[x]);
        return this.fa[x];
    }

    /**
     * 合并两个元素所在的集合
     * @param {number} x - 第一个元素
     * @param {number} y - 第二个元素
     * @return {boolean} - 合并是否成功（如果原本就在同一集合则返回false）
     */
    union(x, y) {
        let fx = this.find(x), fy = this.find(y);
        // 如果已经在同一集合中，则不需要合并
        if (fx == fy) return false;
        // 合并两个集合
        this.fa[fx] = fy;
        // 连通分量数减1
        this.cc--;
        return true;
    }
}

/**
 * 计算一个数字的各位数字之和
 * @param {number} d - 输入数字
 * @return {number} - 各位数字之和
 */
const dSum = (d) => {
    let sum = 0;
    while (d) {
        sum += d % 10; // 取当前数字的最后一位并累加
        d = Math.floor(d / 10); // 移除最后一位
    }
    return sum;
}

```

#### [2471. 逐层排序二叉树所需的最少操作数目](https://leetcode.cn/problems/minimum-number-of-operations-to-sort-a-binary-tree-by-level/description/)

给你一个 值互不相同 的二叉树的根节点 root 。

在一步操作中，你可以选择 同一层 上任意两个节点，交换这两个节点的值。

返回每一层按 严格递增顺序 排序所需的最少操作数目。

节点的 层数 是该节点和根节点之间的路径的边数。

##### 并查集 + 层序遍历

```js
/**
 * 二叉树节点的定义
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */

/**
 * 计算二叉树每层排序所需的最小交换次数总和
 * @param {TreeNode} root - 二叉树的根节点
 * @return {number} - 所有层排序所需的最小交换次数总和
 * @算法核心思想：层序遍历二叉树，对每层使用并查集计算最小交换次数
 * @时间复杂度：O(n log n)，其中n为二叉树节点数，主要来自排序操作
 * @空间复杂度：O(n)
 */
var minimumOperations = function(root) {
    const nums = []; // 存储每层节点值的二维数组
    let q = [[root, 0]]; // 用于BFS的队列，每个元素是[节点, 深度]
    
    // 层序遍历收集每层的节点值
    while (q.length) {
        let [curr, depth] = q.shift(); // 取出队列中的第一个节点及其深度
        
        // 如果当前深度的数组不存在，则创建
        if (!nums[depth]) {
            nums[depth] = [];
        }
        
        // 将当前节点的值添加到对应深度的数组中
        nums[depth].push(curr.val);
        
        // 将左子节点加入队列（如果存在）
        if (curr.left) {
            q.push([curr.left, depth + 1]);
        }
        
        // 将右子节点加入队列（如果存在）
        if (curr.right) {
            q.push([curr.right, depth + 1]);
        }
    }
    
    let ans = 0; // 存储总交换次数
    
    // 从第一层开始（根节点所在层通常不需要排序）
    for (let i = 1; i < nums.length; i++) {
        let curr = nums[i], len = curr.length; // 当前层的节点值数组和长度
        
        // 创建一个包含值和原始索引的数组，并按值排序
        let sorted = curr.map((v, i) => ([v, i])).sort((a, b) => a[0] - b[0]);
        
        let st = new UnionSet(len); // 初始化并查集
        
        // 构建并查集：将排序后位置i的元素与其原始位置连接起来
        for (let i= 0; i < len; i++) {
            st.union(i, sorted[i][1]);
        }
        
        // 当前层的最小交换次数 = 元素总数 - 连通分量数，并累加到结果中
        ans += len - st.cc;
    }
    
    return ans;
};

/**
 * 并查集数据结构实现
 * 用于高效地管理元素的合并与查找操作
 */
class UnionSet {
    /**
     * 初始化并查集
     * @param {number} n - 元素数量
     */
    constructor(n) {
        // 初始化父节点数组，每个元素指向自己
        this.fa = Array.from({length: n}, (_, i) => i);
        // 连通分量计数，初始时每个元素都是一个独立的连通分量
        this.cc = n;
    }

    /**
     * 查找元素所属的集合（带路径压缩优化）
     * @param {number} x - 要查找的元素
     * @return {number} - 元素所属集合的代表元素（根节点）
     */
    find(x) {
        // 路径压缩：将查找路径上的每个节点直接连接到根节点
        if (x == this.fa[x]) return this.fa[x];
        this.fa[x] = this.find(this.fa[x]);
        return this.fa[x];
    }

    /**
     * 合并两个元素所在的集合
     * @param {number} x - 第一个元素
     * @param {number} y - 第二个元素
     * @return {boolean} - 合并是否成功（如果原本就在同一集合则返回false）
     */
    union(x, y) {
        let fx = this.find(x), fy = this.find(y);
        // 如果已经在同一集合中，则不需要合并
        if (fx == fy) return false;
        // 合并两个集合
        this.fa[fx] = fy;
        // 连通分量数减1
        this.cc--;
        return true;
    }
}

```

##### 置换环

```js
/**
 * 二叉树节点的定义
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */

/**
 * 计算二叉树每层排序所需的最小交换次数总和
 * @param {TreeNode} root - 二叉树的根节点
 * @return {number} - 所有层排序所需的最小交换次数总和
 * @算法核心思想：层序遍历二叉树，对每层使用循环检测方法计算最小交换次数
 * @时间复杂度：O(n log n)，其中n为二叉树节点数，主要来自排序操作
 * @空间复杂度：O(n)
 */
var minimumOperations = function (root) {
    let ans = 0; // 存储总交换次数
    let q = [root]; // 用于BFS的队列，初始包含根节点

    // BFS遍历二叉树的每一层
    while (q.length) {
        let temp = []; // 存储下一层的所有节点
        
        // 收集当前层的所有子节点
        for (let node of q) {
            if (node.left) temp.push(node.left);
            if (node.right) temp.push(node.right);
        }
        
        let n = q.length; // 当前层的节点数量
        
        // 创建索引数组并按节点值排序，得到每个位置的元素应该移动到的目标位置
        let sorted = Array.from({ length: n }, (_, i) => i).sort((a, b) => {
            return q[a].val - q[b].val;
        })
        
        let visited = Array(n).fill(false); // 标记节点是否已处理过
        ans += n; // 先假设每个元素都需要交换，然后减去已在正确位置的元素
        
        // 检测并统计当前层中的循环数量
        for (let i = 0; i < n; i++) {
            if (visited[i]) continue; // 如果当前位置已处理过，则跳过
            
            // 遍历一个完整的循环
            let j = i;
            while (!visited[j]) {
                visited[j] = true; // 标记当前位置为已处理
                j = sorted[j]; // 移动到下一个位置
            }
            
            ans--; // 每个循环可以减少一次交换次数
        }

        q = temp; // 移动到下一层
    }
    
    return ans; // 返回所有层的最小交换次数总和
};

```

#### [1202. 交换字符串中的元素](https://leetcode.cn/problems/smallest-string-with-swaps/description/)
 
给你一个字符串 s，以及该字符串中的一些「索引对」数组 pairs，其中 pairs[i] = [a, b] 表示字符串中的两个索引（编号从 0 开始）。

你可以 任意多次交换 在 pairs 中任意一对索引处的字符。

返回在经过若干次交换后，s 可以变成的按字典序最小的字符串。

```js
/**
 * 并查集(Union-Find)数据结构的进阶应用
 * 本文件包含使用并查集解决字符串最小化问题的实现
 * 实现了基于字符交换对生成字典序最小字符串的算法
 */

/**
 * 根据给定的字符交换对，生成字典序最小的字符串
 * @param {string} s - 原始字符串
 * @param {number[][]} pairs - 允许交换的字符索引对数组
 * @return {string} 交换后可以得到的字典序最小的字符串
 * @note 该算法使用并查集将可以互相交换的字符分组，然后对每组字符进行排序重组
 */
var smallestStringWithSwaps = function(s, pairs) {
    const n = s.length;
    // 初始化并查集，用于对字符串索引进行分组
    const st = new UnionSet(n, s);
    // 遍历所有交换对，将可以互相交换的索引合并到同一集合
    for (let [x, y] of pairs) {
        st.union(x, y);
    }
    // 创建映射，键为集合的根节点，值为该集合中字符的最小优先队列
    const map = new Map();
    for (let i = 0; i < n; i++) {
        let rt = st.find(i);
        if (!map.has(rt)) {
            map.set(rt, new MinPriorityQueue());
        }
        map.get(rt).enqueue(s[i]); // 将当前索引的字符加入对应集合的优先队列
    }
    // 构建结果字符串
    let ans = "";
    for (let i = 0; i < n; i++) {
        let rt = st.find(i);
        ans += map.get(rt).dequeue(); // 从优先队列中取出字典序最小的字符
    }
    return ans;
};

/**
 * 并查集数据结构类
 * 支持路径压缩优化和按秩合并(这里使用字符大小作为秩)
 */
class UnionSet {
    /**
     * 初始化并查集
     * @param {number} n - 元素数量
     * @param {string} s - 原始字符串，用于按字符大小进行合并优化
     */
    constructor(n, s) {
        // 初始化父节点数组，每个元素的父节点初始为自己
        this.fa = Array.from({length: n}, (_, i) => i);
        this.s = s;
    }

    /**
     * 查找元素所在集合的根节点(带路径压缩)
     * @param {number} x - 要查找的元素索引
     * @return {number} 元素所在集合的根节点索引
     * @note 路径压缩优化：将查找路径上的所有节点直接连接到根节点
     */
    find(x) {
        if (x == this.fa[x]) return this.fa[x]; // 找到根节点
        // 路径压缩：递归查找父节点，并更新当前节点的父节点为根节点
        this.fa[x] = this.find(this.fa[x]);
        return this.fa[x];
    }

    /**
     * 合并两个元素所在的集合
     * @param {number} x - 第一个元素的索引
     * @param {number} y - 第二个元素的索引
     * @return {boolean} 合并是否成功(如果原本就在同一集合则返回false)
     * @note 按秩合并优化：根据字符的字典序大小决定合并方向
     */
    union(x, y) {
        let fx = this.find(x), fy = this.find(y);
        if (fx == fy) return false; // 已经在同一集合中

        // 按秩合并：将字符较小的节点作为根节点，以优化后续的字符排序
        if (this.s[fx] < this.s[fy]) {
            this.fa[fy] = fx;
        } else {
            this.fa[fx] = fy;
        }

        return true;
    }
}

```

#### [1722. 执行交换操作后的最小汉明距离](https://leetcode.cn/problems/minimize-hamming-distance-after-swap-operations/description/)
 
给你两个整数数组 source 和 target ，长度都是 n 。还有一个数组 allowedSwaps ，其中每个 allowedSwaps[i] = [ai, bi] 表示你可以交换数组 source 中下标为 ai 和 bi（下标从 0 开始）的两个元素。注意，你可以按 任意 顺序 多次 交换一对特定下标指向的元素。

相同长度的两个数组 source 和 target 间的 汉明距离 是元素不同的下标数量。形式上，其值等于满足 source[i] != target[i] （下标从 0 开始）的下标 i（0 <= i <= n-1）的数量。

在对数组 source 执行 任意 数量的交换操作后，返回 source 和 target 间的 最小汉明距离 。

```js
/**
 * 功能：计算两个数组在允许特定位置交换的情况下的最小汉明距离
 * 算法类型：并查集 + 哈希表
 * 输入参数：
 *   source - 源数组
 *   target - 目标数组
 *   allowedSwaps - 允许交换的位置对数组，每个元素为[x,y]表示x和y位置可以交换
 * 返回值：
 *   number - 最小汉明距离（即无法通过允许的交换使两个数组相同的元素个数）
 * 算法核心思想：
 *   使用并查集将可以互相交换的位置划分到同一个连通块中，在每个连通块内统计源数组中各值的出现次数，
 *   然后检查目标数组中每个元素是否能在其所在连通块中找到对应的源数组元素
 * 时间复杂度：O(n α(n))，其中n是数组长度，α是阿克曼函数的反函数，近似于常数
 * 空间复杂度：O(n)，用于存储并查集、哈希表等辅助数据结构
 */
var minimumHammingDistance = function (source, target, allowedSwaps) {
    const n = source.length;  // 获取数组长度
    const st = new UnionSet(n);  // 初始化并查集，用于管理元素的连通性
    
    // 使用并查集将允许交换的位置连接起来
    for (let [x, y] of allowedSwaps) {
        st.union(x, y);  // 合并x和y所在的集合
    }
    
    const valToIdx = new Map();  // 记录源数组中每个值对应的所有索引位置
    const ccMap = new Map();     // 记录每个连通块中各值的出现次数
    
    // 构建值到索引的映射和连通块内值的计数
    for (let i = 0; i < n; i++) {
        let x = source[i];
        // 记录源数组中值到索引的映射
        if (!valToIdx.has(x)) {
            valToIdx.set(x, []);
        }
        valToIdx.get(x).push(i);
        
        // 统计每个连通块中各值的出现次数
        let fxIdx = st.find(i);  // 获取当前索引i所在连通块的代表元素
        if (!ccMap.has(fxIdx)) {
            ccMap.set(fxIdx, new Map());
        }
        let ccCnt = ccMap.get(fxIdx);  // 获取当前连通块的值计数Map
        ccCnt.set(x, (ccCnt.get(x) ?? 0) + 1);  // 更新值x在当前连通块中的计数
    }
    
    let ans = 0;  // 初始化最小汉明距离
    
    // 遍历目标数组，计算最小汉明距离
    outer: for (let i = 0; i < n; i++) {
        let sx = source[i], tx = target[i];
        let fxIdx = st.find(i);  // 获取当前索引i所在连通块的代表元素
        let ccCnt = ccMap.get(fxIdx);  // 获取当前连通块的值计数Map
        
        // 获取目标值tx在源数组中出现的所有索引
        let txIdxInSource = valToIdx.get(tx);
        if (!txIdxInSource?.length) {  // 如果源数组中不存在值tx
            ans++;  // 汉明距离加1
            continue;
        };
        
        // 检查在当前连通块中是否存在可用的tx值
        for (let idxInSource of txIdxInSource) {
            // 如果源数组中存在tx值，并且该值所在索引与当前索引i在同一个连通块中，且计数大于0
            if (st.find(idxInSource) == fxIdx && ccCnt.get(tx) > 0) {
                ccCnt.set(tx, ccCnt.get(tx) - 1);  // 减少当前连通块中tx的计数
                continue outer;  // 跳出当前循环，处理下一个元素
            }
        }
        
        ans++;  // 如果无法在当前连通块中找到可用的tx值，汉明距离加1
    }
    
    return ans;  // 返回最小汉明距离
};

/**
 * 功能：实现并查集数据结构，用于管理元素的连通性
 * 核心操作：查找元素的代表元素(find)和合并两个集合(union)
 */
class UnionSet {
    /**
     * 构造函数
     * @param {number} n - 元素数量
     */
    constructor(n) {
        // 初始化父节点数组，每个元素初始时指向自己
        this.fa = Array.from({ length: n }, (_, i) => i);
    }
    
    /**
     * 查找元素x所在集合的代表元素（带路径压缩优化）
     * @param {number} x - 要查找的元素
     * @return {number} - 代表元素的索引
     */
    find(x) {
        if (this.fa[x] == x) return this.fa[x];  // 如果x是自身的父节点，则返回x
        this.fa[x] = this.find(this.fa[x]);  // 路径压缩：将x的父节点直接设为根节点
        return this.fa[x];
    }
    
    /**
     * 合并元素x和y所在的集合
     * @param {number} x - 第一个元素
     * @param {number} y - 第二个元素
     */
    union(x, y) {
        let fx = this.find(x), fy = this.find(y);  // 找到x和y的代表元素
        if (fx == fy) return;  // 如果x和y已经在同一集合中，无需合并
        this.fa[fx] = fy;  // 将fx的父节点设为fy，合并两个集合
    }
}

```