### GCD并查集

#### [2709. 最大公约数遍历](https://leetcode.cn/problems/greatest-common-divisor-traversal/description/)
 
给你一个下标从 0 开始的整数数组 nums ，你可以在一些下标之间遍历。对于两个下标 i 和 j（i != j），当且仅当 gcd(nums[i], nums[j]) > 1 时，我们可以在两个下标之间通行，其中 gcd 是两个数的 最大公约数 。

你需要判断 nums 数组中 任意 两个满足 i < j 的下标 i 和 j ，是否存在若干次通行可以从 i 遍历到 j 。

如果任意满足条件的下标对都可以遍历，那么返回 true ，否则返回 false 。

**题解：**

预处理所有的数的质因子，然后将每个数和其质因子合并到并查集中（如果两个数有相同的质因子，表示 gcd(nums[i], nums[j]) > 1）。最后判断所有的数是否在同一个并查集中。


```js
/**
 * 功能：判断数组中所有元素对是否可以通过共享公因子的方式相互遍历
 * 算法类型：并查集 + 质因数分解预处理
 * 输入参数：
 *   nums - 包含正整数的数组
 * 返回值：
 *   boolean - 如果所有元素对都可以相互遍历则返回true，否则返回false
 * 算法核心思想：
 *   将每个数与其所有质因数连接到同一个集合中，如果最终所有数都在同一个集合中，则说明可以相互遍历
 * 时间复杂度：O(n log MX + MX log log MX)，其中n是数组长度，MX是数组中的最大值
 * 空间复杂度：O(MX)，用于存储并查集和质数因子表
 */
var canTraverseAllPairs = function (nums) {
    const n = nums.length;
    // 边界情况：只有一个元素时，必然可以遍历
    if (n == 1) return true;
    
    let mx = 0;
    for (let x of nums) {
        mx = Math.max(mx, x);  // 找出数组中的最大值
        // 如果数组中包含1，则无法与其他元素形成连接（因为1与任何数的GCD可能为1，但需要通过质因数连接）
        if (x == 1) return false;
    }
    
    // 创建并查集，大小为最大值+1
    const st = new UnionSet(mx + 1);
    
    // 将每个数与其所有质因数合并到同一个集合
    for (let x of nums) {
        for (let p of PrimesFactory[x]) {
            st.union(x, p);  // 将数x与其质因数p合并
        }
    }
    
    // 检查所有数是否在同一个集合中
    let cnt = new Set();
    for (let x of nums) {
        cnt.add(st.find(x));  // 记录每个数所属的集合代表元素
    }
    
    // 如果所有数都属于同一个集合，则返回true
    return cnt.size == 1;
};

/**
 * 功能：实现并查集数据结构，用于管理元素的连通性
 */
class UnionSet {
    /**
     * 构造函数
     * @param {number} n - 元素数量
     */
    constructor(n) {
        // 初始化父节点数组，每个元素初始时指向自己
        this.fa = Array.from({ length: n }, (_, i) => i);
    }
    
    /**
     * 查找元素x所在集合的代表元素（带路径压缩优化）
     * @param {number} x - 要查找的元素
     * @return {number} - 代表元素的索引
     */
    find(x) {
        if (this.fa[x] == x) return this.fa[x];  // 如果x是自身的父节点，则返回x
        this.fa[x] = this.find(this.fa[x]);  // 路径压缩：将x的父节点直接设为根节点
        return this.fa[x];
    }
    
    /**
     * 合并元素x和y所在的集合
     * @param {number} x - 第一个元素
     * @param {number} y - 第二个元素
     */
    union(x, y) {
        let fx = this.find(x), fy = this.find(y);  // 找到x和y的代表元素
        if (fx == fy) return;  // 如果x和y已经在同一集合中，无需合并
        this.fa[fx] = fy;  // 将fx的父节点设为fy，合并两个集合
    }
}

// 全局常量和预处理
const MX = 1e5;  // 预处理的最大数值（10万）
// PrimesFactory[i]存储i的所有质因数
const PrimesFactory = Array.from({ length: MX + 1 }, () => []);

// 使用筛法预处理每个数的质因数
for (let i = 2; i < MX + 1; i++) {
    // 如果i是质数（其质因数列表为空）
    if (PrimesFactory[i].length == 0) {
        // 标记i的所有倍数，并将i添加到这些倍数的质因数列表中
        for (let j = 2; i * j < MX + 1; j++) {
            PrimesFactory[i * j].push(i);
        }
    }
}

```