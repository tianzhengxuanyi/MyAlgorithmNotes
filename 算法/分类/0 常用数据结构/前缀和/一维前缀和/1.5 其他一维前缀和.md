#### 1.5

#### 3445. 奇偶频次间的最大差值 II

给你一个字符串 s 和一个整数 k 。请你找出 s 的子字符串 subs 中两个字符的出现频次之间的 最大 差值，freq[a] - freq[b] ，其中：

- subs 的长度 至少 为 k 。
- 字符 a 在 subs 中出现奇数次。
- 字符 b 在 subs 中出现偶数次。

返回 最大 差值。

注意 ，subs 可以包含超过 2 个 互不相同 的字符。.

子字符串 是字符串中的一个连续字符序列。
 
提示：

- 3 <= s.length <= 3 * 104
- s 仅由数字 '0' 到 '4' 组成。
- 输入保证至少存在一个子字符串是由一个出现奇数次的字符和一个出现偶数次的字符组成。
- 1 <= k <= s.length

**前缀和+滑动窗口+枚举：**

- 设区间[left, right]中freq[a]为奇数，freq[b]为偶数：
    ```
    freq[a] - freq[b] = prefix[a][right + 1] - prefix[a][left] - (prefix[b][right + 1] - prefix[b][left])
                      = prefix[a][right + 1] - prefix[b][right + 1] - (prefix[a][left] - prefix[b][left])
    ```
- 枚举right，要求得prefix[b][left] - prefix[a][left]的最小值

- freq[a]为奇数，要求prefix[a][right + 1]和prefix[a][left]的奇偶性不同，(奇 - 偶 = 奇， 偶 - 奇 = 奇)
- freq[b]为偶数, 要求prefix[a][right + 1]和prefix[a][left]的奇偶性一致
- 维护prefix[b][left] - prefix[a][left]的最小值时，要根据prefix[a][right + 1] 和 prefix[b][right + 1]的奇偶性的不同维护四个最小值，mn[a][b] a = 0, 1表示prefix[a][left]为偶、奇

```js
/**
 * @param {string} s
 * @param {number} k
 * @return {number}
 */
var maxDifference = function (s, k) {
    const n = s.length;
    // 创建5个字符类别的前缀和数组（假设字符映射为0-4）
    const prefix = Array.from({ length: 5 }, () => Array(n + 1).fill(0));

    // 构建前缀和数组
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < 5; j++) {
            prefix[j][i + 1] = prefix[j][i] + (s[i] == j ? 1 : 0);
        }
    }

    let ans = -Infinity;



    // 遍历所有字符类别组合
    for (let a = 0; a <= 4; a++) {
        for (let b = 0; b <= 4; b++) {
            // 跳过无效组合：相同类别、a未出现、b出现次数不足2次
            if (a === b || prefix[a][n] == 0 || prefix[b][n] < 2) continue;

            let left = 0;
            // 维护四种奇偶组合的最小值 [a奇偶][b奇偶]
            const mn = Array.from({ length: 2 }, () => Array(2).fill(Infinity));

            // 滑动窗口遍历右边界
            for (let right = 0; right < n; right++) {
                // 跳过当前窗口无该字符的情况
                if (prefix[a][right + 1] == 0 || prefix[b][right + 1] == 0) continue;

                // 计算当前右边界前缀和的奇偶性
                const aRightMod2 = prefix[a][right + 1] % 2;
                const bRightMod2 = prefix[b][right + 1] % 2;

                // 调整左边界满足窗口条件 
                // 窗口长度 >= k 且 窗口内存在a、b字符
                while (right - left + 1 >= k &&
                    prefix[a][right + 1] > prefix[a][left] &&
                    prefix[b][right + 1] > prefix[b][left]) {
                    // 记录左边界奇偶组合的最小值
                    const aLeftMod2 = prefix[a][left] % 2;
                    const bLeftMod2 = prefix[b][left] % 2;
                    mn[aLeftMod2][bLeftMod2] = Math.min(
                        mn[aLeftMod2][bLeftMod2],
                        prefix[a][left] - prefix[b][left]
                    );
                    // 尝试更新最大值：当前差值 - 历史最小差值
                    ans = Math.max(ans, prefix[a][right + 1] - prefix[b][right + 1] - mn[1 ^ aRightMod2][bRightMod2]);
                    left++;
                }
                // 处理窗口长度达标后的情况
                if (right >= k) {
                    ans = Math.max(ans, prefix[a][right + 1] - prefix[b][right + 1] - mn[1 ^ aRightMod2][bRightMod2]);
                }
            }
        }
    }
    return ans;
};
```