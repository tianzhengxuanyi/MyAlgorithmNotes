### 因子分解

#### [2427. 公因子的数目](https://leetcode.cn/problems/number-of-common-factors/description/)

给你两个正整数 `a` 和 `b` ，返回 `a` 和 `b` 的 **公** 因子的数目。

如果 `x` 可以同时整除 `a` 和 `b` ，则认为 `x` 是 `a` 和 `b` 的一个 **公因子** 。

**示例 1：**

```
输入：a = 12, b = 6
输出：4
解释：12 和 6 的公因子是 1、2、3、6 。
```

**示例 2：**

```
输入：a = 25, b = 30
输出：2
解释：25 和 30 的公因子是 1、5 。
```

**提示：**

* `1 <= a, b <= 1000`

##### 最大公约数

```js
/**
 * 功能：计算两个正整数的公共因子数量
 * 参数：a - 第一个正整数，b - 第二个正整数
 * 返回：两个数的公共因子个数
 * 算法核心思想：利用最大公约数性质，两个数的公共因子就是它们最大公约数的所有因子
 * 时间复杂度：O(√gcd(a,b))，空间复杂度：O(1)
 * @param {number} a
 * @param {number} b
 * @return {number}
 */
var commonFactors = function(a, b) {
    // 计算a和b的最大公约数，因为两个数的公共因子就是它们最大公约数的因子
    let c = gcd(a, b), ans = 0;
    
    // 只需遍历到√c，大大减少了遍历次数
    // 数学原理：如果x是c的因子，那么c/x也是c的因子
    for (let x = 1; x * x <= c; x++) {
        // 检查x是否是c的因子
        if (c % x == 0) {
            ans++; // 找到一个因子x，计数器加1
            
            // 避免重复计数：当x*x != c时，c/x是另一个不同的因子
            if (x * x != c) ans++; // 找到配对因子c/x，计数器再加1
        }
    }
    
    return ans; // 返回公共因子的总数
};

/**
 * 功能：使用欧几里得算法计算两个数的最大公约数
 * 参数：x - 第一个正整数，y - 第二个正整数
 * 返回：x和y的最大公约数
 * 算法原理：gcd(x,y) = gcd(y, x mod y)，当y=0时，gcd为x
 * 时间复杂度：O(log min(x,y))，空间复杂度：O(1)
 * @param {number} x
 * @param {number} y
 * @return {number}
 */
const gcd = (x, y) => {
    // 当y不为0时，循环计算
    while (y) {
        // 计算x除以y的余数
        let t = x % y;
        // 更新x为y，y为余数t
        x = y, y = t;
    }
    // 当y=0时，x就是最大公约数
    return x;
}

```

##### 预处理因数

```js
/**
 * 功能：计算两个正整数的公共因子数量
 * 参数：a - 第一个正整数，b - 第二个正整数
 * 返回：两个数的公共因子个数
 * 算法核心思想：利用预计算的因子数组和集合的交集操作快速求解
 * 时间复杂度：预计算O(MX log MX)，查询O(min(numberOfFactors(a), numberOfFactors(b)))
 * 空间复杂度：O(MX log MX)，用于存储预计算的因子数组
 * @param {number} a
 * @param {number} b
 * @return {number}
 */
var commonFactors = function(a, b) {
    // 将a的因子数组转换为Set集合以提高查找效率
    let factA = new Set(Factory[a]);
    // 获取b的因子数组
    let factB = Factory[b];
    let ans = 0; // 用于计数公共因子的数量
    
    // 遍历b的所有因子，检查是否也存在于a的因子集合中
    for (let f of factB) {
        if (factA.has(f)) ans++; // 如果是公共因子，计数器加1
    }
    
    return ans; // 返回公共因子的总数
};

// 定义预计算因子的最大值范围
const MX = 1001;
// 初始化因子数组，每个元素初始化为只包含因子1的数组
// Factory[i]将存储i的所有正因子
const Factory = Array.from({length: MX}, () => [1]);

// 预计算阶段：使用埃拉托斯特尼筛法的思想生成所有数的因子
// 外层循环遍历可能的因子i（从2开始）
for (let i = 2; i < MX; i++) {
    // 内层循环遍历i的所有倍数j
    for (let j = i; j < MX; j += i) {
        // 将i添加到j的因子列表中
        Factory[j].push(i);
    }
}

```

#### [507. 完美数](https://leetcode.cn/problems/perfect-number/description/)

对于一个 **正整数**，如果它和除了它自身以外的所有 **正因子** 之和相等，我们称它为 **「完美数」**。

给定一个 **整数**`n`， 如果是完美数，返回 `true`；否则返回 `false`。

**示例 1：**

```
输入：num = 28
输出：true
解释：28 = 1 + 2 + 4 + 7 + 14
1, 2, 4, 7, 和 14 是 28 的所有正因子。
```

**示例 2：**

```
输入：num = 7
输出：false
```

**提示：**

* `1 <= num <= 108`

##### 因子分解

```js
/**
 * 功能：检查一个整数是否为完美数
 * 参数：num - 待检查的整数
 * 返回：布尔值，表示num是否为完美数
 * 算法核心思想：遍历所有可能的因子，计算真因子之和并与原数比较
 * 时间复杂度：O(√n)，只需要遍历到num的平方根
 * 空间复杂度：O(1)，只使用常数额外空间
 * 注：完美数是指一个数等于它所有真因子（除了自身以外的因子）的和
 */
var checkPerfectNumber = function (num) {
    // 初始化真因子和为1（1是任何数的真因子）
    let s = 1;
    
    // 遍历可能的因子，只需遍历到num的平方根
    // 这样可以将时间复杂度优化到O(√n)
    for (let i = 2; i * i <= num; i++) {
        // 如果i是num的因子
        if (num % i == 0) {
            s += i;
            // 注意：当i*i != num时，i和num/i是不同的因子
            if (i * i != num) {
                s += num / i;
            }
        }
    }
    
    // 特殊情况处理：1没有真因子，不是完美数
    // 其他情况下，如果真因子和等于原数，则为完美数
    return num == 1 ? false : s == num;
};

```