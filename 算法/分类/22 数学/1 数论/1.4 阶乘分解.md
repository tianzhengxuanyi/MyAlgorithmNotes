### 阶乘分解

#### [793. 阶乘函数后 K 个零](https://leetcode.cn/problems/preimage-size-of-factorial-zeroes-function/description/)

`f(x)` 是 `x!` 末尾是 0 的数量。回想一下 `x! = 1 * 2 * 3 * ... * x`，且 `0! = 1` 。

* 例如， `f(3) = 0` ，因为 `3! = 6` 的末尾没有 0 ；而 `f(11) = 2` ，因为 `11!= 39916800` 末端有 2 个 0 。

给定 `k`，找出返回能满足 `f(x) = k` 的非负整数 `x` 的数量。

**示例 1：**

```
输入：k = 0
输出：5
解释：0!, 1!, 2!, 3!, 和 4! 均符合 k = 0 的条件。
```

**示例 2：**

```
输入：k = 5
输出：0
解释：没有匹配到这样的 x!，符合 k = 5 的条件。
```

**示例 3:**

```
输入: k = 3
输出: 5
```

**提示:**

* `0 <= k <= 109`

##### 二分

```js
/**
 * 功能：计算阶乘末尾恰好有k个零的非负整数的个数
 * 参数：k - 目标末尾零的个数
 * 返回：满足条件的非负整数的个数（0或5）
 * 算法核心思想：通过二分查找确定上下边界，利用末尾零个数的数学性质
 * 时间复杂度：O(log²k)，空间复杂度：O(1)
 * @param {number} k
 * @return {number}
 */
var preimageSizeFZF = function(k) {
    // 利用二分查找求恰好有k个零的数的范围：[lowerBound(k), lowerBound(k+1))
    // 区间长度即为答案，要么是0（无解）要么是5（有解）
    return lowerBound(k + 1) - lowerBound(k);
};

/**
 * 功能：二分查找求满足trailingZeroes(x) >= k的最小x值
 * 参数：k - 目标末尾零的个数下界
 * 返回：满足条件的最小非负整数x
 * @param {number} k
 * @return {number}
 */
const lowerBound = (k) => {
    // 初始化搜索区间：左边界为0，右边界为5k（数学上的上界估计）
    let l = 0, r = 5 * k;
    
    // 二分查找循环
    while (l <= r) {
        // 计算中间位置（避免整数溢出的写法）
        let m = Math.floor((r - l) / 2) + l;
        
        // 计算中间值的阶乘末尾零个数并比较
        if (trigleZore(m) < k) {
            // 零的个数不足，左边界右移
            l = m + 1;
        } else {
            // 零的个数足够或更多，右边界左移
            r = m - 1;
        }
    }
    
    // 循环结束后，l指向第一个满足trailingZeroes(x) >= k的位置
    return l;
}

/**
 * 功能：计算n!（n的阶乘）末尾零的个数
 * 参数：x - 输入整数n
 * 返回：n!末尾零的个数
 * 数学原理：末尾零的个数等于n!中因子5的个数（因子2的数量总是足够）
 * @param {number} x
 * @return {number}
 */
const trigleZore = (x) => {
    let ans = 0; // 累计末尾零的个数
    
    // 不断除以5并累加商，直到商为0
    // 这一步计算的是x中包含5的倍数、25的倍数、125的倍数等的总个数
    while (x) {
        x = Math.floor(x / 5); // 取整除法，获取当前层5的因子个数
        ans += x; // 累加到结果中
    }
    
    return ans;
}

// f(n) => floor(n / 5) + floor(n / 5^2) + ... + floor(n / 5 ^ k);
```

