### 2.2 组合计数

#### [3405. 统计恰好有 K 个相等相邻元素的数组数目](https://leetcode.cn/problems/count-the-number-of-arrays-with-k-matching-adjacent-elements/description/)
 
给你三个整数 n ，m ，k 。长度为 n 的 好数组 arr 定义如下：

- arr 中每个元素都在 闭 区间 [1, m] 中。
- 恰好 有 k 个下标 i （其中 1 <= i < n）满足 arr[i - 1] == arr[i] 。
- 请你返回可以构造出的 好数组 数目。

由于答案可能会很大，请你将它对 109 + 7 取余 后返回。


```js
/**
 * @param {number} n
 * @param {number} m
 * @param {number} k
 * @return {number}
 */
var countGoodArrays = function(n, m, k) {
    // C(n - 1, k) * m * (m - 1) ^ (n - 1 - k)
    // 问题转换为从n-1个相邻数对中选取k个相邻数相等的数对 == 从n-1个相邻数对中选取n - 1 - k个相邻数不等的数对
    // 第一个**数**有m种可能
    // 后续n - 1 - k个相邻数不等的数对，每个(i-1, i)中的i都有m - 1种可能
    // k个相邻数相等的数对不需要计算
        // 假设i-1, i, i+1 ... j，其中（i-1, i）为不等相邻数对，（i, i+1）为相等相邻数对
        // 当（i-1, i）中i确定后，（i, i+1）中i+1就被确定
    let ans = (fact[n-1] * invF[k]) % MOD;
    ans = (ans * invF[n - k - 1]) % MOD; // 计算C(n-1, k) = fact[n-1]/(fact[k]*fact[n-1-k])
    ans = (ans * BigInt(m)) % MOD; // 乘以第一个元素的选择数
    ans = (ans * qpow(m - 1, n - 1 - k)) % MOD; // 乘以不相等的相邻对的选择数
    return Number(ans);
};

const MX = 100001;
const MOD = BigInt(1e9 + 7);

// 快速幂函数，用于计算x^n mod MOD
const qpow = (x, n) => {
    x = BigInt(x), n = BigInt(n);
    let res = 1n;

    while (n > 0n) {
        if (n & 1n) {
            res = (res * x) % MOD;
        }
        x = (x * x) % MOD;
        n = n >> 1n;
    }

    return res;
}

// 预计算阶乘数组fact和阶乘的逆元数组invF
// C(n, k) =  n! / k! * (n - k - 1)! = fact[n] * invF[k] * invF[n - k - 1];
// invF[n] = invF[n+1] * (n + 1) => 1 / n! = (1 / (n+1)!) * (n+1)
// (a / b) % mod = a * (b ^ (mod - 2)) % mod;

const fact = Array(MX);
fact[0] = 1n;

for (let i = 1; i < MX; i++) {
    fact[i] = (fact[i - 1] * BigInt(i)) % MOD // 计算i! = (i-1)! * i
}

const invF = Array(MX);
// 费马小定理计算最大阶乘的逆元: invF[MX-1] = (MX-1)!^(MOD-2) mod MOD
invF[MX - 1] = qpow(fact[MX - 1], MOD - 2n) % MOD;

// 递推计算所有阶乘的逆元: invF[i] = invF[i+1] * (i+1) mod MOD
for (let i = MX - 2; i >= 0; i--) {
    invF[i] = (invF[i+1] * BigInt(i+1)) % MOD;
}
```

#### [357. 统计各位数字都不同的数字个数](https://leetcode.cn/problems/count-numbers-with-unique-digits/description/)

给你一个整数 `n` ，统计并返回各位数字都不同的数字 `x` 的个数，其中 `0 <= x < 10n`。

**示例 1：**

```
输入：n = 2
输出：91
解释：答案应为除去 11、22、33、44、55、66、77、88、99 外，在 0 ≤ x < 100 范围内的所有数字。
```

**示例 2：**

```
输入：n = 0
输出：1
```

**提示：**

* `0 <= n <= 8`

##### 组合计算 一次遍历

```js
/**
 * @param {number} n
 * @return {number}
 */
var countNumbersWithUniqueDigits = function (n) {
    if (n == 0) return 1;
    if (n == 1) return 10;
    let ans = 10, cnt = 9;
    for (let i = 2; i <= n; i++) {
        cnt = cnt * (9 - i + 2)
        ans += cnt;
    }

    return ans;
};
```

#### [1175. 质数排列](https://leetcode.cn/problems/prime-arrangements/description/)

请你帮忙给从 `1` 到 `n` 的数设计排列方案，使得所有的「质数」都应该被放在「质数索引」（索引从 1 开始）上；你需要返回可能的方案总数。

让我们一起来回顾一下「质数」：质数一定是大于 1 的，并且不能用两个小于它的正整数的乘积来表示。

由于答案可能会很大，所以请你返回答案 **模 mod `10^9 + 7`** 之后的结果即可。

**示例 1：**

```
输入：n = 5
输出：12
解释：举个例子，[1,2,5,4,3] 是一个有效的排列，但 [5,2,3,4,1] 不是，因为在第二种情况里质数 5 被错误地放在索引为 1 的位置上。
```

**示例 2：**

```
输入：n = 100
输出：682289015
```

**提示：**

* `1 <= n <= 100`

##### 判断质数  排列数

```js
/**
 * @param {number} n
 * @return {number}
 */
var numPrimeArrangements = function (n) {
    let pCnt = cnt[n];
    let p1 = 1n;
    for (let i = 1; i <= pCnt; i++) {
        p1 = (p1 * BigInt(i)) % MOD;
    }
    let p2 = 1n;
    for (let i = 1; i <= n - pCnt; i++) {
        p2 = (p2 * BigInt(i)) % MOD;
    }
    return Number(p1 * p2 % MOD);
};

const MOD = BigInt(1e9 + 7);
const MAX = 100;
const isPrime = Array(MAX + 1).fill(1);
isPrime[0] = isPrime[1] = 0;
for (let i = 2; i <= MAX; i++) {
    if (isPrime[i]) {
        for (let j = i; j * i <= MAX; j++) {
            isPrime[i * j] = 0;
        }
    }
}
const cnt = Array(MAX + 1).fill(0);

for (let i = 2; i <= MAX; i++) {
    cnt[i] = cnt[i - 1] + isPrime[i];
}


```

#### [3179. K 秒后第 N 个元素的值](https://leetcode.cn/problems/find-the-n-th-value-after-k-seconds/description/)

给你两个整数 `n` 和 `k`。

最初，你有一个长度为 `n` 的整数数组 `a`，对所有 `0 <= i <= n - 1`，都有 `a[i] = 1` 。每过一秒，你会同时更新每个元素为其前面所有元素的和加上该元素本身。例如，一秒后，`a[0]` 保持不变，`a[1]` 变为 `a[0] + a[1]`，`a[2]` 变为 `a[0] + a[1] + a[2]`，以此类推。

返回 `k` 秒后 `a[n - 1]` 的**值**。

由于答案可能非常大，返回其对 `109 + 7` **取余** 后的结果。

**示例 1：**

**输入：**n = 4, k = 5

**输出：**56

**解释：**

| 时间（秒） | 数组状态 |
| --- | --- |
| 0 | [1,1,1,1] |
| 1 | [1,2,3,4] |
| 2 | [1,3,6,10] |
| 3 | [1,4,10,20] |
| 4 | [1,5,15,35] |
| 5 | [1,6,21,56] |

**示例 2：**

**输入：**n = 5, k = 3

**输出：**35

**解释：**

| 时间（秒） | 数组状态 |
| --- | --- |
| 0 | [1,1,1,1,1] |
| 1 | [1,2,3,4,5] |
| 2 | [1,3,6,10,15] |
| 3 | [1,4,10,20,35] |

**提示：**

* `1 <= n, k <= 1000`

##### a[i][j] = a[i - 1][j] + a[i][j - 1]等价于C[i + j][i]

```js
/**
 * @param {number} n
 * @param {number} k
 * @return {number}
 */
var valueAfterKSeconds = function (n, k) {
    // a[i][j] = a[i - 1][j] + a[i][j - 1]
    // 从[0, 0] 到 [i, j] 的路径数，从 i + j步中选取i步向下，j步向右C[i + j][j] 或 C[i + j][i]

    return Number(comb(k + n - 1, k) % MOD);
};

const MOD = BigInt(1e9 + 7);
const MX = 2000;

const f = Array(MX);
f[0] = 1n;

for (let i = 1; i < MX; i++) {
    f[i] = f[i - 1] * BigInt(i) % MOD;
}

const pow = (x, n) => {
    x = BigInt(x);
    let res = 1n;
    while (n) {
        if (n & 1n) {
            res = res * x % MOD;
        }
        x = x * x % MOD;
        n = n >> 1n;
    }
    return res;
}
const invF = Array(MX);
invF[MX - 1] = pow(f[MX - 1], MOD - 2n);

for (let i = MX - 2; i >= 0; i--) {
    invF[i] = invF[i + 1] * BigInt(i + 1) % MOD;
}


const comb = (n, k) => {
    return f[n] * invF[k] * invF[n - k];
}

```

##### 模拟

```js
/**
 * @param {number} n
 * @param {number} k
 * @return {number}
 */
var valueAfterKSeconds = function(n, k) {
    const a = Array(n).fill(1);
    for (let i = 0; i < k; i++) {
        for (let j = 1; j < n; j++) {
            a[j] = (a[j - 1] + a[j]) % MOD;
        }
    }

    return a[n - 1];
};

const MOD = 1e9 + 7;
```

#### [1359. 有效的快递序列数目](https://leetcode.cn/problems/count-all-valid-pickup-and-delivery-options/description/)

给你 `n` 笔订单，每笔订单都需要快递服务。

计算所有有效的 取货 / 交付 可能的顺序，使 delivery(i) 总是在 pickup(i) 之后。

由于答案可能很大，请返回答案对 10^9 + 7 取余的结果。

**示例 1：**

```
输入：n = 1
输出：1
解释：只有一种序列 (P1, D1)，物品 1 的配送服务（D1）在物品 1 的收件服务（P1）后。
```

**示例 2：**

```
输入：n = 2
输出：6
解释：所有可能的序列包括：
(P1,P2,D1,D2)，(P1,P2,D2,D1)，(P1,D1,P2,D2)，(P2,P1,D1,D2)，(P2,P1,D2,D1) 和 (P2,D2,P1,D1)。
(P1,D2,P2,D1) 是一个无效的序列，因为物品 2 的收件服务（P2）不应在物品 2 的配送服务（D2）之后。
```

**示例 3：**

```
输入：n = 3
输出：90
```

**提示：**

* `1 <= n <= 500`

##### 全排(2n)! 排除顺序的2^n个

```js
/**
 * @param {number} n
 * @return {number}
 */
var countOrders = function(n) {
    let f = 1n;
    for (let i = 1; i <= 2 * n; i++) {
        f = f * BigInt(i) % MOD;
    }
    let p = 1n;
    for (let i = 1; i <= n; i++) {
        p = 2n * p % MOD;
    }
    return Number(f * pow(p, MOD - 2n) % MOD);
};

const MOD = BigInt(1e9 + 7);

const pow = (x, n) => {
    x = BigInt(x)
    let res = 1n;
    while (n) {
        if (n & 1n) {
            res = res * x % MOD;
        }
        x = x * x % MOD;
        n = n >> 1n;
    }
    return res;
}
```

