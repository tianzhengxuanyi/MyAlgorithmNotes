### 5.3 逆向思维

#### [417. 太平洋大西洋水流问题](https://leetcode.cn/problems/pacific-atlantic-water-flow/description/)
 
有一个 m × n 的矩形岛屿，与 太平洋 和 大西洋 相邻。 “太平洋” 处于大陆的左边界和上边界，而 “大西洋” 处于大陆的右边界和下边界。

这个岛被分割成一个由若干方形单元格组成的网格。给定一个 m x n 的整数矩阵 heights ， heights[r][c] 表示坐标 (r, c) 上单元格 高于海平面的高度 。

岛上雨水较多，如果相邻单元格的高度 小于或等于 当前单元格的高度，雨水可以直接向北、南、东、西流向相邻单元格。水可以从海洋附近的任何单元格流入海洋。

返回网格坐标 result 的 2D 列表 ，其中 result[i] = [ri, ci] 表示雨水从单元格 (ri, ci) 流动 既可流向太平洋也可流向大西洋 。

**题解：**

从太平洋和大西洋的边界开始，**逆流而上**，标记所有可以到达的单元格。
最后，遍历所有单元格，将既能到达太平洋也能到达大西洋的单元格加入结果列表。

```js
/**
 * 功能：找出所有既可以流向太平洋又可以流向大西洋的单元格坐标
 * 算法类型：深度优先搜索(DFS) + 逆向思维
 * 输入参数：
 *   heights - 二维数组，表示每个单元格的高度
 * 返回值：
 *   number[][] - 包含满足条件的单元格坐标 [i,j] 的二维数组
 * 算法核心思想：
 *   采用逆向思维，从太平洋和大西洋的边界开始向上搜索（高度不低于当前单元格），
 *   分别标记出可以流向两大洋的单元格，最后取交集即为答案
 * 时间复杂度：O(m*n)，其中m和n分别是二维数组的行数和列数，每个单元格最多被访问两次
 * 空间复杂度：O(m*n)，用于存储两个标记矩阵和递归调用栈
 */
var pacificAtlantic = function (heights) {
    const m = heights.length, n = heights[0].length;  // 获取矩阵的行数和列数
    // 创建两个标记矩阵，分别记录可以流向太平洋和大西洋的单元格
    const p = Array.from({ length: m }, () => Array(n).fill(false));  // 太平洋可达标记矩阵
    const a = Array.from({ length: m }, () => Array(n).fill(false));  // 大西洋可达标记矩阵

    // 从太平洋的边界（上边界和左边界）开始DFS
    for (let j = 0; j < n; j++) {
        dfs(0, j, p, heights);  // 上边界（直接接触太平洋）
    }
    for (let i = 0; i < m; i++) {
        dfs(i, 0, p, heights);  // 左边界（直接接触太平洋）
    }
    // 从大西洋的边界（下边界和右边界）开始DFS
    for (let j = 0; j < n; j++) {
        dfs(m - 1, j, a, heights);  // 下边界（直接接触大西洋）
    }
    for (let i = 0; i < m; i++) {
        dfs(i, n - 1, a, heights);  // 右边界（直接接触大西洋）
    }

    // 收集既可以流向太平洋又可以流向大西洋的单元格坐标
    const ans = [];
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            if (p[i][j] && a[i][j]) {  // 同时被两个大洋标记矩阵标记的单元格
                ans.push([i, j]);
            }
        }
    }
    return ans;
};

/**
 * 功能：深度优先搜索标记可达区域
 * 输入参数：
 *   i, j - 当前搜索的单元格坐标
 *   ocean - 当前正在标记的大洋可达矩阵
 *   heights - 高度矩阵
 */
const dfs = (i, j, ocean, heights) => {
    const m = heights.length, n = heights[0].length;  // 获取矩阵的行数和列数
    if (ocean[i][j]) return;  // 如果当前单元格已经被标记，则直接返回（避免重复访问）
    ocean[i][j] = true;  // 标记当前单元格为可达
    // 向四个方向（下、上、右、左）搜索
    for (let [ni, nj] of [[i + 1, j], [i - 1, j], [i, j + 1], [i, j - 1]]) {
        // 确保新坐标在矩阵范围内，并且新单元格高度不低于当前单元格（水往高处流的逆向逻辑）
        if (ni >= 0 && ni < m && nj >= 0 && nj < n && heights[ni][nj] >= heights[i][j]) {
            dfs(ni, nj, ocean, heights);  // 递归搜索
        }
    }
}

```