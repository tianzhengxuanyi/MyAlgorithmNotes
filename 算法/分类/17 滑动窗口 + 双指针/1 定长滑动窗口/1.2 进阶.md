### 1.2 定长滑动窗口进阶

#### [3439. 重新安排会议得到最多空余时间 I](https://leetcode.cn/problems/reschedule-meetings-for-maximum-free-time-i/description/)
 
给你一个整数 eventTime 表示一个活动的总时长，这个活动开始于 t = 0 ，结束于 t = eventTime 。

同时给你两个长度为 n 的整数数组 startTime 和 endTime 。它们表示这次活动中 n 个时间 没有重叠 的会议，其中第 i 个会议的时间为 [startTime[i], endTime[i]] 。

你可以重新安排 至多 k 个会议，安排的规则是将会议时间平移，且保持原来的 会议时长 ，你的目的是移动会议后 最大化 相邻两个会议之间的 最长 连续空余时间。

移动前后所有会议之间的 相对 顺序需要保持不变，而且会议时间也需要保持互不重叠。

请你返回重新安排会议以后，可以得到的 最大 空余时间。

注意，会议 不能 安排到整个活动的时间以外。

```js
/**
 * @param {number} eventTime
 * @param {number} k
 * @param {number[]} startTime
 * @param {number[]} endTime
 * @return {number}
 */
var maxFreeTime = function (eventTime, k, startTime, endTime) {
    // 会议数量
    const n = startTime.length;
    
    // 辅助函数：获取第i个间隔的时间长度
    const get = (i) => {
        if (i === 0) {
            return startTime[0]; // 第一个会议前的空闲时间
        } else if (i === n) {
            return eventTime - endTime[n - 1]; // 最后一个会议后的空闲时间
        } else {
            return startTime[i] - endTime[i - 1]; // 两个会议之间的空闲时间
        }
    }
    
    // 初始化最大空闲时间和滑动窗口和
    let ans = 0, sum = 0;
    
    // 滑动窗口遍历所有间隔（包括首尾）
    for (let i = 0; i <= n; i++) {
        sum += get(i); // 将当前间隔加入窗口

        // 窗口大小不足k时继续扩大窗口
        if (i < k) continue;

        // 更新最大空闲时间
        ans = Math.max(ans, sum);
        // 滑动窗口：移除最左边的间隔
        sum -= get(i - k);
    }

    return ans; // 返回最大连续空闲时间
};


```