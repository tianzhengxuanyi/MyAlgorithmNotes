### 3.1 相向双指针

两个指针 left=0, right=n−1，从数组的两端开始，向中间移动，这叫相向双指针。上面的滑动窗口相当于同向双指针。

#### [1498. 满足条件的子序列数目](https://leetcode.cn/problems/number-of-subsequences-that-satisfy-the-given-sum-condition/description/)
 
给你一个整数数组 nums 和一个整数 target 。

请你统计并返回 nums 中能满足其最小元素与最大元素的 和 小于或等于 target 的 非空 子序列的数目。

由于答案可能很大，请将结果对 109 + 7 取余后返回。

```js
/**
 * 计算满足条件的子序列数目
 * @param {number[]} nums 输入数组
 * @param {number} target 目标和
 * @return {number} 满足条件的子序列数目
 */
var numSubseq = function (nums, target) {
    nums.sort((a, b) => a - b);  // 先排序数组，便于双指针操作
    const n = nums.length;
    let ans = 0;
    let left = 0, right = n - 1;  // 初始化相向双指针
    
    // 相向双指针遍历
    while (left <= right) {
        // 如果当前最小元素和最大元素的和满足条件
        if (nums[right] + nums[left] <= target) {
            // 计算以left为最小元素的子序列数目
            // C[right-left]表示在left + 1到right的元素可以任意选或不选
            // 应为最小元素和最大元素可以指向同一个元素，所以允许全不选，最小和最大元素都为left
            ans = (ans + C[right - left]) % MOD;
            left++;  // 尝试更大的最小元素
        } else {
            right--;  // 尝试更小的最大元素
        }
    }
    return ans;
};

// 预处理组合数数组
const MOD = 1e9 + 7;  // 模数
const MX = 100001;    // 最大预处理范围
const C = Array(MX);  // 组合数数组，C[k]表示2^k mod MOD
C[0] = 1;  // 2^0 = 1
for (let i = 1; i < MX; i++) {
    C[i] = (C[i - 1] * 2) % MOD;  // 预处理2的幂次
}

```