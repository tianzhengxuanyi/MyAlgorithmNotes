### 求最长/最大 基础

#### [1695. 删除子数组的最大得分](https://leetcode.cn/problems/maximum-erasure-value/description/)

给你一个正整数数组 nums ，请你从中删除一个含有 若干不同元素 的子数组。删除子数组的 得分 就是子数组各元素之 和 。

返回 只删除一个 子数组可获得的 最大得分 。

如果数组 b 是数组 a 的一个连续子序列，即如果它等于 a[l],a[l+1],...,a[r] ，那么它就是 a 的一个子数组。

```js
/**
 * 计算从正整数数组中删除一个含有若干不同元素的子数组所能获得的最大得分。
 * 得分定义为子数组各元素之和。
 * 
 * @param {number[]} nums - 输入的正整数数组
 * @return {number} - 只删除一个子数组可获得的最大得分
 */
var maximumUniqueSubarray = function(nums) {
    // 使用 Set 来存储当前滑动窗口内的元素，确保元素的唯一性
    const set = new Set();
    // ans 用于记录最大得分，sum 用于记录当前滑动窗口内元素的总和
    let ans = 0, sum = 0;
    // 使用双指针 i 和 j 来表示滑动窗口的左右边界，初始都指向数组的起始位置
    for (let i = 0, j = 0; i < nums.length; i++) {
        // 当 Set 中已经存在当前元素 nums[i] 时，说明元素重复了
        // 需要移动左指针 j，缩小窗口，直到窗口内元素唯一
        while (set.has(nums[i])) {
            // 从 Set 中移除左指针 j 指向的元素
            set.delete(nums[j]);
            // 从当前总和中减去左指针 j 指向的元素的值
            sum -= nums[j];
            // 左指针 j 右移一位
            j++;
        }
        // 将当前元素 nums[i] 添加到 Set 中
        set.add(nums[i]);
        // 将当前元素 nums[i] 的值累加到当前总和中
        sum += nums[i];
        // 更新最大得分，取当前最大得分和当前窗口元素总和中的较大值
        ans = Math.max(ans, sum);
    }

    // 返回只删除一个子数组可获得的最大得分
    return ans;
};

```

#### [1493. 删掉一个元素以后全为 1 的最长子数组](https://leetcode.cn/problems/longest-subarray-of-1s-after-deleting-one-element/description/)
 
给你一个二进制数组 nums ，你需要从中删掉一个元素。

请你在删掉元素的结果数组中，返回最长的且只包含 1 的非空子数组的长度。

如果不存在这样的子数组，请返回 0 。

##### 滑动窗口

至多只包含一个 0 的最长子数组的长度


```js
/**
 * 寻找二进制数组中只包含一个0的最长子数组长度
 * @param {number[]} nums - 二进制数组，元素为0或1
 * @return {number} 满足条件的最长子数组长度
 * @note 该算法使用滑动窗口技术，允许窗口内最多包含一个0
 * @algorithm 核心思路：
 *   1. 使用左右指针维护一个滑动窗口
 *   2. 统计窗口内0的数量，超过1个则移动左指针
 *   3. 计算并更新最长窗口长度
 * @complexity 时间复杂度O(n)，空间复杂度O(1)，其中n为数组长度
 */
var longestSubarray = function(nums) {
    // 初始化变量：结果值，0的计数，左指针
    let ans = 0, cnt0 = 0, l = 0;
    
    // 右指针遍历数组
    for (let r = 0; r < nums.length; r++ ) {
        // 如果当前元素是0，增加0的计数
        if (nums[r] == 0) {
            cnt0++;
        }
        
        // 当窗口内0的数量超过1个时，移动左指针
        while (cnt0 > 1) {
            // 如果左指针指向的是0，减少0的计数
            if (nums[l] == 0) {
                cnt0--;
            }
            // 移动左指针
            l++;
        }
        
        // 更新最长子数组长度（r - l 是因为需要删除一个元素，即使不存在0也需要删除一个元素）

        ans = Math.max(ans, r - l);
    }

    return ans;
};

```

##### 前缀和

统计每个位置左边和右边的连续 1 的数量，然后枚举每个位置作为删除的位置，计算删除该位置后的最长子数组长度。

```js
/**
 * 寻找二进制数组中只包含一个0的最长子数组长度（前缀后缀法）
 * @param {number[]} nums - 二进制数组，元素为0或1
 * @return {number} 满足条件的最长子数组长度
 * @note 该算法通过预处理前缀和后缀数组，计算删除每个0后能形成的最长子数组
 * @algorithm 核心思路：
 *   1. 预处理后缀数组，记录每个位置右侧连续1的数量
 *   2. 遍历数组，维护前缀连续1的数量
 *   3. 对于每个0，计算前缀1数量+后缀1数量的总和
 * @complexity 时间复杂度O(n)，空间复杂度O(n)，其中n为数组长度
 */
var longestSubarray = function(nums) {
    const n = nums.length;
    // 后缀数组：suffix[i]表示从i位置开始向右（包括i）的连续1的数量
    const suffix = Array(n + 1).fill(0);
    
    // 从右向左计算后缀数组
    for (let i = n - 1; i >= 0; i--) {
        if (nums[i]) {
            suffix[i] = suffix[i+1] + 1;
        }
        // 若nums[i]为0，suffix[i]保持初始值0
    }
    
    // 前缀连续1的数量
    let prefix = 0;
    // 结果值
    let ans = 0;
    
    // 遍历数组，计算每个位置作为0被删除后的最长子数组长度
    for (let i = 0; i < n; i++) {
        // 当前位置为0时，总长度 = 左侧连续1数量 + 右侧连续1数量
        ans = Math.max(ans, prefix + suffix[i+1]);
        
        // 更新前缀连续1的数量
        if (nums[i]) {
            prefix += 1;
        } else {
            // 遇到0时，前缀连续1数量重置为0
            prefix = 0;
        }
    }

    return ans;
};

```
