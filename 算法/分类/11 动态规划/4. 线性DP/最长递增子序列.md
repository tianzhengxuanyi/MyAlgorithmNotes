### 最长递增子序列

**动态规划：**

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var lengthOfLIS = function (nums) {
  let dp = new Array(nums.length).fill(1);
  let ans = 0;
  for (let i = 0; i < nums.length; i++) {
    for (let j = 0; j < i; j++) {
      if (nums[i] > nums[j]) {
        dp[i] = Math.max(dp[i], dp[j] + 1);
      }
    }
    ans = Math.max(ans, dp[i]);
  }
  return ans;
};
```

**贪心+二分：**

```js
/**
 * 求最长递增子序列长度（贪心 + 二分查找实现）
 * @param {number[]} nums 输入数组
 * @return {number} 返回最长递增子序列长度
 */
var lengthOfLIS = function (nums) {
  const g = []; // 维护的递增序列（实际存储的是当前找到的最小递增序列）
  for (let i = 0; i < nums.length; i++) {
    // 二分查找当前数字的插入位置
    let idx = lowerBound(g, nums[i]);
    if (idx === g.length) {
      g.push(nums[i]); // 比所有元素大，直接添加到末尾
    } else {
      g[idx] = nums[i]; // 替换第一个不小于当前元素的值，维持序列最小性
    }
  }
  return g.length; // 最终序列长度即为 LIS 长度
};

/**
 * 二分查找实现下界查询（第一个不小于 target 的位置）
 * @param {number[]} nums 已排序的数组
 * @param {number} target 查找目标值
 * @return {number} 返回应该插入的位置索引
 */
const lowerBound = (nums, target) => {
  let l = 0,
    r = nums.length; // 初始化左右边界 [l, r)
  while (l < r) {
    // 搜索区间为左闭右开
    let mid = Math.floor((r - l) / 2) + l; // 防溢出取中间值
    if (nums[mid] < target) {
      l = mid + 1; // 目标在右侧，收缩左边界
    } else {
      r = mid; // 目标在左侧，收缩右边界
    }
  }
  return l; // 最终左边界即为插入位置
};
```
