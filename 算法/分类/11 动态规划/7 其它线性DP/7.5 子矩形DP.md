### 子矩形DP

#### [3148. 矩阵中的最大得分](https://leetcode.cn/problems/maximum-difference-score-in-a-grid/description/)
 
给你一个由 正整数 组成、大小为 m x n 的矩阵 grid。你可以从矩阵中的任一单元格移动到另一个位于正下方或正右侧的任意单元格（不必相邻）。从值为 c1 的单元格移动到值为 c2 的单元格的得分为 c2 - c1 。

你可以从 任一 单元格开始，并且必须至少移动一次。

返回你能得到的 最大 总得分。

**动态规划：**
- dp[i][j] 表示从 (i, j) 开始，能得到的最大总得分。
- 状态转移方程：
    - dp[i][j] = max(grid[l][j] - grid[i][j] + max(dp[l][j], 0)) for l in range(i + 1, m)  # 向下移动  max(dp[l][j], 0)表示如果dp[l][j] < 0, 则不移动
    - dp[i][j] = max(grid[i][l] - grid[i][j] + max(dp[i][l], 0)) for l in range(j + 1, n)  # 向右移动  max(dp[i][l], 0)表示如果dp[i][l] < 0, 则不移动


```js
/**
 * @param {number[][]} grid
 * @return {number}
 */
var maxScore = function (grid) {
    const m = grid.length, n = grid[0].length;

    const dp = Array.from({ length: m }, () => Array(n).fill(-Infinity));
    let ans = -Infinity;
    for (let i = m - 1; i >= 0; i--) {
        for (let j = n - 1; j >= 0; j--) {
            if (i === m - 1 && j == n - 1) continue;
            let res = -Infinity;
            for (let l = i + 1; l < m; l++) {
                res = Math.max(res, grid[l][j] - grid[i][j] + Math.max(dp[l][j], 0));
            }
            for (let l = j + 1; l < n; l++) {
                res = Math.max(res, grid[i][l] - grid[i][j] + Math.max(dp[i][l], 0));
            }
            dp[i][j] = res;
            ans = Math.max(ans, res);
        }
    }
    return ans;
};
```

**优化：**
- 用rMax[i]记录第i行从右向左，grid[i][l] + Math.max(dp[i][l], 0)的最大值
- 用cMax[j]记录第j列从下向上，grid[l][j] + Math.max(dp[l][j], 0)的最大值
- 因为是从下向上，从右向左遍历，所以当计算到dp[i][j]时
  - rMax[i]表示Math.max(grid[i][l] + Math.max(dp[i][l], 0)) for l in range(j + 1, n) 
  - cMax[j]表示Math.max(grid[l][j] + Math.max(dp[l][j], 0)) for l in range(i + 1, m)
  
  可以用O(1)时间计算出dp[i][j] = Math.max(rMax[i] - grid[i][j], cMax[j] - grid[i][j])。
- 用计算的dp[i][j]更新rMax[i]和cMax[j]。


```js
/**
 * @param {number[][]} grid
 * @return {number}
 */
var maxScore = function (grid) {
    const m = grid.length, n = grid[0].length;
    const rMax = Array(m).fill(-Infinity), cMax = Array(n).fill(-Infinity);
    rMax[m - 1] = cMax[n - 1] = grid[m - 1][n - 1]
    let ans = -Infinity;
    for (let i = m - 1; i >= 0; i--) {
        for (let j = n - 1; j >= 0; j--) {
            if (i === m - 1 && j === n - 1) continue;
            let curr = grid[i][j];
            let dp = Math.max(rMax[i] - curr, cMax[j] - curr)
            rMax[i] = Math.max(rMax[i], curr + Math.max(0, dp));
            cMax[j] = Math.max(cMax[j], curr + Math.max(0, dp));
            ans = Math.max(ans, dp);
        }
    }
    return ans;
};
```

**优化：**
- 用cMax[j]记录从(i, j)到(m-1, n-1)区域内，grid[l][j] + Math.max(dp[l][j], 0)的最大值。
- dp[i][j] = Math.max(cMax[j], cMax[j+1] ?? -Infinity) - curr (cMax[j]为(i-1, j)到(m-1, n-1)区域内，grid[l][j] + Math.max(dp[l][j], 0)的最大值)，因为此时cMax[j]还未更新。

```js
/**
 * @param {number[][]} grid
 * @return {number}
 */
var maxScore = function (grid) {
    const m = grid.length, n = grid[0].length;
    const cMax = Array(n).fill(-Infinity);
    cMax[n - 1] = grid[m - 1][n - 1]
    let ans = -Infinity;
    for (let i = m - 1; i >= 0; i--) {
        for (let j = n - 1; j >= 0; j--) {
            if (i === m - 1 && j === n - 1) continue;
            let curr = grid[i][j], f = Math.max(cMax[j], cMax[j+1] ?? -Infinity) - curr;
            ans = Math.max(ans, f);
            cMax[j] = Math.max(cMax[j], cMax[j + 1] ?? -Infinity, curr + Math.max(0, f));
        }
    }
    return ans;
};
```