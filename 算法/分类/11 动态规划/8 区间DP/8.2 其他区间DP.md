### 8.2 其他区间DP

对于类似合法括号字符串（RBS）的消除问题，通常根据题意，会有如下性质：

- 可以消除相邻的匹配字符。
- 相邻匹配字符消除后，原本不相邻的字符会变成相邻，可以继续消除。换句话说，设子串 A=x+B+y，如果 x 和 y 是匹配的（可以消除），且子串 B 可以完全消除，那么子串 A 可以完全消除。
- 设子串 A=B+C，如果子串 B 和 C 可以完全消除，那么子串 A 可以完全消除。

满足上述性质的题目（例如 3563 题），可以用区间 DP 解决。

定义 f(i,j) 表示消除 s[i] 到 s[j] 的最优值。

- 根据性质 2，可以把 f(i,j) 缩小成子问题 f(i+1,j−1)。
- 根据性质 3，可以枚举子串 B 的右端点，即枚举 k=i+1,i+3,i+5,…,j−2，把 f(i,j) 划分成子问题 f(i,k) 和 f(k+1,j)。注意这里枚举 k 的步长是 2，因为每次消除 2 个字符，被消除的子串长度一定是偶数。

边界：f(i+1,i)，即空串。

答案：f(0,n−1)。


#### [5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/description/)

给你一个字符串 s，找到 s 中最长的 回文 子串。


**动态规划：**

dp[i][j]表示s[i...j]是否为回文子串。

状态转移：

- 当s[i] === s[j]时，dp[i][j] = dp[i+1][j-1] || i+ 1 > j -1。 // 单个字符或两个字符的情况。
- 当s[i]!== s[j]时，dp[i][j] = false。

初始化：

- 当i === j时，dp[i][j] = true。
- 当i > j时，dp[i][j] = false。

每次迭代更新最长回文子串的起始和结束位置。

```js
/**
 * @param {string} s
 * @return {string}
 */
var longestPalindrome = function (s) {
    const n = s.length;
    // DP数组：isPalindrome[i][j]表示s[i..j]是否为回文
    const isPalindrome = Array.from({ length: n }, () => Array(n).fill(false));
    // 记录最长回文的长度和起止索引
    let maxLen = 1, maxI = 0, maxJ = 0;
    
    // 初始化：单个字符都是回文
    for (let i = 0; i < n; i++) {
        isPalindrome[i][i] = true;
    }
    
    // 倒序计算区间[i,j]的回文状态
    for (let i = n - 2; i >= 0; i--) {
        for (let j = i + 1; j < n; j++) {
            // 状态转移：两端相等且内部子串是回文（或子串长度<=2）
            isPalindrome[i][j] = s[i] === s[j] && 
                (isPalindrome[i + 1][j - 1] || i + 1 > j - 1);
            
            // 更新最长回文记录
            if (isPalindrome[i][j] && j - i + 1 > maxLen) {
                maxLen = j - i + 1;
                maxI = i;
                maxJ = j;
            }
        }
    }

    // 根据记录的索引截取最长回文子串
    return s.slice(maxI, maxJ + 1);
};

```

#### [647. 回文子串](https://leetcode.cn/problems/palindromic-substrings/)

给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。

回文字符串 是正着读和倒过来读一样的字符串。

子字符串 是字符串中的由连续字符组成的一个序列。

**动态规划（同5. 最长回文子串思路一致）**

dp[i][j]表示s[i...j]是否为回文子串。

状态转移：

- 当s[i] === s[j]时，dp[i][j] = dp[i+1][j-1] || i+ 1 > j -1。 // 单个字符或两个字符的情况。
- 当s[i]!== s[j]时，dp[i][j] = false。

最终统计dp[i][j]为true的个数。

```js
/**
 * @param {string} s
 * @return {number}
 */
var countSubstrings = function (s) {
    const n = s.length;
    let ans = n; // 初始值为单字符回文数（每个字符都是回文）
    // DP数组：isP[i][j]表示s[i..j]是否为回文
    const isP = Array.from({ length: n }, () => Array(n).fill(false));

    // 初始化：长度为1的子串都是回文
    for (let i = 0; i < n; i++) {
        isP[i][i] = true;
    }

    // 倒序计算所有可能区间
    for (let i = n - 2; i >= 0; i--) {
        for (let j = i + 1; j < n; j++) {
            // 状态转移：首尾相同且内部子串回文（或长度<=2）
            isP[i][j] = s[i] === s[j] && (isP[i + 1][j - 1] || i + 1 > j - 1);
            
            // 发现回文时累计结果
            if (isP[i][j]) {
                ans++;
            }
        }
    }

    return ans; // 返回所有回文子串总数
};

```


#### [3040. 相同分数的最大操作数目 II 1709](https://leetcode.cn/problems/maximum-number-of-operations-with-the-same-score-ii/description/)

给你一个整数数组 nums ，如果 nums 至少 包含 2 个元素，你可以执行以下操作中的 任意 一个：

选择 nums 中最前面两个元素并且删除它们。
选择 nums 中最后两个元素并且删除它们。
选择 nums 中第一个和最后一个元素并且删除它们。
一次操作的 分数 是被删除元素的和。

在确保 所有操作分数相同 的前提下，请你求出 最多 能进行多少次操作。

请你返回按照上述要求 最多 可以进行的操作次数。

**动态规划：**

dp[i][j][k]表示在nums[i...j]区间内，操作分数为k的最大操作次数。

状态转移：

- nums[i] + nums[i+1] === k: dp[i][j][k] = max(dp[i+2][j][k] + 1, dp[i][j][k])
- nums[j] + nums[j-1] === k: dp[i][j][k] = max(dp[i][j-2][k] + 1, dp[i][j][k])
- nums[i] + nums[j] === k: dp[i][j][k] = max(dp[i+1][j-1][k] + 1, dp[i][j][k])

k的取值只有可能为nums[0] + nums[1], nums[n-1] + nums[n-2], nums[0] + nums[n-1]。

所以可以省去k这个维度。

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxOperations = function (nums) {
    const n = nums.length;
    if (n === 2) return 1; // 特殊情况直接返回
    // 计算可能的初始分数（前两个/后两个/首尾两个元素的和）
    const scores = new Set([nums[0] + nums[1], nums[n - 1] + nums[n - 2], nums[0] + nums[n - 1]]);
    let s1, s2, s3, ans = 0;
    
    // 遍历三种可能的初始分数
    for (let score of scores) {
        // DP数组：dp[i][j]表示区间[i,j]的最大操作次数
        const dp = Array.from({ length: n }, () => Array(n).fill(0));
        
        // 倒序计算所有可能区间（i从右往左，j从左往右）
        for (let i = n - 2; i >= 0; i--) {
            for (let j = i + 1; j < n; j++) {
                // 计算三种可能的操作分数
                s1 = nums[i] + nums[i + 1], s2 = nums[j] + nums[j - 1], s3 = nums[i] + nums[j];
                
                // 处理前两个元素的操作
                if (s1 === score) {
                    dp[i][j] = Math.max(dp[i][j], (dp[i + 2]?.[j] ?? 0) + 1); // 处理越界情况
                }
                // 处理后两个元素的操作
                if (s2 === score) {
                    dp[i][j] = Math.max(dp[i][j], (dp[i][j - 2] ?? 0) + 1);
                }
                // 处理首尾元素的操作
                if (s3 === score) {
                    dp[i][j] = Math.max(dp[i][j], dp[i + 1][j - 1] + 1);
                }
            }
        }
        ans = Math.max(ans, dp[0][n-1]); // 记录三种情况中的最大值
    }
    return ans;
};

```


#### [375. 猜数字大小 II](https://leetcode.cn/problems/guess-number-higher-or-lower-ii/description/)

我们正在玩一个猜数游戏，游戏规则如下：

1. 我从 1 到 n 之间选择一个数字。
2. 你来猜我选了哪个数字。
3. 如果你猜到正确的数字，就会 赢得游戏 。
4. 如果你猜错了，那么我会告诉你，我选的数字比你的 更大或者更小 ，并且你需要继续猜数。
5. 每当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。如果你花光了钱，就会 输掉游戏 。

给你一个特定的数字 n ，返回能够 确保你获胜 的最小现金数，不管我选择那个数字 

**动态规划：**

dp[i][j]表示在[i...j]区间内确保胜利的最小现金数。贪心策略：要确保胜利，所以要计算最坏情况下的最小现金数，即当i == j（只剩一个数）时才猜中。

状态转移：

- 当选择x时，dp[i][j] = min(dp[i][j], x + max(dp[i][x-1], dp[x+1][j]))。 x的取值为[i...j]。

边界情况：

- 当i === j时，dp[i][j] = 0。
- 当i > j时，dp[i][j] = 0。

最终结果为dp[1][n]。

```js
/**
 * @param {number} n
 * @return {number}
 */
var getMoneyAmount = function (n) {
    // DP数组：dp[i][j]表示猜测范围[i,j]时的最小保证金额
    const dp = Array.from({ length: n + 2 }, () => Array(n + 1).fill(0)); // +2处理右边界越界
    
    // 倒序计算所有区间（从小区间到大区间）
    for (let i = n - 1; i >= 1; i--) {
        for (let j = i + 1; j <= n; j++) {
            let res = Infinity;
            // 遍历所有可能的首次猜测值k
            for (let k = i; k <= j; k++) {
                // 当前策略的成本 = k + 左右区间成本的较大值（最坏情况）
                res = Math.min(res, Math.max(dp[i][k - 1], dp[k + 1][j]) + k);
            }
            dp[i][j] = res;
        }
    }

    return dp[1][n]; // 返回整个区间[1,n]的最小保证金额
};

```


#### [1130. 叶值的最小代价生成树 1919](https://leetcode.cn/problems/minimum-cost-tree-from-leaf-values/description/)

给你一个正整数数组 arr，考虑所有满足以下条件的二叉树：

- 每个节点都有 0 个或是 2 个子节点。
- 数组 arr 中的值与树的中序遍历中每个叶节点的值一一对应。
- 每个非叶节点的值等于其左子树和右子树中叶节点的最大值的乘积。
- 在所有这样的二叉树中，返回每个非叶节点的值的最小可能总和。这个和的值是一个 32 位整数。

如果一个节点有 0 个子节点，那么该节点为叶节点。

##### **动态规划：**

dp[i][j]表示在[i...j]区间内的最小可能总和。

将[i...j]区间分为两个子区间[i...k]和[k+1...j]，k为分割点。其中[i...k]看作左子树，[k+1...j]看作右子树。

状态转移：

- 当k为[i...j]内的任意一个分割点时，dp[i][j] = min(dp[i][k] + dp[k+1][j] + max(arr[i...k]) * max(arr[k+1...j]))。

```js
/**
 * @param {number[]} arr
 * @return {number}
 */
var mctFromLeafValues = function (arr) {
    const n = arr.length;
    
    // DP数组：dp[i][j]表示区间[i,j]的最小生成代价
    const dp = Array.from({ length: n }, () => Array(n).fill(Infinity));
    // rangeMax[i][j]存储区间[i,j]中的最大值
    const rangeMax = Array.from({ length: n }, () => Array(n));

    // 初始化单个叶子节点情况
    for (let i = 0; i < n; i++) {
        rangeMax[i][i] = arr[i];  // 单个节点的最大值就是自身
        dp[i][i] = 0;  // 单个叶子节点没有代价
    }

    // 倒序计算所有区间（从小区间到大区间）
    for (let i = n - 1; i >= 0; i--) {
        for (let j = i + 1; j < n; j++) {
            // 计算区间[i,j]的最大值（基于已计算的[i,j-1]区间）
            rangeMax[i][j] = Math.max(rangeMax[i][j - 1], arr[j]);
            
            // 遍历所有可能的分割点k
            for (let k = i; k < j; k++) {
                // 状态转移：左右子树代价 + 当前根节点乘积值
                dp[i][j] = Math.min(
                    dp[i][j],
                    dp[i][k] + dp[k + 1][j] + rangeMax[i][k] * rangeMax[k + 1][j]
                );
            }
        }
    }

    return dp[0][n-1];  // 返回整个数组区间的最小生成代价
};

```

##### [单调栈 ⭐ CV](https://leetcode.cn/problems/minimum-cost-tree-from-leaf-values/solutions/1124237/dan-diao-zhan-and-dong-tai-gui-hua-by-20-z0te/) ：

方法一的思路是自上而下构建二叉树，这里我们可以尝试自下而上构建二叉树：

选择 arr 两个相邻的值，即两个节点，将它们作为一个新节点的左子节点和右子节点；

将这个新节点在数组 arr 替代这两个节点；

如果 arr 剩余的元素数目大于 1，执行步骤 1，否则终止，那么剩余的节点就是构建的二叉树的根节点。

问题可以转化为：给定一个数组 arr，不断地合并相邻的数，合并代价为两个数的乘积，合并之后的数为两个数的最大值，直到数组只剩一个数，求最小合并代价和。

作者：力扣官方题解
链接：https://leetcode.cn/problems/minimum-cost-tree-from-leaf-values/solutions/2285433/xie-zhi-de-zui-xiao-dai-jie-sheng-cheng-26ozf/

- arr[i] <= arr[i+1] <= arr[i+2], 当序列为递增时，我们优先选择最小的两个数进行合并。这样合并后保留的数是最小的，合并代价最小。
- arr[i] >= arr[i+1] >= arr[i+2]，当序列为递减时，选择从后往前合并。
- arr[i] <= arr[i+1] >= arr[i+2]，当序列为先增后减时，递增序列选择从前往后合并，递减序列选择从后往前合并。
- arr[i] >= arr[i+1] <= arr[i+2]，当序列为先减后增时，需要判断极小值左右相邻的数值大小，选择较小的数进行合并。

因此，我们可以使用单调栈来解决这个问题。

单调栈的思路是：

从左往右遍历数组 arr，维护一个单调递减的栈。


```js
var mctFromLeafValues = function(arr) {
    let res = 0; // 累计代价结果
    let stack = []; // 维护递减单调栈
    
    // 第一遍遍历处理数组元素
    for (let x of arr) {
        // 当栈顶元素<=当前元素时，需要合并较小的元素
        while (stack.length && stack[stack.length - 1] <= x) {
            const y = stack.pop(); // 弹出较小的元素
            
            // 选择更小的邻居进行合并：栈空时与x合并，否则与更小的邻居合并
            if (!stack.length || stack[stack.length - 1] > x) {
                res += y * x; // 与当前元素合并
            } else {
                res += stack[stack.length - 1] * y; // 与栈顶元素合并
            }
        }
        stack.push(x); // 将当前元素入栈
    }

    // 处理栈中剩余元素（从右往左合并）
    while (stack.length >= 2) {
        const x = stack.pop();
        res += stack[stack.length - 1] * x; // 总是与左边更大的元素合并
    }

    return res; // 返回最小总代价
}

```


```js
function bitCount32(n) {
    n = n - ((n >> 1) & 0x55555555);
    n = (n & 0x33333333) + ((n >> 2) & 0x33333333);
    return ((n + (n >> 4) & 0xF0F0F0F) * 0x1010101) >> 24;
}
```