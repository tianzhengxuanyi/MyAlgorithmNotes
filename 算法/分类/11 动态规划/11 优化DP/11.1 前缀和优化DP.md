### 11.1 前缀和优化DP

#### [2327. 知道秘密的人数](https://leetcode.cn/problems/number-of-people-aware-of-a-secret/description/)
 
在第 1 天，有一个人发现了一个秘密。

给你一个整数 delay ，表示每个人会在发现秘密后的 delay 天之后，每天 给一个新的人 分享 秘密。同时给你一个整数 forget ，表示每个人在发现秘密 forget 天之后会 忘记 这个秘密。一个人 不能 在忘记秘密那一天及之后的日子里分享秘密。

给你一个整数 n ，请你返回在第 n 天结束时，知道秘密的人数。由于答案可能会很大，请你将结果对 109 + 7 取余 后返回。

**动态规划：**

状态定义：dfs(i) 表示第i天知道秘密的新增人数

```js
/**
 * @param {number} n
 * @param {number} delay
 * @param {number} forget
 * @return {number}
 */
var peopleAwareOfSecret = function(n, delay, forget) {
    // 初始化记忆化数组，memo[i]表示第i天新增知道秘密的人数
    const memo = Array(n + 1).fill(-1);
    memo[0] = 0;  // 第0天没有人知道秘密
    
    // 定义DFS函数，计算第i天新增知道秘密的人数
    const dfs = (i) => {
        if (i == 1) return memo[i] = 1;  // 第1天有1人知道秘密
        if (memo[i] >= 0) return memo[i];  // 如果已经计算过，直接返回
        
        let res = 0;
        
        // 计算第i天新增人数：从i-delay天到i-forget+1天之间知道秘密的人会在第i天传播
        for (let j = Math.max(0, i - delay); j >= Math.max(i - forget + 1, 0); j--) {
            res = (res + dfs(j)) % MOD;  // 累加有效传播人数
        }
        
        return memo[i] = res;  // 记忆化并返回结果
    }

    let ans = 0;
    // 计算第n天结束时知道秘密的总人数：统计最后forget天内新增的人数
    for (let i = n; i >= Math.max(n - forget + 1, 1); i--) {
        ans = (ans + dfs(i)) % MOD;
    }

    return ans;
};

// 定义模数常量
const MOD = 1e9 + 7;

```


**递推：**

```js
/**
 * @param {number} n
 * @param {number} delay
 * @param {number} forget
 * @return {number}
 */
var peopleAwareOfSecret = function (n, delay, forget) {
    // 初始化DP数组，f[i]表示第i天新增知道秘密的人数
    const f = Array(n + 1).fill(0);
    f[1] = 1;  // 第1天有1人知道秘密
    
    // 动态规划递推计算每天新增人数
    for (let i = 1; i <= n; i++) {
        // 计算第i天新增人数：从i-delay天到i-forget+1天之间知道秘密的人会在第i天传播
        for (let j = Math.max(0, i - delay); j >= Math.max(i - forget + 1, 0); j--) {
            f[i] = (f[i] + f[j]) % MOD;  // 累加有效传播人数
        }
    }
    
    // 计算第n天结束时知道秘密的总人数
    let ans = 0;
    // 统计最后forget天内新增的人数（因为超过forget天的人会忘记）
    for (let i = n; i >= Math.max(n - forget + 1, 1); i--) {
        ans = (ans + f[i]) % MOD;
    }
    
    return ans;
};

// 定义模数常量，用于大数取余
const MOD = 1e9 + 7;

```


**前缀和优化：**

```js
/**
 * @param {number} n
 * @param {number} delay
 * @param {number} forget
 * @return {number}
 */
var peopleAwareOfSecret = function (n, delay, forget) {
    // f数组表示前缀和数组，f[i]表示第1天到第i天新增知道秘密的人数总和
    const f = Array(n + 1).fill(0);
    f[1] = 1;  // 第1天初始有1人知道秘密
    
    // 使用前缀和优化计算每天新增人数
    for (let i = 2; i <= n; i++) {
        // 计算f[i] = 
        // (能传播秘密的人数区间[i-delay, i-forget]的总人数(第i天新增的人数) + 前一天的前缀和) % MOD
        // 使用MOD防止负数出现
        f[i] = ((f[Math.max(0, i - delay)] - f[Math.max(i - forget, 0)] + MOD) % MOD + f[i - 1]) % MOD;
    }
    
    // 最终结果 = 最后forget天内新增的人数总和（因为超过forget天的人会忘记）
    return (f[n] - f[Math.max(n - forget , 0)] + MOD) % MOD;
};

// 定义模数常量，用于大数取余
const MOD = 1e9 + 7;

```

**刷表法：**

```js
/**
 * @param {number} n 总天数
 * @param {number} delay 传播延迟天数
 * @param {number} forget 遗忘天数
 * @return {number} 第n天结束时知道秘密的人数
 */
var peopleAwareOfSecret = function(n, delay, forget) {
    // f数组记录每天新增知道秘密的人数
    const f = Array(n + 1).fill(0);
    // 第1天初始有1人知道秘密
    f[1] = 1;
    
    // 刷表法：遍历每一天i，更新i能影响的天数j
    for (let i = 1;  i < n; i++) {
        // j的范围是i+delay到i+forget-1（因为forget天后会忘记）
        for (let j = i + delay; j < Math.min(i + forget, n + 1); j++) {
            // 第j天新增人数 += 第i天知道秘密的人数
            f[j] = (f[i] + f[j]) % MOD;
        }
    }

    // 计算最终结果：最后forget天内新增的人数总和
    let ans = 0;
    for (let i = n - forget + 1; i <= n; i++) {
        ans = (ans + f[i]) % MOD;
    }
    return ans;
};
// 模数常量，用于大数取余
const MOD = 1e9 + 7;

```


#### [1871. 跳跃游戏 VII](https://leetcode.cn/problems/jump-game-vii/description/)

给你一个下标从 0 开始的二进制字符串 s 和两个整数 minJump 和 maxJump 。一开始，你在下标 0 处，且该位置的值一定为 '0' 。当同时满足如下条件时，你可以从下标 i 移动到下标 j 处：

- i + minJump <= j <= min(i + maxJump, s.length - 1) 且
- s[j] == '0'.

如果你可以到达 s 的下标 s.length - 1 处，请你返回 true ，否则返回 false 。

**dfs + 记忆化：超时**

状态定义： dfs(i) 表示从i位置能否到达终点

状态转移方程： dfs(i) = dfs(i + minJump) || dfs(i + minJump + 1) || ... || dfs(i + maxJump)

```js
/**
 * @param {string} s
 * @param {number} minJump
 * @param {number} maxJump
 * @return {boolean}
 */
var canReach = function(s, minJump, maxJump) {
    const n = s.length;
    // 检查终点是否为'0'，不是则直接返回false
    if (s[n - 1] != 0) return false;
    
    // 记忆化数组，memo[i]表示从位置i能否到达终点
    const memo = Array(n);
    
    // DFS函数定义：判断从位置i能否到达终点
    const dfs = (i) => {
        // 基本情况：已经到达终点
        if (i == n - 1) return memo[i] = true;
        // 如果已经计算过，直接返回结果
        if (memo[i] !== undefined) return memo[i];
        
        // 尝试所有可能的跳跃距离
        for (let j = i + minJump; j <= Math.min(n - 1, i + maxJump); j++) {
            // 只有当目标位置是'0'且从该位置能到达终点时，才返回true
            if (s[j] == 0 && dfs(j)) {
                return memo[i] = true;
            }
        }
        
        // 所有可能跳跃都无法到达终点，返回false
        return memo[i] = false;
    }

    // 从起点0开始DFS
    return dfs(0)
};

```

**递推 + 前缀和优化：**

```js
/**
 * @param {string} s
 * @param {number} minJump
 * @param {number} maxJump
 * @return {boolean}
 */
var canReach = function(s, minJump, maxJump) {
    const n = s.length;
    // 检查终点是否为'0'，不是则直接返回false
    if (s[n - 1] != 0) return false;
    
    // cnt数组是前缀和数组，cnt[i]表示从位置i到末尾有多少个可达位置
    const cnt = Array(n + 1).fill(0);
    // 初始化终点位置为可达
    cnt[n - 1] = 1;

    // 从后向前动态规划计算每个位置的可达性
    for (let i = n - 2; i >= 0; i--) {
        // 如果当前位置是'0'，且在跳跃范围内有可达位置
        if (i <= n - 1 - minJump && s[i] == 0 && 
            cnt[i + minJump] - cnt[Math.min(i + maxJump, n - 1) + 1] > 0) {
            // 当前位置可达，前缀和+1
            cnt[i] = cnt[i + 1] + 1;
        } else {
            // 当前位置不可达，继承下一个位置的前缀和
            cnt[i] = cnt[i+1];
        }
    }
    
    // 检查起点0是否在跳跃范围内有可达位置
    return cnt[minJump] - cnt[Math.min(maxJump, n - 1) + 1] > 0;
};

```

#### [3333. 找到初始输入字符串 II]()
 
Alice 正在她的电脑上输入一个字符串。但是她打字技术比较笨拙，她 可能 在一个按键上按太久，导致一个字符被输入 多次 。

给你一个字符串 word ，它表示 最终 显示在 Alice 显示屏上的结果。同时给你一个 正 整数 k ，表示一开始 Alice 输入字符串的长度 至少 为 k 。

请你返回 Alice 一开始可能想要输入字符串的总方案数。

由于答案可能很大，请你将它对 109 + 7 取余 后返回。

**思路**

- 首先统计word中连续相同字符的段（如"aabbb"有2段："aa"和"bbb"）
- 计算不考虑k限制时的总方案数（每段重复n次有n+1种方案：不重复或重复1-n次）
- 如果不同字符段数量s ≥ k，直接返回总方案数
- 否则需要计算不满足k限制的方案数（即原始字符串长度< k的情况）


**记忆化缓存：超时**

```js
/**
 * @param {string} word
 * @param {number} k
 * @return {number}
 */
var possibleStringCount = function(word, k) {
    const n = word.length;
    
    // arr数组记录连续相同字符的重复次数-1（即连续重复n次记为n-1）
    const arr = [];
    // s记录不同字符段的数量，total记录不考虑k限制时的总方案数
    let s = 0, total = 1;
    
    // 遍历字符串，统计连续相同字符段
    for (let i = 0; i < n; i++) {
        let cnt = 1, j = i;
        s++;  // 每遇到一个新字符段，s加1
        // 统计当前字符连续出现的次数
        while (word[j] === word[j+1]) {
            j++;
            cnt++;
        }
        // 如果连续出现超过1次，记录重复次数-1
        if (j - i > 0) {
            arr.push(j - i);
        }
        // 计算总方案数：每个字符段的方案数是(重复次数+1)
        total = (total * (j - i + 1)) % MOD;
        i = j;  // 跳过已处理的连续字符
    }

    // 如果不同字符段数量已经满足k要求，直接返回总方案数
    if (s >= k) return total;

    // 计算还需要增加的字符段数量
    let rest = k - s - 1;
    let len = arr.length;
    
    // 记忆化数组：memo[i][r]表示从前i个重复段中选r个的方案数
    const memo = Array.from({length: len}, () => Array(rest + 1).fill(-1));
    
    // DFS函数：计算从前i个重复段中选r个的方案数
    const dfs = (i, r) => {
        // 基本情况：不需要再选或没有可选段
        if (r == 0 || i < 0) return 1;
        // 如果已经计算过，直接返回
        if (memo[i][r] >= 0) return memo[i][r];
        
        let res = 0;
        // 枚举当前重复段可以贡献的字符段数量（0到arr[i]）
        for (let j = 0; j <= arr[i]; j++) {
            if (r - j < 0) break;
            res = (res + dfs(i - 1, r - j)) % MOD;
        }
        
        return memo[i][r] = res;  // 记忆化并返回结果
    }

    // 最终结果 = 总方案数 - 不满足k限制的方案数
    return (total - dfs(len - 1, rest) + MOD) % MOD;
};

// 模数常量，用于大数取余
const MOD = 1e9 + 7;

```

```js
/**
 * @param {string} word
 * @param {number} k
 * @return {number}
 */
var possibleStringCount = function (word, k) {
    const n = word.length;

    // arr数组：存储每个连续字符段中可以删除的字符数量（即连续重复次数-1）
    const arr = []; 
    // s：不同字符段的数量（即字符变化的次数）
    // total：不考虑k限制时的总方案数（每个字符段的方案数是重复次数+1）
    let s = 0, total = 1; 
    
    // 遍历字符串，统计连续相同字符段
    for (let i = 0; i < n; i++) {
        let cnt = 1, j = i;
        s++;  // 每遇到一个新字符段，s加1
        // 统计当前字符连续出现的次数
        while (word[j] === word[j + 1]) {
            j++;
            cnt++;
        }
        // 如果连续出现超过1次，记录可删除的数量（重复次数-1）
        if (j - i > 0) {
            arr.push(j - i);
        }
        // 计算总方案数：每个字符段的方案数是(重复次数+1)
        total = (total * (j - i + 1)) % MOD;
        i = j;  // 跳过已处理的连续字符
    }

    // 如果不同字符段数量已经满足k要求，直接返回总方案数
    if (s >= k) return total;

    // 计算还需要增加的字符数量（k = s + 1 + rest）
    let rest = k - s - 1;
    let len = arr.length;
    
    // 使用前缀和优化动态规划：
    // prePrefix数组表示前i-1个字符段的前缀和
    // 初始化为[0,1,2,...,rest+1]，表示选择0到r个的方案数初始值
    let dp;
    let prePrefix = Array.from({length: rest + 2}, (_, i) => i);
    
    // 遍历每个可删除的字符段
    for (let i = 1; i <= len; i++) {
        dp = 1;  // 初始化当前字符段的方案数
        let currPrefix = Array(rest + 2);
        currPrefix[0] = 0, currPrefix[1] = 1;  // 初始化前缀和数组
        
        // 计算当前字符段选择r个字符的方案数
        for (let r = 1; r <= rest; r++) {
            // 使用前缀和优化计算：dp[r] = sum(dp[r-j] for j in 0..min(arr[i],r))
            dp = (prePrefix[r + 1] - prePrefix[Math.max(r - arr[i - 1], 0)] + MOD) % MOD;
            // 更新当前前缀和数组
            currPrefix[r + 1] = (currPrefix[r] + dp) % MOD
        }
        prePrefix = currPrefix;  // 更新前缀和数组
    }

    // 最终结果 = 总方案数 - 不满足k限制的方案数（即选择不超过rest个的方案数）
    return (total - dp + MOD) % MOD;
};

// 模数常量，用于大数取余
const MOD = 1e9 + 7;

```