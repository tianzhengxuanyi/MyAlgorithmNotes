### 9.4 子集状压 DP

一般定义 f[S] 表示未选（或者已选）的集合为 S 时，和题目有关的最优值。通过枚举 S（或者 S 的补集 ∁ U S）的子集来转移。

时间复杂度（通常来说）是 O(3 ^ n)

值得注意的是，枚举子集的子集还可以用「选或不选」来做，对于存在无效状态的情况，可以做到更优的时间复杂度。具体见 1349 题解 最后的写法。

#### [2305. 公平分发饼干](https://leetcode.cn/problems/fair-distribution-of-cookies/description/)

给你一个整数数组 cookies ，其中 cookies[i] 表示在第 i 个零食包中的饼干数量。另给你一个整数 k 表示等待分发零食包的孩子数量，所有 零食包都需要分发。在同一个零食包中的所有饼干都必须分发给同一个孩子，不能分开。

分发的 不公平程度 定义为单个孩子在分发过程中能够获得饼干的最大总数。

返回所有分发的最小不公平程度。

**动态规划： 子集状压**

```js
/**
 * @param {number[]} cookies
 * @param {number} k
 * @return {number}
 */
var distributeCookies = function (cookies, k) {
  const n = cookies.length;
  // 预处理所有子集的饼干总和
  const sum = Array(1 << n).fill(0);
  for (let i = 0; i < n; i++) {
    // 动态规划预处理子集和：通过添加第i个元素生成新子集
    for (let j = 0, bit = 1 << i; j < bit; j++) {
      sum[bit | j] = sum[j] + cookies[i];
    }
  }

  // 记忆化数组：memo[i][s] 表示前i个孩子分配s集合时的最小最大和
  const memo = Array.from({ length: k }, () => Array(1 << n).fill(-1));

  // DFS + 记忆化搜索
  const dfs = (i, s) => {
    if (s == 0) return 0; // 所有饼干已分配完毕
    if (i < 0) return Infinity; // 无效状态
    if (memo[i][s] >= 0) return memo[i][s];

    let res = Infinity;
    let sub = s; // 当前孩子要分配的饼干子集

    // 枚举所有可能的子集分配方案
    while (sub !== 0) {
      // 当前子集给第i个孩子，剩余子集递归处理
      res = Math.min(
        res,
        Math.max(
          dfs(i - 1, s ^ sub), // 剩余子集分配给前i-1个孩子
          sum[sub] // 当前孩子获得的饼干数
        )
      );
      // 位运算技巧：获取下一个子集
      sub = (sub - 1) & s;
    }
    return (memo[i][s] = res);
  };

  // 初始状态：k-1号孩子分配全部饼干（二进制全1表示）
  return dfs(k - 1, (1 << n) - 1);
};
```

#### [1986. 完成任务的最少工作时间段](https://leetcode.cn/problems/minimum-number-of-work-sessions-to-finish-the-tasks/description/)

你被安排了 n 个任务。任务需要花费的时间用长度为 n 的整数数组 tasks 表示，第 i 个任务需要花费 tasks[i] 小时完成。一个 工作时间段 中，你可以 至多 连续工作 sessionTime 个小时，然后休息一会儿。

你需要按照如下条件完成给定任务：

如果你在某一个时间段开始一个任务，你需要在 同一个 时间段完成它。
完成一个任务后，你可以 立马 开始一个新的任务。
你可以按 任意顺序 完成任务。
给你 tasks 和 sessionTime ，请你按照上述要求，返回完成所有任务所需要的 最少 数目的 工作时间段 。

测试数据保证 sessionTime 大于等于 tasks[i] 中的 最大值 。

```js
/**
 * 计算完成任务所需的最少工作时间段
 * @param {number[]} tasks - 每个任务所需的时间数组
 * @param {number} sessionTime - 每个工作时间段的最大时长
 * @return {number} 最少需要的工作时间段数
 */
var minSessions = function (tasks, sessionTime) {
  const n = tasks.length;
  // sum[s] 表示任务子集s的总耗时
  const sum = Array(1 << n).fill(0);
  // 预处理所有子集的总耗时
  for (let i = 0; i < n; i++) {
    // 动态规划计算子集和：通过添加第i个任务生成新子集
    for (let j = 0, bit = 1 << i; j < bit; j++) {
      sum[bit | j] = sum[j] + tasks[i];
    }
  }

  // 记忆化数组：memo[s] 表示完成子集s所需的最少时间段数
  const memo = Array(1 << n).fill(-1);

  // DFS + 记忆化搜索
  const dfs = (s) => {
    if (s == 0) return 0; // 基本情况：没有任务需要完成
    if (memo[s] >= 0) return memo[s]; // 已计算过则直接返回

    let res = Infinity; // 初始化结果为最大值
    let sub = s; // 当前时间段要分配的任务子集

    // 枚举所有可能的子集分配方案
    while (sub !== 0) {
      // 检查当前子集是否可以在一个时间段内完成
      if (sum[sub] <= sessionTime) {
        // 递归计算剩余子集所需的时间段数，并取最小值
        res = Math.min(res, 1 + dfs(s ^ sub));
      }
      // 位运算技巧：获取下一个可能的子集
      sub = (sub - 1) & s;
    }

    return (memo[s] = res); // 记忆化并返回结果
  };

  // 初始状态：所有任务都需要完成（二进制全1表示）
  return dfs((1 << n) - 1);
};
```
