#### [337. 打家劫舍 III](https://leetcode.cn/problems/house-robber-iii/description/)

小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 root 。

除了 root 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。

给定二叉树的 root 。返回 在不触动警报的情况下 ，小偷能够盗取的最高金额 。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var rob = function(root) {
    // 定义后序遍历函数，返回一个数组 [偷当前节点的最大值, 不偷当前节点的最大值]
    const dfs = (node) => {
        // 空节点返回 [0,0] 表示偷或不偷都没有收益
        if (!node) return [0,0];

        // 递归获取左右子树的结果
        const [l1, l2] = dfs(node.left);  // l1:偷左子节点的最大值, l2:不偷左子节点的最大值
        const [r1, r2] = dfs(node.right); // r1:偷右子节点的最大值, r2:不偷右子节点的最大值

        // 返回结果数组：
        // [0] 偷当前节点: 当前节点值 + 不偷左子节点的最大值 + 不偷右子节点的最大值
        // [1] 不偷当前节点: 左右子树各自偷或不偷的最大值之和
        return [
            node.val + l2 + r2, 
            Math.max(l1, l2) + Math.max(r1, r2)
        ];
    }

    // 最终结果是偷或不偷根节点的最大值
    return Math.max(...dfs(root));
};

```

#### 派对的最大快乐值

员工信息的定义如下:

```tsx
interface Employee {
  happy: number; // 这名员工可以带来的快乐值
  subordinates: Employee[]; // 这名员工有哪些直接下级
}
```

公司的每个员工都符合 Employee 类的描述。整个公司的人员结构可以看作是一棵标准的、 没有环的多叉树。树的头节点是公司唯一的老板。除老板之外的每个员工都有唯一的直接上级。 叶节点是没有任何下属的基层员工(subordinates 列表为空)，除基层员工外，每个员工都有一个或多个直接下级。

这个公司现在要办 party，你可以决定哪些员工来，哪些员工不来。但是要遵循如下规则。

1. 如果某个员工来了，那么这个员工的所有直接下级都不能来
2. 派对的整体快乐值是所有到场员工快乐值的累加
3. 你的目标是让派对的整体快乐值尽量大

给定一棵多叉树的头节点 boss，请返回派对的最大快乐值。

**思路：**

1. 以 X 为头获得的最大快乐值分为两种情况讨论(X 的 subordinates 为[A,B,C,...])：
   - X 参与：X 快乐值+A 不来的整棵树的最大快乐值+B 不来的整棵树的最大快乐值+C 不来的整棵树的最大快乐值+...
   - X 不参与：0+max{A 不来的整棵树的最大快乐值，A 来的整棵树的最大快乐值}+max{B 来的整棵树的最大快乐值，B 来的整棵树的最大快乐值}+...

```js
function getMaxHappiness(head) {
  function Info(headNotIn, headIn) {
    // headNotIn: 头节点不参与整个树的最大快乐值
    // headIn: 头节点参与整个树的最大快乐值
    this.headNotIn = headNotIn;
    this.headIn = headIn;
  }
  function process(head) {
    if (head === null) {
      return new Info(0, 0);
    }

    let headNotInMaxHappiness = 0,
      headInMaxHappiness = head.happy;

    for (let i = 0; i < head.subordinates.length; i++) {
      const { headNotIn, headIn } = process(head.subordinates[i]);
      headNotInMaxHappiness += Math.max(headNotIn, headIn);
      headInMaxHappiness += headNotIn;
    }

    return new Info(headNotInMaxHappiness, headInMaxHappiness);
  }

  const { headNotIn, headIn } = process(head);

  return Math.max(headNotIn, headIn);
}
```
