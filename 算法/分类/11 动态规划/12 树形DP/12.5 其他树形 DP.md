### 12.5 其他树形 DP

#### 2925. 在树上执行操作以后得到的最大分数

有一棵 n 个节点的无向树，节点编号为 0 到 n - 1 ，根节点编号为 0 。给你一个长度为 n - 1 的二维整数数组 edges 表示这棵树，其中 edges[i] = [ai, bi] 表示树中节点 ai 和 bi 有一条边。

同时给你一个长度为 n 下标从 0 开始的整数数组 values ，其中 values[i] 表示第 i 个节点的值。

一开始你的分数为 0 ，每次操作中，你将执行：

- 选择节点 i 。
- 将 values[i] 加入你的分数。
- 将 values[i] 变为 0 。
  如果从根节点出发，到任意叶子节点经过的路径上的节点值之和都不等于 0 ，那么我们称这棵树是 健康的 。

你可以对这棵树执行任意次操作，但要求执行完所有操作以后树是 健康的 ，请你返回你可以获得的 最大分数 。

```js
/**
 * 计算在保证树健康的前提下能获得的最大分数
 * @param {number[][]} edges - 树的边集合，表示节点连接关系
 * @param {number[]} values - 每个节点的初始值
 * @return {number} 最大可能分数
 */
var maximumScoreAfterOperations = function (edges, values) {
  // 构建树的邻接表表示
  const n = edges.length + 1; // 节点总数
  const graph = Array.from({ length: n }, () => []);
  for (let [x, y] of edges) {
    graph[x].push(y), graph[y].push(x); // 无向图双向连接
  }

  /**
   * 深度优先搜索计算子树的最大分数
   * @param {number} i - 当前节点
   * @param {number} fa - 父节点(防止回溯)
   * @return {[number, number]} - 返回两个值：
   *   [0]: 不保证健康情况下子树的总和(全选)
   *   [1]: 保证健康情况下能获得的最大分数
   */
  const dfs = (i, fa) => {
    let isLeaf = true; // 标记是否为叶子节点
    let sumFull = 0,
      sumHealth = 0; // sumFull:全选总和, sumHealth:健康状态最大分数

    // 遍历所有相邻节点(子节点)
    for (let next of graph[i]) {
      if (next === fa) continue; // 跳过父节点
      let [full, health] = dfs(next, i); // 递归处理子节点
      isLeaf = false;
      sumFull += full; // 累加子节点的全选总和
      sumHealth += health; // 累加子节点的健康状态分数
    }

    // 叶子节点处理：必须不选(保证健康)，所以分数为0
    if (isLeaf) return [values[i], 0];

    // 非叶子节点返回：
    // [0]: 当前节点值 + 所有子节点全选总和
    // [1]: max(选当前节点 + 子节点健康分数, 不选当前节点 + 子节点全选总和)
    return [sumFull + values[i], Math.max(values[i] + sumHealth, sumFull)];
  };

  // 从根节点(0)开始DFS，返回健康状态下的最大分数
  return dfs(0, -1)[1];
};
```


#### [3068. 最大节点价值之和](https://leetcode.cn/problems/find-the-maximum-sum-of-node-values/description/)

给你一棵 n 个节点的 无向 树，节点从 0 到 n - 1 编号。树以长度为 n - 1 下标从 0 开始的二维整数数组 edges 的形式给你，其中 edges[i] = [ui, vi] 表示树中节点 ui 和 vi 之间有一条边。同时给你一个 正 整数 k 和一个长度为 n 下标从 0 开始的 非负 整数数组 nums ，其中 nums[i] 表示节点 i 的 价值 。

Alice 想 最大化 树中所有节点价值之和。为了实现这一目标，Alice 可以执行以下操作 任意 次（包括 0 次）：

- 选择连接节点 u 和 v 的边 [u, v] ，并将它们的值更新为：
  - nums[u] = nums[u] XOR k
  - nums[v] = nums[v] XOR k
请你返回 Alice 通过执行以上操作 任意次 后，可以得到所有节点 价值之和 的 最大值 。

**树形DP：状态转移难以理解**

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @param {number[][]} edges
 * @return {number}
 */
var maximumValueSum = function (nums, k, edges) {
    const n = nums.length;
    const graph = Array.from({ length: n }, () => []);
    for (let [x, y] of edges) {
        graph[x].push(y), graph[y].push(x);
    }

    const dfs = (i, fa) => {
        let f0 = 0, f1 = -Infinity;
        for (let next of graph[i]) {
            if (next === fa) continue;
            let [r0, r1] = dfs(next, i);

            let t = Math.max(f0 + r1, f1 + r0);

            f0 = Math.max(f0 + r0, f1 + r1);
            f1 = t
        }

        const x = nums[i], y = x ^ k;
        return [Math.max(f0 + x, f1 + y), Math.max(f0 + y, f1 + x)];
    }

    return dfs(0, -1)[0];
};
```


**贪心：优化**

1. 选择任意两个节点进行操作是正确的
  - 操作传递性：通过树结构的连通性，可以利用相邻边进行多次操作传递。例如：想要操作不相邻的节点A和C，
    - 可以通过路径A-B-C进行两次操作（A-B操作后接着B-C操作），最终等效于只对A和C进行异或操
  - 位运算特性：每个节点的异或次数只关心奇偶性，通过操作路径上的中间节点进行偶数次异或，最终可实现任意两个节点的独立操作效果。这使得实际可以自由选择要异或的节点，与树结构无关
2. 贪心
 - 因为可以选择任意两个节点进行操作，所以可以贪心的选择两个异或k后val都变大的节点，这样总体的sum变大
 - 如果树中异或k后val都变大的节点为偶数个，则可以两两配对
 - 如果树中异或k后val都变大的节点为奇数个, 则需要判断异或k后最小正差值和最大负差值的节点
    - 如果最小正差值和最大负差值的和大于0, 则操作这两个节点的总体贡献是正的,可以选择
    - 否则不选择操作这两个节点


```js
var maximumValueSum = function (nums, k, edges) {
    // 初始化累计和、有效异或次数、最小正贡献差、最大负贡献差
    let sum = 0, cnt = 0, 
        minPositiveDiff = Infinity, 
        maxNegativeDiff = -Infinity;

    for (let num of nums) {
        // 计算当前元素异或后的贡献差
        let diff = (num ^ k) - num;
        
        if (diff >= 0) { // 有正向贡献的情况
            sum += num ^ k;      // 累计异或后的值
            minPositiveDiff = Math.min(minPositiveDiff, diff); // 记录最小正向贡献差
            cnt++;               // 有效异或次数+1
        } else {        // 负向贡献的情况
            sum += num;           // 保持原值
            maxNegativeDiff = Math.max(maxNegativeDiff, diff); // 记录最大负向贡献差
        }
    }

    // 当有效异或次数为奇数时，需要调整一次操作
    if (cnt % 2) {
        // 选择损失最小的调整方式：要么撤回一个正向贡献，要么增加一个负向贡献
        sum += minPositiveDiff + maxNegativeDiff >= 0 
            ? maxNegativeDiff   // 增加一个负向贡献
            : -minPositiveDiff;  // 撤回最小的正向贡献
    }
    
    return sum;
};

```

**贪心：排序**

```js
/**
 * 计算通过对树中节点进行异或操作后，所有节点价值之和的最大值
 * @param {number[]} nums - 每个节点的初始价值数组
 * @param {number} k - 异或操作使用的常数
 * @param {number[][]} edges - 树的边集合，表示节点连接关系
 * @return {number} 所有节点价值之和的最大值
 */
var maximumValueSum = function(nums, k, edges) {
    // 计算所有节点初始价值的总和
    let ans = nums.reduce((a, b) => a + b, 0);
    // 计算每个节点异或 k 后的价值变化量，存储在 diffs 数组中
    const diffs = nums.map((i) => (i ^ k) - i);
    // 对价值变化量数组进行降序排序，优先处理变化量大的节点
    diffs.sort((a, b) => b - a);
    // 遍历 diffs 数组，每次取两个相邻的元素
    for (let i = 0; i < nums.length && diffs[i] + diffs[i + 1] > 0; i += 2) {
        // 如果两个相邻元素之和大于 0，说明对这两个节点进行异或操作能使总和增加
        ans += diffs[i] + diffs[i + 1];
    }

    return ans;
};

```

**状态机DP：**

1. 选择任意两个节点进行操作是正确的（同贪心）
2. 无论操作多少次，总是有偶数个元素异或了 k。理由如下：
  - 如果我们操作的两个数之前都没有异或过，那么操作后，异或 k 的元素增加了 2。
  - 如果我们操作的两个数之前都异或过，那么操作后，异或 k 的元素减少了 2。
  - 如果我们操作的两个数之前一个异或过，另一个没有异或过，那么操作后，异或 k 的元素加一减一，不变。

状态定义：
  - f[i][0]: 表示 nums的 0 - i 范围内，异或过 k 的节点数为偶数的最大价值
  - f[i][1]: 表示 nums的 0 - i 范围内，异或过 k 的节点数为奇数的最大价值

```js
/**
 * 计算通过对树中节点进行异或操作后，所有节点价值之和的最大值
 * @param {number[]} nums - 每个节点的初始价值数组
 * @param {number} k - 异或操作使用的常数
 * @param {number[][]} edges - 树的边集合，表示节点连接关系
 * @return {number} 所有节点价值之和的最大值
 */
var maximumValueSum = function(nums, k, edges) {
    // f[i][0] 表示在 nums 的 0 到 i 范围内，异或过 k 的节点数为偶数时的最大价值和
    // f[i][1] 表示在 nums 的 0 到 i 范围内，异或过 k 的节点数为奇数时的最大价值和
    // 初始化 f0 为第一个节点未异或 k 的值，对应异或次数为偶数的情况
    let f0 = nums[0];
    // 初始化 f1 为第一个节点异或 k 的值，对应异或次数为奇数的情况
    let f1 = nums[0] ^ k;

    // 从第二个节点开始遍历 nums 数组
    for (let i = 1; i < nums.length; i++) {
        // 当前节点未异或 k 的值
        const x = nums[i];
        // 当前节点异或 k 的值
        const y = nums[i] ^ k;
        // 计算异或 k 的节点数为奇数时的最大价值和的临时值
        // 情况1：前 i-1 个节点异或 k 的节点数为偶数，当前节点异或 k
        // 情况2：前 i-1 个节点异或 k 的节点数为奇数，当前节点不异或 k
        let t = Math.max(f0 + y, f1 + x);
        // 更新异或 k 的节点数为偶数时的最大价值和
        // 情况1：前 i-1 个节点异或 k 的节点数为偶数，当前节点不异或 k
        // 情况2：前 i-1 个节点异或 k 的节点数为奇数，当前节点异或 k
        f0 = Math.max(f0 + x, f1 + y);
        // 将临时值赋给 f1，更新异或 k 的节点数为奇数时的最大价值和
        f1 = t;
    }

    // 最终要求异或 k 的节点数为偶数，所以返回 f0
    return f0;
};

```

