### 12.3 树上最小支配集

#### [968. 监控二叉树](https://leetcode.cn/problems/binary-tree-cameras/description/)

给定一个二叉树，我们在树的节点上安装摄像头。

节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。

计算监控树的所有节点所需的最小摄像头数量。

```js
/**
 * @param {TreeNode} root
 * @return {number}
 */
/**
 * 计算监控二叉树的所有节点所需的最小摄像头数量。
 * @param {TreeNode} root - 二叉树的根节点
 * @return {number} - 最小摄像头数量
 */
var minCameraCover = function (root) {
    /**
     * 深度优先搜索函数，用于计算以当前节点为根的子树在不同状态下所需的最小摄像头数量。
     * @param {TreeNode} node - 当前遍历到的节点
     * @return {number[]} - 一个长度为 3 的数组，分别表示当前节点有摄像头、当前节点被父节点监控、当前节点被子节点监控时所需的最小摄像头数量
     */
    const dfs = (node) => {
        // 若当前节点为空，返回 [Infinity, 0, 0]
        // Infinity 表示空节点不能放置摄像头，0 表示空节点不需要被监控
        if (!node) return [Infinity, 0, 0];

        // 递归计算左子树在三种状态下所需的最小摄像头数量
        const [lHas, lByFa, lByChildren] = dfs(node.left);
        // 递归计算右子树在三种状态下所需的最小摄像头数量
        const [rHas, rByFa, rByChildren] = dfs(node.right);

        let byFa, has, byChildren;
        // 当前节点有摄像头的情况
        // 左右子树的三种状态取最小值相加，再加上当前节点的一个摄像头
        has = Math.min(lHas, lByFa, lByChildren) + Math.min(rHas, rByFa, rByChildren) + 1;
        // 当前节点被父节点监控的情况
        // 左右子树要么有摄像头，要么被子节点监控，取最小值相加
        byFa = Math.min(lHas, lByChildren) + Math.min(rHas, rByChildren);
        // 当前节点被子节点监控的情况
        // 左右子树至少有一个有摄像头，取三种可能情况的最小值
        byChildren = Math.min(lHas + rHas, lHas + rByChildren, lByChildren + rHas);

        return [has, byFa, byChildren];
    }

    // 对根节点进行深度优先搜索
    const [has, byFa, byChildren] = dfs(root);
    // 根节点没有父节点，所以只需考虑根节点有摄像头和被子节点监控这两种情况，取最小值
    return Math.min(has, byChildren);
};

```