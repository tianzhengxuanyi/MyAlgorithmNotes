### 0-1 背包

在有限的容量下选择物品，每个物品要么选要么不选，不能分割。

**转移方程：**

```js
dp[i][j] = Math.max(
  dp[i - 1][j], // 不选当前物品
  dp[i - 1][j - w] + v // 选当前物品（需满足 j >= w）
);
```

- 0-1 背包的空间优化写法要倒序遍历

#### 474. 一和零

给你一个二进制字符串数组 strs 和两个整数 m 和 n 。

请你找出并返回 strs 的最大子集的长度，该子集中 最多 有 m 个 0 和 n 个 1 。

如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。

**记忆化缓存**

```js
/**
 * @param {string[]} strs
 * @param {number} m
 * @param {number} n
 * @return {number}
 */
var findMaxForm = function (strs, m, n) {
  const len = strs.length;
  const cnt = Array(len);
  for (let i = 0; i < len; i++) {
    let c = 0;
    for (let s of strs[i]) {
      c += s - 0;
    }
    cnt[i] = [strs[i].length - c, c];
  }
  const dp = Array.from({ length: len }, () =>
    Array.from({ length: m + 1 }, () => Array(n + 1).fill(0))
  );
  for (i = len - 1; i >= 0; i--) {
    for (let j = 0; j <= m; j++) {
      for (let k = 0; k <= n; k++) {
        dp[i][j][k] = dp[i + 1]?.[j][k] ?? 0;
        if (j - cnt[i][0] >= 0 && k - cnt[i][1] >= 0) {
          dp[i][j][k] = Math.max(
            dp[i][j][k],
            (dp[i + 1]?.[j - cnt[i][0]]?.[k - cnt[i][1]] ?? 0) + 1
          );
        }
      }
    }
  }

  return dp[0][m][n];
};
```

**空间优化** 0-1 背包的空间优化写法要倒序遍历

```js
/**
 * @param {string[]} strs
 * @param {number} m
 * @param {number} n
 * @return {number}
 */
var findMaxForm = function (strs, m, n) {
  const len = strs.length;
  // 空间压缩后的DP数组：dp[j][k]表示用j个0和k个1能组成的最大子集
  const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));

  for (i = len - 1; i >= 0; i--) {
    // 统计cnt0/cnt1的代码不变
    let cnt1 = 0;
    for (let s of strs[i]) {
      cnt1 += s - 0;
    }
    let cnt0 = strs[i].length - cnt1;
    // 逆序更新实现空间压缩：通过复用二维数组避免三维数组存储
    // j从m到cnt0，k从n到cnt1，保证每个状态只被计算一次
    for (let j = m; j >= 0 && j - cnt0 >= 0; j--) {
      for (let k = n; k >= 0 && k - cnt1 >= 0; k--) {
        // 递推式含义：
        // max(不选当前元素保持原值, 选当前元素则取j-cnt0且k-cnt1时的值+1)
        dp[j][k] = Math.max(
          dp[j][k],
          (i === len - 1 ? 0 : dp[j - cnt0][k - cnt1]) + 1
        );
      }
    }
  }

  return dp[m][n];
};
```
