### 1. 拓扑排序

#### [定义](https://blog.csdn.net/lisonglisonglisong/article/details/45543451)

在图论中，拓扑排序（Topological Sorting）是一个有向无环图（DAG, Directed Acyclic Graph）的所有顶点的线性序列。且该序列必须满足下面两个条件：

- 每个顶点出现且只出现一次。
- 若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面。
  有向无环图（DAG）才有拓扑排序，非 DAG 图没有拓扑排序一说。

#### [算法思路](https://leetcode.cn/problems/course-schedule-ii/solutions/249149/ke-cheng-biao-ii-by-leetcode-solution/)

**方法一：深度优先搜索**

对于图中的任意一个节点，它在搜索的过程中有三种状态，即：

- 「未搜索」：我们还没有搜索到这个节点；

- 「搜索中」：我们搜索过这个节点，但还没有回溯到该节点，即该节点还没有入栈，还有相邻的节点没有搜索完成）；

- 「已完成」：我们搜索过并且回溯过这个节点，即该节点已经入栈，并且所有该节点的相邻节点都出现在栈的更底部的位置，满足拓扑排序的要求。

通过上述的三种状态，我们就可以给出使用深度优先搜索得到拓扑排序的算法流程，在每一轮的搜索搜索开始时，我们任取一个「未搜索」的节点开始进行深度优先搜索。

- 我们将当前搜索的节点 u 标记为「搜索中」，遍历该节点的每一个相邻节点 v：

  - 如果 v 为「未搜索」，那么我们开始搜索 v，待搜索完成回溯到 u；

  - 如果 v 为「搜索中」，那么我们就找到了图中的一个**环**，因此是不存在拓扑排序的；

  - 如果 v 为「已完成」，那么说明 v 已经在栈中了，而 u 还不在栈中，因此 u 无论何时入栈都不会影响到 (u,v) 之前的拓扑关系，以及不用进行任何操作。

- 当 u 的所有相邻节点都为「已完成」时，我们将 u 放入栈中，并将其标记为「已完成」。

在整个深度优先搜索的过程结束后，如果我们没有找到图中的环，那么栈中存储这所有的 n 个节点，从栈顶到栈底的顺序即为一种拓扑排序。

**方法二：广度优先搜索**

我们使用一个队列来进行广度优先搜索。开始时，所有入度为 0 的节点都被放入队列中，它们就是可以作为拓扑排序最前面的节点，并且它们之间的相对顺序是无关紧要的。

在广度优先搜索的每一步中，我们取出队首的节点 u：

- 我们将 u 放入答案中；

- 我们移除 u 的所有出边，也就是将 u 的所有相邻节点的入度减少 1。如果某个相邻节点 v 的入度变为 0，那么我们就将 v 放入队列中。

在广度优先搜索的过程结束后。如果答案中**包含了这 n 个节点**，那么我们就找到了一种拓扑排序，否则说明图中存在**环**，也就不存在拓扑排序了。

#### [210. 课程表 II](https://leetcode.cn/problems/course-schedule-ii/description/)

现在你总共有 numCourses 门课需要选，记为 0 到 numCourses - 1。给你一个数组 prerequisites ，其中 prerequisites[i] = [ai, bi] ，表示在选修课程 ai 前 必须 先选修 bi 。

例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示：[0,1] 。
返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 任意一种 就可以了。如果不可能完成所有课程，返回 一个空数组 。

**DFS**

```js
/**
 * @param {number} numCourses
 * @param {number[][]} prerequisites
 * @return {number[]}
 */
var findOrder = function (numCourses, prerequisites) {
  // 构建邻接表图结构（课程依赖关系）
  const graph = Array.from({ length: numCourses }, () => []);
  for (let [x, y] of prerequisites) {
    graph[y].push(x); // y 是 x 的先修课程
  }

  // 访问状态数组：-1未访问，0访问中（用于检测环），1已访问
  const visited = Array(numCourses).fill(-1);
  const ans = Array(numCourses); // 存储最终课程顺序
  let index = numCourses - 1; // 从后往前填充结果

  const dfs = (i) => {
    visited[i] = 0; // 标记为正在访问
    for (let next of graph[i]) {
      if (visited[next] === -1) {
        if (dfs(next)) {
          // 递归访问未访问节点
          return true; // 发现环立即返回
        }
      } else if (visited[next] === 0) {
        return true; // 遇到正在访问的节点（存在环）
      }
    }
    visited[i] = 1; // 标记为已完成访问
    ans[index--] = i; // 后序遍历位置记录课程（拓扑排序）
  };

  // 遍历所有课程，处理未连接的子图
  for (let i = 0; i < numCourses; i++) {
    if (visited[i] < 0 && dfs(i)) {
      return []; // 发现环返回空数组
    }
  }

  return ans; // 返回拓扑排序结果
};
```

**BFS**

```js
/**
 * @param {number} numCourses 课程总数
 * @param {number[][]} prerequisites 先修课程列表，格式为[[课程, 前置课程],...]
 * @return {number[]} 合法的学习顺序数组
 */
var findOrder = function (numCourses, prerequisites) {
  // 初始化入度数组（记录每个课程的先修课程数量）
  const degree = Array(numCourses).fill(0);
  // 构建邻接表（记录每个课程的后续课程）
  const graph = Array.from({ length: numCourses }, () => []);

  // 构建图结构
  for (let [x, y] of prerequisites) {
    degree[x] += 1; // 目标课程入度+1
    graph[y].push(x); // 源课程添加后续课程
  }

  const ans = []; // 结果数组
  const q = []; // 处理队列

  // 初始化队列，添加入度为0的课程
  for (let i = 0; i < numCourses; i++) {
    if (degree[i] === 0) {
      q.push(i);
    }
  }

  // 拓扑排序处理
  while (q.length) {
    let current = q.pop(); // 取出当前课程
    ans.push(current);

    // 处理所有后续课程
    for (let next of graph[current]) {
      degree[next] -= 1; // 减少后续课程的入度
      if (degree[next] === 0) {
        q.push(next); // 当后续课程入度为0时加入队列
      }
    }
  }

  // 判断是否可以完成所有课程（是否存在环）
  return ans.length === numCourses ? ans : [];
};
```

#### [310. 最小高度树](https://leetcode.cn/problems/minimum-height-trees/description/)

树是一个无向图，其中任何两个顶点只通过一条路径连接。 换句话说，任何一个没有简单环路的连通图都是一棵树。

给你一棵包含 n 个节点的树，标记为 0 到 n - 1 。给定数字 n 和一个有 n - 1 条无向边的 edges 列表（每一个边都是一对标签），其中 edges[i] = [ai, bi] 表示树中节点 ai 和 bi 之间存在一条无向边。

可选择树中任何一个节点作为根。当选择节点 x 作为根节点时，设结果树的高度为 h 。在所有可能的树中，具有最小高度的树（即，min(h)）被称为 最小高度树 。

请你找到所有的 最小高度树 并按 任意顺序 返回它们的根节点标签列表。

树的 高度 是指根节点和叶子节点之间最长向下路径上边的数量。

**1、拓扑排序**

> 首先，在节点大于 2 个的时候，最小树的根节点一定不在叶子节点；
>
> 其次，在节点小于等于 2 的时候，最小树的根节点可以是任意一个节点；
>
> 第三，在一个大于 3 个节点的树中，砍掉所有的叶子节点，那么最小树的根节点一定不变，只是新树的高度比原来减少了 1；
>
> 然后就是循环砍叶子节点，树高度循环减少 1，最终剩下 2 个或 1 个节点，这个时候就是原来树的最小树节点。

```js
/**
 * @param {number} n 节点总数
 * @param {number[][]} edges 边的连接数组
 * @return {number[]} 返回最小高度树的根节点集合
 */
var findMinHeightTrees = function (n, edges) {
  if (n === 1) return [0]; // 只有一个节点的特殊情况

  // 初始化邻接表和入度数组
  const graph = Array.from({ length: n }, () => []);
  const inDegree = Array(n).fill(0);

  // 构建图结构并统计入度
  for (let [x, y] of edges) {
    graph[x].push(y), graph[y].push(x); // 无向图的邻接表
    (inDegree[x] += 1), (inDegree[y] += 1); // 每个节点的连接数
  }

  // 初始化叶子节点队列（入度为1的节点）
  const q = [];
  for (let i = 0; i < n; i++) {
    if (inDegree[i] === 1) {
      q.push(i);
    }
  }

  let remindNum = n; // 剩余节点数

  // 拓扑排序：逐层剥离叶子节点
  while (remindNum > 2) {
    let currLen = q.length;
    remindNum -= currLen; // 更新剩余节点数

    // 处理当前层所有叶子节点
    for (let i = 0; i < currLen; i++) {
      let curr = q.shift();

      // 更新相邻节点的入度
      for (let next of graph[curr]) {
        inDegree[next] -= 1;
        // 当相邻节点成为新叶子节点时入队
        if (inDegree[next] === 1) {
          q.push(next);
        }
      }
    }
  }

  // 最后剩下的1或2个节点即为结果
  return q;
};
```

### 2. 在拓扑序上 DP

#### [2050. 并行课程 III](https://leetcode.cn/problems/parallel-courses-iii/description/)

给你一个整数 n ，表示有 n 节课，课程编号从 1 到 n 。同时给你一个二维整数数组 relations ，其中 relations[j] = [prevCoursej, nextCoursej] ，表示课程 prevCoursej 必须在课程 nextCoursej 之前 完成（先修课的关系）。同时给你一个下标从 0 开始的整数数组 time ，其中 time[i] 表示完成第 (i+1) 门课程需要花费的 月份 数。

请你根据以下规则算出完成所有课程所需要的 最少 月份数：

- 如果一门课的所有先修课都已经完成，你可以在 任意 时间开始这门课程。
- 你可以 同时 上 任意门课程 。
  请你返回完成所有课程所需要的 最少 月份数。

注意：测试数据保证一定可以完成所有课程（也就是先修课的关系构成一个有向无环图）。

**题解：**

> 定义 f[i] 表示完成第 i 门课程需要花费的最少月份数。根据题意，只有当 i 的所有先修课程都完成时，才可以开始学习第 i 门课程，并且可以立即开始。
>
> 因此`f[i]=time[i]+ max_j(f[j])`, 其中 j 是 i 的先修课程。
>
> 由于题目保证图是一个有向无环图，所以一定存在拓扑序。我们可以在计算拓扑序的同时，计算**状态转移**。
>
> 具体来说，设当前节点为 x，我们可以在计算出 f[x] 后，更新 y 的所有先修课程耗时的最大值，这里 x 是 y 的先修课程。
>
> 答案就是所有 f[i] 的最大值。

### 3. 基环树

#### 一、基环树概念

标准定义是：具有**N 个点 N 条边的连通图**。

如果不保证联通，它就会成为基环树森林。

![基环树](../../image/基环树.png)

如果把中间的环断开任意一条边，它就会成为一棵树，如果我们把这个环全部断掉，就会成为一个森林。

#### 二、内向树和外向树

内向树和外向树构成类似基环树的有向连通图。

内向树中**每个点有且只有一条出边**。

外向树中**每个点有且只有一条入边**。

比如上面的基环树，变成内向树就是：

![内向基环树](../../image/内向基环树.png)

外向树：

![外向基环树](../../image/外向基环树.png)

#### [2127. 参加会议的最多员工数](https://leetcode.cn/problems/maximum-employees-to-be-invited-to-a-meeting/description/)

一个公司准备组织一场会议，邀请名单上有 n 位员工。公司准备了一张 圆形 的桌子，可以坐下 任意数目 的员工。

员工编号为 0 到 n - 1 。每位员工都有一位 喜欢 的员工，每位员工 当且仅当 他被安排在喜欢员工的旁边，他才会参加会议。每位员工喜欢的员工 不会 是他自己。

给你一个下标从 0 开始的整数数组 favorite ，其中 favorite[i] 表示第 i 位员工喜欢的员工。请你返回参加会议的 最多员工数目 。

**题解** [内向基环树：拓扑排序 + 分类讨论](https://leetcode.cn/problems/maximum-employees-to-be-invited-to-a-meeting/solutions/1187830/nei-xiang-ji-huan-shu-tuo-bu-pai-xu-fen-c1i1b/)
