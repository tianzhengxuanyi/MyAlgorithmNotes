### 单源最短路：Dijkstra 算法

[**基本思想**](https://blog.csdn.net/qq_41040550/article/details/107029809)：

- 一个顶点属于集合 S，当且仅当从源到该顶点的最短路径长度已知。
- 设置顶点集合 S，并不断地作贪心选择来扩充这个集合。
- 贪心策略：每次都从 V-S 中找出具有最短特殊路长的顶点 u 加入 S。

**算法思路**：

1. 初始时，S 中仅含有源点。
2. 设 u 是 G 的某一个顶点，把从源点到 u 且中间只经过 S 中顶点的路称为从源点到 u 的特殊路径，并用数组 dist 记录当前每个顶点所对应的最短特殊路径长度。
3. Dijkstra 算法每次从 V-S 中取出具有最短特殊路长度的顶点 u，将 u 添加到 S 中，同时对数组 dist 作必要的修改。
4. 一旦 S 包含了 V 中所有顶点，dist 就记录了从源到其它所有顶点之间的最短路径长度。

![dijkstra示例](../../image/dijkstra算法示例.png)

#### [743. 网络延迟时间](https://leetcode.cn/problems/network-delay-time/description/)

给你一个列表 times，表示信号经过 有向 边的传递时间。 times[i] = (ui, vi, wi)，其中 ui 是源节点，vi 是目标节点， wi 是一个信号从源节点传递到目标节点的时间。

现在，从某个节点 K 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 -1 。

[**两种 Dijkstra 写法（附题单）**](https://leetcode.cn/problems/network-delay-time/solutions/2668220/liang-chong-dijkstra-xie-fa-fu-ti-dan-py-ooe8/)

**写法一：朴素 Dijkstra** （适用于稠密图）

> 稠密图：边的数量级和 n ^ 2 相当的图。

```js
/**
 * 计算网络信号从节点k传播到所有其他节点所需的最短时间
 * @param {number[][]} times 边列表，每个元素格式为 [源节点, 目标节点, 传播时间]
 * @param {number} n 网络中的节点总数
 * @param {number} k 信号起始节点
 * @return {number} 信号传播到所有节点的最长时间，如果无法到达所有节点则返回-1
 */
var networkDelayTime = function (times, n, k) {
  // 初始化邻接矩阵，默认值为Infinity表示不可达
  const graph = Array.from({ length: n }, () => Array(n).fill(Infinity));
  // 构建图的邻接矩阵表示
  for (let [u, v, w] of times) {
    graph[u - 1][v - 1] = w; // 节点编号转为0-based索引
  }

  // dist数组记录从起点k到各节点的最短距离
  const dist = Array(n).fill(Infinity);
  // done数组标记节点是否已确定最短路径
  const done = Array(n).fill(false);
  dist[k - 1] = 0; // 起点到自身的距离为0

  while (true) {
    // 找出当前未处理节点中距离起点最近的节点x
    let x = -1;
    for (let i = 0; i < n; i++) {
      if (!done[i] && (x < 0 || dist[i] < dist[x])) {
        x = i;
      }
    }

    // 所有节点都已处理，返回最大距离
    if (x == -1) return Math.max(...dist);
    // 存在不可达节点，返回-1
    if (dist[x] === Infinity) return -1;

    done[x] = true; // 标记节点x为已处理
    // 松弛操作：更新x的邻居节点的最短距离
    for (let y = 0; y < n; y++) {
      dist[y] = Math.min(dist[y], dist[x] + graph[x][y]);
    }
  }
};
```

**写法二：堆优化 Dijkstra**（适用于稀疏图）

> 稀疏图：边的数量远小于 n ^ 2 的图。

```js
/**
 * 计算网络信号从节点k传播到所有节点所需的最短时间
 * @param {number[][]} times - 网络连接信息数组，格式为[u, v, w]表示从u到v需要w时间
 * @param {number} n - 网络中的节点总数
 * @param {number} k - 信号起始节点
 * @return {number} - 返回信号传播到所有节点的最短时间，如果无法到达所有节点则返回-1
 */
var networkDelayTime = function (times, n, k) {
  // 初始化邻接表表示的图结构
  const graph = Array.from({ length: n }, () => []);

  // 构建图的邻接表表示
  for (let [u, v, w] of times) {
    graph[u - 1].push([v - 1, w]); // 节点编号转为0-based
  }

  // 初始化距离数组，所有节点初始距离为无穷大
  const dist = Array(n).fill(Infinity);
  // 创建最小优先队列，按距离排序
  const queue = new MinPriorityQueue((p) => p[1]);
  // 将起始节点加入队列，距离设为0
  queue.enqueue([k - 1, 0]);
  dist[k - 1] = 0;

  // Dijkstra算法主循环
  while (!queue.isEmpty()) {
    let [x, dx] = queue.dequeue();
    // 如果当前距离大于已知最短距离，跳过
    if (dx > dist[x]) {
      continue;
    }

    // 遍历当前节点的所有邻居
    for (let [y, w] of graph[x]) {
      let newDis = dx + w;
      // 如果找到更短的路径，更新距离并加入队列
      if (newDis < dist[y]) {
        dist[y] = newDis;
        queue.enqueue([y, dist[y]]);
      }
    }
  }

  // 找出所有节点中的最大距离
  let ans = Math.max(...dist);

  // 如果所有节点都可达则返回最大距离，否则返回-1
  return ans < Infinity ? ans : -1;
};
```

#### [778. 水位上升的泳池中游泳](https://leetcode.cn/problems/swim-in-rising-water/)

在一个 n x n 的整数矩阵 grid 中，每一个方格的值 grid[i][j] 表示位置 (i, j) 的平台高度。

当开始下雨时，在时间为 t 时，水池中的水位为 t 。你可以从一个平台游向四周相邻的任意一个平台，但是前提是此时水位必须同时淹没这两个平台。假定你可以瞬间移动无限距离，也就是默认在方格内部游动是不耗时的。当然，在你游泳的时候你必须待在坐标方格里面。

你从坐标方格的左上平台 (0，0) 出发。返回 你到达坐标方格的右下平台 (n-1, n-1) 所需的最少时间 。

##### Dijkstra

```js
/**
 * 功能：计算从网格左上角(0,0)游泳到右下角(n-1,n-1)所需的最小最大水位值
 * 参数：
 *   grid - 二维数字数组，表示每个格子的水位高度
 * 返回：整数，表示所需的最小最大水位值
 * 算法核心思想：使用优先队列（最小堆）实现的Dijkstra算法变种，每次选择当前已知的最小最大水位路径进行扩展
 * 时间复杂度：O(n² log n)，其中n是网格的边长，优先队列操作的复杂度为O(log (n²)) = O(2 log n) = O(log n)
 * 空间复杂度：O(n²)，用于存储距离数组和优先队列
 */
var swimInWater = function (grid) {
  const n = grid.length; // 网格的边长
  // dist[i][j]表示从起点(0,0)到达(i,j)所需的最小最大水位值，初始化为无穷大
  const dist = Array.from({ length: n }, () => Array(n).fill(Infinity));
  // 创建最小优先队列，按照水位值排序
  const q = new MinPriorityQueue((q) => q[0]);
  // 将起点加入队列，初始水位为起点的水位值
  q.enqueue([grid[0][0], 0, 0]);
  // 设置起点的最小最大水位值
  dist[0][0] = grid[0][0];

  // 当队列不为空时，持续处理
  while (!q.isEmpty()) {
    // 取出当前最小水位的位置
    let [t, i, j] = q.dequeue();
    // 如果到达终点，直接返回当前水位值
    if (i == n - 1 && j == n - 1) return t;

    // 如果当前路径的水位值大于已知到达该点的最小水位值，跳过该路径
    if (t > dist[i][j]) continue;

    // 探索四个方向的相邻格子
    for (let [di, dj] of d) {
      let ni = i + di,
        nj = j + dj; // 计算相邻格子的坐标
      // 检查相邻格子是否在网格范围内
      if (ni >= 0 && ni < n && nj >= 0 && nj < n) {
        // 计算经过当前格子到达相邻格子所需的最大水位值
        let nt = Math.max(t, grid[ni][nj]);
        // 如果找到更小的最大水位值，更新并加入队列
        if (nt < dist[ni][nj]) {
          q.enqueue([nt, ni, nj]);
          dist[ni][nj] = nt;
        }
      }
    }
  }
};

// 定义四个方向的移动向量：下、上、右、左
const d = [
  [1, 0],
  [-1, 0],
  [0, 1],
  [0, -1],
];
```

##### BFS

```js
/**
 * 功能：计算从网格左上角(0,0)游泳到右下角(n-1,n-1)所需的最小最大水位值
 * 参数：
 *   grid - 二维数字数组，表示每个格子的水位高度
 * 返回：整数，表示所需的最小最大水位值
 * 算法核心思想：使用广度优先搜索(BFS)变种，通过记录每个格子的最小最大水位值来避免重复计算
 * 时间复杂度：O(n²)，其中n是网格的边长，每个格子最多被访问一次
 * 空间复杂度：O(n²)，用于存储访问状态数组和队列
 */
var swimInWater = function (grid) {
  const n = grid.length;  // 网格的边长
  // visited[i][j]记录从起点(0,0)到达(i,j)所需的最小最大水位值，初始化为无穷大
  const visited = Array.from({ length: n }, () => Array(n).fill(Infinity));
  // 创建队列用于BFS遍历，初始元素为[起点水位, 行索引, 列索引]
  const q = [[grid[0][0], 0, 0]];
  // 设置起点的最小最大水位值
  visited[0][0] = grid[0][0];
  // 初始化结果为无穷大，用于记录到达终点的最小最大水位值
  let ans = Infinity;
  
  // BFS主循环，当队列不为空时持续处理
  while (q.length) {
    // 从队列头部取出当前格子信息
    let [t, i, j] = q.shift();
    // 如果到达终点，更新最小最大水位值
    if (i == n - 1 && j == n - 1) {
      ans = Math.min(ans, t);
    }
    
    // 探索四个方向的相邻格子
    for (let [di, dj] of d) {
      let ni = di + i, nj = dj + j;  // 计算相邻格子的坐标
      // 检查相邻格子是否在网格范围内，并且当前路径的水位值小于已知到达该相邻格子的最小水位值
      if (ni >= 0 && ni < n && nj >= 0 && nj < n && t < visited[ni][nj]) {
        // 计算到达相邻格子所需的最大水位值
        visited[ni][nj] = Math.max(t, grid[ni][nj]);
        // 将相邻格子及其最大水位值加入队列，继续BFS
        q.push([visited[ni][nj], ni, nj]);
      }
    }
  }
  
  // 返回到达终点所需的最小最大水位值
  return ans;
};

// 定义四个方向的移动向量：下、上、右、左
const d = [
  [1, 0],  // 向下移动
  [-1, 0], // 向上移动
  [0, 1],  // 向右移动
  [0, -1], // 向左移动
];

```

##### 二分

visited 用 mid 表示当前的访问状态

```js
/**
 * 功能：计算从网格左上角(0,0)游泳到右下角(n-1,n-1)所需的最小最大水位值
 * 参数：
 *   grid - 二维数字数组，表示每个格子的水位高度
 * 返回：整数，表示所需的最小最大水位值
 * 算法核心思想：使用二分查找确定可能的水位范围，结合DFS检查在特定水位下是否存在可行路径
 * 时间复杂度：O(n² log n)，其中n是网格的边长，二分查找的次数为log(n²)，每次DFS的时间复杂度为O(n²)
 * 空间复杂度：O(n²)，用于存储访问状态数组和递归调用栈
 */
var swimInWater = function (grid) {
  const n = grid.length;  // 网格的边长
  // 初始化二分查找的左右边界
  // 左边界为起点和终点中的较大值（至少需要这么高才能开始和结束）
  // 右边界为网格可能的最大水位值(n*n)
  let l = Math.max(grid[n - 1][n - 1], grid[0][0]),
    r = n * n;
  // visited数组用于记录每个格子是否在特定水位下被访问过
  // 用当前检查的水位值m作为标记，避免每次都重新初始化数组
  const visited = Array.from({ length: n }, () => Array(n).fill(-1));
  
  /**
   * DFS函数：检查在给定水位值m下，是否能从(i,j)到达终点
   * @param {number} i - 当前行索引
   * @param {number} j - 当前列索引
   * @param {number} m - 当前检查的水位值
   * @return {boolean} - 是否能到达终点
   */
  const dfs = (i, j, m) => {
    // 基本情况：如果到达终点，返回true
    if (i == n - 1 && j == n - 1) return true;
    // 标记当前格子在水位值m下已被访问
    visited[i][j] = m;
    // 探索四个方向的相邻格子
    for (let [di, dj] of d) {
      let ni = i + di, nj = j + dj;
      // 检查相邻格子是否在网格范围内，是否未访问过，水位是否不超过m，并且从相邻格子可以到达终点
      if (
        ni >= 0 &&
        ni < n &&
        nj >= 0 &&
        nj < n &&
        visited[ni][nj] != m &&
        grid[ni][nj] <= m &&
        dfs(ni, nj, m)
      ) {
        return true;
      }
    }
    // 四个方向都无法到达终点，返回false
    return false;
  };
  
  /**
   * 检查函数：封装DFS调用，从起点开始检查在水位m下是否能到达终点
   * @param {number} m - 要检查的水位值
   * @return {boolean} - 是否能到达终点
   */
  const check = (m) => {
    return dfs(0, 0, m);
  };

  // 二分查找主循环
  while (l <= r) {
    // 计算中间水位值
    let m = Math.floor((r - l) / 2) + l;
    // 检查在水位m下是否能到达终点
    if (!check(m)) {
      // 如果不能，则最小水位值在右半部分
      l = m + 1;
    } else {
      // 如果能，则尝试寻找更小的可行水位值
      r = m - 1;
    }
  }

  // 返回最小的可行水位值
  return l;
};

// 定义四个方向的移动向量：下、上、右、左
const d = [
  [1, 0],  // 向下移动
  [-1, 0], // 向上移动
  [0, 1],  // 向右移动
  [0, -1], // 向左移动
];

```

### 多源最短路：Floyd 算法

**[带你发明 Floyd 算法：从记忆化搜索到递推](https://leetcode.cn/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/solutions/2525946/dai-ni-fa-ming-floyd-suan-fa-cong-ji-yi-m8s51/)**

```js
/**
 * 使用Floyd算法实现多源最短路径计算
 * @param {number} n - 图中节点的数量
 * @param {number[][]} graph - 图 graph[i][j] 表示节点 i 到节点 j 的边权, 不存在边则为 Infinity
 * @return {number[][]} - 返回一个二维数组，其中 res[i][j] 表示节点 i 到节点 j 的最短路径长度
 */
var Floyd = function (n, graph) {
  // Floyd算法核心：动态规划更新所有节点间的最短路径
  for (let k = 0; k < n; k++) {
    // 中间节点k
    for (let i = 0; i < n; i++) {
      // 起点i
      if (graph[i][k] === Infinity) continue; // 优化：i到k不可达则跳过
      for (let j = 0; j < n; j++) {
        // 终点j
        graph[i][j] = Math.min(
          graph[i][j],
          graph[i][k] + graph[k][j] // 检查通过k中转是否更短
        );
      }
    }
  }

  return graph;
};
```

#### [2642. 设计可以求最短路径的图类](https://leetcode.cn/problems/design-graph-with-shortest-path-calculator/description/)

给你一个有 n 个节点的 有向带权 图，节点编号为 0 到 n - 1 。图中的初始边用数组 edges 表示，其中 edges[i] = [fromi, toi, edgeCosti] 表示从 fromi 到 toi 有一条代价为 edgeCosti 的边。

请你实现一个 Graph 类：

Graph(int n, int[][] edges) 初始化图有 n 个节点，并输入初始边。
addEdge(int[] edge) 向边集中添加一条边，其中 edge = [from, to, edgeCost] 。数据保证添加这条边之前对应的两个节点之间没有有向边。
int shortestPath(int node1, int node2) 返回从节点 node1 到 node2 的路径 最小 代价。如果路径不存在，返回 -1 。一条路径的代价是路径中所有边代价之和。

```js
/**
 * 图类，使用Floyd算法实现多源最短路径计算
 * @param {number} n - 图中节点的数量
 * @param {number[][]} edges - 图的边集合，每个元素格式为[起点, 终点, 权重]
 */
var Graph = function (n, edges) {
  // 初始化邻接矩阵，所有节点间距离默认为Infinity(不可达)
  this.graph = Array.from({ length: n }, () => Array(n).fill(Infinity));

  // 节点到自身的距离为0
  for (let i = 0; i < n; i++) {
    this.graph[i][i] = 0;
  }

  // 填充初始边权重
  for (let [x, y, w] of edges) {
    this.graph[x][y] = w;
  }

  // Floyd算法核心：动态规划更新所有节点间的最短路径
  for (let k = 0; k < n; k++) {
    // 中间节点k
    for (let i = 0; i < n; i++) {
      // 起点i
      if (this.graph[i][k] === Infinity) continue; // 优化：i到k不可达则跳过
      for (let j = 0; j < n; j++) {
        // 终点j
        this.graph[i][j] = Math.min(
          this.graph[i][j],
          this.graph[i][k] + this.graph[k][j] // 检查通过k中转是否更短
        );
      }
    }
  }
};

/**
 * 添加新边并更新最短路径
 * @param {number[]} edge - 新边，格式为[起点, 终点, 权重]
 */
Graph.prototype.addEdge = function (edge) {
  let [x, y, w] = edge;
  let n = this.graph.length;

  // 只有新边的权重比现有值更小时才需要更新
  if (w < this.graph[x][y]) {
    this.graph[x][y] = w;

    // 更新所有可能受影响的路径(i->x->y->j)
    for (let i = 0; i < n; i++) {
      for (let j = 0; j < n; j++) {
        this.graph[i][j] = Math.min(
          this.graph[i][j],
          this.graph[i][x] + w + this.graph[y][j]
        );
      }
    }
  }
};

/**
 * 查询两个节点间的最短路径
 * @param {number} node1 - 起点
 * @param {number} node2 - 终点
 * @return {number} 最短路径长度，不可达返回-1
 */
Graph.prototype.shortestPath = function (node1, node2) {
  return this.graph[node1][node2] < Infinity ? this.graph[node1][node2] : -1;
};
```
