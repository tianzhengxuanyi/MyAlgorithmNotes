## page 1
各位领导和导师下午好，我是谢飞，现在开始我的试用期转正汇报。

## page 2
我将从以下三个方面展开我的汇报。
## page 3
首先是试用期工作总结。我将针对试用期的目标来进行具体阐述。
## page 4
1.工作成果的总结，在试用期这三个月里，我参与了IOT规则引擎（新）V1.0 和V1.1版本、带球黑灯工程管控平台
## page 5
IoT规则引擎是一个PaaS层的制造业设备监测和分析服务，该系统能够自动进行数据预警，并基于业务规则生成数据预警资产库，为智慧运营项目和金恒大集控类项目提供支持。
在旧版的基础上，新版开发的主要目的在于简化配置流程、降低用户操作难度，同时提升配置的灵活性和拓展性。
IOT规则引擎用可视化的配置方式，高度抽象公共规则，实现规则配置化，降低各领域的开发难度和代码冗余。为各个行业提供数据处理的计算引擎和规则引擎。
通过项目的参与，对规则引擎的整体业务流程有所了解，并熟悉公司所使用的前端框架和代码风格。同时也学习到前端常用的拖动方案，做到学习工作一体。

## page 6
接下来我将介绍我所完成的模块及功能点。
首先是算子注册模块。允许用户注册和使用计算、查询、消息等类型算子（操作节点）的功能。这些算子通常用于执行特定的数学运算、逻辑运算或其他类型的计算任务。算子注册功能的主要目的是提供一个灵活的、可扩展的方法来处理各种计算需求。
主要的功能点如下：
1. 左侧的算子分组管理；
2. 算子列表展示、搜索、新增、查看、删除；
3. 算子基本信息的编辑和展示；
4. 图标上传组件的改造；
    1. 问题：
        用户进行上传或删除图标操作后，此时如果用户直接关闭页面，对图标文件的操作无法撤回。用户可能会产生困惑：我没有保存，为什么图标上传了？
    2. 解决方案：
        将图片的上传的操作与表单提交绑定，统一整个页面的提交逻辑。改造图片上传组件暴露出submit方法，用户只对组件的fileList操作，当保存时再上传图标并提交表单。

## page 7
5. 算子属性/出入参表格表单的动态校验；
    - 问题：
        算子属性和出入参允许用户在表格中直接添加和修改字段，保存时需要校验规则，静态的校验方案需要在保存时遍历表格内容进行判断，然后修改标识符给出提示，不能实时提示用户的输入是否合法。
    - 解决方案：
        用表格的行标为el-form-item动态绑定prop参数实现输入框的动态校验，并将错误提示改为message提示，保证了表格的行高不会被错误提示突然撑开。
6. 算子属性行间的拖动排序；
   - 问题：
        算子属性允许用户自定义排序，使用拖动改变排序便捷且直观，但是element-ui不支持表格中行的拖动。
   - 解决方案：
        使用sortable.js实现列表行与行之间的拖动交换排序，并判断拖动是否合法，禁止不同层级交换排序。

7. 代码优化
   - vue2选项式API改造成vue3 setup组合式API风格；
   - 将Mixin改为组合式函数使用；
        之前代码中包含Mixin导致难以将代码升级成vue3。将Mixin改为组合式函数，数据来源清晰，同时避免函数和变量重名现象。
   - 编辑页面组件的抽离；
        算子注册和编辑页面代码量过大，将基本信息、属性、出入参抽离封装成组件，减少文件代码量，并使用eventBus进行组件通讯，便于后期维护。
## page 8
涉及的第二个模块为规则流，主要设计和配置规则执行流。具体包含规则详情、规则权限、保存并设计画布等，最终会生成可执行的EL表达式。
我所完成的主要功能点如下：
1. 规则列表的展示；
2. 规则复制；
3. 执行报警结果展示；
4. 任务执行记录展示；
5. 规则点位的历史追踪；
## page 9
6. CRON表达式生成组件；
   - 问题：
        用户可以选择时间频率和cron表达式两种模式定时触发规则。部分用户可能不了解cron表单表达式的规则和作用，所以需要内置cron表达式生成。
   - 解决方案：
        对开源库进行改造，添加cron表达式的反解析、展示最近5条执行时间、常用表达式示例、结果自动填入表单，降低用户配置cron表达式的操作难度。
7. 算子的分组展示；
8. 代码生成组件;
     使用vue3 draggable.next插件实现参数、常数和运算符的拖拽，并用不同颜色进行区分。实时对拖动生成的公式解析和展示，保存时对生成的公式进行合法性校验。

## page 10
第三个模块为过程点位，管理提供给规则流使用的过程点位信息。
1. 过程点位列表展示和搜索；
2. 导出模版和导入编码；
3. 过程点位编辑；
4. 过程点位的数据流向；
    过程点位可能来源于多个原始点位，所有使用leader-line绘制指引线，图形化展示数据流向，清晰明了地告知用户过程点位的来源。

## page 11
IOT规则引擎（新）V1.1在V1.0基础进行了进一步优化，并针对用户提出的建议做出修改。

## page 12
首先是算子注册页面的优化。算子禁用会导致正在使用的规则异常，所以添加警告提示用户正在使用的当前算子的规则。

## page 13
其他主要是规则流模块的优化。
1. 规则列表添加规则状态展示；
2. 规则的历史版本展示和回退；
3. 规则详情表单的展开和收起；让用户可以更清楚的预览画布；
4. 流程节点的修改：
    - 连接线变成动态；增加流程感
    - 推送中间件的展示；
    - 入参移入显示名称；
    - 默认上级出参为下级节点入参；
    - 删除节点自动删除后续所有节点并提示；
## page 14
5. 画布放大和缩小快捷按钮；
6. 小地图的展示；
7. 清除画布快捷键绑定；
8. 快捷键的提示；
9. 规则详情的展示；

## page 15
10.  点位挑选的功能优化。点位解绑时提示使用点位的节点名称。点位增加替换功能，当用户复制后直接替换点位已获得想要的规则。
11.  画布保存校验；提交画布时校验节点的属性
和入参是否填写，在流程节点右下角加图标表示验证是否通过并弹窗提示校验未通过的节点和对应属性。
12. 代码生成添加版本回退功能；

## page 16
另外还有一些用户提出的优化需求；
## page 17
工作总结的最后一个部分是带球黑灯工程管控平台项目，我所负责的模块为原料管理，为球团厂提供仓储信息、原料计算和边料记录等服务。
主要功能为仓位管理、正向计算和边料记录
## page 18
## page 19
## page 20
## page 21
接下来是试用期间我的一些学习总结
## page 22
参照试用期目标我主要从一下六个方面开展了前端知识的学习。
## page 23
我将选择javascript中原型和原型链来进行汇报，以展示我的学习成果。

js中数据类型可以分为两大类：简单类型和引用类型。用typeof可以判断出简单类型值的类型，但需要注意typeof null为object，因为在Javascript中null表示的含义为空对象。

## page 24

而对引用类型使用typeof除了函数类型返回值为function，其余的返回值都为Object。

引用类型一般使用instanceof来进行判断。fun instanceof Object 返回的为true。这表明一切的引用类型都是对象。
## page 25
众所周知，JS的复杂类型都是对象类型（Object），而JS不是一门完全面向对象编程的语言，所以如何涉及继承机制，就是一个问题。
因为JS中没有类（Class）这个概念，所以JS的设计者使用了构造函数来实现继承机制。
    ES6中的class可以看作只是一个语法糖，它的绝大部分的功能，ES5都可以做到，新的class写法只是让原型的写法更加的清晰、更像面向对象编程的语法而已。
对象都是通过函数创建，对象可以通过以下三种最基础的方式进行创建：
1. 构造函数
2. new Object()
3. 字面量

但实质上都是都过构造函数构建的对象，new Object()中Object是一个内置的构造函数，而字面量构建则是一个语法糖。
## page 26

对象是属性的集合。函数是对象，所以函数上会包含各种属性。
每个函数function都会包含一个类型为object的属性prototype（原型），而prototype有一个constructor属性指向其对应的函数。

## page 27
构造函数创造的实例上都有一个__proto__属性（隐式原型），指向创造该对象的函数的prototype。
## page 28

Person.prototype也是一个对象，所以也有一个__proto__，指向创造这个对象的函数的prototype，既Object.prototype。

而Object.prototype的__proto__的指向为null。

函数也是一种对象，所以函数也有__proto__，函数的创建函数为构造函数Function，所以构造函数Object的__proto__和Person的__proto__都指向Function.prototype。Function.prototype的__proto__则指向Object.prototype。

最后构造函数Function也是一个函数，那么一定是被Function创建，故Function的__proto__指向为自身的prototype（Function.prototype）。
## page 29
typeof无法正确判断引用类型，所以需要用instanceof。

Instanceof运算符的第一个变量是一个对象，暂时称为A；第二个变量一般是一个函数，暂时称为B。

Instanceof的判断规则是：沿着A的__proto__这条链路来找，如果在链路中找到B.prototype，那么就返回true。如果找到终点还未找到，则返回false。

## page 30

## page 31

## page 32
## page 33
图中由__proto__所形成的链路就是原型链。

## page 34
javascript中的继承是通过原型链来体现的。

访问一个对象的属性时，先在自身属性中查找，如果没有，再沿着__proto__这条链向上找，这就是原型链。

如上例，访问obj.valueof时，obj的自身属性中没有valueof，于是沿着__proto__找到了Object.prototype.valueof。

## page 35

Object.prototype上有hasOwnProperty可以判断一个属性到底时自身的还是从原型链中到的。

obj上的hasOwnProperty是来自原型链上Object.prototype.hasOwnProperty
## page 36
最后是团队协作方面。
## page 37

## page 38
接下来汇报的是未来的工作规划，我将从工作展望和学习规划两个方面展开。
## page 39
对于工作规划
第一个阶段是、IOT规则引擎项目跟进和代码的优化。分析现有业务流程和系统，思考提升用户体验的可能改进。
第二阶段则要1、关注低代码开发领域的最新技术和趋势。
2、快速熟悉低代码平台的业务。
3、积极参与低代码平台建设，提升团队价值。

最后持续支撑公司的需求和业务发展，提升项目的业务价值和技术质量。


## page 40
对于学习规划，
我将从VUE源码、前端核心基础、设计思想、代码质量、性能优化等方面展开深入的学习
## page 41

最后是我在试用期期间对前端岗位的一些思考
## page 42
前端不仅是页面的展示，更重要的是关注与用户的交互和体验；
有效的团队协作，促进信息共享和沟通，确保项目的顺利进行。
善于思考，寻求业务的中的可能性。
关注前端领域的最新技术和趋势，参与技术社区的讨论和分享，持续学习和积累经验，提高自己的专业水平。

## page 43
谢谢各位，我的汇报完毕！！
## page 44

