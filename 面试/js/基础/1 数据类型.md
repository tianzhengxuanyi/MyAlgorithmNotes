### JavaScript 有哪些数据类型？它们的区别是什么？

js 中共有八种数据类型，分别是 Undefined、Null、Boolean、Number、String、Object、Symbol、BigInt。

其中 Symbol 和 BigInt 两种数据类型是后续新增的。

- Symbol 代表创建后独一无二且不可变的数据类型，主要是为了解决可能出现的全局变量冲突的问题。
- BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。
  这些数据可以分为基本(原始)数据类型和引用数据类型：

- 栈：基本数据类型（Undefined、Null、Boolean、Number、String、Symbol、BigInt）
- 堆：引用数据类型（对象、数组和函数）

两种类型的区别在于存储位置的不同：

- 基本数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；
- 引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。

堆和栈的概念存在于数据结构和操作系统内存中，在数据结构中：

- 在数据结构中，栈中数据的存取方式为先进后出。
- 堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。

在操作系统中，内存被分为栈区和堆区：

- 栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。
- 堆区内存一般由开发着分配释放，若开发者不释放，程序结束时可能由垃圾回收机制回收。

### js 数据类型检测的方式有哪些

- typeof (用于检测变量的基本类型，但对于某些类型（如 null 和复杂对象）可能不够准确)

  ```js
  console.log("🚀 ~ Undefined:", typeof undefined); // 'undefined'
  console.log("🚀 ~ Null:", typeof null); // 'object' （这是一个历史遗留问题）
  console.log("🚀 ~ Boolean:", typeof true); // 'boolean'
  console.log("🚀 ~ Number:", typeof 999); // 'number'
  console.log("🚀 ~ String:", typeof "string"); // 'string'
  console.log("🚀 ~ Object:", typeof {}); // 'object'
  console.log("🚀 ~ Array:", typeof []); // 'object' （数组也是对象）
  console.log("🚀 ~ Function:", typeof function () {}); // 'function'
  console.log("🚀 ~ Symbol:", typeof Symbol(1)); // 'symbol'
  console.log("🚀 ~ BigInt:", typeof BigInt(1)); // 'bigint'
  ```

- instanceof (用于检测对象是否是某个构造函数的实例，适用于检测复杂对象类型)

  ```js
  class Person {}
  const person = new Person();

  console.log("🚀 ~ Array instanceof Array:", [] instanceof Array); // true
  console.log("🚀 ~ Object instanceof Object:", {} instanceof Object); // true
  console.log(
    "🚀 ~ Function instanceof Function:",
    function () {} instanceof Function
  ); // true
  console.log("🚀 ~ Person instanceof Person:", person instanceof Person); // true
  console.log("🚀 ~ Array instanceof Object:", [] instanceof Object); // true （数组也是对象）
  console.log("🚀 ~ null instanceof Object:", null instanceof Object); // false
  console.log("🚀 ~ undefined instanceof Object:", undefined instanceof Object); // false
  // 基本数据类型与 instanceof
  console.log("🚀 ~ 42 instanceof Number:", 42 instanceof Number); // false
  console.log("🚀 ~ 'hello' instanceof String:", "hello" instanceof String); // false
  console.log("🚀 ~ true instanceof Boolean:", true instanceof Boolean); // false
  console.log(
    "🚀 ~ Symbol('sym') instanceof Symbol:",
    Symbol(1) instanceof Symbol
  ); // false
  console.log("🚀 ~ BigInt(1) instanceof BigInt:", BigInt(1) instanceof BigInt); // false
  ```

- constructor (每个对象都有一个 constructor 属性，指向创建该对象的构造函数。可以通过检查 constructor 来判断类型)

  ```js
  const arr = [];
  const obj = {};
  const str = "hello";
  const bool = true;
  const num = 123; // 注意：基本类型没有 constructor 属性，需要包装为对象

  console.log("🚀 ~ Array constructor:", arr.constructor === Array); // true
  console.log("🚀 ~ Object constructor:", obj.constructor === Object); // true
  console.log(
    "🚀 ~ String constructor (wrapper):",
    Object(str).constructor === String
  ); // true
  console.log(
    "🚀 ~ Boolean constructor (wrapper):",
    Object(bool).constructor === Boolean
  ); // true
  console.log(
    "🚀 ~ Number constructor (wrapper):",
    Object(num).constructor === Number
  ); // true
  ```

- Object.prototype.toString.call() (是一种更为通用和准确的类型检测方法，适用于几乎所有数据类型)

  ```js
  const getType = (value) => Object.prototype.toString.call(value);

  console.log("🚀 ~ Undefined:", getType(undefined)); // [object Undefined]
  console.log("🚀 ~ Null:", getType(null)); // [object Null]
  console.log("🚀 ~ Boolean:", getType(true)); // [object Boolean]
  console.log("🚀 ~ Number:", getType(999)); // [object Number]
  console.log("🚀 ~ String:", getType("string")); // [object String]
  console.log("🚀 ~ Object:", getType({})); // [object Object]
  console.log("🚀 ~ Array:", getType([])); // [object Array]
  console.log("🚀 ~ Function:", getType(getType)); // [object Function]
  console.log("🚀 ~ Symbol:", getType(Symbol(1))); // [object Symbol]
  console.log("🚀 ~ BigInt:", getType(BigInt(1))); // [object BigInt]
  console.log("🚀 ~ Date:", getType(new Date())); // [object Date]
  console.log("🚀 ~ RegExp:", getType(/abc/)); // [object RegExp]
  console.log("🚀 ~ Map:", getType(new Map())); // [object Map]
  console.log("🚀 ~ Set:", getType(new Set())); // [object Set]
  ```

  | 方法                             | 支持类型                 | 准确性       | 简单性             | 注意事项                                 |
  | -------------------------------- | ------------------------ | ------------ | ------------------ | ---------------------------------------- |
  | typeof                           | 基本类型(除 null 外)     | 高(基本类型) | 高                 | 无法区分 null、数组和其他对象            |
  | instanceof                       | 对象类型(需构造函数存在) | 中等         | 中等               | 不适用于基本类型，受跨环境限制           |
  | constructor                      | 大多数对象类型           | 中等         | 中等               | 可被修改，不适用于基本类型               |
  | Object.prototype.toString.call() | 几乎所有类型             | 高           | 较低(需处理字符串) | 对于自定义对象需要额外处理，返回格式固定 |

### 谈谈 JavaScript 中的类型转换机制

 ![](https://static.vue-js.com/2abd00a0-6692-11eb-85f6-6fac77c0c9b3.png)

#### 一、概述

前面我们讲到，`JS `中有六种简单数据类型：`undefined`、`null`、`boolean`、`string`、`number`、`symbol`，以及引用类型：`object`

但是我们在声明的时候只有一种数据类型，只有到运行期间才会确定当前类型

```js
let x = y ? 1 : a;
```

上面代码中，`x`的值在编译阶段是无法获取的，只有等到程序运行时才能知道

虽然变量的数据类型是不确定的，但是各种运算符对数据类型是有要求的，如果运算子的类型与预期不符合，就会触发类型转换机制

常见的类型转换有：

- 强制转换（显示转换）
- 自动转换（隐式转换）



#### 二、显示转换

显示转换，即我们很清楚可以看到这里发生了类型的转变，常见的方法有：

- Number()
- parseInt()
- String()
- Boolean()



##### Number()

将任意类型的值转化为数值

先给出类型转换规则：

 ![](https://static.vue-js.com/915b7300-6692-11eb-ab90-d9ae814b240d.png)

实践一下：

```js
Number(324) // 324

// 字符串：如果可以被解析为数值，则转换为相应的数值
Number('324') // 324

// 字符串：如果不可以被解析为数值，返回 NaN
Number('324abc') // NaN

// 空字符串转为0
Number('') // 0

// 布尔值：true 转成 1，false 转成 0
Number(true) // 1
Number(false) // 0

// undefined：转成 NaN
Number(undefined) // NaN

// null：转成0
Number(null) // 0

// 对象：通常转换成NaN(除了只包含单个数值的数组)
Number({a: 1}) // NaN
Number([1, 2, 3]) // NaN
Number([5]) // 5
```

从上面可以看到，`Number`转换的时候是很严格的，只要有一个字符无法转成数值，整个字符串就会被转为`NaN`



##### parseInt()

`parseInt`相比`Number`，就没那么严格了，`parseInt`函数逐个解析字符，遇到不能转换的字符就停下来

```js
parseInt('32a3') //32
```



##### String()

可以将任意类型的值转化成字符串

给出转换规则图：

   ![](https://static.vue-js.com/48dd8eb0-6692-11eb-85f6-6fac77c0c9b3.png)

实践一下：

```js
// 数值：转为相应的字符串
String(1) // "1"

//字符串：转换后还是原来的值
String("a") // "a"

//布尔值：true转为字符串"true"，false转为字符串"false"
String(true) // "true"

//undefined：转为字符串"undefined"
String(undefined) // "undefined"

//null：转为字符串"null"
String(null) // "null"

//对象
String({a: 1}) // "[object Object]"
String([1, 2, 3]) // "1,2,3"
```



##### Boolean()

可以将任意类型的值转为布尔值，转换规则如下：

 ![](https://static.vue-js.com/53bdad10-6692-11eb-ab90-d9ae814b240d.png)

实践一下：

```js
Boolean(undefined) // false
Boolean(null) // false
Boolean(0) // false
Boolean(NaN) // false
Boolean('') // false
Boolean({}) // true
Boolean([]) // true
Boolean(new Boolean(false)) // true
```



#### 三、隐式转换

在隐式转换中，我们可能最大的疑惑是 ：何时发生隐式转换？

我们这里可以归纳为两种情况发生隐式转换的场景：

- 比较运算（`==`、`!=`、`>`、`<`）、`if`、`while`需要布尔值地方
- 算术运算（`+`、`-`、`*`、`/`、`%`）

除了上面的场景，还要求运算符两边的操作数不是同一类型



##### 自动转换为布尔值

在需要布尔值的地方，就会将非布尔值的参数自动转为布尔值，系统内部会调用`Boolean`函数

可以得出个小结：

- undefined 
- null 
- false 
- +0 
- -0
-  NaN
-  ""

除了上面几种会被转化成`false`，其他都换被转化成`true`



##### 自动转换成字符串

遇到预期为字符串的地方，就会将非字符串的值自动转为字符串

具体规则是：先将复合类型的值转为原始类型的值，再将原始类型的值转为字符串

常发生在`+`运算中，一旦存在字符串，则会进行字符串拼接操作

```js
'5' + 1 // '51'
'5' + true // "5true"
'5' + false // "5false"
'5' + {} // "5[object Object]"
'5' + [] // "5"
'5' + function (){} // "5function (){}"
'5' + undefined // "5undefined"
'5' + null // "5null"
```



##### 自动转换成数值

除了`+`有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值

```js
'5' - '2' // 3
'5' * '2' // 10
true - 1  // 0
false - 1 // -1
'1' - 1   // 0
'5' * []    // 0
false / '5' // 0
'abc' - 1   // NaN
null + 1 // 1
undefined + 1 // NaN
```

`null`转为数值时，值为`0` 。`undefined`转为数值时，值为`NaN`